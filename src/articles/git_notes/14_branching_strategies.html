<!DOCTYPE html>

<html lang="en">

<head>
    <script async="" crossorigin="anonymous" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5593122079896089"></script>
    <meta charset="utf-8" />
    <title>Strategies for Branching</title>
    <meta content="Before choosing a branching strategy, it helps to decide what youâ€™re optimizing for: speed, safety, or simplicity." name="description" />
    <meta content="Adam Djellouli" name="author" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <meta content="IE=edge" http-equiv="X-UA-Compatible" />
    <link crossorigin="" href="https://fonts.googleapis.com" rel="preconnect" />
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/icon.ico" rel="icon" />
    <link href="../../resources/style.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
</head>

<body>
    <nav aria-label="Main navigation">
        <a class="logo" href="https://adamdjellouli.com">
            <img alt="Adam Djellouli - Home Page Logo" id="logo-image" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/logo.PNG" />
        </a>
        <input aria-label="Toggle navigation menu" id="navbar-toggle" type="checkbox" />
        <ul aria-labelledby="navbar-toggle" role="menu">
            <li role="menuitem">
                <a href="../../index.html" title="Go to Home Page"> Home </a>
            </li>
            <li role="menuitem">
                <a class="active" href="../../core/blog.html" title="Read Adam Djellouli Blog on Programming and Technology"> Blog </a>
            </li>
            <li role="menuitem">
                <a href="../../core/tools.html" title="Discover Tools Created by Adam Djellouli"> Tools </a>
            </li>
            <li role="menuitem">
                <a href="../../core/projects.html" title="Explore Projects Developed by Adam Djellouli"> Projects </a>
            </li>
            <li role="menuitem">
                <a href="../../core/resume.html" title="View Adam Djellouli Professional Resume"> Resume </a>
            </li>
            <li>
                <script async="" src="https://cse.google.com/cse.js?cx=8160ef9bb935f4f68"></script>
                <div class="gcse-search"></div>
            </li>
            <li>
                <button aria-label="Toggle dark mode" id="dark-mode-button"></button>
            </li>
        </ul>
    </nav>
    <div id="article-wrapper"><article-section id="article-body">
            <div class="article-action-buttons"><button class="btn-suggest-edit" title="Suggest Edit">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <path d="M4 21h4l11-11-4-4L4 17v4z" stroke="currentColor" stroke-width="2"></path>
                    </svg>
                </button><button class="btn-create-issue" title="Create Issue">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2"></circle>
                        <line stroke="currentColor" stroke-width="2" x1="12" x2="12" y1="8" y2="12"></line>
                        <circle cx="12" cy="16" fill="currentColor" r="1"></circle>
                    </svg>
                </button><button class="btn-download" title="Download">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <path d="M12 5v14m0 0l-6-6m6 6l6-6" stroke="currentColor" stroke-width="2"></path>
                    </svg>
                </button></div>
            <p style="text-align: right;"><i>Last modified: October 01, 2017</i></p>
            <p style="text-align: right;"><i>This article is written in: ğŸ‡ºğŸ‡¸</i></p>
            <h2 id="strategies-for-branching">Strategies for Branching</h2>
            <p>Before choosing a branching strategy, it helps to decide what youâ€™re optimizing for: speed, safety, or simplicity. Different teams and projects lean different waysâ€”startups with small codebases wonâ€™t work the same as larger, multi-repo setups. This overview lays out the options and how to adapt them to your workflow.</p>
            <h3 id="trunk-based-development">Trunk-Based Development</h3>
            <p>In trunk-based development, <strong>a single long-lived branchâ€”usually <code>main</code>, <code>master</code>, or <code>trunk</code>â€”is the integration point for all code</strong>. Small, short-lived feature (topic) branches are fine, but they <em>must</em> merge back to trunk quicklyâ€”ideally within hours, and rarely later than a day or two.</p>
            <p>Every commit to trunk triggers the CI pipeline: it builds, runs the full automated test suite, performs static analysis, andâ€”if greenâ€”deploys to a staging/integration environment. After acceptance tests pass, the <strong>same artifact</strong> is promoted toward production unchanged.</p>
            <p>This approach depends on <strong>continuous integration</strong>, <strong>strong automated tests</strong>, and <strong>fast feedback loops</strong> so trunk stays releasable.</p>
            <div>
                <pre><code class="language-shell">Main Branch (Trunk)
   |
   |â€”â€”&gt; Continuous Integration (CI)
   |         |
   |         v
   |  Automated Testing
   |
   |â€”â€”&gt; Short-Lived Feature Branches (optional)
   |         |
   |         v
   |  Feature Development
   |
   |â€”â€”&gt; Merge Back to Trunk (at least daily)
   |
   |â€”â€”&gt; Staging â†’ Production Release</code></pre>
            </div>
            <p><strong>How are big breaking changes introduced?</strong></p>
            <p>Use incremental, backward-compatible steps: feature flags/toggles, <em>branch by abstraction</em>, and â€œexpand/contractâ€ migrations (e.g., add new paths first, dual-write, then remove the old). If a short branch is unavoidable, keep it tiny, merge daily, and hide behavior behind flags.</p>
            <p><strong>Is every commit here a transaction?</strong>
                Treat each commit as <strong>atomic and releasable</strong>: it should build, pass tests, and leave user-visible behavior unchanged by default (flags off). Commits trigger CI and often deploy to staging, but <strong>releases to users are controlled</strong> by flag flips or artifact promotionâ€”not by every commit.</p>
            <h4 id="advantages">Advantages</h4>
            <ul>
                <li>A single trunk minimizes merge and release overhead; multiple long-lived branches create bottlenecks. For example, a startup can ship daily without heavy integration work.</li>
                <li>Small, frequent releases reduce risk versus bundling big updates; an e-commerce site can roll out checkout tweaks weekly instead of quarterly.</li>
                <li>Early integration surfaces conflicts quickly; delaying merges makes them harder and costlier. A game studio avoids last-minute crunch by merging daily.</li>
                <li>Keeping trunk releasable enables continuous deployability; otherwise teams get stuck stabilizing. A SaaS provider can hotfix anytime without waiting for a hardening sprint.</li>
            </ul>
            <h4 id="disadvantages">Disadvantages</h4>
            <ul>
                <li>Incomplete work needs <strong>feature flags</strong> to ship safely; without them, unfinished functionality can leak. A payments app hides a new API behind a toggle until testing is done.</li>
                <li>Large or architectural changes require <strong>branch by abstraction</strong> or expand/contract techniques; skipping them risks destabilizing trunk. A cloud service splits a database migration into small, deployable steps.</li>
                <li>Success hinges on <strong>disciplined automated testing</strong>; neglect leads to fragile releases. A healthcare platform runs full regression suites on every commit.</li>
                <li>Build stability suffers if <strong>merge frequency</strong> drops; regular integration prevents long disruptions. A large open-source project enforces daily merges to avoid spikes in broken builds.</li>
            </ul>
            <h4 id="when-to-use">When to Use</h4>
            <ul>
                <li>Teams <strong>practicing daily CI</strong> benefit most; merging weekly or less blunts the gains. A fintech team commits multiple times per day to maintain flow.</li>
                <li>Projects that can be <strong>tested in independent slices</strong> fit well; tightly coupled systems struggle. A microservices platform evolves each service without blocking others.</li>
                <li>Organizations aiming for <strong>continuous delivery</strong> gain speed and safe rollback; long, gated release trains lose much of the benefit. A streaming provider ships fast with instant rollback if needed.</li>
                <li>Heavy regulatory gates or <strong>big-bang releases</strong> reduce suitability; such environments often keep long-running release branches. A defense contractor bound by compliance stages remains on release branches.</li>
            </ul>
            <h4 id="critique">Critique</h4>
            <ul>
                <li>Critics say this model only works well when a team has excellent automated tests and very reliable CI.</li>
                <li>Without that, frequent merges to the main branch feel risky.</li>
                <li>Feature flags (used to hide unfinished work) add complexity and can accidentally expose half-built features.</li>
                <li>Big, sweeping changes are hard to slice into tiny safe steps, so they can feel awkward or slow.</li>
                <li>If the build pipeline is flaky, everyone gets blocked.</li>
                <li>Some also find lots of small PRs reduce review depth and make the history noisy.</li>
            </ul>
            <h3 id="release-branches">Release Branches</h3>
            <p>In the <strong>release-branching</strong> workflow, each upcoming version is stabilised on its own branch while everyday feature work continues elsewhere. A typical setup includes:</p>
            <ul>
                <li><code>main</code> (or <code>master</code>) â€“ holds production-ready code and immutable version tags (e.g., <code>v2.3.0</code>).</li>
                <li><code>develop</code> â€“ the integration branch for day-to-day feature work.</li>
                <li><em>Release branch</em> â€“ cut from <code>develop</code> when you declare the next version feature-complete; only bug fixes, documentation tweaks, and release housekeeping (version bumps, build scripts, localisation strings, etc.) are allowed.</li>
                <li><em>Hotfix branch</em> â€“ cut directly from <code>main</code> to address critical production issues; merge back into both <code>main</code> <em>and</em> <code>develop</code> (or the active release branch) to prevent regressions.</li>
            </ul>
            <div>
                <pre><code class="language-main">â”‚
 â”œâ”€â”€â–¶ develop
 â”‚       â”‚
 â”‚       â”œâ”€â”€â–¶ Feature branches (feat/XYZ)
 â”‚       â”‚        â”‚
 â”‚       â”‚        â–¼
 â”‚       â”‚  Merge back to develop
 â”‚       â”‚
 â”‚       â””â”€â”€â–¶ Release-X.Y branch
 â”‚                â”‚
 â”‚                â”œâ”€â”€â–¶ Bug fixes / final hardening
 â”‚                â”‚
 â”‚                â””â”€â”€â–¶ (if urgent) Hotfix branch
 â”‚                         â”‚
 â”‚                         â–¼
 â”‚                     Merge to Release-X.Y
 â”‚
 â”œâ”€â”€â–¶ Merge Release-X.Y â†’ main &amp; tag vX.Y.0
 â”‚
 â–¼
Production deployment</code></pre>
            </div>
            <p>Once the release branch is declared stable:</p>
            <ol>
                <li><em>Merge into <code>main</code></em> and create an annotated, immutable tag (<code>vX.Y.0</code>) for traceability.</li>
                <li><em>Merge (or rebase) back into <code>develop</code></em> so ongoing work includes all post-freeze fixes.</li>
                <li><em>Delete (or archive) the release branch</em> to avoid clutter.</li>
            </ol>
            <h4 id="advantages">Advantages</h4>
            <ul>
                <li><em>Parallel version support</em> lets you stabilise one release while new features move forward elsewhere (e.g., an ERP vendor patches <code>v3.2</code> while building <code>v3.3</code>).</li>
                <li><em>No feature flags on the release branch</em>â€”only completed work lands there, reducing runtime complexity (a mobile team ships toggles-free releases).</li>
                <li><em>Scoped hotfixes</em> target just the affected version, avoiding unintended side effects (a cloud provider patches <code>v2.x</code> without touching <code>v3.x</code>).</li>
                <li><em>Predictable milestones</em> give QA and stakeholders a clear test scope (a quarterly on-prem release locks features so validation is focused).</li>
            </ul>
            <h4 id="disadvantages">Disadvantages</h4>
            <ul>
                <li><em>Slower cadence</em>â€”features may wait for the next window, whereas CI/CD on trunk moves faster (app-store cycles can delay delivery).</li>
                <li><em>Merge overhead</em>â€”fixes must be propagated across branches; a single-branch model avoids duplication (teams on <code>v1.x</code> and <code>v2.x</code> copy fixes twice).</li>
                <li><em>Branch sprawl</em>â€”more active branches complicate tooling and mental models; small teams often prefer a single trunk.</li>
                <li><em>Divergence risk</em>â€”long-lived branches drift and make merges painful; frequent integration keeps differences small.</li>
            </ul>
            <h4 id="when-to-use">When to Use</h4>
            <ul>
                <li>Products with <em>formal release schedules</em> (e.g., quarterly enterprise software).</li>
                <li>Situations with <em>multiple supported versions</em> in the wild (supporting <code>v1.x</code> for legacy and <code>v2.x</code> for new customers).</li>
                <li>Environments with <em>compliance/audit gates</em> where clearly scoped releases map to documentation (e.g., medical devices).</li>
                <li>Less suitable for teams pursuing <em>continuous delivery</em>, where frequent releases and feature toggles already work well.</li>
            </ul>
            <h4 id="not-the-same-as-git-flow">Not the same as Git Flow</h4>
            <p><em>Git Flow</em> is a full branching methodology. <em>Release branches</em> are a single ingredientâ€”often used within Git Flow, but also viable on their own.</p>
            <h4 id="critique">Critique</h4>
            <ul>
                <li>Extra ceremony and slower pace can frustrate teams.</li>
                <li>â€œCode freezeâ€ on the release branch pauses new work.</li>
                <li>Fixes often have to be merged twice (into the release and back into develop), which is tedious and error-prone.</li>
                <li>Long-lived release branches drift from the main line, causing painful merge conflicts later.</li>
                <li>The workflow encourages big â€œall-at-onceâ€ releases instead of small, frequent ones.</li>
                <li>Tracking changes across many branches makes automation and debugging harder.</li>
            </ul>
            <h3 id="feature-branches">Feature Branches</h3>
            <p>In a <strong>feature-branch</strong> workflow, each new capability, enhancement, or bug fix lives on its <em>own</em> branch cut from a stable integration branch (<code>main</code> or, more often, <code>develop</code>). Work proceeds in isolation until the change set is <em>complete</em> and the CI pipeline is green. The branch is then merged back via a pull/merge request after code review and automated checks. The resulting commits flow to production in the next release trainâ€”or immediately, if you practise continuous delivery.</p>
            <p>Typical naming conventions: <code>feat/&lt;ticket-id&gt;-&lt;slug&gt;</code> for new functionality and <code>fix/&lt;ticket-id&gt;</code> for defects. This keeps context clear for both tooling and humans.</p>
            <div>
                <pre><code class="language-main">â”‚
 â”œâ”€â”€â–¶ develop   (optional integration branch)
 â”‚       â”‚
 â”‚       â”œâ”€â”€â–¶ feat/ABC-123-cool-feature
 â”‚       â”‚        â”‚
 â”‚       â”‚        â–¼
 â”‚       â”‚   Commit â†’ test â†’ review
 â”‚       â”‚        â”‚
 â”‚       â””â”€â”€â–¶â”€â”€â”€â”€â”€â”˜  Merge to develop
 â”‚
 â””â”€â”€â–¶ (CI) â†’ Release preparation â†’ Production</code></pre>
            </div>
            <h4 id="advantages">Advantages</h4>
            <ul>
                <li><em>Isolation</em> keeps incomplete work off trunk, reducing broken builds; e.g., a fintech team develops a new payment flow separately until itâ€™s production-ready.</li>
                <li><em>Parallel development</em> lets multiple efforts progress without constant conflicts; a web platform team can add search while redesigning the UI.</li>
                <li><em>Focused reviews</em> on small, scoped PRs improve signal and accountability; an open-source project reviews only the new API endpoint in a single branch.</li>
            </ul>
            <h4 id="disadvantages">Disadvantages</h4>
            <ul>
                <li><em>Integration drift</em> grows on long-lived branches; frequent rebases/merges keep code close to trunk. A mobile team faces multi-day conflicts after a month-long branch.</li>
                <li><em>Delayed feedback</em> hides interaction bugs until merge; early, regular syncs surface issues sooner. A logistics platform discovers a shipments/invoicing bug at final merge.</li>
                <li><em>Discipline required</em>â€”branches should be short-lived; neglect leads to stale, hard-to-merge work. A game studio rebases daily and closes branches within a week.</li>
            </ul>
            <h4 id="when-to-use">When to Use</h4>
            <ul>
                <li>Teams that value <em>explicit review gates</em> and an auditable trail of changes; a government IT project treats each MR as a compliance artefact.</li>
                <li>Projects delivering <em>independent features</em> in days or weeks; a SaaS product ships dashboard filters via short-lived branches.</li>
                <li>Organisations not yet ready for <em>trunk-based development</em> can reduce risk with scoped branches; teams already practising trunk-based merges may not need them.</li>
            </ul>
            <p>Avoid very long-running feature branches. If a change is large, break it into incremental slices or use <em>branch-by-abstraction</em> so you can merge to trunk early and often.</p>
            <h4 id="critique">Critique</h4>
            <ul>
                <li><strong>Delay and drift:</strong> When branches stay open for weeks, they fall behind the main codebase and merge conflicts pile up.</li>
                <li><strong>Large pull requests:</strong> PRs can grow large, slowing reviews and hiding problems until late in the process.</li>
                <li><strong>Wasted effort:</strong> Rebasing or updating branches burns time, and CI runs are duplicated for many branches.</li>
                <li><strong>Reduced collaboration:</strong> The PR gate can replace early, direct collaboration with a slower â€œthrow it over the wallâ€ review cycle.</li>
                <li><strong>Stale work:</strong> Lingering branches and PRs sap momentum.</li>
            </ul>
            <h3 id="forking">Forking</h3>
            <p>In a <strong>fork-based</strong> workflow, contributors work on their <em>own</em> copy of the repositoryâ€”a <em>fork</em>â€”instead of pushing branches to the canonical project. Changes flow back to the <em>upstream</em> repository via pull requests (PRs; â€œmerge requestsâ€ on some platforms), where maintainers review, discuss, and merge.</p>
            <p>Typical fork setup:</p>
            <ul>
                <li><em>Upstream</em> â€“ the original, authoritative repository. In a contributorâ€™s clone, this is usually added as the <code>upstream</code> remote (while <code>origin</code> points to the fork).</li>
                <li><em>Fork</em> â€“ a full clone under the contributorâ€™s account or an internal team namespace.</li>
                <li><em>Feature/topic branches</em> â€“ created in the fork for each unit of work.</li>
                <li><em>Pull request (PR)</em> â€“ proposes the branch for inclusion upstream; CI runs, reviewers comment, and maintainers merge (often with <strong>squash</strong> or <strong>rebase-and-merge</strong>) to keep history tidy.</li>
            </ul>
            <div>
                <pre><code class="language-shell">Upstream repo
   â”‚
   â”œâ”€â”€â–¶ main (production)
   â”‚       â”‚
   â”‚       â””â”€â”€â–¶ (optional) topic branches
   â”‚
   â””â”€â”€â–¶ Forked repo (contributor / team)
           â”‚
           â”œâ”€â”€â–¶ main (kept in sync with upstream)
           â”‚
           â””â”€â”€â–¶ feat/XYZ-topic
                     â”‚
                     â–¼
                Development &amp; local CI
                     â”‚
                     â–¼
                 Pull request â–²
                               â”‚
                               â–¼
                  Review â†’ Merge â†’ Upstream main</code></pre>
            </div>
            <h4 id="advantages">Advantages</h4>
            <ul>
                <li>Enforcing a <em>safe contribution model</em> by requiring PRs from forks prevents direct changes to upstream; skipping this risks accidents like force-pushes. A popular JavaScript library, for example, avoids exposing write access to casual contributors.</li>
                <li>Operating with <em>low coupling</em> lets each fork run its own CI and manage work independently; sharing a single namespace often causes collisions. A research consortium can experiment per university before proposing upstream changes.</li>
                <li>Scaling to <em>large contributor bases</em> is feasible when maintainers control merges centrally; direct-commit models donâ€™t scale under volume. Global projects can accept patches from thousands without granting upstream write access.</li>
            </ul>
            <h4 id="disadvantages">Disadvantages</h4>
            <ul>
                <li>Poor <em>sync hygiene</em> causes forks to drift; regular fetch/rebase keeps contributors aligned with upstream. A contributor to an ML framework may face hours of conflict resolution after months without syncing.</li>
                <li><em>Review bottlenecks</em> slow progress when maintainers face heavy PR queues; smaller, curated contributor pools reduce wait times. A blockchain project can see week-long delays before patches are merged.</li>
                <li>Duplicated <em>CI runs</em> across forks inflate costs; consolidated pipelines minimise waste. An enterprise open-sourcing an SDK may see cloud CI bills climb as hundreds of forks trigger builds.</li>
            </ul>
            <h4 id="when-to-use">When to Use</h4>
            <ul>
                <li>Open-source projects that rely on <em>external contributions</em> benefit most; closed teams often gain little from the added overhead. A web framework community depends on forked PRs to manage outside patches.</li>
                <li>Internal platforms with <em>strict permission boundaries</em> gain isolation through forks; permissive repos may prefer simpler branch-based models. A multinational lets subsidiaries adapt code safely in their own forks.</li>
                <li><em>Security-sensitive environments</em> can enforce signed PRs and audit trails through forks; looser workflows risk unverified changes. A defence contractor requires every patch to arrive via a forked PR.</li>
            </ul>
            <p>Keep forks fresh by adding the upstream remote (<code>git remote add upstream &lt;url&gt;</code>), then regularly syncing: <code>git fetch upstream</code> followed by <code>git rebase upstream/main</code> (or <code>git pull --rebase upstream main</code>). Stale forks are the main pain point here; proactive syncing and small, focused PRs keep the workflow smooth.</p>
            <h4 id="critique">Critique</h4>
            <ul>
                <li>Contributors often struggle to keep their fork in sync with the upstream project; long gaps mean ugly conflicts later.</li>
                <li>CI can be weaker on forks (secrets and internal checks may not run), so maintainers must re-run jobs, adding friction.</li>
                <li>A small maintainer team canâ€™t review a huge PR queue quickly, so contributions sit for days or weeks.</li>
                <li>Discussion and context spread across many forks and PRs, which makes triage and coordination harder.</li>
                <li>Itâ€™s secure, but high-friction for frequent collaborators.</li>
            </ul>
            <h3 id="git-flow">Git Flow</h3>
            <p><strong>Git Flow</strong> is a prescriptive branching model, proposed by Vincent Driessen, that assigns <em>named roles</em> to branches with clear rules for when to create, merge, and retire them.
                It suits projects that ship <em>versioned</em> releases on a predictable cadence and need to patch production urgently while regular feature work continues.</p>
            <ul>
                <li><code>main</code> â€“ always reflects whatâ€™s running in production and is tagged (<code>vX.Y.Z</code>) at each release.</li>
                <li><code>develop</code> â€“ the permanent integration branch for day-to-day development.</li>
                <li><code>feature/*</code> â€“ short-lived branches cut from <code>develop</code> for each new capability or bug fix; merge back into <code>develop</code> when complete.</li>
                <li><code>release/*</code> â€“ cut from <code>develop</code> once the next version is feature-complete; only stabilisation changes (bug fixes, docs, build metadata) are allowed; merges into both <code>main</code> and <code>develop</code>.</li>
                <li><code>hotfix/*</code> â€“ cut directly from <code>main</code> to address urgent production defects; merges into both <code>main</code> <em>and</em> <code>develop</code> (and any active <code>release/*</code> branch).</li>
            </ul>
            <div>
                <pre><code class="language-shell">main â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ (tag vX.Y.0) â”€â”€â”
       â”‚                              â”‚
       â”‚â—€â”€ merge hotfix/* â”€â”€â”€â”€â”€â”€â–¶ (tag vX.Y.1)
       â”‚                              â”‚
developâ”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ merge release/*â”˜
  â”‚
  â”œâ”€â”€â–¶ feature/ABC-123
  â”‚        â”‚
  â”‚        â””â”€â”€â–¶ merge â†’ develop
  â”‚
  â””â”€â”€â–¶ release/X.Y
           â”‚
           â”œâ”€â”€â–¶ final bug fixes
           â””â”€â”€â–¶ merge â†’ main  &amp;  merge â†’ develop</code></pre>
            </div>
            <h4 id="advantages">Advantages</h4>
            <ul>
                <li><em>Role clarity</em> gives each branch a distinct purpose; without it, responsibilities blur and contributors get confused. For example, a banking platform keeps ongoing work on <code>develop</code> while urgent fixes go to <code>hotfix/*</code>.</li>
                <li><em>Parallel work streams</em> allow teams to develop features, stabilise a release, and patch production simultaneously; a mobile app team can ready <code>v2.1</code> on <code>release/*</code> while starting <code>v2.2</code> features on <code>develop</code>.</li>
                <li><em>Release hardening</em> phases surface late bugs without halting new work; an on-prem ERP vendor stabilises <code>v5.4</code> on <code>release/*</code> while roadmap features continue on <code>develop</code>.</li>
            </ul>
            <h4 id="disadvantages">Disadvantages</h4>
            <ul>
                <li>Five branch types add <em>process overhead</em>; simpler models need less training and coordination. A midsize SaaS finds Git Flow slower to onboard than trunk-based workflows.</li>
                <li><em>Long-lived divergence</em> makes merges painful; keeping branches short reduces integration risk. A telecom vendor struggles when <code>release/*</code> drifts weeks from <code>develop</code>.</li>
                <li>Typically a <em>slower cadence</em> than trunk-based or short-lived branching; a startup delays customer-visible improvements until the next scheduled release.</li>
            </ul>
            <h4 id="when-to-use">When to Use</h4>
            <ul>
                <li>Products with <em>formal release schedules</em> benefit, while continuously deployed services may find it heavy. A quarterly enterprise desktop product fits well.</li>
                <li>Organisations with <em>separate Dev, QA, and Ops roles</em> gain from explicit branch stages; cross-functional teams may prefer lighter models. A regulated insurer requires QA sign-off before merging into <code>release/*</code>.</li>
                <li>Maintaining <em>multiple supported versions</em> makes hotfix branches valuable; single-version products rarely need them. A medical software provider patches <code>v3.x</code> in production while continuing work on <code>v4.x</code>.</li>
            </ul>
            <p>If you aim for <em>continuous delivery</em> or deploy many times a day, Git Flow will likely feel heavyweight; consider trunk-based development or a simple feature-branch workflow instead.</p>
            <h4 id="critique">Critique</h4>
            <ul>
                <li>Considered <em>heavy and dated</em> for modern CI/CD; detractors argue it slows down teams used to rapid iteration.</li>
                <li>The <em>many branch types</em> add process and slow onboarding; new team members face a steeper learning curve.</li>
                <li>The permanent <code>develop</code> branch can feel like an unnecessary extra hop, complicating the path to production.</li>
                <li><code>release/*</code> and <code>hotfix/*</code> branches add merge overhead and increase the risk of divergence; teams report painful merges when branches drift apart.</li>
                <li>Teams often experience <em>slower feedback</em> and <em>slower releases</em> compared to trunk-based or short-lived feature branch workflows.</li>
                <li>Histories can become cluttered with coordination merges, making it harder to read and understand the commit log.</li>
            </ul>
            <h3 id="environment-branching">Environment Branching</h3>
            <p>In an <strong>environment-branching</strong> workflow, each <em>runtime environment</em>â€”development, QA, staging, productionâ€”has its own long-lived branch. Code moves â€œup the ladderâ€ by merging (or cherry-picking) from one environment branch to the next, mirroring how build artefacts and database changes are promoted.</p>
            <p>Typical branch mapping:</p>
            <ul>
                <li><code>develop</code> â€“ the developersâ€™ sandbox; unstable experiments are expected.</li>
                <li><code>qa</code> (or <code>test</code>) â€“ mirrors the formal testing environment; only code that has passed review and automated checks is promoted here.</li>
                <li><code>staging</code> â€“ a pre-production clone of live; final acceptance, performance, and compliance testing happen here.</li>
                <li><code>main</code> (or <code>production</code>) â€“ tracks what is currently in production; immutable tags (<code>vX.Y.Z</code>) mark each deployment.</li>
            </ul>
            <div>
                <pre><code class="language-shell">develop â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ (dev environment)
          â”‚
          â””â”€â”€â–¶ qa â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â–¶ (QA / test environment)
                      â”‚
                      â””â”€â”€â–¶ staging â”€â”€â”€â–¶ (staging environment)
                                          â”‚
                                          â–¼
                                      main (prod) â”€â”€â–¶ (production)</code></pre>
            </div>
            <p>Promotion flow:</p>
            <ol>
                <li>Finish work on <code>develop</code> â†’ merge to <code>qa</code>.</li>
                <li>QA passes â†’ fast-forward or merge <code>qa</code> â†’ <code>staging</code>.</li>
                <li>Final sign-off â†’ merge <code>staging</code> â†’ <code>main</code> and deploy.
                    <em>Hotfixes</em> start on <code>main</code>, then cascade back to <code>staging</code>, <code>qa</code>, and <code>develop</code> to keep branches aligned.
                </li>
            </ol>
            <h4 id="advantages">Advantages</h4>
            <ul>
                <li>Maintaining <em>environment visibility</em> means each branch maps to a deployed environment, whereas skipping this blurs traceability; for example, a bankâ€™s <code>qa</code> branch reflects exactly what testers are validating.</li>
                <li>Using <em>paced promotion</em> lets changes pause in QA or staging for deeper checks, whereas merging straight to production risks unvetted code; a medical-device firm runs extended regulatory tests in <code>staging</code> before promoting.</li>
                <li>Aligning with <em>regulatory expectations</em> provides auditors a clear branch-to-environment link, whereas missing this mapping complicates evidence; an aviation vendor can point regulators to the precise branch under test.</li>
            </ul>
            <h4 id="disadvantages">Disadvantages</h4>
            <ul>
                <li>Orchestrating <em>merges across environments</em> adds complexity, whereas lighter models need fewer moves; a finance team spends hours cherry-picking fixes through <code>qa</code>, <code>staging</code>, and <code>prod</code>.</li>
                <li>Allowing <em>branch divergence</em> breeds â€œworks-on-my-envâ€ bugs, whereas disciplined syncing prevents drift; a telecom sees a prod incident when a <code>staging</code> patch never reaches <code>develop</code>.</li>
                <li><em>Slower feedback loops</em> postpone integration issues, whereas trunk-based flows surface them early; a logistics platform discovers conflicting features only after days sitting in <code>qa</code>.</li>
                <li>Supporting <em>multiple environment branches</em> strains CI/CD, whereas single-branch pipelines stay lean; a legacy ERP vendor pays for duplicated builds across several environment branches.</li>
            </ul>
            <h4 id="when-to-use">When to Use</h4>
            <ul>
                <li>Organisations with <em>rigid stage gates</em> (e.g., FDA/aviation) benefit, whereas less-regulated sectors may not need the overhead; a medical records system must pass certified environments.</li>
                <li><em>Separate Dev, QA, and Ops teams</em> align well with environment ownership, whereas integrated product teams may prefer trunk-based flows; a bank assigns <code>qa</code>, <code>staging</code>, and <code>prod</code> to different groups.</li>
                <li><em>Legacy, heavyweight deployments</em> justify extra staging steps, whereas modern cloud-native platforms may prefer faster rollback strategies; an insurer running mainframe code relies on staging time to mitigate rollback risk.</li>
            </ul>
            <p>If rapid, continuous delivery is the goal, consider slimming the number of environment branchesâ€”or switch to release branches or trunk-based development plus feature flagsâ€”to keep promotion fast while retaining control.</p>
            <h4 id="critique">Critique</h4>
            <p>Common complaints about this model include:</p>
            <ul>
                <li><strong>Branches represent environments, not changes:</strong> Branches end up representing <em>environments</em> (dev/QA/staging/prod) instead of <em>changes to the code</em>, which leads to drift between branches, lots of cherry-picking, and hard-to-trace deployments.</li>
                <li><strong>Breaks artifact promotion best practices:</strong> Best practice is to build <strong>once</strong> and promote the <strong>same artifact</strong> through each environment, changing only configuration. Environment branches usually break that rule, so â€œstagingâ€ and â€œprodâ€ run different commits and bugs slip through.</li>
                <li><strong>Configuration management issues:</strong> Configuration should live outside the code (env vars, secrets, config stores), not as separate code branches, which is a core 12-factor principle.</li>
                <li><strong>CI/CD and audit complexity:</strong> Per-environment branches multiply CI pipelines and make rollbacks and audits harder because you canâ€™t point to one SHA that moved through the pipeline unchanged.</li>
            </ul>
            <p>These critiques show up across CD/GitOps guidance and are a big reason many call â€œbranch-per-environmentâ€ an anti-pattern.</p>
        </article-section>
        <div id="table-of-contents">
            <h2>Table of Contents</h2>
            <ol><a href="#strategies-for-branching">Strategies for Branching</a>
                <ol>
                    <li><a href="#trunk-based-development">Trunk-Based Development</a>
                        <ol>
                            <li><a href="#advantages">Advantages</a></li>
                            <li><a href="#disadvantages">Disadvantages</a></li>
                            <li><a href="#when-to-use">When to Use</a></li>
                            <li><a href="#critique">Critique</a></li>
                        </ol>
                    </li>
                    <li><a href="#release-branches">Release Branches</a>
                        <ol>
                            <li><a href="#advantages">Advantages</a></li>
                            <li><a href="#disadvantages">Disadvantages</a></li>
                            <li><a href="#when-to-use">When to Use</a></li>
                            <li><a href="#not-the-same-as-git-flow">Not the same as Git Flow</a></li>
                            <li><a href="#critique">Critique</a></li>
                        </ol>
                    </li>
                    <li><a href="#feature-branches">Feature Branches</a>
                        <ol>
                            <li><a href="#advantages">Advantages</a></li>
                            <li><a href="#disadvantages">Disadvantages</a></li>
                            <li><a href="#when-to-use">When to Use</a></li>
                            <li><a href="#critique">Critique</a></li>
                        </ol>
                    </li>
                    <li><a href="#forking">Forking</a>
                        <ol>
                            <li><a href="#advantages">Advantages</a></li>
                            <li><a href="#disadvantages">Disadvantages</a></li>
                            <li><a href="#when-to-use">When to Use</a></li>
                            <li><a href="#critique">Critique</a></li>
                        </ol>
                    </li>
                    <li><a href="#git-flow">Git Flow</a>
                        <ol>
                            <li><a href="#advantages">Advantages</a></li>
                            <li><a href="#disadvantages">Disadvantages</a></li>
                            <li><a href="#when-to-use">When to Use</a></li>
                            <li><a href="#critique">Critique</a></li>
                        </ol>
                    </li>
                    <li><a href="#environment-branching">Environment Branching</a>
                        <ol>
                            <li><a href="#advantages">Advantages</a></li>
                            <li><a href="#disadvantages">Disadvantages</a></li>
                            <li><a href="#when-to-use">When to Use</a></li>
                            <li><a href="#critique">Critique</a></li>
                        </ol>
                    </li>
                </ol>
            </ol>
            <div id="related-articles">
                <h2>Related Articles</h2>
                <ol>
                    <li><a href="https://adamdjellouli.com/articles/git_notes/01_introduction_to_version_control.html">Introduction to Version Control</a></li>
                    <li><a href="https://adamdjellouli.com/articles/git_notes/02_create_repository.html">Create Repository</a></li>
                    <li><a href="https://adamdjellouli.com/articles/git_notes/03_making_changes.html">Making Changes</a></li>
                    <li><a href="https://adamdjellouli.com/articles/git_notes/04_working_with_branches.html">Working with Branches</a></li>
                    <li><a href="https://adamdjellouli.com/articles/git_notes/05_head.html">Head</a></li>
                    <li><a href="https://adamdjellouli.com/articles/git_notes/06_tags.html">Tags</a></li>
                    <li><a href="https://adamdjellouli.com/articles/git_notes/07_stashing_files.html">Stashing Files</a></li>
                    <li><a href="https://adamdjellouli.com/articles/git_notes/08_observing_repository.html">Observing Repository</a></li>
                    <li><a href="https://adamdjellouli.com/articles/git_notes/09_synchronization.html">Synchronization</a></li>
                    <li><a href="https://adamdjellouli.com/articles/git_notes/10_squashing_commits.html">Squashing Commits</a></li>
                    <li><a href="https://adamdjellouli.com/articles/git_notes/11_archive.html">Archive</a></li>
                    <li><a href="https://adamdjellouli.com/articles/git_notes/12_git_server.html">Git Server</a></li>
                    <li><a href="https://adamdjellouli.com/articles/git_notes/13_points_of_confusion.html">Points of Confusion</a></li>
                    <li><a href="https://adamdjellouli.com/articles/git_notes/14_branching_strategies.html">Branching Strategies</a></li>
                    <li><a href="https://adamdjellouli.com/articles/git_notes/15_mono_and_multi_repo.html">Mono and Multi Repo</a></li>
                    <li><a href="https://adamdjellouli.com/articles/git_notes/16_dangerous_commands.html">Dangerous Commands</a></li>
                    <li><a href="https://adamdjellouli.com/articles/git_notes/17_git_internals.html">Git Internals</a></li>
                </ol>
            </div>
        </div>
    </div>
    <footer>
        <div class="footer-columns">
            <div class="footer-column">
                <img alt="Adam Djellouli Symbol" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/symbol.png" />
            </div>
            <div class="footer-column">
                <h2><a href="https://adamdjellouli.com/core/privacy_policy.html" title="Privacy Policy">Our Privacy Policy</a></h2>
                <p>Thank you for visiting my personal website. All content here is free to use, but please remember to be respectful and avoid any misuse of the site. If youâ€™d like to get in touch, feel free to reach out via my <a href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" title="LinkedIn Profile">LinkedIn profile</a> or connect with me on <a href="https://github.com/djeada" title="GitHub Profile">GitHub</a> if you have technical questions or ideas to share. Wishing you all the best and a fantastic life ahead!</p>
            </div>
            <div class="footer-column">
                <h2>Follow me</h2>
                <ul class="social-media">
                    <li>
                        <a class="fa fa-youtube" href="https://www.youtube.com/channel/UCGPoHTVjMN77wcGknXPHl1Q" target="_blank" title="YouTube">
                        </a>YouTube
                    </li>
                    <li>
                        <a class="fa fa-linkedin" href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" target="_blank" title="LinkedIn">
                        </a>LinkedIn
                    </li>
                    <li>
                        <a class="fa fa-instagram" href="https://www.instagram.com/linuxchallenges/" target="_blank" title="Instagram">
                        </a>Instagram
                    </li>
                    <li>
                        <a class="fa fa-github" href="https://github.com/djeada" title="GitHub">
                        </a>Github
                    </li>
                </ul>
            </div>
        </div>
        <div>
            <p id="copyright">
                Â© Adam Djellouli. All rights reserved.
            </p>
        </div>
        <script>
            document.getElementById("copyright").innerHTML = "&copy; " + new Date().getFullYear() + " Adam Djellouli. All rights reserved.";
        </script>
        <script src="../../app.js"></script>
    </footer>
    <div id="pdf-spinner-overlay">
        <div class="spinner"></div>
    </div>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-bash.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-cpp.min.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
jax: ["input/TeX", "output/HTML-CSS"],
extensions: ["tex2jax.js"],
"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] },
tex2jax: { inlineMath: [ ["$", "$"] ], displayMath: [ ["$$","$$"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
TeX: { noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } } },
messageStyle: "none"
});
</script>
<script async="" id="MathJax-script" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>

</html>