<!DOCTYPE html>

<html lang="en">

<head>
    <script async="" crossorigin="anonymous" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5593122079896089"></script>
    <meta charset="utf-8" />
    <title>Strategies for Branching</title>
    <meta content="Before choosing a branching strategy, it helps to decide what you‚Äôre optimizing for: speed, safety, or simplicity." name="description" />
    <meta content="Adam Djellouli" name="author" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <meta content="IE=edge" http-equiv="X-UA-Compatible" />
    <link crossorigin="" href="https://fonts.googleapis.com" rel="preconnect" />
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/icon.ico" rel="icon" />
    <link href="../../resources/style.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
</head>

<body>
    <nav aria-label="Main navigation">
        <a class="logo" href="https://adamdjellouli.com">
            <img alt="Adam Djellouli - Home Page Logo" id="logo-image" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/logo.PNG" />
        </a>
        <input aria-label="Toggle navigation menu" id="navbar-toggle" type="checkbox" />
        <ul aria-labelledby="navbar-toggle" role="menu">
            <li role="menuitem">
                <a href="../../index.html" title="Go to Home Page"> Home </a>
            </li>
            <li role="menuitem">
                <a class="active" href="../../core/blog.html" title="Read Adam Djellouli Blog on Programming and Technology"> Blog </a>
            </li>
            <li role="menuitem">
                <a href="../../core/tools.html" title="Discover Tools Created by Adam Djellouli"> Tools </a>
            </li>
            <li role="menuitem">
                <a href="../../core/projects.html" title="Explore Projects Developed by Adam Djellouli"> Projects </a>
            </li>
            <li role="menuitem">
                <a href="../../core/resume.html" title="View Adam Djellouli Professional Resume"> Resume </a>
            </li>
            <li>
                <script async="" src="https://cse.google.com/cse.js?cx=8160ef9bb935f4f68"></script>
                <div class="gcse-search"></div>
            </li>
            <li>
                <button aria-label="Toggle dark mode" id="dark-mode-button"></button>
            </li>
        </ul>
    </nav>
    <div id="article-wrapper"><article-section id="article-body">
            <div class="article-action-buttons"><button class="btn-suggest-edit" title="Suggest Edit">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <path d="M4 21h4l11-11-4-4L4 17v4z" stroke="currentColor" stroke-width="2"></path>
                    </svg>
                </button><button class="btn-create-issue" title="Create Issue">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2"></circle>
                        <line stroke="currentColor" stroke-width="2" x1="12" x2="12" y1="8" y2="12"></line>
                        <circle cx="12" cy="16" fill="currentColor" r="1"></circle>
                    </svg>
                </button><button class="btn-download" title="Download">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <path d="M12 5v14m0 0l-6-6m6 6l6-6" stroke="currentColor" stroke-width="2"></path>
                    </svg>
                </button></div>
            <p style="text-align: right;"><i>Last modified: September 13, 2025</i></p>
            <p style="text-align: right;"><i>This article is written in: üá∫üá∏</i></p>
            <h2 id="strategies-for-branching">Strategies for Branching</h2>
            <p>Before choosing a branching strategy, it helps to decide what you‚Äôre optimizing for: speed, safety, or simplicity. Different teams and projects lean different ways‚Äîstartups with small codebases won‚Äôt work the same as larger, multi-repo setups. This overview lays out the options and how to adapt them to your workflow.</p>
            <h3 id="trunk-based-development">Trunk-Based Development</h3>
            <p>In trunk-based development, <strong>a single long-lived branch‚Äîusually <code>main</code>, <code>master</code>, or <code>trunk</code>‚Äîis the integration point for all code</strong>. Small, short-lived feature (topic) branches are fine, but they <em>must</em> merge back to trunk quickly‚Äîideally within hours, and rarely later than a day or two.</p>
            <p>Every commit to trunk triggers the CI pipeline: it builds, runs the full automated test suite, performs static analysis, and‚Äîif green‚Äîdeploys to a staging/integration environment. After acceptance tests pass, the <strong>same artifact</strong> is promoted toward production unchanged.</p>
            <p>This approach depends on <strong>continuous integration</strong>, <strong>strong automated tests</strong>, and <strong>fast feedback loops</strong> so trunk stays releasable.</p>
            <p>
            <div>
                <pre><code class="language-shell">Main Branch (Trunk)
   |
   |‚Äî‚Äî&gt; Continuous Integration (CI)
   |         |
   |         v
   |  Automated Testing
   |
   |‚Äî‚Äî&gt; Short-Lived Feature Branches (optional)
   |         |
   |         v
   |  Feature Development
   |
   |‚Äî‚Äî&gt; Merge Back to Trunk (at least daily)
   |
   |‚Äî‚Äî&gt; Staging ‚Üí Production Release</code></pre>
            </div>
            </p>
            <p><strong>How are big breaking changes introduced?</strong></p>
            <p>Use incremental, backward-compatible steps: feature flags/toggles, <em>branch by abstraction</em>, and ‚Äúexpand/contract‚Äù migrations (e.g., add new paths first, dual-write, then remove the old). If a short branch is unavoidable, keep it tiny, merge daily, and hide behavior behind flags.</p>
            <p><strong>Is every commit here a transaction?</strong>
                Treat each commit as <strong>atomic and releasable</strong>: it should build, pass tests, and leave user-visible behavior unchanged by default (flags off). Commits trigger CI and often deploy to staging, but <strong>releases to users are controlled</strong> by flag flips or artifact promotion‚Äînot by every commit.</p>
            <h4 id="advantages">Advantages</h4>
            <ul>
                <li>A single trunk minimizes merge and release overhead; multiple long-lived branches create bottlenecks. For example, a startup can ship daily without heavy integration work.</li>
                <li>Small, frequent releases reduce risk versus bundling big updates; an e-commerce site can roll out checkout tweaks weekly instead of quarterly.</li>
                <li>Early integration surfaces conflicts quickly; delaying merges makes them harder and costlier. A game studio avoids last-minute crunch by merging daily.</li>
                <li>Keeping trunk releasable enables continuous deployability; otherwise teams get stuck stabilizing. A SaaS provider can hotfix anytime without waiting for a hardening sprint.</li>
            </ul>
            <h4 id="disadvantages">Disadvantages</h4>
            <ul>
                <li>Incomplete work needs <strong>feature flags</strong> to ship safely; without them, unfinished functionality can leak. A payments app hides a new API behind a toggle until testing is done.</li>
                <li>Large or architectural changes require <strong>branch by abstraction</strong> or expand/contract techniques; skipping them risks destabilizing trunk. A cloud service splits a database migration into small, deployable steps.</li>
                <li>Success hinges on <strong>disciplined automated testing</strong>; neglect leads to fragile releases. A healthcare platform runs full regression suites on every commit.</li>
                <li>Build stability suffers if <strong>merge frequency</strong> drops; regular integration prevents long disruptions. A large open-source project enforces daily merges to avoid spikes in broken builds.</li>
            </ul>
            <h4 id="when-to-use">When to Use</h4>
            <ul>
                <li>Teams <strong>practicing daily CI</strong> benefit most; merging weekly or less blunts the gains. A fintech team commits multiple times per day to maintain flow.</li>
                <li>Projects that can be <strong>tested in independent slices</strong> fit well; tightly coupled systems struggle. A microservices platform evolves each service without blocking others.</li>
                <li>Organizations aiming for <strong>continuous delivery</strong> gain speed and safe rollback; long, gated release trains lose much of the benefit. A streaming provider ships fast with instant rollback if needed.</li>
                <li>Heavy regulatory gates or <strong>big-bang releases</strong> reduce suitability; such environments often keep long-running release branches. A defense contractor bound by compliance stages remains on release branches.</li>
            </ul>
            <h4 id="critique">Critique</h4>
            <ul>
                <li>Critics say this model only works well when a team has excellent automated tests and very reliable CI.</li>
                <li>Without that, frequent merges to the main branch feel risky.</li>
                <li>Feature flags (used to hide unfinished work) add complexity and can accidentally expose half-built features.</li>
                <li>Big, sweeping changes are hard to slice into tiny safe steps, so they can feel awkward or slow.</li>
                <li>If the build pipeline is flaky, everyone gets blocked.</li>
                <li>Some also find lots of small PRs reduce review depth and make the history noisy.</li>
            </ul>
            <h3 id="release-branches">Release Branches</h3>
            <p>In the <strong>release-branching</strong> workflow, each upcoming version is stabilised on its own branch while everyday feature work continues elsewhere. A typical setup includes:</p>
            <ul>
                <li><code>main</code> (or <code>master</code>) ‚Äì holds production-ready code and immutable version tags (e.g., <code>v2.3.0</code>).</li>
                <li><code>develop</code> ‚Äì the integration branch for day-to-day feature work.</li>
                <li><em>Release branch</em> ‚Äì cut from <code>develop</code> when you declare the next version feature-complete; only bug fixes, documentation tweaks, and release housekeeping (version bumps, build scripts, localisation strings, etc.) are allowed.</li>
                <li><em>Hotfix branch</em> ‚Äì cut directly from <code>main</code> to address critical production issues; merge back into both <code>main</code> <em>and</em> <code>develop</code> (or the active release branch) to prevent regressions.</li>
            </ul>
            <p>
            <div>
                <pre><code class="language-shell">main
 ‚îÇ
 ‚îú‚îÄ‚îÄ‚ñ∂ develop
 ‚îÇ       ‚îÇ
 ‚îÇ       ‚îú‚îÄ‚îÄ‚ñ∂ Feature branches (feat/XYZ)
 ‚îÇ       ‚îÇ        ‚îÇ
 ‚îÇ       ‚îÇ        ‚ñº
 ‚îÇ       ‚îÇ  Merge back to develop
 ‚îÇ       ‚îÇ
 ‚îÇ       ‚îî‚îÄ‚îÄ‚ñ∂ Release-X.Y branch
 ‚îÇ                ‚îÇ
 ‚îÇ                ‚îú‚îÄ‚îÄ‚ñ∂ Bug fixes / final hardening
 ‚îÇ                ‚îÇ
 ‚îÇ                ‚îî‚îÄ‚îÄ‚ñ∂ (if urgent) Hotfix branch
 ‚îÇ                         ‚îÇ
 ‚îÇ                         ‚ñº
 ‚îÇ                     Merge to Release-X.Y
 ‚îÇ
 ‚îú‚îÄ‚îÄ‚ñ∂ Merge Release-X.Y ‚Üí main &amp; tag vX.Y.0
 ‚îÇ
 ‚ñº
Production deployment</code></pre>
            </div>
            </p>
            <p>Once the release branch is declared stable:</p>
            <ol>
                <li><em>Merge into <code>main</code></em> and create an annotated, immutable tag (<code>vX.Y.0</code>) for traceability.</li>
                <li><em>Merge (or rebase) back into <code>develop</code></em> so ongoing work includes all post-freeze fixes.</li>
                <li><em>Delete (or archive) the release branch</em> to avoid clutter.</li>
            </ol>
            <h4 id="advantages">Advantages</h4>
            <ul>
                <li><em>Parallel version support</em> lets you stabilise one release while new features move forward elsewhere (e.g., an ERP vendor patches <code>v3.2</code> while building <code>v3.3</code>).</li>
                <li><em>No feature flags on the release branch</em>‚Äîonly completed work lands there, reducing runtime complexity (a mobile team ships toggles-free releases).</li>
                <li><em>Scoped hotfixes</em> target just the affected version, avoiding unintended side effects (a cloud provider patches <code>v2.x</code> without touching <code>v3.x</code>).</li>
                <li><em>Predictable milestones</em> give QA and stakeholders a clear test scope (a quarterly on-prem release locks features so validation is focused).</li>
            </ul>
            <h4 id="disadvantages">Disadvantages</h4>
            <ul>
                <li><em>Slower cadence</em>‚Äîfeatures may wait for the next window, whereas CI/CD on trunk moves faster (app-store cycles can delay delivery).</li>
                <li><em>Merge overhead</em>‚Äîfixes must be propagated across branches; a single-branch model avoids duplication (teams on <code>v1.x</code> and <code>v2.x</code> copy fixes twice).</li>
                <li><em>Branch sprawl</em>‚Äîmore active branches complicate tooling and mental models; small teams often prefer a single trunk.</li>
                <li><em>Divergence risk</em>‚Äîlong-lived branches drift and make merges painful; frequent integration keeps differences small.</li>
            </ul>
            <h4 id="when-to-use">When to Use</h4>
            <ul>
                <li>Products with <em>formal release schedules</em> (e.g., quarterly enterprise software).</li>
                <li>Situations with <em>multiple supported versions</em> in the wild (supporting <code>v1.x</code> for legacy and <code>v2.x</code> for new customers).</li>
                <li>Environments with <em>compliance/audit gates</em> where clearly scoped releases map to documentation (e.g., medical devices).</li>
                <li>Less suitable for teams pursuing <em>continuous delivery</em>, where frequent releases and feature toggles already work well.</li>
            </ul>
            <h4 id="not-the-same-as-git-flow">Not the same as Git Flow</h4>
            <p><em>Git Flow</em> is a full branching methodology. <em>Release branches</em> are a single ingredient‚Äîoften used within Git Flow, but also viable on their own.</p>
            <h4 id="critique">Critique</h4>
            <ul>
                <li>Extra ceremony and slower pace can frustrate teams.</li>
                <li>‚ÄúCode freeze‚Äù on the release branch pauses new work.</li>
                <li>Fixes often have to be merged twice (into the release and back into develop), which is tedious and error-prone.</li>
                <li>Long-lived release branches drift from the main line, causing painful merge conflicts later.</li>
                <li>The workflow encourages big ‚Äúall-at-once‚Äù releases instead of small, frequent ones.</li>
                <li>Tracking changes across many branches makes automation and debugging harder.</li>
            </ul>
            <h3 id="feature-branches">Feature Branches</h3>
            <p>In a <strong>feature-branch</strong> workflow, each new capability, enhancement, or bug fix lives on its <em>own</em> branch cut from a stable integration branch (<code>main</code> or, more often, <code>develop</code>). Work proceeds in isolation until the change set is <em>complete</em> and the CI pipeline is green. The branch is then merged back via a pull/merge request after code review and automated checks. The resulting commits flow to production in the next release train‚Äîor immediately, if you practise continuous delivery.</p>
            <p>Typical naming conventions: <code>feat/&lt;ticket-id&gt;-&lt;slug&gt;</code> for new functionality and <code>fix/&lt;ticket-id&gt;</code> for defects. This keeps context clear for both tooling and humans.</p>
            <p>
            <div>
                <pre><code class="language-shell">main
 ‚îÇ
 ‚îú‚îÄ‚îÄ‚ñ∂ develop   (optional integration branch)
 ‚îÇ       ‚îÇ
 ‚îÇ       ‚îú‚îÄ‚îÄ‚ñ∂ feat/ABC-123-cool-feature
 ‚îÇ       ‚îÇ        ‚îÇ
 ‚îÇ       ‚îÇ        ‚ñº
 ‚îÇ       ‚îÇ   Commit ‚Üí test ‚Üí review
 ‚îÇ       ‚îÇ        ‚îÇ
 ‚îÇ       ‚îî‚îÄ‚îÄ‚ñ∂‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  Merge to develop
 ‚îÇ
 ‚îî‚îÄ‚îÄ‚ñ∂ (CI) ‚Üí Release preparation ‚Üí Production</code></pre>
            </div>
            </p>
            <h4 id="advantages">Advantages</h4>
            <ul>
                <li><em>Isolation</em> keeps incomplete work off trunk, reducing broken builds; e.g., a fintech team develops a new payment flow separately until it‚Äôs production-ready.</li>
                <li><em>Parallel development</em> lets multiple efforts progress without constant conflicts; a web platform team can add search while redesigning the UI.</li>
                <li><em>Focused reviews</em> on small, scoped PRs improve signal and accountability; an open-source project reviews only the new API endpoint in a single branch.</li>
            </ul>
            <h4 id="disadvantages">Disadvantages</h4>
            <ul>
                <li><em>Integration drift</em> grows on long-lived branches; frequent rebases/merges keep code close to trunk. A mobile team faces multi-day conflicts after a month-long branch.</li>
                <li><em>Delayed feedback</em> hides interaction bugs until merge; early, regular syncs surface issues sooner. A logistics platform discovers a shipments/invoicing bug at final merge.</li>
                <li><em>Discipline required</em>‚Äîbranches should be short-lived; neglect leads to stale, hard-to-merge work. A game studio rebases daily and closes branches within a week.</li>
            </ul>
            <h4 id="when-to-use">When to Use</h4>
            <ul>
                <li>Teams that value <em>explicit review gates</em> and an auditable trail of changes; a government IT project treats each MR as a compliance artefact.</li>
                <li>Projects delivering <em>independent features</em> in days or weeks; a SaaS product ships dashboard filters via short-lived branches.</li>
                <li>Organisations not yet ready for <em>trunk-based development</em> can reduce risk with scoped branches; teams already practising trunk-based merges may not need them.</li>
            </ul>
            <p>Avoid very long-running feature branches. If a change is large, break it into incremental slices or use <em>branch-by-abstraction</em> so you can merge to trunk early and often.</p>
            <h4 id="critique">Critique</h4>
            <ul>
                <li><strong>Delay and drift:</strong> When branches stay open for weeks, they fall behind the main codebase and merge conflicts pile up.</li>
                <li><strong>Large pull requests:</strong> PRs can grow large, slowing reviews and hiding problems until late in the process.</li>
                <li><strong>Wasted effort:</strong> Rebasing or updating branches burns time, and CI runs are duplicated for many branches.</li>
                <li><strong>Reduced collaboration:</strong> The PR gate can replace early, direct collaboration with a slower ‚Äúthrow it over the wall‚Äù review cycle.</li>
                <li><strong>Stale work:</strong> Lingering branches and PRs sap momentum.</li>
            </ul>
            <h3 id="forking">Forking</h3>
            <p>In a <strong>fork-based</strong> workflow, contributors work on their <em>own</em> copy of the repository‚Äîa <em>fork</em>‚Äîinstead of pushing branches to the canonical project. Changes flow back to the <em>upstream</em> repository via pull requests (PRs; ‚Äúmerge requests‚Äù on some platforms), where maintainers review, discuss, and merge.</p>
            <p>Typical fork setup:</p>
            <ul>
                <li><em>Upstream</em> ‚Äì the original, authoritative repository. In a contributor‚Äôs clone, this is usually added as the <code>upstream</code> remote (while <code>origin</code> points to the fork).</li>
                <li><em>Fork</em> ‚Äì a full clone under the contributor‚Äôs account or an internal team namespace.</li>
                <li><em>Feature/topic branches</em> ‚Äì created in the fork for each unit of work.</li>
                <li><em>Pull request (PR)</em> ‚Äì proposes the branch for inclusion upstream; CI runs, reviewers comment, and maintainers merge (often with <strong>squash</strong> or <strong>rebase-and-merge</strong>) to keep history tidy.</li>
            </ul>
            <p>
            <div>
                <pre><code class="language-shell">Upstream repo
   ‚îÇ
   ‚îú‚îÄ‚îÄ‚ñ∂ main (production)
   ‚îÇ       ‚îÇ
   ‚îÇ       ‚îî‚îÄ‚îÄ‚ñ∂ (optional) topic branches
   ‚îÇ
   ‚îî‚îÄ‚îÄ‚ñ∂ Forked repo (contributor / team)
           ‚îÇ
           ‚îú‚îÄ‚îÄ‚ñ∂ main (kept in sync with upstream)
           ‚îÇ
           ‚îî‚îÄ‚îÄ‚ñ∂ feat/XYZ-topic
                     ‚îÇ
                     ‚ñº
                Development &amp; local CI
                     ‚îÇ
                     ‚ñº
                 Pull request ‚ñ≤
                               ‚îÇ
                               ‚ñº
                  Review ‚Üí Merge ‚Üí Upstream main</code></pre>
            </div>
            </p>
            <h4 id="advantages">Advantages</h4>
            <ul>
                <li>Enforcing a <em>safe contribution model</em> by requiring PRs from forks prevents direct changes to upstream; skipping this risks accidents like force-pushes. A popular JavaScript library, for example, avoids exposing write access to casual contributors.</li>
                <li>Operating with <em>low coupling</em> lets each fork run its own CI and manage work independently; sharing a single namespace often causes collisions. A research consortium can experiment per university before proposing upstream changes.</li>
                <li>Scaling to <em>large contributor bases</em> is feasible when maintainers control merges centrally; direct-commit models don‚Äôt scale under volume. Global projects can accept patches from thousands without granting upstream write access.</li>
            </ul>
            <h4 id="disadvantages">Disadvantages</h4>
            <ul>
                <li>Poor <em>sync hygiene</em> causes forks to drift; regular fetch/rebase keeps contributors aligned with upstream. A contributor to an ML framework may face hours of conflict resolution after months without syncing.</li>
                <li><em>Review bottlenecks</em> slow progress when maintainers face heavy PR queues; smaller, curated contributor pools reduce wait times. A blockchain project can see week-long delays before patches are merged.</li>
                <li>Duplicated <em>CI runs</em> across forks inflate costs; consolidated pipelines minimise waste. An enterprise open-sourcing an SDK may see cloud CI bills climb as hundreds of forks trigger builds.</li>
            </ul>
            <h4 id="when-to-use">When to Use</h4>
            <ul>
                <li>Open-source projects that rely on <em>external contributions</em> benefit most; closed teams often gain little from the added overhead. A web framework community depends on forked PRs to manage outside patches.</li>
                <li>Internal platforms with <em>strict permission boundaries</em> gain isolation through forks; permissive repos may prefer simpler branch-based models. A multinational lets subsidiaries adapt code safely in their own forks.</li>
                <li><em>Security-sensitive environments</em> can enforce signed PRs and audit trails through forks; looser workflows risk unverified changes. A defence contractor requires every patch to arrive via a forked PR.</li>
            </ul>
            <p>Keep forks fresh by adding the upstream remote (<code>git remote add upstream &lt;url&gt;</code>), then regularly syncing: <code>git fetch upstream</code> followed by <code>git rebase upstream/main</code> (or <code>git pull --rebase upstream main</code>). Stale forks are the main pain point here; proactive syncing and small, focused PRs keep the workflow smooth.</p>
            <h4 id="critique">Critique</h4>
            <ul>
                <li>Contributors often struggle to keep their fork in sync with the upstream project; long gaps mean ugly conflicts later.</li>
                <li>CI can be weaker on forks (secrets and internal checks may not run), so maintainers must re-run jobs, adding friction.</li>
                <li>A small maintainer team can‚Äôt review a huge PR queue quickly, so contributions sit for days or weeks.</li>
                <li>Discussion and context spread across many forks and PRs, which makes triage and coordination harder.</li>
                <li>It‚Äôs secure, but high-friction for frequent collaborators.</li>
            </ul>
            <h3 id="git-flow">Git Flow</h3>
            <p><strong>Git Flow</strong> is a prescriptive branching model, proposed by Vincent Driessen, that assigns <em>named roles</em> to branches with clear rules for when to create, merge, and retire them.
                It suits projects that ship <em>versioned</em> releases on a predictable cadence and need to patch production urgently while regular feature work continues.</p>
            <ul>
                <li><code>main</code> ‚Äì always reflects what‚Äôs running in production and is tagged (<code>vX.Y.Z</code>) at each release.</li>
                <li><code>develop</code> ‚Äì the permanent integration branch for day-to-day development.</li>
                <li><code>feature/*</code> ‚Äì short-lived branches cut from <code>develop</code> for each new capability or bug fix; merge back into <code>develop</code> when complete.</li>
                <li><code>release/*</code> ‚Äì cut from <code>develop</code> once the next version is feature-complete; only stabilisation changes (bug fixes, docs, build metadata) are allowed; merges into both <code>main</code> and <code>develop</code>.</li>
                <li><code>hotfix/*</code> ‚Äì cut directly from <code>main</code> to address urgent production defects; merges into both <code>main</code> <em>and</em> <code>develop</code> (and any active <code>release/*</code> branch).</li>
            </ul>
            <p>
            <div>
                <pre><code class="language-shell">main ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂ (tag vX.Y.0) ‚îÄ‚îÄ‚îê
       ‚îÇ                              ‚îÇ
       ‚îÇ‚óÄ‚îÄ merge hotfix/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂ (tag vX.Y.1)
       ‚îÇ                              ‚îÇ
develop‚îÇ‚óÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ merge release/*‚îò
  ‚îÇ
  ‚îú‚îÄ‚îÄ‚ñ∂ feature/ABC-123
  ‚îÇ        ‚îÇ
  ‚îÇ        ‚îî‚îÄ‚îÄ‚ñ∂ merge ‚Üí develop
  ‚îÇ
  ‚îî‚îÄ‚îÄ‚ñ∂ release/X.Y
           ‚îÇ
           ‚îú‚îÄ‚îÄ‚ñ∂ final bug fixes
           ‚îî‚îÄ‚îÄ‚ñ∂ merge ‚Üí main  &amp;  merge ‚Üí develop</code></pre>
            </div>
            </p>
            <h4 id="advantages">Advantages</h4>
            <ul>
                <li><em>Role clarity</em> gives each branch a distinct purpose; without it, responsibilities blur and contributors get confused. For example, a banking platform keeps ongoing work on <code>develop</code> while urgent fixes go to <code>hotfix/*</code>.</li>
                <li><em>Parallel work streams</em> allow teams to develop features, stabilise a release, and patch production simultaneously; a mobile app team can ready <code>v2.1</code> on <code>release/*</code> while starting <code>v2.2</code> features on <code>develop</code>.</li>
                <li><em>Release hardening</em> phases surface late bugs without halting new work; an on-prem ERP vendor stabilises <code>v5.4</code> on <code>release/*</code> while roadmap features continue on <code>develop</code>.</li>
            </ul>
            <h4 id="disadvantages">Disadvantages</h4>
            <ul>
                <li>Five branch types add <em>process overhead</em>; simpler models need less training and coordination. A midsize SaaS finds Git Flow slower to onboard than trunk-based workflows.</li>
                <li><em>Long-lived divergence</em> makes merges painful; keeping branches short reduces integration risk. A telecom vendor struggles when <code>release/*</code> drifts weeks from <code>develop</code>.</li>
                <li>Typically a <em>slower cadence</em> than trunk-based or short-lived branching; a startup delays customer-visible improvements until the next scheduled release.</li>
            </ul>
            <h4 id="when-to-use">When to Use</h4>
            <ul>
                <li>Products with <em>formal release schedules</em> benefit, while continuously deployed services may find it heavy. A quarterly enterprise desktop product fits well.</li>
                <li>Organisations with <em>separate Dev, QA, and Ops roles</em> gain from explicit branch stages; cross-functional teams may prefer lighter models. A regulated insurer requires QA sign-off before merging into <code>release/*</code>.</li>
                <li>Maintaining <em>multiple supported versions</em> makes hotfix branches valuable; single-version products rarely need them. A medical software provider patches <code>v3.x</code> in production while continuing work on <code>v4.x</code>.</li>
            </ul>
            <p>If you aim for <em>continuous delivery</em> or deploy many times a day, Git Flow will likely feel heavyweight; consider trunk-based development or a simple feature-branch workflow instead.</p>
            <h4 id="critique">Critique</h4>
            <ul>
                <li>Considered <em>heavy and dated</em> for modern CI/CD; detractors argue it slows down teams used to rapid iteration.</li>
                <li>The <em>many branch types</em> add process and slow onboarding; new team members face a steeper learning curve.</li>
                <li>The permanent <code>develop</code> branch can feel like an unnecessary extra hop, complicating the path to production.</li>
                <li><code>release/*</code> and <code>hotfix/*</code> branches add merge overhead and increase the risk of divergence; teams report painful merges when branches drift apart.</li>
                <li>Teams often experience <em>slower feedback</em> and <em>slower releases</em> compared to trunk-based or short-lived feature branch workflows.</li>
                <li>Histories can become cluttered with coordination merges, making it harder to read and understand the commit log.</li>
            </ul>
            <h3 id="environment-branching">Environment Branching</h3>
            <p>In an <strong>environment-branching</strong> workflow, each <em>runtime environment</em>‚Äîdevelopment, QA, staging, production‚Äîhas its own long-lived branch. Code moves ‚Äúup the ladder‚Äù by merging (or cherry-picking) from one environment branch to the next, mirroring how build artefacts and database changes are promoted.</p>
            <p>Typical branch mapping:</p>
            <ul>
                <li><code>develop</code> ‚Äì the developers‚Äô sandbox; unstable experiments are expected.</li>
                <li><code>qa</code> (or <code>test</code>) ‚Äì mirrors the formal testing environment; only code that has passed review and automated checks is promoted here.</li>
                <li><code>staging</code> ‚Äì a pre-production clone of live; final acceptance, performance, and compliance testing happen here.</li>
                <li><code>main</code> (or <code>production</code>) ‚Äì tracks what is currently in production; immutable tags (<code>vX.Y.Z</code>) mark each deployment.</li>
            </ul>
            <p>
            <div>
                <pre><code class="language-shell">develop ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂ (dev environment)
          ‚îÇ
          ‚îî‚îÄ‚îÄ‚ñ∂ qa ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂ (QA / test environment)
                      ‚îÇ
                      ‚îî‚îÄ‚îÄ‚ñ∂ staging ‚îÄ‚îÄ‚îÄ‚ñ∂ (staging environment)
                                          ‚îÇ
                                          ‚ñº
                                      main (prod) ‚îÄ‚îÄ‚ñ∂ (production)</code></pre>
            </div>
            </p>
            <p>Promotion flow:</p>
            <ol>
                <li>Finish work on <code>develop</code> ‚Üí merge to <code>qa</code>.</li>
                <li>QA passes ‚Üí fast-forward or merge <code>qa</code> ‚Üí <code>staging</code>.</li>
                <li>Final sign-off ‚Üí merge <code>staging</code> ‚Üí <code>main</code> and deploy.
                    <em>Hotfixes</em> start on <code>main</code>, then cascade back to <code>staging</code>, <code>qa</code>, and <code>develop</code> to keep branches aligned.
                </li>
            </ol>
            <h4 id="advantages">Advantages</h4>
            <ul>
                <li>Maintaining <em>environment visibility</em> means each branch maps to a deployed environment, whereas skipping this blurs traceability; for example, a bank‚Äôs <code>qa</code> branch reflects exactly what testers are validating.</li>
                <li>Using <em>paced promotion</em> lets changes pause in QA or staging for deeper checks, whereas merging straight to production risks unvetted code; a medical-device firm runs extended regulatory tests in <code>staging</code> before promoting.</li>
                <li>Aligning with <em>regulatory expectations</em> provides auditors a clear branch-to-environment link, whereas missing this mapping complicates evidence; an aviation vendor can point regulators to the precise branch under test.</li>
            </ul>
            <h4 id="disadvantages">Disadvantages</h4>
            <ul>
                <li>Orchestrating <em>merges across environments</em> adds complexity, whereas lighter models need fewer moves; a finance team spends hours cherry-picking fixes through <code>qa</code>, <code>staging</code>, and <code>prod</code>.</li>
                <li>Allowing <em>branch divergence</em> breeds ‚Äúworks-on-my-env‚Äù bugs, whereas disciplined syncing prevents drift; a telecom sees a prod incident when a <code>staging</code> patch never reaches <code>develop</code>.</li>
                <li><em>Slower feedback loops</em> postpone integration issues, whereas trunk-based flows surface them early; a logistics platform discovers conflicting features only after days sitting in <code>qa</code>.</li>
                <li>Supporting <em>multiple environment branches</em> strains CI/CD, whereas single-branch pipelines stay lean; a legacy ERP vendor pays for duplicated builds across several environment branches.</li>
            </ul>
            <h4 id="when-to-use">When to Use</h4>
            <ul>
                <li>Organisations with <em>rigid stage gates</em> (e.g., FDA/aviation) benefit, whereas less-regulated sectors may not need the overhead; a medical records system must pass certified environments.</li>
                <li><em>Separate Dev, QA, and Ops teams</em> align well with environment ownership, whereas integrated product teams may prefer trunk-based flows; a bank assigns <code>qa</code>, <code>staging</code>, and <code>prod</code> to different groups.</li>
                <li><em>Legacy, heavyweight deployments</em> justify extra staging steps, whereas modern cloud-native platforms may prefer faster rollback strategies; an insurer running mainframe code relies on staging time to mitigate rollback risk.</li>
            </ul>
            <p>If rapid, continuous delivery is the goal, consider slimming the number of environment branches‚Äîor switch to release branches or trunk-based development plus feature flags‚Äîto keep promotion fast while retaining control.</p>
            <h4 id="critique">Critique</h4>
            <p>Common complaints about this model include:</p>
            <ul>
                <li><strong>Branches represent environments, not changes:</strong> Branches end up representing <em>environments</em> (dev/QA/staging/prod) instead of <em>changes to the code</em>, which leads to drift between branches, lots of cherry-picking, and hard-to-trace deployments.</li>
                <li><strong>Breaks artifact promotion best practices:</strong> Best practice is to build <strong>once</strong> and promote the <strong>same artifact</strong> through each environment, changing only configuration. Environment branches usually break that rule, so ‚Äústaging‚Äù and ‚Äúprod‚Äù run different commits and bugs slip through.</li>
                <li><strong>Configuration management issues:</strong> Configuration should live outside the code (env vars, secrets, config stores), not as separate code branches, which is a core 12-factor principle.</li>
                <li><strong>CI/CD and audit complexity:</strong> Per-environment branches multiply CI pipelines and make rollbacks and audits harder because you can‚Äôt point to one SHA that moved through the pipeline unchanged.</li>
            </ul>
            <p>These critiques show up across CD/GitOps guidance and are a big reason many call ‚Äúbranch-per-environment‚Äù an anti-pattern.</p>
        </article-section>
        <div id="table-of-contents">
            <h2>Table of Contents</h2>
            <ol><a href="#strategies-for-branching">Strategies for Branching</a>
                <ol>
                    <li><a href="#trunk-based-development">Trunk-Based Development</a>
                        <ol>
                            <li><a href="#advantages">Advantages</a></li>
                            <li><a href="#disadvantages">Disadvantages</a></li>
                            <li><a href="#when-to-use">When to Use</a></li>
                            <li><a href="#critique">Critique</a></li>
                        </ol>
                    </li>
                    <li><a href="#release-branches">Release Branches</a>
                        <ol>
                            <li><a href="#advantages">Advantages</a></li>
                            <li><a href="#disadvantages">Disadvantages</a></li>
                            <li><a href="#when-to-use">When to Use</a></li>
                            <li><a href="#not-the-same-as-git-flow">Not the same as Git Flow</a></li>
                            <li><a href="#critique">Critique</a></li>
                        </ol>
                    </li>
                    <li><a href="#feature-branches">Feature Branches</a>
                        <ol>
                            <li><a href="#advantages">Advantages</a></li>
                            <li><a href="#disadvantages">Disadvantages</a></li>
                            <li><a href="#when-to-use">When to Use</a></li>
                            <li><a href="#critique">Critique</a></li>
                        </ol>
                    </li>
                    <li><a href="#forking">Forking</a>
                        <ol>
                            <li><a href="#advantages">Advantages</a></li>
                            <li><a href="#disadvantages">Disadvantages</a></li>
                            <li><a href="#when-to-use">When to Use</a></li>
                            <li><a href="#critique">Critique</a></li>
                        </ol>
                    </li>
                    <li><a href="#git-flow">Git Flow</a>
                        <ol>
                            <li><a href="#advantages">Advantages</a></li>
                            <li><a href="#disadvantages">Disadvantages</a></li>
                            <li><a href="#when-to-use">When to Use</a></li>
                            <li><a href="#critique">Critique</a></li>
                        </ol>
                    </li>
                    <li><a href="#environment-branching">Environment Branching</a>
                        <ol>
                            <li><a href="#advantages">Advantages</a></li>
                            <li><a href="#disadvantages">Disadvantages</a></li>
                            <li><a href="#when-to-use">When to Use</a></li>
                            <li><a href="#critique">Critique</a></li>
                        </ol>
                    </li>
                </ol>
            </ol>
            <div id="related-articles">
                <h2>Related Articles</h2>
                <ol>
                    <li><a href="https://adamdjellouli.com/articles/git_notes/01_introduction_to_version_control.html">Introduction to Version Control</a></li>
                    <li><a href="https://adamdjellouli.com/articles/git_notes/02_create_repository.html">Create Repository</a></li>
                    <li><a href="https://adamdjellouli.com/articles/git_notes/03_making_changes.html">Making Changes</a></li>
                    <li><a href="https://adamdjellouli.com/articles/git_notes/04_working_with_branches.html">Working with Branches</a></li>
                    <li><a href="https://adamdjellouli.com/articles/git_notes/05_head.html">Head</a></li>
                    <li><a href="https://adamdjellouli.com/articles/git_notes/06_tags.html">Tags</a></li>
                    <li><a href="https://adamdjellouli.com/articles/git_notes/07_stashing_files.html">Stashing Files</a></li>
                    <li><a href="https://adamdjellouli.com/articles/git_notes/08_observing_repository.html">Observing Repository</a></li>
                    <li><a href="https://adamdjellouli.com/articles/git_notes/09_synchronization.html">Synchronization</a></li>
                    <li><a href="https://adamdjellouli.com/articles/git_notes/10_squashing_commits.html">Squashing Commits</a></li>
                    <li><a href="https://adamdjellouli.com/articles/git_notes/11_archive.html">Archive</a></li>
                    <li><a href="https://adamdjellouli.com/articles/git_notes/12_git_server.html">Git Server</a></li>
                    <li><a href="https://adamdjellouli.com/articles/git_notes/13_points_of_confusion.html">Points of Confusion</a></li>
                    <li><a href="https://adamdjellouli.com/articles/git_notes/14_branching_strategies.html">Branching Strategies</a></li>
                    <li><a href="https://adamdjellouli.com/articles/git_notes/15_mono_and_multi_repo.html">Mono and Multi Repo</a></li>
                    <li><a href="https://adamdjellouli.com/articles/git_notes/16_dangerous_commands.html">Dangerous Commands</a></li>
                    <li><a href="https://adamdjellouli.com/articles/git_notes/17_git_internals.html">Git Internals</a></li>
                </ol>
            </div>
        </div>
    </div>
    <footer>
        <div class="footer-columns">
            <div class="footer-column">
                <img alt="Adam Djellouli Symbol" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/symbol.png" />
            </div>
            <div class="footer-column">
                <h2><a href="https://adamdjellouli.com/core/privacy_policy.html" title="Privacy Policy">Our Privacy Policy</a></h2>
                <p>Thank you for visiting my personal website. All content here is free to use, but please remember to be respectful and avoid any misuse of the site. If you‚Äôd like to get in touch, feel free to reach out via my <a href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" title="LinkedIn Profile">LinkedIn profile</a> or connect with me on <a href="https://github.com/djeada" title="GitHub Profile">GitHub</a> if you have technical questions or ideas to share. Wishing you all the best and a fantastic life ahead!</p>
            </div>
            <div class="footer-column">
                <h2>Follow me</h2>
                <ul class="social-media">
                    <li>
                        <a class="fa fa-youtube" href="https://www.youtube.com/channel/UCGPoHTVjMN77wcGknXPHl1Q" target="_blank" title="YouTube">
                        </a>YouTube
                    </li>
                    <li>
                        <a class="fa fa-linkedin" href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" target="_blank" title="LinkedIn">
                        </a>LinkedIn
                    </li>
                    <li>
                        <a class="fa fa-instagram" href="https://www.instagram.com/linuxchallenges/" target="_blank" title="Instagram">
                        </a>Instagram
                    </li>
                    <li>
                        <a class="fa fa-github" href="https://github.com/djeada" title="GitHub">
                        </a>Github
                    </li>
                </ul>
            </div>
        </div>
        <div>
            <p id="copyright">
                ¬© Adam Djellouli. All rights reserved.
            </p>
        </div>
        <script>
            document.getElementById("copyright").innerHTML = "&copy; " + new Date().getFullYear() + " Adam Djellouli. All rights reserved.";
        </script>
        <script src="../../app.js"></script>
    </footer>
    <div id="pdf-spinner-overlay">
        <div class="spinner"></div>
    </div>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-bash.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-cpp.min.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
jax: ["input/TeX", "output/HTML-CSS"],
extensions: ["tex2jax.js"],
"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] },
tex2jax: { inlineMath: [ ["$", "$"] ], displayMath: [ ["$$","$$"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
TeX: { noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } } },
messageStyle: "none"
});
</script>
<script async="" id="MathJax-script" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>

</html>