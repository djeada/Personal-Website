<!DOCTYPE html>

<html lang="pl">

<head>
    <script async="" crossorigin="anonymous" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5593122079896089"></script>
    <title>Programowanie Obiektowe</title>
    <meta charset="utf-8" />
    <meta content="Programowanie obiektowe polega na pisaniu programów, w których różne elementy programu, takie jak dane oraz funkcje, zostają zorganizowane w formie obiektów." name="description" />
    <meta content="Adam Djellouli" name="keywords" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/icon.ico" rel="icon" />
    <link href="../resources/style.css" rel="stylesheet" type="text/css" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />
    <link href="https://fonts.googleapis.com" rel="preconnect" />
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <meta content="ie-edge" http-equiv="X-UA-Compatible" />
</head>

<body>
    <nav>
        <a class="logo" href="../index.html" title="Adam Djellouli - Home">
            <img alt="Adam Djellouli Logo" id="logo-image" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/logo.PNG" />
        </a>
        <input aria-label="Toggle navigation menu" id="navbar-toggle" type="checkbox" />
        <ul>
            <li> <a href="../index.html" title="Home"> Home </a> </li>
            <li> <a class="active" href="../core/blog.html" title="Adam Djellouli's Blog - Programming, technology and more"> Blog </a> </li>
            <li> <a href="../core/tools.html" title="Useful Tools by Adam Djellouli"> Tools </a> </li>
            <li> <a href="../core/projects.html" title="Projects by Adam Djellouli"> Projects </a> </li>
            <li> <a href="../core/resume.html" title="Adam Djellouli's Resume"> Resume </a> </li>
            <li> <a href="../core/about.html" title="About Adam Djellouli"> About </a> </li>
            <button aria-label="Toggle dark mode" id="dark-mode-button"></button>
        </ul>
    </nav>
    <section id="article-body"></section>
    <p style="text-align: right;"><i>This article is written in: 🇵🇱</i></p>
    <div id="article-wrapper">
        <section id="article-body">

            <h2 id="programowanie-obiektowe">Programowanie Obiektowe</h2>
            <p>Programowanie obiektowe polega na pisaniu programów, w których różne elementy programu, takie jak dane oraz funkcje, zostają zorganizowane w formie obiektów.</p>
            <ol>
                <li>Klasa jest szablonem, w którym definiujemy pola (dane przechowywane przez obiekt) oraz metody (funkcje, które operują na polach). Na przykład, klasa Prostokat mogłaby mieć pola a i b (wymiary prostokątu) oraz metodę pole(), która zwraca pole tego prostokątu.</li>
            </ol>
            <p>
            <div>
                <pre><code class="language-clike">class Prostokat {
  int a;
  int b;
public:
  Prostokat(int a, int b) {
    this-&gt;a = a;
    this-&gt;b = b;
  }
int pole() { return a * b; }
};</code></pre>
            </div>
            </p>
            <ol>
                <li>Obiekty to instancje klasy w programie. Przykład użycia powyższej klasy:</li>
            </ol>
            <p>
            <div>
                <pre><code class="language-clike">Prostokat p(3,4); // Tworzymy obiekt klasy Prostokat
std::cout &lt;&lt; p.pole() &lt;&lt; std::endl; // Wypisujemy pole tego prostokątu</code></pre>
            </div>
            </p>
            <p>Dlaczego warto korzystać z programowania obiektowego?</p>
            <ul>
                <li>Modularność: każda klasa ma jasno określony cel i wszystko, co z nią jest związane, jest zamknięte w tej klasie. Dzięki temu, łatwiej jest zrozumieć i utrzymać kod.</li>
                <li>Łatwość wielokrotnego użytku: możemy tworzyć (teoretycznie) nieskończoną ilość obiektów danej klasy, co pozwala na rozwiązanie różnych problemów.</li>
            </ul>
            <h3 id="konstruktor">Konstruktor</h3>
            <p>Konstruktor jest funkcją, która jest wywoływana przy tworzeniu obiektu. Konstruktor ma taką samą nazwę jak klasa i nie posiada zwracanego typu, gdyż nigdy nie zwraca wartości. Istnieje kilka rodzajów konstruktorów:</p>
            <ul>
                <li>konstruktor domyślny (nie przyjmuje żadnych argumentów)</li>
                <li>konstruktor z parametami (przyjmuje argumenty, które służą do inicjalizacji pól obiektu)</li>
                <li>konstruktor kopiujący (tworzy nowy obiekt na podstawie istniejącego)</li>
                <li>konstruktor przenoszący (tworzy nowy obiekt na podstawie istniejącego, a następnie ustawia pola istniejącego obiektu na domyślne wartości)</li>
            </ul>
            <p>Przykład użycia różnych typów konstruktorów dla klasy Prostokat:</p>
            <p>
            <div>
                <pre><code class="language-clike">class Prostokat {
  int a;
  int b;
public:
  // konstruktor domyślny
  Prostokat() {
    a = 1;
    b = 1;
  }
// konstruktor z parametrem
  Prostokat(int a, int b) {
    this-&gt;a = a;
    this-&gt;b = b;
  }
// konstruktor kopiujący
  Prostokat(const Prostokat &amp;p) {
    a = p.a;
    b = p.b;
  }
// konstruktor przenoszący
  Prostokat(Prostokat &amp;&amp;p) {
    a = p.a;
    b = p.b;
    p.a = 0;
    p.b = 0;
  }
};</code></pre>
            </div>
            </p>
            <p>W przykładzie powyżej, tworzenie nowego obiektu klasy Prostokat bez podawania żadnych argumentów wywoła konstruktor domyślny, który ustawi pola <code>a</code> i <code>b</code> na 1. Tworzenie obiektu z podaniem dwóch argumentów wywoła konstruktor z parametrami, który ustawi pola <code>a</code> i <code>b</code> na podane wartości. Kopiowanie obiektu wywoła konstruktor kopiujący, a przenoszenie obiektu wywoła konstruktor przenoszący.</p>
            <h3 id="destruktor">Destruktor</h3>
            <p>Destruktor jest specjalnym typem metody, która jest wywoływana, gdy obiekt jest usuwany z pamięci. Jego nazwa jest taka sama jak nazwa klasy, ale poprzedzona znakiem <code>~</code>. Podobnie jak konstruktor, destruktor nie posiada zwracanego typu.</p>
            <p>Destruktor jest przydatny w sytuacjach, gdy chcemy zwolnić zasoby zajmowane przez obiekt, takie jak pamięć czy otwarte pliki. Możemy też użyć destruktora do wywołania innych metod, które służą do kończenia działania obiektu.</p>
            <p>
            <div>
                <pre><code class="language-clike">class Prostokat {
  int a;
  int b;
public:
  Prostokat(int a, int b) {
    this-&gt;a = a;
    this-&gt;b = b;
  }
~Prostokat() { std::cout &lt;&lt; "Destruktor" &lt;&lt; std::endl; }
};</code></pre>
            </div>
            </p>
            <h3 id="dostępność-pól-oraz-metod">Dostępność pól oraz metod</h3>
            <p>Istnieją trzy poziomy dostępu do pól oraz metod:</p>
            <ul>
                <li><code>public</code>: dostęp do pól i metod zdefiniowanych jako public jest zawsze możliwy, zarówno z poziomu klasy, jak i z poziomu obiektu.</li>
                <li><code>private</code>: dostęp do pól i metod zdefiniowanych jako private jest możliwy tylko z poziomu klasy.</li>
                <li><code>protected</code>: dostęp do pól i metod zdefiniowanych jako protected jest możliwy tylko dla klas pochodnych.</li>
            </ul>
            <p>Poziom dostępu jest definiowany przy deklaracji pola lub metody. Domyślnie, pola i metody są prywatne.</p>
            <p>
            <div>
                <pre><code class="language-clike">class Prostokat {
  int a;
  int b;
public:
  Prostokat(int a, int b) {
    this-&gt;a = a;
    this-&gt;b = b;
  }
int pole() { return a * b; }
};
int main() {
Prostokat prostokat(2, 3);
  auto pole = prostokat.pole(); // Ok. Mamy dostęp do pól publicznych.
  // auto a = prostokat.a;         // Źle. Nie mamy dostępu do pól prywatnych.
return 0;
}</code></pre>
            </div>
            </p>
            <h3 id="wskaźnik-na-obiekt">Wskaźnik na obiekt</h3>
            <p>Podobnie jak tworzyliśmy wskaźniki na typy wbudowane, możemy tworzyć wskaźniki na obiekty. Do pól obiektu, na który wskazuje wskaźnik, możemy się odwoływać za pomocą konstrukcji <code>*wsk.pole</code> lub <code>wsk-&gt;pole</code>.</p>
            <p>
            <div>
                <pre><code class="language-clike"># include &lt;iostream&gt;
class Foo {
  int bar;
public:
  Foo() { bar = 0; }
void setBar(int bar) { this-&gt;bar = bar; }
int getBar() { return bar; }
};
int main() {
  Foo foo;
  Foo *wsk = &amp;foo
  wsk-&gt;setBar(10);
  std::cout &lt;&lt; wsk-&gt;getBar() &lt;&lt; std::endl;
  return 0;
}</code></pre>
            </div>
            </p>
            <p>W powyższym przykładzie, tworzymy obiekt klasy <code>Foo</code> i przypisujemy adres tego obiektu do wskaźnika wsk. Następnie, wykorzystując operator <code>-&gt;</code>, ustawiamy wartość pola <code>ba</code>r na 10 oraz pobieramy jego wartość za pomocą metody <code>getBar()</code>.</p>
            <p>Wskaźnik na obiekt jest przydatny w wielu sytuacjach, takich jak przekazywanie obiektów do funkcji jako argumentów, tworzenie tablic wskaźników na obiekty itp.</p>
            <h3 id="przeciążanie-operatorów">Przeciążanie operatorów</h3>
            <p>C++ daje nam możliwość definiowania nowego znaczenia różnych operatorów dla definiowanych przez nas klas. W naszym przykładzie, definiujemy operator <code>+</code> dla klasy <code>Prostokat</code>.</p>
            <p>
            <div>
                <pre><code class="language-clike">class Prostokat {
  int a;
  int b;
  public:
  Prostokat(int a, int b) {
    this-&gt;a = a;
    this-&gt;b = b;
  }
  Prostokat operator + (Prostokat &amp;p1) {
    return Prostokat(a + p1.a, b + p1.b);
  }
};</code></pre>
            </div>
            </p>
            <p>W powyższym przykładzie, operator <code>+</code> został zdefiniowany jako metoda składowa klasy <code>Prostokat</code>, która przyjmuje jako argument obiekt klasy <code>Prostokat</code> i zwraca obiekt klasy <code>Prostokat</code>, którego pola <code>a</code> oraz <code>b</code> są sumą odpowiadających pól obiektów. Dzięki temu, możemy stosować operator <code>+</code> dla obiektów klasy <code>Prostokat</code> tak jak roblibyśmy to ze zwykłymi liczbami.</p>
            <p>
            <div>
                <pre><code class="language-clike">Prostokat p1(2,3);
Prostokat p2(4,5);
Prostokat p3 = p1+p2;</code></pre>
            </div>
            </p>
            <h3 id="pola-i-metody-statyczne">Pola i metody statyczne</h3>
            <p>Istnieje specjalny typ pól oraz metod definiowanych w obrębie klasy, są to pola i metody statyczne. Tworzymy je umieszczając przed typem danej zmiennej lub przed typem zwracanym przez funkcję słowo kluczowe <code>static</code>. Do pól statycznych możemy się odwoływać za pomocą konstrukcji <code>*klasa::pole</code> lub <code>klasa::pole</code>. Nie wymagają one utworzenia obiektu klasy. Wartości pól statycznych są współdzielone przez wszystkie obiekty klasy.</p>
            <p>
            <div>
                <pre><code class="language-clike">class Prostokat {
  static int liczbaProstokatow;
  public:
  Prostokat() { liczbaProstokatow++; }
  static int getLiczbaProstokatow() { return liczbaProstokatow; }
};
int Prostokat::liczbaProstokatow = 0;
int main() {
  Prostokat p1;
  Prostokat p2;
  Prostokat p3;
  cout&lt;&lt;Prostokat::getLiczbaProstokatow()&lt;&lt;endl; //3
  return 0;
}</code></pre>
            </div>
            </p>
            <p>Jak widzimy, pole <code>liczbaProstokatow</code> jest współdzielone przez wszystkie obiekty klasy <code>Prostokat</code>.</p>
            <h3 id="funkcje-zaprzyjaźnione">Funkcje zaprzyjaźnione</h3>
            <p>Funkcje zaprzyjaźnione są to zewnętrzne funkcje, które mają dostęp do prywatnych pól i metod klasy. Przykład dla klasy <code>Prostokat</code>:</p>
            <p>
            <div>
                <pre><code class="language-clike">class Prostokat {
  int a;
  int b;
  public:
  Prostokat(int a, int b) {
    this-&gt;a = a;
    this-&gt;b = b;
  }
  friend void swap(Prostokat &amp;p1, Prostokat &amp;p2) {
    int tmp = p1.a;
    p1.a = p2.a;
    p2.a = tmp;
    tmp = p1.b;
    p1.b = p2.b;
    p2.b = tmp;
  }
};
int main() {
  Prostokat p1(1, 2);
  Prostokat p2(3, 4);
  swap(p1, p2);
  cout&lt;&lt;p1.a&lt;&lt;" "&lt;&lt;p1.b&lt;&lt;endl; // 3 4
  cout&lt;&lt;p2.a&lt;&lt;" "&lt;&lt;p2.b&lt;&lt;endl; // 1 2
  return 0;
}</code></pre>
            </div>
            </p>
            <p>Dzięki funkcji zaprzyjaźnionej <code>swap</code>, która ma dostęp do prywatnych pól klasy <code>Prostokat</code>, możemy zamienić wartości pól dwóch obiektów.</p>
            <h3 id="struktury">Struktury</h3>
            <p>Struktura jest protoplastą klasy. W C struktury pozwalają na łączenie pod jedną nazwą danych różnego typu. W C nie ma jednak możliwości definiowania funkcji w obrębie struktury. C++ zmienia znaczenie tego pojęcia. W C++ struktury i klasy są dokładnie tym samym, z wyjątkiem tego, że domyślnie wszystkie pola struktur są publiczne, a pola klas prywatne (mamy więc możliwość definiowania metod).</p>
            <p>Przykład w C:</p>
            <p>
            <div>
                <pre><code class="language-clike">struct Foo {
  int bar;
};
int main() {
  struct Foo foo;
  foo.bar = 10;
  return 0;
}</code></pre>
            </div>
            </p>
            <p>W C nazwy struktur żyją we własnej przestrzeni nazw. Zmienną tego typu tworzymy, podając jako jej typ słowo kluczowe <code>struct</code>, nazwę struktury oraz nazwę zmiennej.</p>
            <p>
            <div>
                <pre><code class="language-clike">struct Foo obiekt_foo;</code></pre>
            </div>
            </p>
            <p>W C++ możemy dalej używać tej składni, ale nie jest to konieczne. Możemy po prostu napisać:</p>
            <p>
            <div>
                <pre><code class="language-clike">Foo obiekt_foo;</code></pre>
            </div>
            </p>
            <h3 id="unie">Unie</h3>
            <p>Unie to inny sposób reprezentacji danych w pamięci. Unie pozwalają na przechowywanie różnych typów danych w tym samym bloku pamięci. W przeciwieństwie do struktur, w uniach w danej chwili tylko jedno pole unii może przechowywać wartość. Z tego powodu unie są lżejsze od struktur i unia zajmuje w pamięci tyle miejsca, ile wynosi rozmiar największego z jej pól.</p>
            <p>
            <div>
                <pre><code class="language-clike"># include &lt;iostream&gt;
union Przyklad {
  int a;
  int b;
};
int main() {
  Przyklad unia;
  unia.a = 10;
  unia.b = 20;
std::cout &lt;&lt; unia.a &lt;&lt; std::endl; // 20
  std::cout &lt;&lt; unia.b &lt;&lt; std::endl; // 20
return 0;
}</code></pre>
            </div>
            </p>
            <p>W powyższym przykładzie tworzona jest unia o nazwie "Przyklad", która posiada dwa pola "a" i "b" typu int. W mainie następuje przypisanie wartości 10 do pola "a" oraz wartości 20 do pola "b". Następnie wypisywane są wartości obu pól, jednak obie wartości są równe 20, ponieważ unia ma tylko jedno pole aktywne w danej chwili, a przypisanie do pola "b" nadpisuje wartość pola "a".</p>
            <p>Unie mogą być używane w sytuacjach, gdy potrzebujemy oszczędzić miejsce w pamięci, a także gdy potrzebujemy dostępu do danych za pomocą różnych typów. Przykładami zastosowania unii mogą być:</p>
            <ul>
                <li>Interpretacja bajtów w pamięci jako różnego typu danych (np. liczby całkowitej, znaków, itp.)</li>
                <li>Przechowywanie danych o różnym typie w tablicy bez konieczności tworzenia kilku tablic</li>
                <li>Przechowywanie danych o różnym typie w strukturze bez konieczności tworzenia kilku pol różnego typu.</li>
            </ul>
            <h3 id="pole-bitowe">Pole bitowe</h3>
            <p>Pola bitowe pozwalają na zdefiniowanie dokładnej liczby bitów, które chcemy zarezerwować dla danego pola struktury lub unii. Możemy to zrobić poprzez użycie operatora : po nazwie pola oraz podanie liczby bitów. W przykładzie poniżej, pole <code>Rok</code> zajmuje 13 bitów, pole <code>Miesiac</code> 4 bity, a pole <code>Dzien</code> 5 bitów.</p>
            <p>
            <div>
                <pre><code class="language-clike"># include &lt;iostream&gt;
struct Data {
  unsigned int Rok : 13;    // 2^13 = 8192
  unsigned int Miesiac : 4; // 2^4 = 16
  unsigned int Dzien : 5;   // 2^5 = 32
};
void wypiszDate(Data d) {
  std::cout &lt;&lt; "Mamy dziś: " &lt;&lt; std::endl;
  std::cout &lt;&lt; d.Dzien &lt;&lt; "-" &lt;&lt; d.Miesiac &lt;&lt; "-" &lt;&lt; d.Rok &lt;&lt; std::endl;
}
int main() {
  Data d;
  d.Rok = 2020;
  d.Miesiac = 7;
  d.Dzien = 18;
wypiszDate(d);
return 0;
}</code></pre>
            </div>
            </p>
        </section>
        <div id="table-of-contents">
            <h2>Table of Contents</h2>
            <ol>
                <li><a href="#programowanie-obiektowe">Programowanie Obiektowe</a></li>
                <li><a href="#konstruktor">Konstruktor</a></li>
                <li><a href="#destruktor">Destruktor</a></li>
                <li><a href="#dostępność-pól-oraz-metod">Dostępność pól oraz metod</a></li>
                <li><a href="#wskaźnik-na-obiekt">Wskaźnik na obiekt</a></li>
                <li><a href="#przeciążanie-operatorów">Przeciążanie operatorów</a></li>
                <li><a href="#pola-i-metody-statyczne">Pola i metody statyczne</a></li>
                <li><a href="#funkcje-zaprzyjaźnione">Funkcje zaprzyjaźnione</a></li>
                <li><a href="#struktury">Struktury</a></li>
                <li><a href="#unie">Unie</a></li>
                <li><a href="#pole-bitowe">Pole bitowe</a></li>
            </ol>
        </div>
    </div>
    <footer>
        <div class="footer-columns">
            <div class="footer-column">
                <img alt="Adam Djellouli Symbol" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/symbol.png" />
            </div>
            <div class="footer-column">
                <h2><a href="https://adamdjellouli.com/core/privacy_policy.html" title="Privacy Policy">Our Privacy Policy</a></h2>
                <p>
                    Thank you for visiting my personal website. All of the <br />
                    content on this site is free to use, but please remember <br />
                    to be a good human being and refrain from any abuse<br />
                    of the site. If you would like to contact me, please use <br />
                    my <a href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" title="LinkedIn Profile">LinkedIn profile</a> or my <a href="https://github.com/djeada" title="GitHub Profile">GitHub</a> if you have any technical <br />
                    issues or ideas to share. I wish you the best and hope you <br />
                    have a fantastic life. <br />
                </p>
            </div>
            <div class="footer-column">
                <h2>Follow me</h2>
                <ul class="social-media">
                    <li>
                        <a class="fa fa-youtube" href="https://www.youtube.com/channel/UCGPoHTVjMN77wcGknXPHl1Q" target="_blank" title="YouTube">
                        </a>YouTube
                    </li>
                    <li>
                        <a class="fa fa-linkedin" href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" target="_blank" title="LinkedIn">
                        </a>LinkedIn
                    </li>
                    <li>
                        <a class="fa fa-instagram" href="https://www.instagram.com/addjellouli/" target="_blank" title="Instagram">
                        </a>Instagram
                    </li>
                    <li>
                        <a class="fa fa-github" href="https://github.com/djeada" title="GitHub">
                        </a>Github
                    </li>
                </ul>
            </div>
        </div>
        <div>
            <p id="copyright">
                © Adam Djellouli. All rights reserved.
            </p>
        </div>
        <script>
            document.getElementById("copyright").innerHTML = "&copy; " + new Date().getFullYear() + " Adam Djellouli. All rights reserved.";
        </script>
        <script src="../app.js"></script>
    </footer>
</body>

</html>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-bash.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-cpp.min.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
jax: ["input/TeX", "output/HTML-CSS"],
extensions: ["tex2jax.js"],
"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] },
tex2jax: { inlineMath: [ ["$", "$"] ], displayMath: [ ["$$","$$"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
TeX: { noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } } },
messageStyle: "none"
});
</script>
<script async="" id="MathJax-script" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>