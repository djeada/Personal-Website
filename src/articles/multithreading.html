<!DOCTYPE html>

<html lang="en">

<head>
    <script async="" crossorigin="anonymous" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5593122079896089"></script>
    <title>Multithreading</title>
    <meta charset="utf-8" />
    <meta content="
Multithreading is a way of achieving concurrency in software development." name="description" />
    <meta content="Adam Djellouli" name="keywords" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/icon.ico" rel="icon" />
    <link href="../resources/style.css" rel="stylesheet" type="text/css" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />
    <link href="https://fonts.googleapis.com" rel="preconnect" />
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <meta content="ie-edge" http-equiv="X-UA-Compatible" />
</head>

<body>
    <nav>
        <a class="logo" href="../index.html" title="Adam Djellouli - Home">
            <img alt="Adam Djellouli Logo" id="logo-image" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/logo.PNG" />
        </a>
        <input aria-label="Toggle navigation menu" id="navbar-toggle" type="checkbox" />
        <ul>
            <li> <a href="../index.html" title="Home"> Home </a> </li>
            <li> <a class="active" href="../core/blog.html" title="Adam Djellouli's Blog - Programming, technology and more"> Blog </a> </li>
            <li> <a href="../core/tools.html" title="Useful Tools by Adam Djellouli"> Tools </a> </li>
            <li> <a href="../core/projects.html" title="Projects by Adam Djellouli"> Projects </a> </li>
            <li> <a href="../core/resume.html" title="Adam Djellouli's Resume"> Resume </a> </li>
            <li> <a href="../core/about.html" title="About Adam Djellouli"> About </a> </li>
            <button aria-label="Toggle dark mode" id="dark-mode-button"></button>
        </ul>
    </nav>
    <section id="article-body"></section>
    <p style="text-align: right;"><i>This article is written in: ðŸ‡ºðŸ‡¸</i></p>
    <div id="article-wrapper">
        <section id="article-body">

            <h2 id="multithreading">Multithreading</h2>
            <ul>
                <li>Multithreading is a way of achieving concurrency in software development.</li>
                <li>It involves creating multiple threads within a single process to execute tasks concurrently.</li>
                <li>Multithreading does not guarantee parallelism.</li>
            </ul>
            <h3 id="thread-pool-vs-on-demand-thread">Thread pool vs On-demand thread</h3>
            <ul>
                <li>Two ways to create threads in multithreading are: using a thread pool or on-demand thread spawning.</li>
                <li>Thread pool pre-spawns threads to reduce creation costs, while on-demand thread spawning reduces resource wastage.</li>
                <li>On-demand thread spawning may slow down the program when threads are needed.</li>
            </ul>
            <h3 id="worker-threads">Worker threads</h3>
            <ul>
                <li>In multithreading, one thread initiates all other threads, known as worker threads.</li>
                <li>Worker threads only perform tasks when allocated to them by another thread.</li>
                <li>To regulate and limit the number of worker threads, a thread pool can be employed.</li>
            </ul>
            <p>A web server process, for example, receives a request and assigns it to a thread from its pool for processing. That thread obeys the main thread, completes the task, and returns to the pool. Until then, the main thread is free to do anything it wants. </p>
            <h3 id="advantages-of-threads-over-processes">Advantages of threads over processes</h3>
            <ol>
                <li>Multithreading has several advantages over using multiple processes, such as:<ul>
                        <li>Better responsiveness.</li>
                        <li>Faster context transitions.</li>
                        <li>Improved resource sharing.</li>
                    </ul>
                </li>
                <li>Code, data, and files can be shared across all threads within a process.</li>
            </ol>
            <h3 id="challenges-with-multithreading">Challenges with multithreading</h3>
            <ul>
                <li>Multithreading challenges arise from the fact that threads share state with one another, making communication simple.</li>
                <li>The most common challenge when dealing with multithreading is data race.</li>
                <li>Data race happens when the result of a multithreaded program depends on the order in which threads are executed.</li>
                <li>This is because threads switch preemptively, meaning that you don't control when they switch, and a switch may occur at an inconvenient moment.</li>
                <li>When multiple threads use the same resources, data race becomes increasingly dangerous.</li>
                <li>Mutex and semaphore are mechanisms developed to prevent data race.</li>
            </ul>
            <h4>Data race</h4>
            <p>When in multithreaded program, the result is depndend on the order in which the threads are executed, then we refer to that stuation as 'race condition'. </p>
            <p>Why does it happen? By defualt threads switch preemptively (you don't control when the threads switch, the os can make the switch at any time). This is useful since you don't have to manually code where the task should switch. The tradeoff of this convenience is that you must presume that a switch may occur at an inconvenient moment.</p>
            <p>Consider the following simple example: we have two functions, <em>funA()</em> and <em>funB()</em>, and <em>funB()</em> is dependent on the results of <em>funA()</em>.
                If we write a single threaded program, all we have to do is call the functions in the correct order:</p>
            <p>
            <div>
                <pre><code class="language-bash">funA()
funB()</code></pre>
            </div>
            If we delegate both functions to separate threads, this solution will fail.
            We don't know which function will be chosen to execute first, or whether they will run in parallel.
            In either case, our software will not function properly.</p>
            <p>When many threads use the same resources, the scenario becomes increasingly dangerous.</p>
            <ul>
                <li>Data race occurs when at least two concurrent threads access the same memory address that's being modified by at least one thread.</li>
                <li>That section of memory may get corrupted, and crucial areas must be protected with locks.</li>
            </ul>
            <p>Analogy: Imagine a crowded restaurant kitchen where multiple chefs are working on the same dish at the same time, using the same ingredients and tools. If they are not coordinated properly, they might end up bumping into each other or accidentally using the same tool or ingredient at the same time, causing confusion and potentially ruining the dish. This is similar to what happens in a data race, where multiple threads are accessing the same memory location at the same time without proper synchronization, leading to unpredictable and potentially incorrect results.</p>
            <h4>Mutex</h4>
            <ul>
                <li>A mutex is a mechanism that prevents data race.</li>
                <li>Multiple threads or processes can take turns sharing the same resource without conflict.</li>
                <li>While one thread is allowed to use the resources, other requesting threads are put to sleep until the thread exits the portion of code guarded by the mutex.</li>
            </ul>
            <p>Analogy: Think of a public restroom with only one stall. If multiple people try to use the stall at the same time, chaos will ensue, with people pushing and shoving, and no one getting to use the restroom properly. To prevent this, a lock is installed on the door, which can only be opened by one person at a time. This ensures that only one person can use the stall at any given time, and others have to wait their turn. In the same way, a mutex is a lock that threads can use to access a shared resource in a mutually exclusive way.</p>
            <h4>Semaphore</h4>
            <ul>
                <li>A semaphore is an integer variable that can only be accessed via two atomic operations: wait and signal.</li>
                <li>Semaphores are used for synchronization.</li>
                <li>Changes to the semaphore value in the wait and signal actions must be carried out independently.</li>
                <li>A binary semaphore should be used as a signaling technique, where the binary "producer" informs all of the "consumers" that what they were expecting has occurred.</li>
            </ul>
            <p>Analogy: Imagine a busy street intersection with a traffic light. The traffic light controls the flow of traffic by changing colors at regular intervals, and different lanes of traffic have to take turns moving through the intersection. A semaphore works in a similar way, controlling access to a shared resource by allowing a certain number of threads to access it at a time, and blocking others until there is available capacity. The semaphore acts as a signal to the threads, letting them know when it is safe to access the shared resource.</p>
            <h4>Common miconceptions</h4>
            <ul>
                <li>Binary semaphore and mutex are the same thing: A binary semaphore can only accept one of two values, and it serves the same function as a mutex. However, the prevalent misunderstanding is that they are the same thing. A mutex is used to gain exclusive access to a resource, while a binary semaphore should be used as a signaling technique. The binary "producer" merely informs all of the "consumers" that what they were expecting has occurred.</li>
                <li>Multithreading automatically improves performance: While multithreading can improve performance in certain scenarios, it does not always lead to faster execution times. In fact, if not implemented correctly, multithreading can even decrease performance due to increased overhead and synchronization costs.</li>
                <li>More threads always means better performance: This is not necessarily true. Creating too many threads can actually lead to decreased performance due to increased context switching overhead and resource contention.</li>
                <li>Multithreaded code is always more difficult to write and maintain: While writing correct and efficient multithreaded code can be challenging, it is not always more difficult than writing single-threaded code. Additionally, many modern programming languages and frameworks provide abstractions and tools to simplify multithreaded programming.</li>
            </ul>
            <h3 id="examples">Examples</h3>
            <h4>Examples in C++</h4>
            <p>Every C++ application has one default main thread, which is represented by the <code>main()</code> function. Since C++11, we may spawn more threads by creating instances of the <code>std::thread</code> type. The constructor of that class receives a callback to the function to be called from the new thread as well as a list of arguments for that function. When an object is created, the thread begins executing.</p>
            <p>There are two alternatives for handling the created threads: joining or detaching them.</p>
            <p>When we use <code>join()</code>:
                * The program will wait for the thread to complete before continuing its execution.
                * Any resources belonging to the thread will be cleaned up.</p>
            <p>When we use <code>detach()</code>:
                * The program does not wait for the threads to complete their execution before proceeding to the next instruction.
                * When the program terminates, all remaining detached threads are suspended and their objects are destroyed.</p>
            <p>To compile the C++ examples, use the <code>GCC</code> compiler with the following flags:</p>
            <p><code>g++ file_name.cpp -std=c++17 -pthread -o executable_name</code></p>
            <p>Here are some example code snippets demonstrating various aspects of multithreading in C++:</p>
            <ul>
                <li><a href="https://github.com/djeada/Parallel-and-Concurrent-Programming/blob/master/src/cpp/multithreading/raw_pthread.cpp">raw pthread</a></li>
                <li><a href="https://github.com/djeada/Parallel-and-Concurrent-Programming/blob/master/src/cpp/multithreading/single_worker_thread.cpp">single worker thread</a></li>
                <li><a href="https://github.com/djeada/Parallel-and-Concurrent-Programming/blob/master/src/cpp/multithreading/multiple_worker_threads.cpp">multiple worker threads</a></li>
                <li><a href="https://github.com/djeada/Parallel-and-Concurrent-Programming/blob/master/src/cpp/multithreading/race_condition.cpp">race condition</a></li>
                <li><a href="https://github.com/djeada/Parallel-and-Concurrent-Programming/blob/master/src/cpp/multithreading/mutex.cpp">mutex</a></li>
                <li><a href="https://github.com/djeada/Parallel-and-Concurrent-Programming/blob/master/src/cpp/multithreading/semaphore.cpp">semaphore</a></li>
                <li><a href="https://github.com/djeada/Parallel-and-Concurrent-Programming/blob/master/src/cpp/multithreading/merge_sort.cpp">merge sort</a></li>
            </ul>
            <h4>Examples in Python</h4>
            <p>A global interpreter lock (GIL) is a technique used in programming language interpreters to synchronize thread execution such that only one native thread may run at any given moment. Even when running on a multi-core CPU, GIL permits only one native thread to execute at a time.</p>
            <p>The natural question is if it even makes sense to use threads in Python? The answer is, it depends. We can still make greater use of the CPU that is idle while waiting for I/O by using multithreading. We can increase performance by overlapping the waiting time for requests. We should however look at multiprocessing if we want to split CPU-intensive activities over multiple CPU cores.</p>
            <p>The main module we'll be using is named <code>threading</code>. To spawn a new thread, just create an object of <code>Thread</code> class and specify the function that you want to run in the new thread as the first parameter. The thread will not begin executing until you invoke the <code>start()</code> method. Call the <code>join()</code> method to suspend further program execution until the thread has completed its task. There are several other functions available that make it simple to work with threads. For example, to see which thread is currently executing, we can call <code>current_thread()</code>. We use <code>main_thread()</code> to obtain the main thread instance.</p>
            <p>Here are some example code snippets demonstrating various aspects of multithreading in Python:</p>
            <ul>
                <li><a href="https://github.com/djeada/Parallel-and-Concurrent-Programming/blob/master/src/python/multithreading/single_worker_thread.py">single worker thread</a></li>
                <li><a href="https://github.com/djeada/Parallel-and-Concurrent-Programming/blob/master/src/python/multithreading/multiple_worker_threads.py">multiple worker threads</a></li>
                <li><a href="https://github.com/djeada/Parallel-and-Concurrent-Programming/blob/master/src/python/multithreading/thread_subclass.py">thread subclass</a></li>
                <li><a href="https://github.com/djeada/Parallel-and-Concurrent-Programming/blob/master/src/python/multithreading/race_condition.py">race condition</a></li>
                <li><a href="https://github.com/djeada/Parallel-and-Concurrent-Programming/blob/master/src/python/multithreading/mutex.py">mutex</a></li>
                <li><a href="https://github.com/djeada/Parallel-and-Concurrent-Programming/blob/master/src/python/multithreading/semaphore.py">semaphore</a></li>
                <li><a href="https://github.com/djeada/Parallel-and-Concurrent-Programming/blob/master/src/python/multithreading/merge_sort.py">merge sort</a></li>
                <li><a href="https://github.com/djeada/Parallel-and-Concurrent-Programming/blob/master/src/python/multithreading/fetch_parallel.py">fetch parallel</a></li>
                <li><a href="https://github.com/djeada/Parallel-and-Concurrent-Programming/blob/master/src/python/multithreading/schedule_every_n_sec.py">schedule every n sec</a></li>
            </ul>
            <h4>Examples in JavaScript (Node.js)</h4>
            <p>By default, a Node.js application operates on a single thread. An event loop in this thread listens for events and then calls the event's related callback function when one is detected. Since V10.5, the <code>worker_threads</code> module can be used to spawn extra threads. This module enables the use of threads that execute JavaScript in parallel.</p>
            <p>Be aware that Node.js already internally handles I/O operations through the usage of a thread pool. Spawning a thread makes sense only for CPU-intensive work.</p>
            <p>To use the <code>worker_threads</code> module, you need to create a separate JavaScript file containing the code to be executed in the worker thread. To create a worker thread, use the <code>Worker</code> constructor and pass the file path as its first parameter.</p>
            <p>
            <div>
                <pre><code class="language-javascript">const { Worker } = require('worker_threads');
const worker = new Worker('./path/to/worker.js');</code></pre>
            </div>
            </p>
            <p>Inside the worker file, you can use the <code>parentPort</code> object to communicate with the main thread. For example, you can use the <code>postMessage()</code> method to send messages from the worker to the main thread.</p>
            <p>
            <div>
                <pre><code class="language-javascript">// worker.js
const { parentPort } = require('worker_threads');
parentPort.postMessage('Hello from the worker thread!');</code></pre>
            </div>
            </p>
            <p>In the main thread, you can listen for messages from the worker by attaching a listener to the message event.</p>
            <p>
            <div>
                <pre><code class="language-javascript">worker.on('message', (message) =&gt; {
  console.log(`Received message from worker: ${message}`);
});</code></pre>
            </div>
            </p>
            <p>Here are some example code snippets demonstrating various aspects of multithreading in JavaScript (Node.js):</p>
            <ul>
                <li><a href="https://github.com/djeada/Parallel-and-Concurrent-Programming/blob/master/src/nodejs/multithreading/single_worker_thread/main.js">single worker thread</a></li>
                <li><a href="https://github.com/djeada/Parallel-and-Concurrent-Programming/blob/master/src/nodejs/multithreading/multiple_worker_threads/main.js">multiple worker threads</a></li>
            </ul>
        </section>
        <div id="table-of-contents">
            <h2>Table of Contents</h2>
            <ol>
                <li><a href="#multithreading">Multithreading</a></li>
                <li><a href="#thread-pool-vs-on-demand-thread">Thread pool vs On-demand thread</a></li>
                <li><a href="#worker-threads">Worker threads</a></li>
                <li><a href="#advantages-of-threads-over-processes">Advantages of threads over processes</a></li>
                <li><a href="#challenges-with-multithreading">Challenges with multithreading</a></li>
                <li><a href="#examples">Examples</a></li>
            </ol>
        </div>
    </div>
    <footer>
        <div class="footer-columns">
            <div class="footer-column">
                <img alt="Adam Djellouli Symbol" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/symbol.png" />
            </div>
            <div class="footer-column">
                <h2><a href="https://adamdjellouli.com/core/privacy_policy.html" title="Privacy Policy">Our Privacy Policy</a></h2>
                <p>
                    Thank you for visiting my personal website. All of the <br />
                    content on this site is free to use, but please remember <br />
                    to be a good human being and refrain from any abuse<br />
                    of the site. If you would like to contact me, please use <br />
                    my <a href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" title="LinkedIn Profile">LinkedIn profile</a> or my <a href="https://github.com/djeada" title="GitHub Profile">GitHub</a> if you have any technical <br />
                    issues or ideas to share. I wish you the best and hope you <br />
                    have a fantastic life. <br />
                </p>
            </div>
            <div class="footer-column">
                <h2>Follow me</h2>
                <ul class="social-media">
                    <li>
                        <a class="fa fa-youtube" href="https://www.youtube.com/channel/UCGPoHTVjMN77wcGknXPHl1Q" target="_blank" title="YouTube">
                        </a>YouTube
                    </li>
                    <li>
                        <a class="fa fa-linkedin" href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" target="_blank" title="LinkedIn">
                        </a>LinkedIn
                    </li>
                    <li>
                        <a class="fa fa-instagram" href="https://www.instagram.com/addjellouli/" target="_blank" title="Instagram">
                        </a>Instagram
                    </li>
                    <li>
                        <a class="fa fa-github" href="https://github.com/djeada" title="GitHub">
                        </a>Github
                    </li>
                </ul>
            </div>
        </div>
        <div>
            <p id="copyright">
                Â© Adam Djellouli. All rights reserved.
            </p>
        </div>
        <script>
            document.getElementById("copyright").innerHTML = "&copy; " + new Date().getFullYear() + " Adam Djellouli. All rights reserved.";
        </script>
        <script src="../app.js"></script>
    </footer>
</body>

</html>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-python.min.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
jax: ["input/TeX", "output/HTML-CSS"],
extensions: ["tex2jax.js"],
"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] },
tex2jax: { inlineMath: [ ["$", "$"] ], displayMath: [ ["$$","$$"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
TeX: { noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } } },
messageStyle: "none"
});
</script>
<script async="" id="MathJax-script" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>