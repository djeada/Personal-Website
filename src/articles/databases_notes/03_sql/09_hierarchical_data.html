<!DOCTYPE html>

<html lang="en">

<head>
    <script async="" crossorigin="anonymous" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5593122079896089"></script>
    <meta charset="utf-8" />
    <title>Storing Hierarchical Data in Relational Databases with SQL</title>
    <meta content="In many applications, data is naturally organized in a hierarchical structure, such as organizational charts, file systems, categories and subcategories, and family trees." name="description" />
    <meta content="Adam Djellouli" name="author" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <meta content="IE=edge" http-equiv="X-UA-Compatible" />
    <link crossorigin="" href="https://fonts.googleapis.com" rel="preconnect" />
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/icon.ico" rel="icon" />
    <link href="../../../resources/style.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
</head>

<body>
    <nav aria-label="Main navigation">
        <a class="logo" href="https://adamdjellouli.com">
            <img alt="Adam Djellouli - Home Page Logo" id="logo-image" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/logo.PNG" />
        </a>
        <input aria-label="Toggle navigation menu" id="navbar-toggle" type="checkbox" />
        <ul aria-labelledby="navbar-toggle" role="menu">
            <li role="menuitem">
                <a href="../../../index.html" title="Go to Home Page"> Home </a>
            </li>
            <li role="menuitem">
                <a class="active" href="../../../core/blog.html" title="Read Adam Djellouli Blog on Programming and Technology"> Blog </a>
            </li>
            <li role="menuitem">
                <a href="../../../core/tools.html" title="Discover Tools Created by Adam Djellouli"> Tools </a>
            </li>
            <li role="menuitem">
                <a href="../../../core/projects.html" title="Explore Projects Developed by Adam Djellouli"> Projects </a>
            </li>
            <li role="menuitem">
                <a href="../../../core/resume.html" title="View Adam Djellouli Professional Resume"> Resume </a>
            </li>
            <li>
                <script async="" src="https://cse.google.com/cse.js?cx=8160ef9bb935f4f68"></script>
                <div class="gcse-search"></div>
            </li>
            <li>
                <button aria-label="Toggle dark mode" id="dark-mode-button"></button>
            </li>
        </ul>
    </nav>
    <div id="article-wrapper">
        <section id="article-body">
            <div class="article-action-buttons"><button class="btn-suggest-edit" title="Suggest Edit">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <path d="M4 21h4l11-11-4-4L4 17v4z" stroke="currentColor" stroke-width="2"></path>
                    </svg>
                </button><button class="btn-create-issue" title="Create Issue">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2"></circle>
                        <line stroke="currentColor" stroke-width="2" x1="12" x2="12" y1="8" y2="12"></line>
                        <circle cx="12" cy="16" fill="currentColor" r="1"></circle>
                    </svg>
                </button><button class="btn-download" title="Download">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <path d="M12 5v14m0 0l-6-6m6 6l6-6" stroke="currentColor" stroke-width="2"></path>
                    </svg>
                </button></div>
            <p style="text-align: right;"><i>Last modified: May 24, 2025</i></p>
            <p style="text-align: right;"><i>This article is written in: üá∫üá∏</i></p>
            <h2 id="storing-hierarchical-data-in-relational-databases-with-sql">Storing Hierarchical Data in Relational Databases with SQL</h2>
            <p>In many applications, data is naturally organized in a hierarchical structure, such as organizational charts, file systems, categories and subcategories, and family trees. Representing and querying this hierarchical data efficiently in a relational database can be challenging due to the flat nature of relational tables. In this guide, we'll explore several models and techniques for storing and querying hierarchical data in SQL, including:</p>
            <ul>
                <li><strong>Adjacency List Model</strong></li>
                <li><strong>Path Enumeration Model</strong></li>
                <li><strong>Other Models</strong> (Materialized Path, Nested Set, Closure Table)</li>
                <li><strong>Recursive Queries with Common Table Expressions (CTEs)</strong></li>
            </ul>
            <p>After reading the material, you should be able to answer the following questions:</p>
            <ol>
                <li>What is the Adjacency List Model, and what are its primary advantages and disadvantages when storing hierarchical data in a relational database?</li>
                <li>How does the Path Enumeration Model enhance the Adjacency List Model, and in what scenarios is it most effectively used?</li>
                <li>What are the key differences between the Nested Set Model and the Closure Table Model for representing hierarchical data, and what are the respective use cases for each?</li>
                <li>How do recursive queries with Common Table Expressions (CTEs) facilitate the retrieval of hierarchical data in SQL, and what are the advantages and limitations of using this approach?</li>
                <li>What best practices should be followed when choosing a model for storing hierarchical data in a relational database, and how do factors like query performance and maintenance complexity influence this decision?</li>
            </ol>
            <h3 id="adjacency-list-model">Adjacency List Model</h3>
            <p>The <strong>Adjacency List Model</strong> is a straightforward way to represent hierarchies in SQL by having each record point to its immediate parent in the same table. This self-referencing design makes it very intuitive to understand and maintain simple tree structures, though querying deep hierarchies can require recursive logic or iterative joins.</p>
            <h4 id="table-schema">Table Schema</h4>
            <p>Before working with the model, you need to define a table that stores both the node and a reference to its parent. The example below creates a <code>categories</code> table where each category can optionally link to another category as its parent.</p>
            <p>
            <div>
                <pre><code class="language-sql">CREATE TABLE categories (
    category_id   INT PRIMARY KEY,
    parent_id     INT NULL REFERENCES categories(category_id)
                  ON UPDATE CASCADE
                  ON DELETE SET NULL,
    category_name TEXT NOT NULL
);

-- Helpful index for fast child look-ups
CREATE INDEX idx_categories_parent ON categories(parent_id);</code></pre>
            </div>
            </p>
            <p>Example data:</p>
            <p>
            <table>
                <tr>
                    <td>category_id</td>
                    <td>parent_id</td>
                    <td>category_name</td>
                </tr>
                <tr>
                    <td>1</td>
                    <td>NULL</td>
                    <td>Electronics</td>
                </tr>
                <tr>
                    <td>2</td>
                    <td>1</td>
                    <td>Computers</td>
                </tr>
                <tr>
                    <td>3</td>
                    <td>2</td>
                    <td>Laptops</td>
                </tr>
                <tr>
                    <td>4</td>
                    <td>2</td>
                    <td>Desktops</td>
                </tr>
                <tr>
                    <td>5</td>
                    <td>1</td>
                    <td>Televisions</td>
                </tr>
                <tr>
                    <td>6</td>
                    <td>3</td>
                    <td>Gaming Laptops</td>
                </tr>
                <tr>
                    <td>7</td>
                    <td>3</td>
                    <td>Business Laptops</td>
                </tr>
            </table>
            </p>
            <blockquote>
                <p><em>Root</em> nodes are characterised by a <code>NULL</code> <code>parent_id</code>. If sibling order matters, add a column such as <code>sort_order</code>.</p>
            </blockquote>
            <h4 id="why-choose-it-">Why Choose It?</h4>
            <p>Choosing the Adjacency List Model is often driven by its simplicity and portability. It works in any SQL database without special extensions and makes simple inserts, updates, and deletes very cheap ‚Äî only a single row needs to be changed. However, reading an entire branch can become inefficient unless your database supports recursive queries or you build additional logic.</p>
            <p>
            <table>
                <tr>
                    <td>‚úîÔ∏è Strengths</td>
                    <td>‚ùó Trade‚Äëoffs</td>
                </tr>
                <tr>
                    <td>Intuitive‚Äîmirrors real‚Äëworld parent‚Äìchild relationships.</td>
                    <td>Reading an entire branch is costly; requires recursion or iterative joins.</td>
                </tr>
                <tr>
                    <td>ACID‚Äësafe, portable to <strong>any</strong> SQL database.</td>
                    <td>Path constraints (preventing cycles) need application logic or triggers.</td>
                </tr>
                <tr>
                    <td>Cheap <code>INSERT</code>/<code>UPDATE</code>/<code>DELETE</code>‚Äîonly one row changes.</td>
                    <td>Join depth grows with tree depth; performance degrades on deep hierarchies unless recursive CTEs are available.</td>
                </tr>
            </table>
            </p>
            <h4 id="common-queries">Common Queries</h4>
            <p>This section outlines typical operations you‚Äôll perform when navigating the hierarchy, from finding direct children to retrieving full descendant trees or building breadcrumb trails.</p>
            <p><strong>Immediate children</strong></p>
            <p>
            <div>
                <pre><code class="language-sql">SELECT *
FROM   categories
WHERE  parent_id = :parent;</code></pre>
            </div>
            </p>
            <p><strong>All descendants</strong> (PostgreSQL / MySQL 8.0+ / SQL Server)</p>
            <p>
            <div>
                <pre><code class="language-sql">WITH RECURSIVE subtree AS (
    SELECT category_id, parent_id, category_name, 1 AS depth
    FROM   categories
    WHERE  category_id = :root

    UNION ALL

    SELECT c.category_id, c.parent_id, c.category_name, st.depth + 1
    FROM   categories AS c
    JOIN   subtree     AS st ON c.parent_id = st.category_id
)
SELECT *
FROM   subtree
ORDER  BY depth, category_name;</code></pre>
            </div>
            </p>
            <p><strong>Path from root to a node</strong></p>
            <p>
            <div>
                <pre><code class="language-sql">WITH RECURSIVE path AS (
    SELECT category_id, parent_id, category_name
    FROM   categories
    WHERE  category_id = :leaf
    UNION ALL
    SELECT c.category_id, c.parent_id, c.category_name
    FROM   categories AS c
    JOIN   path        AS p ON p.parent_id = c.category_id
)
SELECT string_agg(category_name, ' ‚Üí ' ORDER BY category_id DESC) AS breadcrumb
FROM   path;</code></pre>
            </div>
            </p>
            <h4 id="implementation-tips">Implementation Tips</h4>
            <p>When implementing the adjacency list, consider additional constraints and indexing to maintain data integrity and performance. You can enforce sibling uniqueness, control cascading behaviors on deletes, and guard against cyclical references.</p>
            <ul>
                <li>Add <code>UNIQUE (parent_id, category_name)</code> if sibling names must be unique.</li>
                <li>Use <code>ON DELETE CASCADE</code> if removing a parent should delete its sub‚Äëtree, or <code>ON DELETE RESTRICT</code> to forbid orphaning.</li>
                <li>Guard against cycles with a trigger (<code>parent_id</code> cannot reference the row itself or any of its descendants).</li>
            </ul>
            <h4 id="suitable-scenarios">Suitable Scenarios</h4>
            <p>The adjacency list shines in applications where you typically read or modify small parts of the tree rather than large sub‚Äëtrees. It pairs well with vendor extensions for trees but still remains portable across systems.</p>
            <ul>
                <li>Menus, site navigation trees, forum threads‚Äîstructures that are usually read in small slices.</li>
                <li>Workloads with heavy write activity, where the cost of complex read queries is acceptable.</li>
                <li>Systems where vendor‚Äëspecific tree extensions (e.g., Oracle <code>CONNECT BY</code>) are available.</li>
            </ul>
            <h3 id="path-enumeration-materialised-path-model">Path Enumeration (Materialised Path) Model</h3>
            <p>The <strong>Path Enumeration Model</strong>, often called the <em>materialised path</em> technique, represents hierarchies by storing each node‚Äôs complete ancestry as a single delimited string. This means any descendant or ancestor lookup requires no joins or recursion, trading read simplicity for more complex writes.</p>
            <h4 id="table-schema">Table Schema</h4>
            <p>To implement this model, your table must include a <code>path</code> column that uniquely holds the concatenated IDs from the root to each node, using a consistent delimiter. An index on this column enables fast prefix scans for hierarchical queries.</p>
            <p>
            <div>
                <pre><code class="language-sql">CREATE TABLE categories_path (
    category_id   INT PRIMARY KEY,
    path          TEXT NOT NULL UNIQUE,  -- e.g. '1.2.3.' (note the trailing delimiter)
    category_name TEXT NOT NULL
);

-- Index for blazing‚Äëfast prefix queries (PostgreSQL)
CREATE INDEX idx_categories_path_prefix
        ON categories_path USING btree (path text_pattern_ops);</code></pre>
            </div>
            </p>
            <p><em>Trailing delimiter (<code>.</code> here) ensures prefix matches never confuse <code>1.12.</code> with <code>1.1.</code>.</em></p>
            <p>Example rows:</p>
            <p>
            <table>
                <tr>
                    <td>category_id</td>
                    <td>path</td>
                    <td>category_name</td>
                </tr>
                <tr>
                    <td>1</td>
                    <td>1.</td>
                    <td>Electronics</td>
                </tr>
                <tr>
                    <td>2</td>
                    <td>1.2.</td>
                    <td>Computers</td>
                </tr>
                <tr>
                    <td>3</td>
                    <td>1.2.3.</td>
                    <td>Laptops</td>
                </tr>
                <tr>
                    <td>4</td>
                    <td>1.2.4.</td>
                    <td>Desktops</td>
                </tr>
                <tr>
                    <td>5</td>
                    <td>1.5.</td>
                    <td>Televisions</td>
                </tr>
                <tr>
                    <td>6</td>
                    <td>1.2.3.6.</td>
                    <td>Gaming Laptops</td>
                </tr>
                <tr>
                    <td>7</td>
                    <td>1.2.3.7.</td>
                    <td>Business Laptops</td>
                </tr>
            </table>
            </p>
            <h4 id="strengths-trade-offs">Strengths / Trade‚Äëoffs</h4>
            <p>This model shines when you need lightning-fast reads at the expense of more expensive writes. By duplicating path information, prefix queries for whole sub‚Äëtrees become trivial, but moving nodes requires updating every affected row.</p>
            <p>
            <table>
                <tr>
                    <td>‚úîÔ∏è Benefits</td>
                    <td>‚ö†Ô∏è Costs</td>
                </tr>
                <tr>
                    <td><strong>Instant reads</strong> ‚Äì descendants/ancestors fetched with a single <code>LIKE</code> or prefix scan.</td>
                    <td><strong>Write ripple</strong> ‚Äì any move/insert/delete may touch an entire sub‚Äëtree.</td>
                </tr>
                <tr>
                    <td>Works in <em>any</em> SQL engine; no recursive CTE required.</td>
                    <td>Storage overhead from repeating path segments in every row.</td>
                </tr>
                <tr>
                    <td>Natural ordering for breadcrumbs and hierarchical sort.</td>
                    <td>Deep trees risk hitting string‚Äëlength or index‚Äëkey limits.</td>
                </tr>
            </table>
            </p>
            <h4 id="everyday-queries">Everyday Queries</h4>
            <p>With materialised paths, common tree operations reduce to simple text operations. Here are examples for finding descendants, children, or building breadcrumbs.</p>
            <p><strong>All descendants of ‚ÄúComputers‚Äù</strong></p>
            <p>
            <div>
                <pre><code class="language-sql">SELECT *
FROM   categories_path
WHERE  path LIKE '1.2.%';</code></pre>
            </div>
            </p>
            <p><strong>Immediate children</strong></p>
            <p>
            <div>
                <pre><code class="language-sql">SELECT *
FROM   categories_path
WHERE  path LIKE '1.2.%'
  AND  path NOT LIKE '1.2.%._%'; -- optional depth filter if delimiter is '.'</code></pre>
            </div>
            </p>
            <p><strong>Breadcrumb / ancestors of node \:leaf</strong> (PostgreSQL)</p>
            <p>
            <div>
                <pre><code class="language-sql">SELECT *
FROM   categories_path
WHERE  ':leaf_path' LIKE path || '%'
ORDER  BY length(path);</code></pre>
            </div>
            </p>
            <h4 id="maintenance-recipes">Maintenance Recipes</h4>
            <p>Writes in this model require cascaded updates to keep paths consistent. Wrap each multi-step change in a transaction to avoid partial updates.</p>
            <p>
            <table>
                <tr>
                    <td>Operation</td>
                    <td>Example (SQL pseudo-code)</td>
                </tr>
                <tr>
                    <td><strong>Insert</strong></td>
                    <td><code>-- insert child under parent_id = :p</code><br /><code>INSERT INTO categories_path (category_id, path, category_name)</code><br /><code>SELECT :id, CONCAT(path, '.', :id), :name FROM categories_path WHERE category_id = :p;</code></td>
                </tr>
                <tr>
                    <td><strong>Move</strong></td>
                    <td><code>-- fetch old prefix</code><br /><code>SELECT path AS old_prefix FROM categories_path WHERE category_id = :old_p;</code><br /><code>-- fetch new prefix</code><br /><code>SELECT path AS new_prefix FROM categories_path WHERE category_id = :new_p;</code><br /><code>-- apply update</code><br /><code>UPDATE categories_path SET path = REPLACE(path, old_prefix, new_prefix) WHERE path LIKE CONCAT(old_prefix, '%');</code></td>
                </tr>
                <tr>
                    <td><strong>Delete</strong></td>
                    <td><code>-- delete a node and its entire sub-tree</code><br /><code>DELETE FROM categories_path WHERE path LIKE '1.2.3.%';</code></td>
                </tr>
            </table>
            </p>
            <blockquote>
                <p><em>Tip:</em> Wrap these statements in a transaction to keep the tree consistent.</p>
            </blockquote>
            <h4 id="implementation-tips">Implementation Tips</h4>
            <p>To keep your materialised paths robust:</p>
            <ul>
                <li>Choose a delimiter unlikely to appear in IDs (e.g., <code>.</code> or <code>/</code>).</li>
                <li>Enforce trailing delimiter via <code>CHECK (path LIKE '%.')</code> to simplify queries.</li>
                <li>Add a <strong>prefix index</strong> (or functional index on <code>substring(path, 1, N)</code> in MySQL) for speed.</li>
                <li>Guard against cycles by ensuring <code>path</code> never contains <code>'.' || category_id || '.'</code> beyond the tail.</li>
                <li>For deep trees, store <code>path</code> in <code>VARCHAR(2048)</code> or <code>TEXT</code>; most RDBMS support long keys with in‚Äëpage overflow.</li>
            </ul>
            <h4 id="when-to-use-it">When to Use It</h4>
            <p>This pattern excels when read performance is paramount and writes are rare or batched.</p>
            <ul>
                <li>Read‚Äëheavy workloads: CMS menus, product catalogs, comment threads, category breadcrumbs.</li>
                <li>Databases lacking or throttling recursive CTEs.</li>
                <li>Systems where tree edits are infrequent or batched (daily ETL refresh).</li>
            </ul>
            <h4 id="limitations-mitigations">Limitations &amp; Mitigations</h4>
            <p>Although materialised paths speed up reads, they can introduce maintenance challenges. Use these strategies to mitigate common issues:</p>
            <p>
            <table>
                <tr>
                    <td>Issue</td>
                    <td>Mitigation</td>
                </tr>
                <tr>
                    <td>Large string updates during <em>move</em> operations</td>
                    <td>Buffer changes in staging table, then swap; or migrate to Closure Table model for heavy mutability.</td>
                </tr>
                <tr>
                    <td>Index key length limits (e.g., MySQL &lt; 3072 bytes)</td>
                    <td>Hash long prefixes into an additional column and index that.</td>
                </tr>
                <tr>
                    <td>Human error constructing paths</td>
                    <td>Provide stored procedures or application service layer to encapsulate path math.</td>
                </tr>
            </table>
            </p>
            <h3 id="nested-set-modified-preorder-tree-traversal-model">Nested Set (Modified Preorder Tree Traversal) Model</h3>
            <p>The <strong>Nested Set Model</strong>, also known as <em>Modified Preorder Tree Traversal (MPTT)</em>, encodes hierarchical structures by assigning two numerical bounds (<code>lft</code> and <code>rgt</code>) to each node. These bounds encompass all descendants, allowing entire subtrees to be retrieved with a simple range query.</p>
            <h4 id="table-schema">Table Schema</h4>
            <p>Before using MPTT, your table must include left and right bound columns, and optionally a <code>depth</code> to save computing levels. Unique indexes on the bounds prevent overlapping subtrees.</p>
            <p>
            <div>
                <pre><code class="language-sql">CREATE TABLE categories_nested (
    category_id   INT PRIMARY KEY,
    lft           INT NOT NULL,
    rgt           INT NOT NULL,
    depth         INT NOT NULL,           -- optional, but saves a COUNT(*)
    category_name TEXT NOT NULL,
    CONSTRAINT chk_bounds CHECK (lft &lt; rgt)
);

--  Ensure no overlapping ranges
CREATE UNIQUE INDEX idx_categories_lft  ON categories_nested(lft);
CREATE UNIQUE INDEX idx_categories_rgt  ON categories_nested(rgt);</code></pre>
            </div>
            </p>
            <p><em>Rule</em>: a parent‚Äôs <code>lft</code> is less than any value in its subtree and its <code>rgt</code> is greater.</p>
            <p>Example rows:</p>
            <p>
            <table>
                <tr>
                    <td>category_id</td>
                    <td>lft</td>
                    <td>rgt</td>
                    <td>depth</td>
                    <td>category_name</td>
                </tr>
                <tr>
                    <td>1</td>
                    <td>1</td>
                    <td>14</td>
                    <td>0</td>
                    <td>Electronics</td>
                </tr>
                <tr>
                    <td>2</td>
                    <td>2</td>
                    <td>9</td>
                    <td>1</td>
                    <td>Computers</td>
                </tr>
                <tr>
                    <td>3</td>
                    <td>3</td>
                    <td>6</td>
                    <td>2</td>
                    <td>Laptops</td>
                </tr>
                <tr>
                    <td>6</td>
                    <td>4</td>
                    <td>5</td>
                    <td>3</td>
                    <td>Gaming Laptops</td>
                </tr>
                <tr>
                    <td>4</td>
                    <td>7</td>
                    <td>8</td>
                    <td>2</td>
                    <td>Desktops</td>
                </tr>
                <tr>
                    <td>5</td>
                    <td>10</td>
                    <td>13</td>
                    <td>1</td>
                    <td>Televisions</td>
                </tr>
                <tr>
                    <td>7</td>
                    <td>11</td>
                    <td>12</td>
                    <td>2</td>
                    <td>Business TVs</td>
                </tr>
            </table>
            </p>
            <p><code>width = rgt - lft + 1</code>; leaves have width = 2.</p>
            <h4 id="strengths-trade-offs">Strengths / Trade‚Äëoffs</h4>
            <p>MPTT delivers constant-time reads for whole subtrees, but at the cost of complex writes: inserting or moving nodes requires shifting bounds for many rows. It‚Äôs ideal for static or read-heavy hierarchies.</p>
            <p>
            <table>
                <tr>
                    <td>‚úîÔ∏è Benefits</td>
                    <td>‚ö†Ô∏è Costs</td>
                </tr>
                <tr>
                    <td><strong>O(1) reads</strong> of any subtree‚Äîno recursion, just <code>BETWEEN lft AND rgt</code>.</td>
                    <td>Inserts / moves require shifting (updating) <code>lft</code>/<code>rgt</code> for <em>every</em> node right of the gap.</td>
                </tr>
                <tr>
                    <td>Easy aggregate queries (e.g., counts, sums) over subtrees with one <code>GROUP BY</code>.</td>
                    <td>Heavy write contention; large trees can lock many rows.</td>
                </tr>
                <tr>
                    <td>Works on all SQL engines; no special features needed.</td>
                    <td>Can exhaust integer range if tree mutates frequently.</td>
                </tr>
            </table>
            </p>
            <h4 id="everyday-queries">Everyday Queries</h4>
            <p>MPTT makes tree retrieval simple. Here are common patterns for subtrees, children, and breadcrumbs.</p>
            <p><strong>Entire subtree of node \:id</strong></p>
            <p>
            <div>
                <pre><code class="language-sql">SELECT *
FROM   categories_nested AS c
JOIN   categories_nested AS root ON root.category_id = :id
WHERE  c.lft BETWEEN root.lft AND root.rgt
ORDER  BY c.lft;</code></pre>
            </div>
            </p>
            <p><strong>Immediate children</strong></p>
            <p>
            <div>
                <pre><code class="language-sql">SELECT *
FROM   categories_nested AS c
JOIN   categories_nested AS p ON p.category_id = :parent
WHERE  c.depth = p.depth + 1
  AND  c.lft BETWEEN p.lft AND p.rgt
ORDER  BY c.lft;</code></pre>
            </div>
            </p>
            <p><strong>Breadcrumb / ancestors of node \:id</strong></p>
            <p>
            <div>
                <pre><code class="language-sql">SELECT *
FROM   categories_nested AS anc
JOIN   categories_nested AS leaf ON leaf.category_id = :id
WHERE  anc.lft &lt; leaf.lft AND anc.rgt &gt; leaf.rgt
ORDER  BY anc.lft;</code></pre>
            </div>
            </p>
            <h4 id="maintenance-recipes">Maintenance Recipes</h4>
            <p>Writes in the Nested Set Model involve multi-step bound shifts. Always wrap these operations in one transaction to maintain consistency.</p>
            <p>
            <table>
                <tr>
                    <td>Operation</td>
                    <td>Steps (SQL pseudo-code)</td>
                </tr>
                <tr>
                    <td><strong>Insert</strong> leaf as last child of parent \:p</td>
                    <td>1Ô∏è‚É£ Compute <code>new_lft = p.rgt</code>, <code>new_rgt = p.rgt + 1</code>.<br />2Ô∏è‚É£ <code>UPDATE categories_nested SET rgt = rgt + 2 WHERE rgt &gt;= new_lft;</code><br />3Ô∏è‚É£ <code>UPDATE categories_nested SET lft = lft + 2 WHERE lft &gt; new_lft;</code><br />4Ô∏è‚É£ <code>INSERT ... VALUES (:id, new_lft, new_rgt, p.depth+1, :name);</code></td>
                </tr>
                <tr>
                    <td><strong>Delete</strong> a node + subtree</td>
                    <td>1Ô∏è‚É£ <code>DELETE FROM categories_nested WHERE lft BETWEEN n.lft AND n.rgt;</code><br />2Ô∏è‚É£ Compute <code>gap = n.rgt - n.lft + 1</code>.<br />3Ô∏è‚É£ Shift remaining nodes: <code>UPDATE ... SET lft = lft - gap WHERE lft &gt; n.rgt;</code> and similarly for <code>rgt</code>.</td>
                </tr>
                <tr>
                    <td><strong>Move</strong> subtree</td>
                    <td>Complex: remove (gap), shift, compute new position, re-insert with offset. Best done in stored procedure.</td>
                </tr>
            </table>
            </p>
            <blockquote>
                <p><em>Tip:</em> All steps must run in a single transaction to avoid window overlap.</p>
            </blockquote>
            <h4 id="implementation-tips">Implementation Tips</h4>
            <p>To make MPTT robust in production:</p>
            <ul>
                <li>Keep <code>lft</code> and <code>rgt</code> odd/even (e.g., parent <code>lft</code> odd) to detect leaves (<code>rgt = lft + 1</code>).</li>
                <li>Use <code>BIGINT</code> if the tree may exceed 2^31 nodes or undergo frequent reorganisations.</li>
                <li>For bulk imports, load rows with provisional numbers, then run a recursive counter to assign <code>lft</code>/<code>rgt</code> in one pass.</li>
                <li>Add <code>CHECK (rgt % 2 = 0 AND lft % 2 = 1)</code> if employing a parity scheme.</li>
            </ul>
            <h4 id="when-to-use-it">When to Use It</h4>
            <p>MPTT fits static, read-heavy hierarchies requiring fast subtree aggregations and reports:</p>
            <ul>
                <li>Reporting/analytics where tree structure is mostly static.</li>
                <li>Systems requiring lightning-fast subtotal queries over entire branches.</li>
                <li>Legacy applications already using MPTT numbering.</li>
            </ul>
            <h4 id="limitations-mitigations">Limitations &amp; Mitigations</h4>
            <p>Heavy shifts and concurrency can challenge MPTT; consider these strategies:</p>
            <p>
            <table>
                <tr>
                    <td>Issue</td>
                    <td>Mitigation</td>
                </tr>
                <tr>
                    <td>Heavy lock during large shifts</td>
                    <td>Use <em>gap strategy</em>: leave spare numbers (e.g., increment by 10) to amortise small inserts.</td>
                </tr>
                <tr>
                    <td>Integer exhaustion after many moves</td>
                    <td>Periodically renumber tree offline (re-index).</td>
                </tr>
                <tr>
                    <td>Concurrency conflicts (two inserts same location)</td>
                    <td>Wrap shifts in pessimistic locks (<code>SELECT ... FOR UPDATE</code>).</td>
                </tr>
            </table>
            </p>
            <h3 id="closure-table-model">Closure Table Model</h3>
            <p>The <strong>Closure Table Model</strong> captures every ancestor‚Äìdescendant relationship, including self-relations, in a dedicated table. By precomputing the transitive closure of the hierarchy, queries become simple joins, offering consistent performance for both upward and downward navigations.</p>
            <h4 id="table-schema">Table Schema</h4>
            <p>Implementing a closure table requires two tables: one for the nodes themselves and another for all their ancestor‚Äìdescendant pairs. Each row in the closure table holds an <code>ancestor_id</code>, a <code>descendant_id</code>, and the <code>depth</code> between them.</p>
            <p>
            <div>
                <pre><code class="language-sql">CREATE TABLE categories (
    category_id   INT PRIMARY KEY,
    category_name TEXT NOT NULL
);

CREATE TABLE category_closure (
    ancestor_id   INT NOT NULL,
    descendant_id INT NOT NULL,
    depth         INT NOT NULL,
    PRIMARY KEY (ancestor_id, descendant_id),
    FOREIGN KEY (ancestor_id)   REFERENCES categories(category_id)
          ON DELETE CASCADE,
    FOREIGN KEY (descendant_id) REFERENCES categories(category_id)
          ON DELETE CASCADE
);

-- Fast look-ups
CREATE INDEX idx_closure_desc ON category_closure(descendant_id);</code></pre>
            </div>
            </p>
            <p><em>Rule</em>: Every node has a <strong>self-row</strong> <code>(id, id, 0)</code>; direct children use <code>depth = 1</code>, grandchildren <code>depth = 2</code>, and so on.</p>
            <h4 id="strengths-trade-offs">Strengths / Trade‚Äëoffs</h4>
            <p>The closure table excels at query performance, providing constant-time joins for ancestor and descendant lookups. However, it incurs extra storage proportional to the number of relationships and adds complexity to write operations.</p>
            <p>
            <table>
                <tr>
                    <td>‚úîÔ∏è Benefits</td>
                    <td>‚ö†Ô∏è Costs</td>
                </tr>
                <tr>
                    <td><strong>Consistent O(1) reads</strong> for any ancestor/descendant query‚Äîjust a join on the closure table.</td>
                    <td>Storage overhead can grow from O(n¬∑log‚ÄØn) to O(n¬≤) in dense trees.</td>
                </tr>
                <tr>
                    <td>Inserts and moves only touch paths related to the changed branch, not the entire tree.</td>
                    <td>Managing closure logic often requires stored procedures or triggers.</td>
                </tr>
                <tr>
                    <td>Excellent concurrency characteristics‚Äîno global bound shifts and minimal row locking.</td>
                    <td>Deletions and moves require careful cascading updates to maintain integrity.</td>
                </tr>
                <tr>
                    <td>Easy to track aggregates (e.g., subtree size) by adding columns to the closure table.</td>
                    <td>Additional indexes can become large; careful tuning is needed.</td>
                </tr>
            </table>
            </p>
            <h4 id="everyday-queries">Everyday Queries</h4>
            <p>With all relationships precomputed, typical hierarchy operations reduce to straightforward joins and filters.</p>
            <p><strong>All descendants of a node</strong></p>
            <p>
            <div>
                <pre><code class="language-sql">SELECT c.*
FROM   categories         AS c
JOIN   category_closure   AS cc ON cc.descendant_id = c.category_id
WHERE  cc.ancestor_id   = :id
  AND  cc.depth         &gt; 0  -- exclude the node itself
ORDER  BY cc.depth, c.category_name;</code></pre>
            </div>
            </p>
            <p><strong>All ancestors (breadcrumbs)</strong></p>
            <p>
            <div>
                <pre><code class="language-sql">SELECT c.*
FROM   categories         AS c
JOIN   category_closure   AS cc ON cc.ancestor_id   = c.category_id
WHERE  cc.descendant_id = :id
  AND  cc.depth         &gt; 0
ORDER  BY cc.depth DESC;  -- root first</code></pre>
            </div>
            </p>
            <p><strong>Immediate children</strong></p>
            <p>
            <div>
                <pre><code class="language-sql">SELECT c.*
FROM   categories         AS c
JOIN   category_closure   AS cc ON cc.descendant_id = c.category_id
WHERE  cc.ancestor_id = :id
  AND  cc.depth       = 1;</code></pre>
            </div>
            </p>
            <h4 id="maintenance-recipes">Maintenance Recipes</h4>
            <p>Updating the closure table involves inserting or deleting multiple relationship rows. Wrap these operations in transactions to preserve tree consistency.</p>
            <p>
            <table>
                <tr>
                    <td>Operation</td>
                    <td>Steps</td>
                </tr>
                <tr>
                    <td><strong>Insert</strong> new node under parent¬†p</td>
                    <td>1Ô∏è‚É£ Insert the node into <code>categories</code>.<br />2Ô∏è‚É£ For each ancestor of p (including p itself), insert <code>(ancestor, new_node, depth+1)</code> rows.<br />3Ô∏è‚É£ Insert the self-row <code>(new_node, new_node, 0)</code>.</td>
                </tr>
                <tr>
                    <td><strong>Move</strong> subtree from old to new p</td>
                    <td>1Ô∏è‚É£ Delete closure rows where <code>ancestor</code> is in old ancestors and <code>descendant</code> in the subtree.<br />2Ô∏è‚É£ Insert new rows by pairing new parent‚Äôs ancestors with subtree nodes.</td>
                </tr>
                <tr>
                    <td><strong>Delete</strong> node and its subtree</td>
                    <td>Delete from <code>categories</code> where <code>category_id</code> in <code>(SELECT descendant_id FROM category_closure WHERE ancestor_id = :id)</code>; cascading drops closure rows.</td>
                </tr>
            </table>
            </p>
            <h4 id="implementation-tips">Implementation Tips</h4>
            <p>To streamline closure table maintenance in production:</p>
            <ul>
                <li>Use triggers or stored procedures to automate insertion and deletion of closure rows.</li>
                <li>Consider materialised or indexed views for frequently used aggregates like subtree counts.</li>
                <li>Set <code>depth</code> as <code>SMALLINT</code> if tree depth is limited; otherwise use <code>INT</code>.</li>
                <li>For very large hierarchies, partition the closure table by <code>ancestor_id</code> range.</li>
                <li>Add a composite index on <code>(ancestor_id, depth)</code> for depth‚Äëfiltered lookups.</li>
            </ul>
            <h4 id="when-to-use-it">When to Use It</h4>
            <p>Closure tables are ideal for systems requiring both high-performance reads and frequent writes across the hierarchy:</p>
            <ul>
                <li>Interactive applications like task managers, ACL trees, or social graphs.</li>
                <li>Multi-tenant architectures where isolation of subtree operations is critical.</li>
                <li>Analytical workloads that need dynamic ancestor/descendant aggregations without the write penalty of Nested Sets.</li>
            </ul>
            <h4 id="limitations-mitigations">Limitations &amp; Mitigations</h4>
            <p>While powerful, closure tables can grow quickly and involve complex write logic. Use these strategies to address common challenges:</p>
            <p>
            <table>
                <tr>
                    <td>Issue</td>
                    <td>Mitigation</td>
                </tr>
                <tr>
                    <td>Quadratic growth in dense trees</td>
                    <td>Limit stored depths (e.g., only <code>depth¬†‚â§¬†k</code> rows) or prune distant ancestors if not needed.</td>
                </tr>
                <tr>
                    <td>Complex move operations</td>
                    <td>Encapsulate logic in atomic stored procedures rather than application code.</td>
                </tr>
                <tr>
                    <td>Large indexes due to many relationships</td>
                    <td>Employ partial or filtered indexes and consider table partitioning.</td>
                </tr>
            </table>
            </p>
            <h3 id="storing-hierarchical-data-in-sql-with-recursive-ctes">Storing Hierarchical Data in SQL with <strong>Recursive CTEs</strong></h3>
            <p>Using <em>Recursive Common Table Expressions</em> (CTEs) lets you navigate arbitrarily deep hierarchies within a single table. This method is fully declarative: the database optimizer figures out the traversal, so you write less procedural code.</p>
            <h4 id="why-bother-">Why Bother?</h4>
            <p>Recursive CTEs provide a portable, one-table solution for unlimited depth hierarchies. They work across major SQL vendors (PostgreSQL, SQL Server, Oracle, MySQL, MariaDB, SQLite, DuckDB) and can retrieve descendants, ancestors, paths, and even leaf nodes‚Äîall with a consistent query structure.</p>
            <h4 id="table-layout-adjacency-list-">Table Layout (Adjacency-List)</h4>
            <p>To use recursive CTEs, your table only needs an ID and a self-reference to its parent. This simple schema underpins the traversal logic without extra helper tables.</p>
            <p>
            <div>
                <pre><code class="language-sql">CREATE TABLE categories (
  category_id   INT PRIMARY KEY,
  parent_id     INT REFERENCES categories(category_id),
  category_name TEXT NOT NULL
);</code></pre>
            </div>
            </p>
            <h5>Visual Map of Demo Data</h5>
            <p>Below is the tree we'll query in examples. It shows categories and subcategories connected by parent‚Äìchild links.</p>
            <p>
            <div>
                <pre><code class="language-shell">Electronics
‚îú‚îÄ Computers
‚îÇ  ‚îú‚îÄ Laptops
‚îÇ  ‚îÇ  ‚îú‚îÄ Gaming Laptops
‚îÇ  ‚îÇ  ‚îî‚îÄ Business Laptops
‚îÇ  ‚îî‚îÄ Desktops
‚îî‚îÄ Televisions</code></pre>
            </div>
            </p>
            <h4 id="the-recursive-cte-template">The Recursive-CTE Template</h4>
            <p>Recursive CTEs follow a three-part pattern: an <em>anchor</em> to seed the starting rows, a <em>recursive step</em> that joins to the CTE itself to add layers, and a <em>final query</em> to filter or order the results.</p>
            <p>
            <div>
                <pre><code class="language-sql">WITH RECURSIVE cte_name AS (
    -- ‚ë† Anchor: select initial rows (e.g., roots)
    SELECT ... FROM base_table WHERE ...

    UNION ALL

    -- ‚ë° Recursive step: join new rows to previous layer
    SELECT ...
    FROM   base_table
    JOIN   cte_name ON ...
)
SELECT *            -- ‚ë¢ Final query: retrieve or filter the accumulated set
FROM   cte_name;</code></pre>
            </div>
            </p>
            <p>The engine executes the anchor once, then repeats the recursive step until no new rows emerge.</p>
            <h4 id="example-a-breadcrumb-path-for-every-category">Example A ‚Äì Breadcrumb Path for Every Category</h4>
            <p>This query builds a <code>full_path</code> column by concatenating names from root to each node. Each recursion appends the child‚Äôs name and increments the depth.</p>
            <p>
            <div>
                <pre><code class="language-sql">WITH RECURSIVE category_path AS (
    -- ‚ë† Anchor: top-level categories
    SELECT
        category_id,
        parent_id,
        category_name,
        category_name            AS full_path,
        0                        AS depth
    FROM   categories
    WHERE  parent_id IS NULL

    UNION ALL

    -- ‚ë° Recursive step: append child names
    SELECT
        c.category_id,
        c.parent_id,
        c.category_name,
        cp.full_path || ' &gt; ' || c.category_name AS full_path,
        cp.depth + 1                         AS depth
    FROM   categories      c
    JOIN   category_path   cp ON cp.category_id = c.parent_id
)
SELECT *
FROM   category_path
ORDER  BY full_path;</code></pre>
            </div>
            </p>
            <p><em>Key Ideas:</em> use <code>UNION ALL</code> to preserve duplicates, <code>depth</code> for ordering or indenting, and string concatenation (<code>||</code> or <code>CONCAT()</code>).</p>
            <h4 id="example-b-subtree-of-a-chosen-node">Example B ‚Äì Subtree of a Chosen Node</h4>
            <p>To extract a subtree, seed the CTE with the chosen node, then recur downward to include all descendants.</p>
            <p>
            <div>
                <pre><code class="language-sql">WITH RECURSIVE sub_tree AS (
    -- ‚ë† Anchor: the selected category
    SELECT * FROM categories WHERE category_name = 'Computers'

    UNION ALL

    -- ‚ë° Recursive step: find children of the current layer
    SELECT c.*
    FROM   categories c
    JOIN   sub_tree  s ON s.category_id = c.parent_id
)
SELECT *
FROM   sub_tree;</code></pre>
            </div>
            </p>
            <p>Swap the join direction (<code>ON c.category_id = s.parent_id</code>) to climb upward and list ancestors instead.</p>
            <h4 id="example-c-leaf-nodes-only">Example C ‚Äì Leaf Nodes Only</h4>
            <p>This pattern discovers nodes that never appear as a parent. The CTE collects all nodes, then a final <code>LEFT JOIN</code> filters out those with children.</p>
            <p>
            <div>
                <pre><code class="language-sql">WITH RECURSIVE walker AS (
    SELECT category_id, parent_id FROM categories
    UNION ALL
    SELECT c.category_id, c.parent_id
    FROM   categories c
    JOIN   walker     w ON w.category_id = c.parent_id
)
SELECT w.category_id
FROM   walker w
LEFT   JOIN categories x ON x.parent_id = w.category_id
WHERE  x.category_id IS NULL;</code></pre>
            </div>
            </p>
            <h4 id="performance-safety-checklist">Performance &amp; Safety Checklist</h4>
            <p>Recursive CTEs are powerful but can misbehave on large or cyclic graphs. Follow these guidelines for robust, efficient queries.</p>
            <p>
            <table>
                <tr>
                    <td>‚úîÔ∏é Do</td>
                    <td>‚úò Avoid</td>
                </tr>
                <tr>
                    <td>Index <code>parent_id</code> (and <code>category_id</code>).</td>
                    <td>Cartesian joins in the recursive part.</td>
                </tr>
                <tr>
                    <td>Add <code>WHERE depth &lt; 30</code> if depth is bounded.</td>
                    <td>Deep recursion on un-indexed columns.</td>
                </tr>
                <tr>
                    <td>Test with small data first ‚Äì verify that recursion stops.</td>
                    <td>Recursing on cyclic graphs without depth guards.</td>
                </tr>
                <tr>
                    <td>Use <code>UNION ALL</code> (not <code>UNION</code>) unless duplicate elimination is needed.</td>
                    <td>Heavy aggregates inside the recursive member ‚Äì separate queries.</td>
                </tr>
            </table>
            </p>
            <h4 id="quick-reference">Quick Reference</h4>
            <p>A handy cheat sheet for common tasks:</p>
            <p>
            <div>
                <pre><code class="language-sql">-- Descendants: JOIN cte ON cte.category_id = base.parent_id
-- Ancestors:   JOIN cte ON cte.parent_id   = base.category_id
-- Path string: full_path || ' &gt; ' || child.name
-- Depth:       parent.depth + 1</code></pre>
            </div>
            </p>
            <h4 id="when-recursive-ctes-are-not-enough">When Recursive CTEs Are <strong>Not</strong> Enough</h4>
            <p>While versatile, recursive CTEs can struggle with very deep or wide trees, frequent full-branch reads, or legacy systems lacking support. In such cases, explore <strong>Closure Tables</strong>, <strong>Nested Sets</strong>, <strong>Materialised Paths</strong>, or specialized graph databases (e.g., Neo4j).</p>
        </section>
        <div id="table-of-contents">
            <h2>Table of Contents</h2>
            <ol><a href="#storing-hierarchical-data-in-relational-databases-with-sql">Storing Hierarchical Data in Relational Databases with SQL</a>
                <ol>
                    <li><a href="#adjacency-list-model">Adjacency List Model</a>
                        <ol>
                            <li><a href="#table-schema">Table Schema</a></li>
                            <li><a href="#why-choose-it-">Why Choose It?</a></li>
                            <li><a href="#common-queries">Common Queries</a></li>
                            <li><a href="#implementation-tips">Implementation Tips</a></li>
                            <li><a href="#suitable-scenarios">Suitable Scenarios</a></li>
                        </ol>
                    </li>
                    <li><a href="#path-enumeration-materialised-path-model">Path Enumeration (Materialised Path) Model</a>
                        <ol>
                            <li><a href="#table-schema">Table Schema</a></li>
                            <li><a href="#strengths-trade-offs">Strengths / Trade‚Äëoffs</a></li>
                            <li><a href="#everyday-queries">Everyday Queries</a></li>
                            <li><a href="#maintenance-recipes">Maintenance Recipes</a></li>
                            <li><a href="#implementation-tips">Implementation Tips</a></li>
                            <li><a href="#when-to-use-it">When to Use It</a></li>
                            <li><a href="#limitations-mitigations">Limitations &amp; Mitigations</a></li>
                        </ol>
                    </li>
                    <li><a href="#nested-set-modified-preorder-tree-traversal-model">Nested Set (Modified Preorder Tree Traversal) Model</a>
                        <ol>
                            <li><a href="#table-schema">Table Schema</a></li>
                            <li><a href="#strengths-trade-offs">Strengths / Trade‚Äëoffs</a></li>
                            <li><a href="#everyday-queries">Everyday Queries</a></li>
                            <li><a href="#maintenance-recipes">Maintenance Recipes</a></li>
                            <li><a href="#implementation-tips">Implementation Tips</a></li>
                            <li><a href="#when-to-use-it">When to Use It</a></li>
                            <li><a href="#limitations-mitigations">Limitations &amp; Mitigations</a></li>
                        </ol>
                    </li>
                    <li><a href="#closure-table-model">Closure Table Model</a>
                        <ol>
                            <li><a href="#table-schema">Table Schema</a></li>
                            <li><a href="#strengths-trade-offs">Strengths / Trade‚Äëoffs</a></li>
                            <li><a href="#everyday-queries">Everyday Queries</a></li>
                            <li><a href="#maintenance-recipes">Maintenance Recipes</a></li>
                            <li><a href="#implementation-tips">Implementation Tips</a></li>
                            <li><a href="#when-to-use-it">When to Use It</a></li>
                            <li><a href="#limitations-mitigations">Limitations &amp; Mitigations</a></li>
                        </ol>
                    </li>
                    <li><a href="#storing-hierarchical-data-in-sql-with-recursive-ctes">Storing Hierarchical Data in SQL with Recursive CTEs</a>
                        <ol>
                            <li><a href="#why-bother-">Why Bother?</a></li>
                            <li><a href="#table-layout-adjacency-list-">Table Layout (Adjacency-List)</a></li>
                            <li><a href="#the-recursive-cte-template">The Recursive-CTE Template</a></li>
                            <li><a href="#example-a-breadcrumb-path-for-every-category">Example A ‚Äì Breadcrumb Path for Every Category</a></li>
                            <li><a href="#example-b-subtree-of-a-chosen-node">Example B ‚Äì Subtree of a Chosen Node</a></li>
                            <li><a href="#example-c-leaf-nodes-only">Example C ‚Äì Leaf Nodes Only</a></li>
                            <li><a href="#performance-safety-checklist">Performance &amp; Safety Checklist</a></li>
                            <li><a href="#quick-reference">Quick Reference</a></li>
                            <li><a href="#when-recursive-ctes-are-not-enough">When Recursive CTEs Are Not Enough</a></li>
                        </ol>
                    </li>
                </ol>
            </ol>
            <div id="related-articles">
                <h2>Related Articles</h2>
                <ol>
                    <li>Introduction to Databases<ol>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/01_introduction_to_databases/01_databases_intro.html">Databases Intro</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/01_introduction_to_databases/02_types_of_databases.html">Types of Databases</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/01_introduction_to_databases/03_database_management_systems_dbms_.html">Database Management Systems Dbms</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/01_introduction_to_databases/04_data_models.html">Data Models</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/01_introduction_to_databases/05_glossary.html">Glossary</a></li>
                        </ol>
                    </li>
                    <li>Database Design<ol>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/02_database_design/01_requirements_analysis.html">Requirements Analysis</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/02_database_design/02_normalization.html">Normalization</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/02_database_design/03_denormalization.html">Denormalization</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/02_database_design/04_indexing_strategies.html">Indexing Strategies</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/02_database_design/05_data_integrity.html">Data Integrity</a></li>
                        </ol>
                    </li>
                    <li>Sql<ol>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/03_sql/01_intro_to_sql.html">Intro to Sql</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/03_sql/02_data_definition_language_ddl.html">Data Definition Language Ddl</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/03_sql/03_data_manipulation_language_dml.html">Data Manipulation Language Dml</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/03_sql/04_data_control_language_dcl.html">Data Control Language Dcl</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/03_sql/05_transaction_control_language_tcl.html">Transaction Control Language Tcl</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/03_sql/06_joins_subqueries_and_views.html">Joins Subqueries and Views</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/03_sql/07_stored_procedures_and_functions.html">Stored Procedures and Functions</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/03_sql/08_triggers.html">Triggers</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/03_sql/09_hierarchical_data.html">Hierarchical Data</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/03_sql/10_aggregate_functions.html">Aggregate Functions</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/03_sql/11_window_functions.html">Window Functions</a></li>
                        </ol>
                    </li>
                    <li>Acid Properties and Transactions<ol>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/04_acid_properties_and_transactions/01_transactions_intro.html">Transactions Intro</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/04_acid_properties_and_transactions/02_atomicity.html">Atomicity</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/04_acid_properties_and_transactions/03_consistency.html">Consistency</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/04_acid_properties_and_transactions/04_isolation.html">Isolation</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/04_acid_properties_and_transactions/05_durability.html">Durability</a></li>
                        </ol>
                    </li>
                    <li>Storage and Indexing<ol>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/05_storage_and_indexing/01_how_tables_and_indexes_are_stored_on_disk.html">How Tables and Indexes Are Stored on Disk</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/05_storage_and_indexing/02_row_based_vs_column_based_databases.html">Row Based vs Column Based Databases</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/05_storage_and_indexing/03_primary_key_vs_secondary_key.html">Primary Key vs Secondary Key</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/05_storage_and_indexing/04_database_pages.html">Database Pages</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/05_storage_and_indexing/05_indexing.html">Indexing</a></li>
                        </ol>
                    </li>
                    <li>Distributed Databases<ol>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/06_distributed_databases/01_distributed_database_systems.html">Distributed Database Systems</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/06_distributed_databases/02_partitioning.html">Partitioning</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/06_distributed_databases/03_sharding.html">Sharding</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/06_distributed_databases/04_partitioning_vs_sharding.html">Partitioning vs Sharding</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/06_distributed_databases/05_consistent_hashing.html">Consistent Hashing</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/06_distributed_databases/06_cap_theorem.html">Cap Theorem</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/06_distributed_databases/07_eventual_consistency.html">Eventual Consistency</a></li>
                        </ol>
                    </li>
                    <li>Concurrency Control<ol>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/07_concurrency_control/01_shared_vs_exclusive_locks.html">Shared vs Exclusive Locks</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/07_concurrency_control/02_deadlocks.html">Deadlocks</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/07_concurrency_control/03_two_phase_locking.html">Two Phase Locking</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/07_concurrency_control/04_double_booking_problem.html">Double Booking Problem</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/07_concurrency_control/05_serializable_vs_repeatable_read.html">Serializable vs Repeatable Read</a></li>
                        </ol>
                    </li>
                    <li>Database Performance<ol>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/08_database_performance/01_query_optimization_techniques.html">Query Optimization Techniques</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/08_database_performance/02_indexing_strategies.html">Indexing Strategies</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/08_database_performance/03_database_caching.html">Database Caching</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/08_database_performance/04_materialized_views.html">Materialized Views</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/08_database_performance/05_accessing_database_in_code.html">Accessing Database in Code</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/08_database_performance/06_working_with_billion_row_table.html">Working with Billion Row Table</a></li>
                        </ol>
                    </li>
                    <li>Database Replication<ol>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/09_database_replication/01_intro_to_replication.html">Intro to Replication</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/09_database_replication/02_master_standby_replication.html">Master Standby Replication</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/09_database_replication/03_multi_master_replication.html">Multi Master Replication</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/09_database_replication/04_synchronous_vs_asynchronous_replication.html">Synchronous vs Asynchronous Replication</a></li>
                        </ol>
                    </li>
                    <li>Nosql Databases<ol>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/10_nosql_databases/01_nosql_databases_intro.html">Nosql Databases Intro</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/10_nosql_databases/02_types_of_nosql_databases.html">Types of Nosql Databases</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/10_nosql_databases/03_querying_nosql_databases.html">Querying Nosql Databases</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/10_nosql_databases/04_crud_in_sql_vs_nosql.html">Crud in Sql vs Nosql</a></li>
                        </ol>
                    </li>
                    <li>Security Best Practices<ol>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/11_security_best_practices/01_backup_and_recovery_strategies.html">Backup and Recovery Strategies</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/11_security_best_practices/02_database_security.html">Database Security</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/11_security_best_practices/03_capacity_planning.html">Capacity Planning</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/11_security_best_practices/04_database_migration.html">Database Migration</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/11_security_best_practices/05_performance_monitoring_and_tuning.html">Performance Monitoring and Tuning</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/11_security_best_practices/06_sql_injection.html">Sql Injection</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/11_security_best_practices/07_crash_recovery_in_databases.html">Crash Recovery in Databases</a></li>
                        </ol>
                    </li>
                    <li>Database Engines<ol>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/12_database_engines/01_sqlite.html">Sqlite</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/12_database_engines/02_mysql.html">Mysql</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/12_database_engines/03_postgresql.html">Postgresql</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/12_database_engines/04_mongodb.html">Mongodb</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/12_database_engines/05_neo4j.html">Neo4J</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/12_database_engines/06_aws_services.html">Aws Services</a></li>
                            <li><a href="https://adamdjellouli.com/articles/databases_notes/12_database_engines/07_choosing_database.html">Choosing Database</a></li>
                        </ol>
                    </li>
                </ol>
            </div>
        </div>
    </div>
    <footer>
        <div class="footer-columns">
            <div class="footer-column">
                <img alt="Adam Djellouli Symbol" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/symbol.png" />
            </div>
            <div class="footer-column">
                <h2><a href="https://adamdjellouli.com/core/privacy_policy.html" title="Privacy Policy">Our Privacy Policy</a></h2>
                <p>Thank you for visiting my personal website. All content here is free to use, but please remember to be respectful and avoid any misuse of the site. If you‚Äôd like to get in touch, feel free to reach out via my <a href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" title="LinkedIn Profile">LinkedIn profile</a> or connect with me on <a href="https://github.com/djeada" title="GitHub Profile">GitHub</a> if you have technical questions or ideas to share. Wishing you all the best and a fantastic life ahead!</p>
            </div>
            <div class="footer-column">
                <h2>Follow me</h2>
                <ul class="social-media">
                    <li>
                        <a class="fa fa-youtube" href="https://www.youtube.com/channel/UCGPoHTVjMN77wcGknXPHl1Q" target="_blank" title="YouTube">
                        </a>YouTube
                    </li>
                    <li>
                        <a class="fa fa-linkedin" href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" target="_blank" title="LinkedIn">
                        </a>LinkedIn
                    </li>
                    <li>
                        <a class="fa fa-instagram" href="https://www.instagram.com/linuxchallenges/" target="_blank" title="Instagram">
                        </a>Instagram
                    </li>
                    <li>
                        <a class="fa fa-github" href="https://github.com/djeada" title="GitHub">
                        </a>Github
                    </li>
                </ul>
            </div>
        </div>
        <div>
            <p id="copyright">
                ¬© Adam Djellouli. All rights reserved.
            </p>
        </div>
        <script>
            document.getElementById("copyright").innerHTML = "&copy; " + new Date().getFullYear() + " Adam Djellouli. All rights reserved.";
        </script>
        <script src="../../../app.js"></script>
    </footer>
    <div id="pdf-spinner-overlay">
        <div class="spinner"></div>
    </div>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-bash.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-cpp.min.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
jax: ["input/TeX", "output/HTML-CSS"],
extensions: ["tex2jax.js"],
"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] },
tex2jax: { inlineMath: [ ["$", "$"] ], displayMath: [ ["$$","$$"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
TeX: { noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } } },
messageStyle: "none"
});
</script>
<script async="" id="MathJax-script" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>

</html>