<!DOCTYPE html>

<html lang="pl">

<head>
    <script async="" crossorigin="anonymous" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5593122079896089"></script>
    <meta charset="utf-8" />
    <title>Pętle</title>
    <meta content="Pętle to kluczowe konstrukcje w programowaniu, które pozwalają na wielokrotne wykonanie określonego fragmentu kodu w zależności od ustalonych warunków lub do momentu osiągnięcia konkretnego celu." name="description" />
    <meta content="Adam Djellouli" name="author" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <meta content="IE=edge" http-equiv="X-UA-Compatible" />
    <link crossorigin="" href="https://fonts.googleapis.com" rel="preconnect" />
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/icon.ico" rel="icon" />
    <link href="../../resources/style.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
</head>

<body>
    <nav aria-label="Main navigation">
        <a class="logo" href="https://adamdjellouli.com">
            <img alt="Adam Djellouli - Home Page Logo" id="logo-image" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/logo.PNG" />
        </a>
        <input aria-label="Toggle navigation menu" id="navbar-toggle" type="checkbox" />
        <ul aria-labelledby="navbar-toggle" role="menu">
            <li role="menuitem">
                <a href="../../index.html" title="Go to Home Page"> Home </a>
            </li>
            <li role="menuitem">
                <a class="active" href="../../core/blog.html" title="Read Adam Djellouli Blog on Programming and Technology"> Blog </a>
            </li>
            <li role="menuitem">
                <a href="../../core/tools.html" title="Discover Tools Created by Adam Djellouli"> Tools </a>
            </li>
            <li role="menuitem">
                <a href="../../core/projects.html" title="Explore Projects Developed by Adam Djellouli"> Projects </a>
            </li>
            <li role="menuitem">
                <a href="../../core/resume.html" title="View Adam Djellouli Professional Resume"> Resume </a>
            </li>
            <li>
                <script async="" src="https://cse.google.com/cse.js?cx=8160ef9bb935f4f68"></script>
                <div class="gcse-search"></div>
            </li>
            <li>
                <button aria-label="Toggle dark mode" id="dark-mode-button"></button>
            </li>
        </ul>
    </nav>
    <div id="article-wrapper"><article-section id="article-body">
            <div class="article-action-buttons"><button class="btn-suggest-edit" title="Suggest Edit">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <path d="M4 21h4l11-11-4-4L4 17v4z" stroke="currentColor" stroke-width="2"></path>
                    </svg>
                </button><button class="btn-create-issue" title="Create Issue">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2"></circle>
                        <line stroke="currentColor" stroke-width="2" x1="12" x2="12" y1="8" y2="12"></line>
                        <circle cx="12" cy="16" fill="currentColor" r="1"></circle>
                    </svg>
                </button><button class="btn-download" title="Download">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <path d="M12 5v14m0 0l-6-6m6 6l6-6" stroke="currentColor" stroke-width="2"></path>
                    </svg>
                </button></div>
            <p style="text-align: right;"><i>Last modified: May 20, 2023</i></p>
            <p style="text-align: right;"><i>This article is written in: 🇵🇱</i></p>
            <h2 id="pętle">Pętle</h2>
            <p>Pętle to kluczowe konstrukcje w programowaniu, które pozwalają na wielokrotne wykonanie określonego fragmentu kodu w zależności od ustalonych warunków lub do momentu osiągnięcia konkretnego celu. Dzięki pętlom można automatyzować powtarzalne procesy, co znacznie przyspiesza działanie programów i ułatwia zarządzanie wieloma operacjami jednocześnie. Ich umiejętne wykorzystanie pozwala pisać kod nie tylko bardziej zwięzły, ale też zdecydowanie bardziej czytelny.</p>
            <p>W języku C++ (jak i w wielu innych językach programowania) do najpopularniejszych rodzajów pętli należą:</p>
            <ol>
                <li><strong>Pętla <code>for</code></strong> – najczęściej stosowana w sytuacjach, gdy z góry znamy liczbę iteracji lub planujemy przechodzić po zakresie liczb, np. indeksach tablicy.</li>
                <li><strong>Pętla <code>while</code></strong> – wykorzystywana, gdy nie jesteśmy pewni, ile razy kod powinien zostać powtórzony, ale decydujemy na podstawie warunku logicznego.</li>
                <li><strong>Pętla <code>do-while</code></strong> – podobna do <code>while</code>, z tą różnicą, że blok kodu wykona się przynajmniej raz, zanim zostanie sprawdzony warunek.</li>
            </ol>
            <p>Każdy z tych rodzajów pętli posiada swoją charakterystykę i jest przydatny w nieco innych przypadkach. W praktyce programistycznej często będziesz wybierać rodzaj pętli w zależności od tego, czy warunek przetwarzania znany jest z góry, czy też zależy od zmieniających się w trakcie działania programu danych.</p>
            <h3 id="pętla-for">Pętla <code>for</code></h3>
            <p>Pętla <code>for</code> jest szczególnie przydatna, gdy znamy z góry liczbę powtórzeń danej operacji. Składa się z trzech głównych elementów: inicjalizacji, warunku i operacji po każdej iteracji (zwykle inkrementacji). Ten typ pętli ułatwia też czytelne utrzymanie i aktualizację licznika (zmiennej kontrolnej), ponieważ cały mechanizm liczenia iteracji zawiera się w pojedynczym wierszu.</p>
            <h4 id="struktura-pętli-for">Struktura pętli <code>for</code></h4>
            <p>
            <div>
                <pre><code class="language-clike">for (inicjalizacja; warunek; inkrementacja) {
    // kod do wykonania w każdej iteracji
}</code></pre>
            </div>
            </p>
            <ul>
                <li><strong>inicjalizacja</strong> – zwykle służy do zainicjalizowania zmiennej kontrolnej (np. <code>int i = 0;</code>).</li>
                <li><strong>warunek</strong> – określa moment zakończenia pętli (np. <code>i &lt; n;</code>).</li>
                <li><strong>inkrementacja</strong> – zmiana wartości zmiennej kontrolnej (np. <code>i++</code>;).</li>
            </ul>
            <h4 id="przykład-wypisanie-wszystkich-parzystych-liczb-od-0-do-n-">Przykład: wypisanie wszystkich parzystych liczb od 0 do <code>n</code>.</h4>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;

int main() {
    int n;
    std::cout &lt;&lt; "Podaj liczbę: ";
    std::cin &gt;&gt; n;

    for (int i = 0; i &lt;= n; i++) {
        if (i % 2 == 0)
            std::cout &lt;&lt; i &lt;&lt; std::endl;
    }

    return 0;
}</code></pre>
            </div>
            </p>
            <p>W powyższym kodzie korzystamy z klasycznego formatu pętli <code>for</code>. Pętla startuje od <code>i = 0</code> i trwa tak długo, jak długo <code>i &lt;= n</code>. Po każdej iteracji wartość <code>i</code> zwiększa się o 1. Wewnątrz pętli sprawdzany jest warunek <code>if (i % 2 == 0)</code>, który filtruje liczby parzyste.</p>
            <h4 id="pętla-for-z-różnymi-typami-danych">Pętla <code>for</code> z różnymi typami danych</h4>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;

int main() {
    for (char c = 'a'; c &lt;= 'z'; c++) {
        std::cout &lt;&lt; c &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;

    for (double d = 0.0; d &lt;= 1.0; d += 0.1) {
        std::cout &lt;&lt; d &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;

    return 0;
}</code></pre>
            </div>
            </p>
            <p>W tym przykładzie pierwsza pętla przechodzi przez zakres znaków od <code>'a'</code> do <code>'z'</code>. Każda iteracja wyświetla jeden znak, co pozwala na wypisanie całego alfabetu. Druga pętla wykorzystuje zmienną typu <code>double</code>, inkrementując ją o <code>0.1</code> w każdej iteracji aż do osiągnięcia wartości <code>1.0</code>. Dzięki temu możliwe jest wykonywanie pętli z wartościami zmiennoprzecinkowymi, np. do obliczeń matematycznych lub generowania pewnych sekwencji liczb.</p>
            <h3 id="pętla-while">Pętla <code>while</code></h3>
            <p>Pętla <code>while</code> powtarza blok instrukcji, dopóki podany warunek jest prawdziwy. Jest ona szczególnie użyteczna, gdy nie wiemy z góry, ile razy blok kodu powinien się wykonać. Wystarczy opisać warunek, a pętla będzie działać do momentu, w którym warunek przestanie być spełniony.</p>
            <h4 id="struktura-pętli-while">Struktura pętli <code>while</code></h4>
            <p>
            <div>
                <pre><code class="language-clike">while (warunek) {
    // kod do wykonania w każdej iteracji
}</code></pre>
            </div>
            </p>
            <ul>
                <li><strong>warunek</strong> – wyrażenie logiczne, które musi być spełnione, aby kontynuować wykonywanie pętli. Gdy warunek przestaje być prawdziwy, pętla się kończy.</li>
            </ul>
            <h4 id="przykład-wypisanie-wszystkich-liczb-od-0-do-n-">Przykład: wypisanie wszystkich liczb od 0 do n.</h4>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;

int main() {
    int n;
    std::cout &lt;&lt; "Podaj liczbę: ";
    std::cin &gt;&gt; n;
    
    int i = 0;
    while (i &lt;= n) {
        std::cout &lt;&lt; i &lt;&lt; std::endl;
        i++;
    }

    return 0;
}</code></pre>
            </div>
            </p>
            <p>W tym przykładzie pętla będzie się wykonywać do momentu, w którym <code>i &lt;= n</code>. Z każdą iteracją wartość <code>i</code> jest zwiększana o 1, dzięki czemu wykonujemy dokładnie tyle obrotów pętli, ile potrzeba do wypisania liczb z przedziału <code>[0, n]</code>.</p>
            <h3 id="pętla-do-while">Pętla <code>do-while</code></h3>
            <p>Pętla <code>do-while</code> jest podobna do pętli <code>while</code>, z tą różnicą, że warunek sprawdzany jest na końcu iteracji. Dlatego blok instrukcji wykona się przynajmniej raz, niezależnie od warunku. To oznacza, że <code>do-while</code> jest przydatne w sytuacjach, w których chcemy wykonać pewien fragment kodu co najmniej jeden raz, zanim w ogóle sprawdzimy warunek.</p>
            <h4 id="struktura-pętli-do-while">Struktura pętli <code>do-while</code></h4>
            <p>
            <div>
                <pre><code class="language-clike">do {
    // kod do wykonania w każdej iteracji
} while (warunek);</code></pre>
            </div>
            </p>
            <ul>
                <li>Kod zawarty między <code>do { ... }</code> a <code>while (warunek);</code> wykona się <strong>zawsze przynajmniej raz</strong>, bez względu na początkową wartość warunku.</li>
            </ul>
            <h4 id="przykład-prośba-o-podanie-liczby-dodatniej-przez-użytkownika-">Przykład: Prośba o podanie liczby dodatniej przez użytkownika.</h4>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;

int main() {
    int n;

    do {
        std::cout &lt;&lt; "Podaj liczbę dodatnią: ";
        std::cin &gt;&gt; n;
    } while (n &lt;= 0);

    std::cout &lt;&lt; "Dziękuję! Podana liczba to: " &lt;&lt; n &lt;&lt; std::endl;

    return 0;
}</code></pre>
            </div>
            </p>
            <p>W tym kodzie użytkownik jest proszony o podanie liczby co najmniej raz. Nawet gdyby początkowo <code>n</code> miało wartość mniejszą od zera, pętla uruchomi się i umożliwi wprowadzenie liczby. Dopiero po wykonaniu bloku następuje sprawdzenie, czy <code>n &lt;= 0</code>. Jeśli tak, cała sekwencja się powtarza, dopóki nie zostanie wprowadzona wartość dodatnia.</p>
            <h3 id="pętla-nieskończona">Pętla nieskończona</h3>
            <p>Pętla nieskończona to pętla, która teoretycznie nigdy się nie kończy, ponieważ jej warunek zawsze pozostaje prawdziwy. Zwykle jest kontrolowana za pomocą zewnętrznych warunków, np. dodatkowych instrukcji <code>if</code> czy mechanizmu obsługi zdarzeń, dzięki którym możemy ręcznie przerwać jej działanie. Pętla nieskończona bywa używana w aplikacjach systemowych i serwerach, które muszą nieustannie nasłuchiwać zdarzeń i nie powinny się kończyć w sposób „naturalny”.</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;

int main() {
    while (true) {
        std::cout &lt;&lt; "To jest pętla nieskończona. Naciśnij Ctrl+C, aby zakończyć." &lt;&lt; std::endl;
    }

    return 0;
}</code></pre>
            </div>
            </p>
            <p>Przykład ten obrazuje niekończące się wypisywanie komunikatu na ekran. W praktyce zamiast samych komunikatów w pętli nieskończonej mogłyby się znaleźć np. operacje obsługi zadań w tle, komunikacja z innymi procesami czy reagowanie na zdarzenia z systemu operacyjnego.</p>
            <h3 id="zagnieżdżone-pętle">Zagnieżdżone pętle</h3>
            <p>Zagnieżdżone pętle to konstrukcja, w której jedna pętla jest umieszczona wewnątrz innej pętli. Są one często używane do operacji na danych wielowymiarowych, takich jak tablice dwuwymiarowe (macierze). Każda iteracja pętli zewnętrznej uruchamia pełny cykl iteracji pętli wewnętrznej. Zagnieżdżenie pętli może być dowolnie głębokie, choć w praktyce więcej niż trzy poziomy zagnieżdżenia znacząco utrudniają czytelność i mogą świadczyć o konieczności refaktoryzacji kodu.</p>
            <h4 id="struktura-zagnieżdżonej-pętli">Struktura zagnieżdżonej pętli</h4>
            <p>
            <div>
                <pre><code class="language-clike">for (inicjalizacja1; warunek1; inkrementacja1) {
    // Kod pętli zewnętrznej
    for (inicjalizacja2; warunek2; inkrementacja2) {
        // Kod pętli wewnętrznej
    }
}</code></pre>
            </div>
            </p>
            <p>Możemy łączyć różne typy pętli, np. pętlę <code>for</code> jako zewnętrzną i pętlę <code>while</code> jako wewnętrzną, jednak warto wtedy zachować szczególną ostrożność w zakresie kontrolowania warunków ich zakończenia.</p>
            <h4 id="przykład-wypisanie-tablicy-mnożenia">Przykład: Wypisanie tablicy mnożenia</h4>
            <p>Poniżej znajduje się przykład programu, który używa zagnieżdżonych pętli do wypisania tablicy mnożenia dla liczb od 1 do <code>n</code>.</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;

int main() {
    int n;
    std::cout &lt;&lt; "Podaj rozmiar tablicy mnożenia: ";
    std::cin &gt;&gt; n;

    // Pętla zewnętrzna iteruje po wierszach
    for (int i = 1; i &lt;= n; i++) {
        // Pętla wewnętrzna iteruje po kolumnach
        for (int j = 1; j &lt;= n; j++) {
            std::cout &lt;&lt; i * j &lt;&lt; "\t";
        }
        std::cout &lt;&lt; std::endl;
    }

    return 0;
}</code></pre>
            </div>
            </p>
            <p>W tym przykładzie, dla każdej wartości <code>i</code> w pętli zewnętrznej, pętla wewnętrzna wykonuje pełny cykl iteracji dla wartości <code>j</code>. Dzięki temu uzyskujemy wszystkie iloczyny postaci <code>i * j</code>, co pozwala na wypisanie tablicy mnożenia o wymiarach <code>n x n</code>.</p>
            <h4 id="zagnieżdżone-pętle-while">Zagnieżdżone pętle <code>while</code></h4>
            <p>Zagnieżdżenie pętli nie dotyczy wyłącznie <code>for</code>. Poniżej przykład osiągający ten sam efekt co powyżej, ale przy użyciu pętli <code>while</code>.</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;

int main() {
    int n;
    std::cout &lt;&lt; "Podaj rozmiar tablicy mnożenia: ";
    std::cin &gt;&gt; n;

    int i = 1;
    while (i &lt;= n) {
        int j = 1;
        while (j &lt;= n) {
            std::cout &lt;&lt; i * j &lt;&lt; "\t";
            j++;
        }
        std::cout &lt;&lt; std::endl;
        i++;
    }

    return 0;
}</code></pre>
            </div>
            </p>
            <p>Kod działania jest bardzo podobny: pętla zewnętrzna (kontrolująca <code>i</code>) uruchamia się od 1 do <code>n</code>, a w jej obrębie pętla wewnętrzna przechodzi przez wartości <code>j</code> od 1 do <code>n</code>. Wynik jest identyczny – tablica mnożenia rozmiaru <code>n x n</code>.</p>
            <h4 id="na-co-uważać-przy-zagnieżdżonych-pętlach">Na co uważać przy zagnieżdżonych pętlach</h4>
            <ul>
                <li>Zagnieżdżone pętle mogą prowadzić do <strong>dużej liczby iteracji</strong> i w efekcie do wzrostu złożoności obliczeniowej. Przy dużych wartościach zmiennych kontrolnych może to znacząco wydłużyć działanie programu.</li>
                <li><strong>Czytelność kodu</strong> może ulec pogorszeniu, gdy używane są wielopoziomowe zagnieżdżenia. Dlatego warto stosować czytelne nazwy zmiennych i ewentualnie dzielić kod na mniejsze funkcje pomocnicze.</li>
                <li>Aby uniknąć <strong>niekończących się pętli</strong>, należy zwrócić szczególną uwagę na poprawne zdefiniowanie warunków zakończenia oraz poprawnie pisać inkrementacje lub dekrementacje zmiennych kontrolnych.</li>
                <li>W przypadku pracy z tablicami wielowymiarowymi, istotne jest <strong>poprawne indeksowanie tablic</strong>, by nie wyjść poza zakres, co może prowadzić do trudnych do wykrycia błędów i uszkodzeń pamięci programu.</li>
            </ul>
            <h3 id="continue">Continue</h3>
            <p>Instrukcja <code>continue</code> umożliwia natychmiastowe przejście do następnej iteracji pętli, pomijając pozostałe instrukcje w bieżącym cyklu. Jest ona przydatna, gdy chcemy zignorować pewne przypadki i nie wykonywać dalszego kodu w danej iteracji, ale nie chcemy przerywać całej pętli.</p>
            <p>Przykład użycia <code>continue</code> do wypisania wszystkich parzystych liczb od 0 do n:</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;

int main() {
    int n;
    std::cout &lt;&lt; "Podaj liczbę: " &lt;&lt; std::endl;
    std::cin &gt;&gt; n;

    for (int i = 0; i &lt;= n; i++) {
        if (i % 2 != 0)
            continue;
        std::cout &lt;&lt; i &lt;&lt; std::endl;
    }

    return 0;
}</code></pre>
            </div>
            </p>
            <p>W powyższym kodzie, gdy <code>i</code> jest nieparzyste (<code>i % 2 != 0</code>), instrukcja <code>continue</code> powoduje pominięcie wszystkiego, co jest poniżej w ciele pętli, i przejście do kolejnej iteracji. Dzięki temu wyświetlane są wyłącznie liczby parzyste.</p>
            <h3 id="break">Break</h3>
            <p>Instrukcja <code>break</code> pozwala na zakończenie wykonywania pętli przedwcześnie, nie czekając na spełnienie warunku zakończenia (w przypadku <code>while</code> i <code>for</code>) czy warunku zapisanego w pętli <code>do-while</code>. Może to być przydatne np. wtedy, gdy znaleźliśmy już to, czego szukaliśmy, i dalsze iteracje są zbędne, albo w sytuacji kontrolowania jakichś wyjątkowych stanów.</p>
            <p>Przykład: Wypisz wszystkie liczby od 0 do n lub zakończ pętlę po napotkaniu pierwszej nieparzystej liczby:</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;

int main() {
    int n;
    std::cout &lt;&lt; "Podaj liczbę: " &lt;&lt; std::endl;
    std::cin &gt;&gt; n;

    for (int i = 0; i &lt;= n; i++) {
        if (i % 2 != 0)
            break;
        std::cout &lt;&lt; i &lt;&lt; std::endl;
    }

    return 0;
}</code></pre>
            </div>
            </p>
            <p>W powyższym kodzie pętla zakończy się natychmiast, gdy <code>i</code> przyjmie wartość nieparzystą. Dzięki temu nie będą drukowane kolejne liczby, nawet jeśli do końca zakresu (do <code>n</code>) zostało jeszcze wiele potencjalnych iteracji.</p>
        </article-section>
        <div id="table-of-contents">
            <h2>Spis Treści</h2>
            <ol><a href="#pętle">Pętle</a>
                <ol>
                    <li><a href="#pętla-for">Pętla for</a>
                        <ol>
                            <li><a href="#struktura-pętli-for">Struktura pętli for</a></li>
                            <li><a href="#przykład-wypisanie-wszystkich-parzystych-liczb-od-0-do-n-">Przykład: wypisanie wszystkich parzystych liczb od 0 do n.</a></li>
                            <li><a href="#pętla-for-z-różnymi-typami-danych">Pętla for z różnymi typami danych</a></li>
                        </ol>
                    </li>
                    <li><a href="#pętla-while">Pętla while</a>
                        <ol>
                            <li><a href="#struktura-pętli-while">Struktura pętli while</a></li>
                            <li><a href="#przykład-wypisanie-wszystkich-liczb-od-0-do-n-">Przykład: wypisanie wszystkich liczb od 0 do n.</a></li>
                        </ol>
                    </li>
                    <li><a href="#pętla-do-while">Pętla do-while</a>
                        <ol>
                            <li><a href="#struktura-pętli-do-while">Struktura pętli do-while</a></li>
                            <li><a href="#przykład-prośba-o-podanie-liczby-dodatniej-przez-użytkownika-">Przykład: Prośba o podanie liczby dodatniej przez użytkownika.</a></li>
                        </ol>
                    </li>
                    <li><a href="#pętla-nieskończona">Pętla nieskończona</a></li>
                    <li><a href="#zagnieżdżone-pętle">Zagnieżdżone pętle</a>
                        <ol>
                            <li><a href="#struktura-zagnieżdżonej-pętli">Struktura zagnieżdżonej pętli</a></li>
                            <li><a href="#przykład-wypisanie-tablicy-mnożenia">Przykład: Wypisanie tablicy mnożenia</a></li>
                            <li><a href="#zagnieżdżone-pętle-while">Zagnieżdżone pętle while</a></li>
                            <li><a href="#na-co-uważać-przy-zagnieżdżonych-pętlach">Na co uważać przy zagnieżdżonych pętlach</a></li>
                        </ol>
                    </li>
                    <li><a href="#continue">Continue</a></li>
                    <li><a href="#break">Break</a></li>
                </ol>
            </ol>
            <div id="related-articles">
                <h2>Related Articles</h2>
                <ol>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/01_proces_kompilacji.html">Proces Kompilacji</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/02_preprocesor.html">Preprocesor</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/03_zmienne_i_typy_danych.html">Zmienne i Typy Danych</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/04_interakcja_z_konsola.html">Interakcja z Konsola</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/05_instrukcja_warunkowa.html">Instrukcja Warunkowa</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/06_petle.html">Petle</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/07_liczby_losowe.html">Liczby Losowe</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/08_typ_wyliczeniowy.html">Typ Wyliczeniowy</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/09_funkcje.html">Funkcje</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/10_l_wartosci_r_wartosci.html">L Wartosci R Wartosci</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/11_wskazniki.html">Wskazniki</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/12_tablice.html">Tablice</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/13_napisy.html">Napisy</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/14_operacje_bitowe.html">Operacje Bitowe</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/15_programowanie_obietkowe.html">Programowanie Obietkowe</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/16_dziedziczenie.html">Dziedziczenie</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/17_zaawansowane_wskazniki.html">Zaawansowane Wskazniki</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/18_przeciazanie.html">Przeciazanie</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/19_konwersje.html">Konwersje</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/20_lambdy.html">Lambdy</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/21_szablony.html">Szablony</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/22_wyjatki.html">Wyjatki</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/23_stl.html">Stl</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/24_praca_z_plikami.html">Praca z Plikami</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/25_c_vs_cpp.html">C vs Cpp</a></li>
                </ol>
            </div>
        </div>
    </div>
    <footer>
        <div class="footer-columns">
            <div class="footer-column">
                <img alt="Adam Djellouli Symbol" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/symbol.png" />
            </div>
            <div class="footer-column">
                <h2><a href="https://adamdjellouli.com/core/privacy_policy.html" title="Privacy Policy">Our Privacy Policy</a></h2>
                <p>Thank you for visiting my personal website. All content here is free to use, but please remember to be respectful and avoid any misuse of the site. If you’d like to get in touch, feel free to reach out via my <a href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" title="LinkedIn Profile">LinkedIn profile</a> or connect with me on <a href="https://github.com/djeada" title="GitHub Profile">GitHub</a> if you have technical questions or ideas to share. Wishing you all the best and a fantastic life ahead!</p>
            </div>
            <div class="footer-column">
                <h2>Follow me</h2>
                <ul class="social-media">
                    <li>
                        <a class="fa fa-youtube" href="https://www.youtube.com/channel/UCGPoHTVjMN77wcGknXPHl1Q" target="_blank" title="YouTube">
                        </a>YouTube
                    </li>
                    <li>
                        <a class="fa fa-linkedin" href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" target="_blank" title="LinkedIn">
                        </a>LinkedIn
                    </li>
                    <li>
                        <a class="fa fa-instagram" href="https://www.instagram.com/linuxchallenges/" target="_blank" title="Instagram">
                        </a>Instagram
                    </li>
                    <li>
                        <a class="fa fa-github" href="https://github.com/djeada" title="GitHub">
                        </a>Github
                    </li>
                </ul>
            </div>
        </div>
        <div>
            <p id="copyright">
                © Adam Djellouli. All rights reserved.
            </p>
        </div>
        <script>
            document.getElementById("copyright").innerHTML = "&copy; " + new Date().getFullYear() + " Adam Djellouli. All rights reserved.";
        </script>
        <script src="../../app.js"></script>
    </footer>
    <div id="pdf-spinner-overlay">
        <div class="spinner"></div>
    </div>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-bash.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-cpp.min.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
jax: ["input/TeX", "output/HTML-CSS"],
extensions: ["tex2jax.js"],
"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] },
tex2jax: { inlineMath: [ ["$", "$"] ], displayMath: [ ["$$","$$"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
TeX: { noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } } },
messageStyle: "none"
});
</script>
<script async="" id="MathJax-script" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>

</html>