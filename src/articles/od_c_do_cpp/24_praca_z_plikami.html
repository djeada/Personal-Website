<!DOCTYPE html>

<html lang="pl">
<head>
<script async="" crossorigin="anonymous" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5593122079896089"></script>
<meta charset="utf-8"/>
<title>Praca z plikami</title>
<meta content="ObsÅ‚uga plikÃ³w jest przydatnÄ… umiejÄ™tnoÅ›ciÄ… przy pisaniu aplikacji w C i C++." name="description"/>
<meta content="Adam Djellouli" name="author"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<link crossorigin="" href="https://fonts.googleapis.com" rel="preconnect"/>
<link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.0/themes/prism.min.css" rel="stylesheet"/>
<link href="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/icon.ico" rel="icon"/>
<link href="../../resources/style.css" rel="stylesheet"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
</head>
<body><nav aria-label="Main navigation">
<a class="logo" href="https://adamdjellouli.com">
<img alt="Adam Djellouli - Home Page Logo" id="logo-image" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/logo.PNG"/>
</a>
<input aria-label="Toggle navigation menu" id="navbar-toggle" type="checkbox"/>
<ul aria-labelledby="navbar-toggle" role="menu">
<li role="menuitem">
<a href="../../index.html" title="Go to Home Page"> Home </a>
</li>
<li role="menuitem">
<a class="active" href="../../core/blog.html" title="Read Adam Djellouli Blog on Programming and Technology"> Blog </a>
</li>
<li role="menuitem">
<a href="../../core/tools.html" title="Discover Tools Created by Adam Djellouli"> Tools </a>
</li>
<li role="menuitem">
<a href="../../core/projects.html" title="Explore Projects Developed by Adam Djellouli"> Projects </a>
</li>
<li role="menuitem">
<a href="../../core/resume.html" title="View Adam Djellouli Professional Resume"> Resume </a>
</li>
<li>
<script async="" src="https://cse.google.com/cse.js?cx=8160ef9bb935f4f68"></script>
<div class="gcse-search"></div>
</li>
<li>
<button aria-label="Toggle dark mode" id="dark-mode-button"></button>
</li>
</ul>
</nav>
<div id="article-wrapper"><article-section id="article-body">
<p style="text-align: right;"><i>Last modified: December 25, 2025</i></p>
<p style="text-align: right;"><i>This article is written in: ğŸ‡µğŸ‡±</i></p>
<h2 id="praca-z-plikami">Praca z plikami</h2>
<p>ObsÅ‚uga plikÃ³w jest przydatnÄ… umiejÄ™tnoÅ›ciÄ… przy pisaniu aplikacji w C i C++. Praca z plikami pozwala na trwaÅ‚e przechowywanie danych, ktÃ³re mogÄ… byÄ‡ pÃ³Åºniej odczytywane i przetwarzane przez program. DziÄ™ki temu aplikacje mogÄ… zachowywaÄ‡ stan miÄ™dzy uruchomieniami, przechowywaÄ‡ konfiguracje, logi, a takÅ¼e przetwarzaÄ‡ duÅ¼e iloÅ›ci danych wejÅ›ciowych i wyjÅ›ciowych.</p>
<p>ZarÃ³wno C, jak i C++ oferujÄ… bogaty zestaw funkcji oraz klas do pracy z plikami, co umoÅ¼liwia programistom efektywne zarzÄ…dzanie danymi. W zaleÅ¼noÅ›ci od potrzeb aplikacji, moÅ¼na wybraÄ‡ odpowiednie narzÄ™dzia i metody do otwierania, czytania, zapisywania oraz zamykania plikÃ³w. PoniÅ¼ej przedstawione zostanÄ… podstawowe operacje zwiÄ…zane z obsÅ‚ugÄ… plikÃ³w w obu jÄ™zykach, wraz z przykÅ‚adami kodu i omÃ³wieniem najwaÅ¼niejszych funkcji.</p>
<h3 id="praca-z-plikami-w-c">Praca z plikami w C</h3>
<p>W jÄ™zyku C obsÅ‚uga plikÃ³w odbywa siÄ™ za pomocÄ… funkcji z biblioteki <code>&lt;stdio.h&gt;</code>. Ta biblioteka dostarcza zestaw funkcji, ktÃ³re umoÅ¼liwiajÄ… otwieranie, czytanie, zapisywanie oraz zamykanie plikÃ³w. DziÄ™ki nim programiÅ›ci mogÄ… Å‚atwo manipulowaÄ‡ danymi zapisanymi na dysku, co jest niezbÄ™dne w wielu zastosowaniach, takich jak przetwarzanie danych, logowanie informacji czy tworzenie plikÃ³w konfiguracyjnych.</p>
<p>NajwaÅ¼niejsze funkcje do tej operacji to <code>fopen</code>, <code>fclose</code>, <code>fread</code>, <code>fwrite</code>, <code>fprintf</code>, <code>fscanf</code>, <code>fgetc</code>, i <code>fputc</code>. KaÅ¼da z nich peÅ‚ni specyficznÄ… rolÄ™ w procesie zarzÄ…dzania plikami, umoÅ¼liwiajÄ…c rÃ³Å¼norodne operacje na danych. PoniÅ¼ej omÃ³wimy te funkcje szczegÃ³Å‚owo, zaczynajÄ…c od otwierania plikÃ³w.</p>
<h4 id="otwieranie-plikÃ³w">Otwieranie plikÃ³w</h4>
<p>Aby rozpoczÄ…Ä‡ pracÄ™ z plikiem, naleÅ¼y go najpierw otworzyÄ‡. W jÄ™zyku C sÅ‚uÅ¼y do tego funkcja <code>fopen</code>, ktÃ³ra zwraca wskaÅºnik do pliku. WskaÅºnik ten jest niezbÄ™dny do dalszych operacji na pliku, takich jak czytanie czy zapisywanie danych. Proces otwierania pliku wymaga podania nazwy pliku oraz trybu, w jakim ma byÄ‡ otwarty.</p>
<p><div><pre><code class="language-clike">#include &lt;stdio.h&gt;

int main() {
    FILE *f = fopen("plik.txt", "r");
    // ... operacje na pliku ...
    fclose(f);
}</code></pre></div></p>
<p>Argumenty <code>fopen</code> to nazwa pliku oraz tryb otwarcia:</p>
<ul>
<li><code>"r"</code>: odczyt â€“ otwiera plik do odczytu. Plik musi istnieÄ‡.</li>
<li><code>"w"</code>: zapis â€“ otwiera plik do zapisu. Tworzy nowy plik lub nadpisuje istniejÄ…cy.</li>
<li><code>"a"</code>: dopisanie do koÅ„ca pliku â€“ otwiera plik do dopisywania danych na koÅ„cu. JeÅ›li plik nie istnieje, zostaje utworzony.</li>
<li><code>"rb"</code>, <code>"wb"</code>, <code>"ab"</code>: odpowiednie tryby binarne â€“ uÅ¼ywane do otwierania plikÃ³w w trybie binarnym, co jest przydatne przy pracy z plikami nie-tekstowymi.</li>
</ul>
<p>WybÃ³r odpowiedniego trybu otwarcia pliku jest istotny, poniewaÅ¼ determinuje sposÃ³b, w jaki dane bÄ™dÄ… odczytywane lub zapisywane. NieprawidÅ‚owy tryb moÅ¼e prowadziÄ‡ do bÅ‚Ä™dÃ³w, takich jak utrata danych czy nieudane prÃ³by otwariaÅ„ia pliku.</p>
<h4 id="czytanie-z-pliku">Czytanie z pliku</h4>
<p>Po otwarciu pliku w trybie odczytu, moÅ¼na rozpoczÄ…Ä‡ proces czytania danych z niego. Jednym ze sposobÃ³w czytania z pliku jest uÅ¼ycie funkcji <code>fgetc</code>, ktÃ³ra odczytuje pojedynczy znak z pliku. PoniÅ¼szy przykÅ‚ad pokazuje, jak moÅ¼na odczytywaÄ‡ plik znak po znaku, a nastÄ™pnie wyÅ›wietlaÄ‡ jego zawartoÅ›Ä‡ na standardowym wyjÅ›ciu.</p>
<p><div><pre><code class="language-clike">#include &lt;stdio.h&gt;

int main() {
    FILE *f = fopen("plik.txt", "r");
    char c;
    
    while ((c = fgetc(f)) != EOF) {
        putchar(c);
    }

    fclose(f);
}</code></pre></div></p>
<p>PÄ™tla <code>while</code> kontynuuje odczytywanie znakÃ³w z pliku aÅ¼ do napotkania koÅ„ca pliku (<code>EOF</code>). Funkcja <code>putchar</code> sÅ‚uÅ¼y do wyÅ›wietlania kaÅ¼dego odczytanego znaku na standardowym wyjÅ›ciu, co pozwala na przeglÄ…danie zawartoÅ›ci pliku w konsoli.</p>
<h4 id="zapisywanie-do-pliku">Zapisywanie do pliku</h4>
<p>Zapisywanie danych do pliku jest rÃ³wnie waÅ¼nÄ… operacjÄ…. W jÄ™zyku C moÅ¼na to zrobiÄ‡ za pomocÄ… funkcji <code>fputc</code>, ktÃ³ra zapisuje pojedynczy znak do pliku. Alternatywnie, dla bardziej zÅ‚oÅ¼onych operacji, moÅ¼na uÅ¼yÄ‡ <code>fprintf</code>, ktÃ³ra umoÅ¼liwia formatowane zapisywanie danych, podobnie jak funkcja <code>printf</code>.</p>
<p><div><pre><code class="language-clike">#include &lt;stdio.h&gt;

int main() {
    FILE *f = fopen("wyjscie.txt", "w");
    
    fputc('H', f);
    fputc('i', f);
    
    fclose(f);
}</code></pre></div></p>
<p>W powyÅ¼szym przykÅ‚adzie otwieramy plik <code>wyjscie.txt</code> w trybie zapisu (<code>"w"</code>) i zapisujemy do niego dwa znaki: <code>H</code> oraz <code>i</code>. Po zakoÅ„czeniu operacji waÅ¼ne jest, aby zamknÄ…Ä‡ plik, co gwarantuje zapisanie wszystkich danych i zwolnienie zasobÃ³w systemowych.</p>
<p>Lub uÅ¼yj <code>fprintf</code> dla formatowanego wyjÅ›cia:</p>
<p><div><pre><code class="language-clike">FILE *f = fopen("wyjscie.txt", "w");
fprintf(f, "Witaj, %s!", "Å›wiecie");
fclose(f);</code></pre></div></p>
<p>Funkcja <code>fprintf</code> pozwala na zapisanie sformatowanego tekstu do pliku, co jest szczegÃ³lnie przydatne przy generowaniu bardziej zÅ‚oÅ¼onych treÅ›ci, takich jak raporty czy pliki konfiguracyjne.</p>
<h4 id="sprawdzanie-bÅ‚Ä™dÃ³w">Sprawdzanie bÅ‚Ä™dÃ³w</h4>
<p>Przy pracy z plikami zawsze istnieje ryzyko wystÄ…pienia bÅ‚Ä™dÃ³w, takich jak brak dostÄ™pu do pliku, nieistniejÄ…cy plik czy problemy z dyskiem. Dlatego zawsze warto sprawdziÄ‡, czy otwarie pliku powiodÅ‚o siÄ™ przed przystÄ…pieniem do dalszych operacji.</p>
<p><div><pre><code class="language-clike">FILE *f = fopen("plik.txt", "r");
if (!f) {
    perror("BÅ‚Ä…d podczas otwierania pliku");
    return 1;
}</code></pre></div></p>
<p>Funkcja <code>perror</code> wyÅ›wietla komunikat o bÅ‚Ä™dzie zwiÄ…zanym z ostatniÄ… operacjÄ… systemowÄ…, co pomaga w diagnozowaniu problemÃ³w podczas pracy z plikami. DziÄ™ki temu program moÅ¼e odpowiednio zareagowaÄ‡ na bÅ‚Ä™dy, na przykÅ‚ad poprzez zakoÅ„czenie dziaÅ‚ania lub prÃ³bÄ™ ponownego otwariaÅ„ia pliku.</p>
<p>W jÄ™zyku C obsÅ‚uga plikÃ³w opiera siÄ™ na wskaÅºnikach do plikÃ³w i zestawie funkcji z <code>&lt;stdio.h&gt;</code>. CzÄ™sto uÅ¼ywanÄ… funkcjÄ… jest <code>fopen</code>, ktÃ³ra zwraca wskaÅºnik do pliku, a takÅ¼e <code>fclose</code>, ktÃ³ra zamyka plik. PamiÄ™taj, aby zawsze zamykaÄ‡ pliki po zakoÅ„czeniu pracy, co pozwala na prawidÅ‚owe zarzÄ…dzanie zasobami systemowymi i unikanie problemÃ³w z dostÄ™pem do plikÃ³w przez inne procesy.</p>
<h3 id="praca-z-plikami-w-c-">Praca z plikami w C++</h3>
<p>ObsÅ‚uga plikÃ³w w C++ odbywa siÄ™ gÅ‚Ã³wnie za pomocÄ… klas <code>ifstream</code>, <code>ofstream</code> i <code>fstream</code> z biblioteki <code>&lt;fstream&gt;</code>. Te klasy sÄ… czÄ™Å›ciÄ… standardowej biblioteki C++ i oferujÄ… obiektowo-zorientowane podejÅ›cie do pracy z plikami, co uÅ‚atwia zarzÄ…dzanie zasobami i integracjÄ™ z resztÄ… kodu.</p>
<p>W przeciwieÅ„stwie do C, gdzie operacje na plikach sÄ… funkcjami proceduralnymi, C++ pozwala na uÅ¼ywanie strumieni, ktÃ³re moÅ¼na Å‚atwo Å‚Ä…czyÄ‡ i manipulowaÄ‡ nimi w bardziej intuicyjny sposÃ³b. DziÄ™ki temu programiÅ›ci mogÄ… pisaÄ‡ bardziej czytelny i zorganizowany kod, co jest szczegÃ³lnie waÅ¼ne w wiÄ™kszych projektach.</p>
<h4 id="otwieranie-plikÃ³w">Otwieranie plikÃ³w</h4>
<p>Aby rozpoczÄ…Ä‡ pracÄ™ z plikiem w C++, naleÅ¼y stworzyÄ‡ obiekt jednej z klas <code>ifstream</code> (do czytania), <code>ofstream</code> (do pisania) lub <code>fstream</code> (do obu operacji). Podczas tworzenia obiektu moÅ¼na od razu podaÄ‡ nazwÄ™ pliku oraz tryb otwarcia, co upraszcza proces inicjalizacji.</p>
<p><div><pre><code class="language-clike">#include &lt;fstream&gt;

int main() {
  std::ifstream plik_wejsciowy("plik.txt");
  std::ofstream plik_wyjsciowy("wyjscie.txt");
}</code></pre></div></p>
<p>W powyÅ¼szym przykÅ‚adzie tworzymy dwa obiekty: <code>plik_wejsciowy</code> do odczytu z pliku <code>plik.txt</code> oraz <code>plik_wyjsciowy</code> do zapisu do pliku <code>wyjscie.txt</code>. DziÄ™ki temu moÅ¼emy Å‚atwo zarzÄ…dzaÄ‡ rÃ³Å¼nymi operacjami na plikach w naszym programie.</p>
<h4 id="czytanie-z-pliku">Czytanie z pliku</h4>
<p>Do czytania z pliku w C++ czÄ™sto uÅ¼ywa siÄ™ pÄ™tli <code>while</code> w poÅ‚Ä…czeniu z metodÄ… <code>getline()</code>, ktÃ³ra odczytuje kolejne linie z pliku. Jest to wygodny sposÃ³b na przetwarzanie danych tekstowych linia po linii, co jest czÄ™sto potrzebne w aplikacjach przetwarzajÄ…cych duÅ¼e pliki tekstowe.</p>
<p><div><pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;

int main() {
  std::ifstream plik("plik.txt");
  std::string linia;
  
  while (std::getline(plik, linia)) {
    std::cout &lt;&lt; linia &lt;&lt; std::endl;
  }

  plik.close();
}</code></pre></div></p>
<p>W tym przykÅ‚adzie otwieramy plik <code>plik.txt</code> do odczytu, a nastÄ™pnie w pÄ™tli <code>while</code> odczytujemy kaÅ¼dÄ… liniÄ™ i wyÅ›wietlamy jÄ… na standardowym wyjÅ›ciu. Po zakoÅ„czeniu operacji zamykamy plik, co jest dobrÄ… praktykÄ… zapewniajÄ…cÄ… prawidÅ‚owe zarzÄ…dzanie zasobami.</p>
<h4 id="zapisywanie-do-pliku">Zapisywanie do pliku</h4>
<p>Zapisywanie danych do pliku w C++ jest rÃ³wnie proste jak odczytywanie. MoÅ¼emy uÅ¼yÄ‡ operatora <code>&lt;&lt;</code>, ktÃ³ry umoÅ¼liwia Å‚atwe i intuicyjne zapisywanie danych do strumienia wyjÅ›ciowego.</p>
<p><div><pre><code class="language-clike">#include &lt;fstream&gt;

int main() {
  std::ofstream plik("wyjscie.txt");
  
  plik &lt;&lt; "Witaj, Å›wiecie!" &lt;&lt; std::endl;
  
  plik.close();
}</code></pre></div></p>
<p>W tym przykÅ‚adzie otwieramy plik <code>wyjscie.txt</code> w trybie zapisu i zapisujemy do niego tekst <code>"Witaj, Å›wiecie!"</code>. Operator <code>&lt;&lt;</code> automatycznie konwertuje dane do formatu odpowiedniego dla pliku, co upraszcza proces zapisywania danych.</p>
<h4 id="sprawdzanie-bÅ‚Ä™dÃ³w">Sprawdzanie bÅ‚Ä™dÃ³w</h4>
<p>Podobnie jak w jÄ™zyku C, w C++ rÃ³wnieÅ¼ warto sprawdziÄ‡, czy otwarie pliku powiodÅ‚o siÄ™ przed przystÄ…pieniem do dalszych operacji. Pozwala to na odpowiednie reagowanie na ewentualne problemy, takie jak brak dostÄ™pu do pliku czy bÅ‚Ä™dy dysku.</p>
<p><div><pre><code class="language-clike">#include &lt;fstream&gt;
#include &lt;iostream&gt;

int main() {
  std::ifstream plik("plik.txt");
  
  if (!plik) {
    std::cerr &lt;&lt; "BÅ‚Ä…d podczas otwierania pliku!" &lt;&lt; std::endl;
    return 1;
  }
  
  // reszta kodu

  plik.close();
}</code></pre></div></p>
<p>W tym przykÅ‚adzie sprawdzamy, czy plik <code>plik.txt</code> zostaÅ‚ poprawnie otwarty. JeÅ›li nie, wyÅ›wietlamy komunikat o bÅ‚Ä™dzie na standardowym wyjÅ›ciu bÅ‚Ä™dÃ³w (<code>std::cerr</code>) i koÅ„czymy dziaÅ‚anie programu z kodem bÅ‚Ä™du <code>1</code>. DziÄ™ki temu unikamy prÃ³b operacji na nieotwartym pliku, co mogÅ‚oby prowadziÄ‡ do nieprzewidywalnych zachowaÅ„ programu.</p>
<h4 id="binary-mode">Binary Mode</h4>
<p>DomyÅ›lnie pliki sÄ… otwierane w trybie tekstowym, co oznacza, Å¼e dane sÄ… interpretowane jako tekst. Jednak w niektÃ³rych przypadkach, zwÅ‚aszcza przy pracy z plikami binarnymi, konieczne jest otwarie pliku w trybie binarnym. W C++ moÅ¼na to zrobiÄ‡, dodajÄ…c flagÄ™ <code>std::ios::binary</code> jako drugi argument podczas otwierania pliku.</p>
<p><div><pre><code class="language-clike">std::ofstream binarny_plik("plik.bin", std::ios::binary);</code></pre></div></p>
<p>Otwieranie pliku w trybie binarnym jest niezbÄ™dne, gdy chcemy pracowaÄ‡ z danymi nie-tekstowymi, takimi jak obrazy, pliki dÅºwiÄ™kowe czy inne formaty binarne. Tryb binarny zapewnia, Å¼e dane sÄ… zapisywane i odczytywane dokÅ‚adnie w takiej formie, w jakiej sÄ… przechowywane, bez Å¼adnych modyfikacji czy konwersji.</p>
<p>ObsÅ‚uga plikÃ³w w C++ jest prosta i intuicyjna dziÄ™ki zastosowaniu klas <code>ifstream</code>, <code>ofstream</code> i <code>fstream</code>. Te klasy umoÅ¼liwiajÄ… odpowiednio czytanie, zapisywanie lub wykonywanie obu tych operacji na plikach. Nie zapominaj teÅ¼ o zamykaniu plikÃ³w po zakoÅ„czeniu pracy, co zapewnia prawidÅ‚owe zarzÄ…dzanie zasobami systemowymi i unikanie potencjalnych problemÃ³w z dostÄ™pem do plikÃ³w przez inne procesy.</p>
<h3 id="gwarancja-bezpiecznego-zamkniÄ™cia-pliku">Gwarancja bezpiecznego zamkniÄ™cia pliku</h3>
<p>PrawidÅ‚owe zarzÄ…dzanie zasobami, takimi jak pliki, jest waÅ¼ne dla stabilnoÅ›ci i wydajnoÅ›ci programu. W jÄ™zykach programowania, ktÃ³re nie majÄ… wbudowanego zarzÄ…dzania pamiÄ™ciÄ…, jak C++, bÅ‚Ä™dy w obsÅ‚udze zasobÃ³w mogÄ… prowadziÄ‡ do wyciekÃ³w pamiÄ™ci, bÅ‚Ä™dÃ³w dostÄ™pu lub blokowania zasobÃ³w. Dlatego waÅ¼ne jest, aby zawsze dbaÄ‡ o zamkniÄ™cie plikÃ³w po zakoÅ„czeniu ich uÅ¼ywania oraz korzystaÄ‡ z technik programistycznych, ktÃ³re zapewniajÄ… bezpieczeÅ„stwo i niezawodnoÅ›Ä‡ w zarzÄ…dzaniu zasobami.</p>
<h4 id="dlaczego-bezpieczne-zamykanie-pliku-jest-waÅ¼ne-">Dlaczego bezpieczne zamykanie pliku jest waÅ¼ne?</h4>
<p>Bezpieczne zamykanie pliku jest istotne z kilku powodÃ³w:</p>
<ul>
<li>Zamykanie plikÃ³w zapewnia <strong>integralnoÅ›Ä‡ danych</strong>, poniewaÅ¼ gwarantuje, Å¼e wszystkie zapisane dane zostanÄ… prawidÅ‚owo zapisane na dysku. NieprawidÅ‚owo zamkniÄ™ty plik moÅ¼e prowadziÄ‡ do utraty danych lub ich uszkodzenia, co jest szczegÃ³lnie istotne w przypadku krytycznych informacji.</li>
<li>Proces ten pozwala na <strong>zwolnienie zasobÃ³w systemowych</strong>, takich jak uchwyty plikÃ³w. Brak zamykania plikÃ³w moÅ¼e doprowadziÄ‡ do osiÄ…gniÄ™cia limitu otwartych plikÃ³w, uniemoÅ¼liwiajÄ…c otwieranie nowych plikÃ³w przez programy.</li>
<li>Zamykanie plikÃ³w eliminuje <strong>blokady plikÃ³w</strong>, ktÃ³re mogÄ… ograniczaÄ‡ dostÄ™p dla innych aplikacji. Otwarte pliki czÄ™sto blokujÄ… moÅ¼liwoÅ›Ä‡ modyfikacji przez inne programy, co moÅ¼e prowadziÄ‡ do bÅ‚Ä™dÃ³w.</li>
<li>W niektÃ³rych przypadkach zamykanie plikÃ³w pozwala na <strong>zwalnianie pamiÄ™ci</strong>, poniewaÅ¼ otwarte pliki mogÄ… zajmowaÄ‡ zasoby pamiÄ™ciowe. NieprawidÅ‚owe zarzÄ…dzanie tymi plikami moÅ¼e prowadziÄ‡ do wyciekÃ³w pamiÄ™ci, co w dÅ‚uÅ¼szej perspektywie moÅ¼e skutkowaÄ‡ awariami aplikacji.</li>
</ul>
<p>WaÅ¼ne jest, aby programiÅ›ci dbali o prawidÅ‚owe zamykanie plikÃ³w oraz stosowali techniki zapewniajÄ…ce, Å¼e pliki zostanÄ… zamkniÄ™te nawet w przypadku wystÄ…pienia bÅ‚Ä™dÃ³w czy wyjÄ…tkÃ³w.</p>
<h3 id="raii-w-c-">RAII w C++</h3>
<p><strong>RAII (Resource Acquisition Is Initialization)</strong> to wzorzec projektowy i zarazem podejÅ›cie, w ktÃ³rym przejÄ™cie zasobÃ³w (np. pamiÄ™ci, gniazda sieciowego czy uchwytu do pliku) nastÄ™puje podczas inicjalizacji obiektu, a zwolnienie tych zasobÃ³w jest gwarantowane w jego destruktorze. DziÄ™ki temu:</p>
<ol>
<li><strong>Obiekt jest uznawany za w peÅ‚ni zainicjalizowany dopiero wtedy, gdy z powodzeniem uda siÄ™ nabyÄ‡ wszystkie potrzebne zasoby.</strong> JeÅ¼eli pozyskanie ktÃ³regokolwiek z nich siÄ™ nie powiedzie (np. nie uda siÄ™ otworzyÄ‡ pliku czy nawiÄ…zaÄ‡ poÅ‚Ä…czenia sieciowego), konstruktor moÅ¼e zgÅ‚osiÄ‡ bÅ‚Ä…d poprzez wyjÄ…tek, a obiekt nie zostanie w peÅ‚ni utworzony.  </li>
<li><strong>Zwalnianie zasobÃ³w odbywa siÄ™ automatycznie w destruktorze</strong>, gdy obiekt wychodzi z zasiÄ™gu (scope) â€“ na przykÅ‚ad po zakoÅ„czeniu funkcji lub bloku, w ktÃ³rym zostaÅ‚ zadeklarowany.  </li>
<li><strong>Nie ma potrzeby wywoÅ‚ywania jawnych operacji zwalniania</strong> (np. zamykania pliku czy zwalniania pamiÄ™ci), co znaczÄ…co minimalizuje ryzyko wyciekÃ³w zasobÃ³w.  </li>
</ol>
<p>PrzykÅ‚adowymi zasobami, ktÃ³re czÄ™sto sÄ… â€opakowywaneâ€ w obiekty RAII, mogÄ… byÄ‡:</p>
<ul>
<li><strong>PamiÄ™Ä‡</strong> (zazwyczaj zarzÄ…dzana przy pomocy inteligentnych wskaÅºnikÃ³w, takich jak <code>std::unique_ptr</code> czy <code>std::shared_ptr</code> w C++),  </li>
<li><strong>Gniazda sieciowe (sockets)</strong> do komunikacji przez sieÄ‡,  </li>
<li><strong>Uchwyty do plikÃ³w</strong> (otwarte strumienie wejÅ›cia/wyjÅ›cia),  </li>
<li><strong>Blokady (locki) i muteksy</strong> w Å›rodowiskach wielowÄ…tkowych,  </li>
<li><strong>Dowolne inne zasoby systemowe</strong>, takie jak uchwyty do baz danych czy identyfikatory procesÃ³w.</li>
</ul>
<p>KluczowÄ… zaletÄ… RAII jest to, Å¼e <strong>dopÃ³ki obiekt istnieje, zasÃ³b pozostaje w uÅ¼ytecznym stanie</strong>, a gdy obiekt przestaje istnieÄ‡, zasÃ³b jest zwalniany. PodejÅ›cie to Å›ciÅ›le wspÃ³Å‚gra z mechanizmem wyjÄ…tkÃ³w w C++ â€“ jeÅ›li nie uda siÄ™ pozyskaÄ‡ zasobu, konstruktor zgÅ‚asza wyjÄ…tek, a wszystkie wczeÅ›niej pobrane zasoby sÄ… natychmiast zwalniane w ramach stack unwinding (cofania stosu wywoÅ‚aÅ„).</p>
<p><strong>PrzykÅ‚ad z klasÄ… <code>File</code></strong></p>
<p>Aby zilustrowaÄ‡ ideÄ™ RAII na prostym przykÅ‚adzie, moÅ¼na zaprezentowaÄ‡ klasÄ™ <code>File</code>, ktÃ³ra odpowiada za otwieranie i zamykanie pliku:</p>
<p><div><pre><code class="language-clike">#include &lt;fstream&gt;
#include &lt;stdexcept&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;

class File {
 public:
  File(const std::string&amp; filename, const std::string&amp; mode = "r") 
    : m_filename(filename) {
      if (mode == "r") {
          m_file.open(filename, std::ios::in);
      } else if (mode == "w") {
          m_file.open(filename, std::ios::out);
      } else if (mode == "a") {
          m_file.open(filename, std::ios::app);
      } else {
          throw std::invalid_argument("Nieznany tryb otwarcia pliku");
      }

      if (!m_file.is_open()) {
          throw std::runtime_error("Nie moÅ¼na otworzyÄ‡ pliku");
      }
  }

  ~File() {
    if (m_file.is_open()) {
      m_file.close();
    }
  }

  std::fstream&amp; stream() {
    return m_file;
  }

 private:
  std::string m_filename;
  std::fstream m_file;
};

int main() {
  try {
      File file("plik.txt", "r");
      char znak;
      while (file.stream().get(znak)) {
        std::cout &lt;&lt; znak;
      }
  } catch (const std::exception&amp; e) {
      std::cerr &lt;&lt; "BÅ‚Ä…d: " &lt;&lt; e.what() &lt;&lt; std::endl;
  }

  return 0;
}</code></pre></div></p>
<ol>
<li><strong>Konstruktor</strong> prÃ³buje otworzyÄ‡ plik w zadanym trybie. JeÅ›li wskazany tryb jest niepoprawny, zgÅ‚asza wyjÄ…tek <code>std::invalid_argument</code>. W przypadku nieudanego otwarcia pliku rzuca <code>std::runtime_error</code>.  </li>
<li><strong>Obiekt</strong> bÄ™dzie uznany za w peÅ‚ni zainicjalizowany wyÅ‚Ä…cznie wÃ³wczas, gdy uda siÄ™ skutecznie otworzyÄ‡ plik. Gdyby pojawiÅ‚ siÄ™ bÅ‚Ä…d, konstrukcja obiektu zostanie przerwana, a kod w <code>main</code> moÅ¼e przechwyciÄ‡ wyjÄ…tek i odpowiednio na niego zareagowaÄ‡.  </li>
<li><strong>Destruktor</strong> sprawdza, czy plik wciÄ…Å¼ jest otwarty, i zamyka go, gdy obiekt wyjdzie z zasiÄ™gu. Ma to miejsce zarÃ³wno przy normalnym zakoÅ„czeniu funkcji, jak i w przypadku wyjÄ…tku. DziÄ™ki temu programista nie musi pamiÄ™taÄ‡ o rÄ™cznym zamykaniu pliku.  </li>
<li>Metoda <code>stream()</code> zwraca referencjÄ™ do strumienia <code>std::fstream</code>, co umoÅ¼liwia czytanie i pisanie do pliku za pomocÄ… dostÄ™pnych w C++ operacji na strumieniach.</li>
</ol>
<h4 id="raii-a-wyjÄ…tki">RAII a wyjÄ…tki</h4>
<p>RAII i obsÅ‚uga wyjÄ…tkÃ³w w C++ stanowiÄ… spÃ³jny mechanizm. JeÅ›li konstruktor obiektu nie jest w stanie pozyskaÄ‡ wszystkich zasobÃ³w (na przykÅ‚ad plik nie moÅ¼e zostaÄ‡ otwarty, brakuje pamiÄ™ci lub nie udaÅ‚o siÄ™ nawiÄ…zaÄ‡ poÅ‚Ä…czenia sieciowego), to wyjÄ…tek zgÅ‚oszony w konstruktorze zapewnia:</p>
<ul>
<li><strong>Automatyczne wycofanie</strong> juÅ¼ zarezerwowanych zasobÃ³w (jeÅ›li zdÄ…Å¼ono je zainicjalizowaÄ‡ przed wystÄ…pieniem bÅ‚Ä™du).  </li>
<li><strong>Brak wyciekÃ³w</strong>: obiekt â€nie powstajeâ€ w niekompletnym stanie, wiÄ™c nie pozostaje w pamiÄ™ci.  </li>
<li><strong>ÅatwiejszÄ… kontrolÄ™ logiki bÅ‚Ä™dÃ³w</strong>: tam, gdzie tworzymy obiekt, moÅ¼emy uchwyciÄ‡ wyjÄ…tek i podjÄ…Ä‡ decyzjÄ™, co zrobiÄ‡ dalej (np. przerwaÄ‡ dziaÅ‚anie programu, wyÅ›wietliÄ‡ komunikat, sprÃ³bowaÄ‡ innej Å›cieÅ¼ki, itp.).</li>
</ul>
<h4 id="krytyka-i-praktyczne-wskazÃ³wki">Krytyka i praktyczne wskazÃ³wki</h4>
<p>ChociaÅ¼ RAII jest bardzo pomocne, czasem krytykuje siÄ™ je za to, Å¼e:</p>
<ol>
<li><strong>Wszystkie scenariusze obsÅ‚ugi bÅ‚Ä™du mogÄ… trafiaÄ‡ do konstruktorÃ³w i destruktorÃ³w</strong>, co bywa trudne do rozbudowanej personalizacji. W niektÃ³rych przypadkach chcemy np. po nieudanej prÃ³bie otwarcia pliku sprÃ³bowaÄ‡ ponownie po kilku sekundach, w innych â€“ zapisaÄ‡ komunikat do dziennika zdarzeÅ„ lub caÅ‚kowicie zakoÅ„czyÄ‡ dziaÅ‚anie programu.  </li>
<li><strong>Zbyt duÅ¼e obciÄ…Å¼enie logikÄ… bÅ‚Ä™dÃ³w</strong> wewnÄ…trz klasy moÅ¼e prowadziÄ‡ do zbytniej komplikacji. Zamiast ograniczaÄ‡ siÄ™ do prostego â€otwÃ³rz plik â†’ w razie niepowodzenia rzuÄ‡ wyjÄ…tekâ€, moÅ¼emy potrzebowaÄ‡ bardziej zÅ‚oÅ¼onych Å›cieÅ¼ek decyzyjnych (np. warunkowe retry, praca w trybie awaryjnym, przeÅ‚Ä…czenie na inny plik itd.).  </li>
<li><strong>W niektÃ³rych sytuacjach</strong> konieczna jest bardziej rozproszona obsÅ‚uga zasobÃ³w â€“ np. kiedy Å¼ywotnoÅ›Ä‡ zasobu nie jest Å›ciÅ›le powiÄ…zana z Å¼ywotnoÅ›ciÄ… pojedynczego obiektu (moÅ¼emy mieÄ‡ duÅ¼y system, w ktÃ³rym zasÃ³b jest wspÃ³Å‚dzielony miÄ™dzy wieloma komponentami). Wtedy konstrukcja typu RAII bywa niewystarczajÄ…ca lub nadmiernie skomplikowana do utrzymania.</li>
</ol>
<p>W praktycznych projektach czÄ™sto stosuje siÄ™ RAII do tych zasobÃ³w, ktÃ³re sÄ… wyraÅºnie powiÄ…zane z czasem Å¼ycia obiektu i nie wymagajÄ… skomplikowanej logiki w sytuacjach awaryjnych. JeÅ›li jednak potrzeby aplikacji wykraczajÄ… poza standardowy â€otwÃ³rz-wykorzystaj-zamknijâ€, naleÅ¼y rozwaÅ¼yÄ‡ uzupeÅ‚nienie RAII o inny mechanizm obsÅ‚ugi bÅ‚Ä™dÃ³w (np. dedykowane metody zarzÄ…dzania pewnymi zasobami lub rozbudowany system odroczonego przywracania/zwalniania zasobu).</p>
</article-section><div id="table-of-contents"><h2>Spis TreÅ›ci</h2><ol><a href="#praca-z-plikami">Praca z plikami</a><ol><li><a href="#praca-z-plikami-w-c">Praca z plikami w C</a><ol><li><a href="#otwieranie-plikÃ³w">Otwieranie plikÃ³w</a></li><li><a href="#czytanie-z-pliku">Czytanie z pliku</a></li><li><a href="#zapisywanie-do-pliku">Zapisywanie do pliku</a></li><li><a href="#sprawdzanie-bÅ‚Ä™dÃ³w">Sprawdzanie bÅ‚Ä™dÃ³w</a></li></ol></li><li><a href="#praca-z-plikami-w-c-">Praca z plikami w C++</a><ol><li><a href="#otwieranie-plikÃ³w">Otwieranie plikÃ³w</a></li><li><a href="#czytanie-z-pliku">Czytanie z pliku</a></li><li><a href="#zapisywanie-do-pliku">Zapisywanie do pliku</a></li><li><a href="#sprawdzanie-bÅ‚Ä™dÃ³w">Sprawdzanie bÅ‚Ä™dÃ³w</a></li><li><a href="#binary-mode">Binary Mode</a></li></ol></li><li><a href="#gwarancja-bezpiecznego-zamkniÄ™cia-pliku">Gwarancja bezpiecznego zamkniÄ™cia pliku</a><ol><li><a href="#dlaczego-bezpieczne-zamykanie-pliku-jest-waÅ¼ne-">Dlaczego bezpieczne zamykanie pliku jest waÅ¼ne?</a></li></ol></li><li><a href="#raii-w-c-">RAII w C++</a><ol><li><a href="#raii-a-wyjÄ…tki">RAII a wyjÄ…tki</a></li><li><a href="#krytyka-i-praktyczne-wskazÃ³wki">Krytyka i praktyczne wskazÃ³wki</a></li></ol></li></ol></ol><div id="related-articles"><h2>Related Articles</h2><ol><li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/01_proces_kompilacji.html">Proces Kompilacji</a></li><li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/02_preprocesor.html">Preprocesor</a></li><li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/03_zmienne_i_typy_danych.html">Zmienne i Typy Danych</a></li><li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/04_interakcja_z_konsola.html">Interakcja z Konsola</a></li><li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/05_instrukcja_warunkowa.html">Instrukcja Warunkowa</a></li><li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/06_petle.html">Petle</a></li><li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/07_liczby_losowe.html">Liczby Losowe</a></li><li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/08_typ_wyliczeniowy.html">Typ Wyliczeniowy</a></li><li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/09_funkcje.html">Funkcje</a></li><li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/10_l_wartosci_r_wartosci.html">L Wartosci R Wartosci</a></li><li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/11_wskazniki.html">Wskazniki</a></li><li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/12_tablice.html">Tablice</a></li><li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/13_napisy.html">Napisy</a></li><li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/14_operacje_bitowe.html">Operacje Bitowe</a></li><li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/15_programowanie_obietkowe.html">Programowanie Obietkowe</a></li><li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/16_dziedziczenie.html">Dziedziczenie</a></li><li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/17_zaawansowane_wskazniki.html">Zaawansowane Wskazniki</a></li><li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/18_przeciazanie.html">Przeciazanie</a></li><li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/19_konwersje.html">Konwersje</a></li><li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/20_lambdy.html">Lambdy</a></li><li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/21_szablony.html">Szablony</a></li><li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/22_wyjatki.html">Wyjatki</a></li><li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/23_stl.html">Stl</a></li><li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/24_praca_z_plikami.html">Praca z Plikami</a></li><li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/25_c_vs_cpp.html">C vs Cpp</a></li></ol></div></div></div><footer>
<div class="footer-columns">
<div class="footer-column">
<img alt="Adam Djellouli Symbol" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/symbol.png"/>
</div>
<div class="footer-column">
<h2><a href="https://adamdjellouli.com/core/privacy_policy.html" title="Privacy Policy">Our Privacy Policy</a></h2>
<p>Thank you for visiting my personal website. All content here is free to use, but please remember to be respectful and avoid any misuse of the site. If youâ€™d like to get in touch, feel free to reach out via my <a href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" title="LinkedIn Profile">LinkedIn profile</a> or connect with me on <a href="https://github.com/djeada" title="GitHub Profile">GitHub</a> if you have technical questions or ideas to share. Wishing you all the best and a fantastic life ahead!</p>
</div>
<div class="footer-column">
<h2>Follow me</h2>
<ul class="social-media">
<li>
<a class="fa fa-youtube" href="https://www.youtube.com/channel/UCGPoHTVjMN77wcGknXPHl1Q" target="_blank" title="YouTube">
</a>YouTube
                </li>
<li>
<a class="fa fa-linkedin" href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" target="_blank" title="LinkedIn">
</a>LinkedIn
                </li>
<li>
<a class="fa fa-instagram" href="https://www.instagram.com/linuxchallenges/" target="_blank" title="Instagram">
</a>Instagram
                </li>
<li>
<a class="fa fa-github" href="https://github.com/djeada" title="GitHub">
</a>Github
                </li>
</ul>
</div>
</div>
<div>
<p id="copyright">
            Â© Adam Djellouli. All rights reserved.
        </p>
</div>
<script>
        document.getElementById("copyright").innerHTML = "&copy; " + new Date().getFullYear() + " Adam Djellouli. All rights reserved.";
    </script>
<script src="../../app.js"></script>
</footer></body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-bash.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-cpp.min.js"></script><script type="text/x-mathjax-config">
MathJax.Hub.Config({
jax: ["input/TeX", "output/HTML-CSS"],
extensions: ["tex2jax.js"],
"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] },
tex2jax: { inlineMath: [ ["$", "$"] ], displayMath: [ ["$$","$$"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
TeX: { noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } } },
messageStyle: "none"
});
</script>
<script async="" id="MathJax-script" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script></html>