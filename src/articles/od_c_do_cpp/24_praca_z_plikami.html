<!DOCTYPE html>

<html lang="pl">

<head>
    <script async="" crossorigin="anonymous" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5593122079896089"></script>
    <meta charset="utf-8" />
    <title>Praca z plikami</title>
    <meta content="Obsługa plików jest przydatną umiejętnością przy pisaniu aplikacji w C i C++." name="description" />
    <meta content="Adam Djellouli" name="author" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <meta content="IE=edge" http-equiv="X-UA-Compatible" />
    <link crossorigin="" href="https://fonts.googleapis.com" rel="preconnect" />
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/icon.ico" rel="icon" />
    <link href="../../resources/style.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />
</head>

<body>
    <nav aria-label="Main navigation">
        <a class="logo" href="https://adamdjellouli.com">
            <img alt="Adam Djellouli - Home Page Logo" id="logo-image" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/logo.PNG" />
        </a>
        <input aria-label="Toggle navigation menu" id="navbar-toggle" type="checkbox" />
        <ul aria-labelledby="navbar-toggle" role="menu">
            <li role="menuitem">
                <a href="../../index.html" title="Go to Home Page"> Home </a>
            </li>
            <li role="menuitem">
                <a class="active" href="../../core/blog.html" title="Read Adam Djellouli Blog on Programming and Technology"> Blog </a>
            </li>
            <li role="menuitem">
                <a href="../../core/tools.html" title="Discover Tools Created by Adam Djellouli"> Tools </a>
            </li>
            <li role="menuitem">
                <a href="../../core/projects.html" title="Explore Projects Developed by Adam Djellouli"> Projects </a>
            </li>
            <li role="menuitem">
                <a href="../../core/resume.html" title="View Adam Djellouli Professional Resume"> Resume </a>
            </li>
            <li>
                <script async="" src="https://cse.google.com/cse.js?cx=8160ef9bb935f4f68"></script>
                <div class="gcse-search"></div>
            </li>
            <li>
                <button aria-label="Toggle dark mode" id="dark-mode-button"></button>
            </li>
        </ul>
    </nav>
    <div id="article-wrapper">
        <section id="article-body">
            <p style="text-align: right;"><i>Last modified: January 27, 2023</i></p>
            <p style="text-align: right;"><i>This article is written in: 🇵🇱</i></p>
            <h2 id="praca-z-plikami">Praca z plikami</h2>
            <p>Obsługa plików jest przydatną umiejętnością przy pisaniu aplikacji w C i C++. Praca z plikami pozwala na trwałe przechowywanie danych, które mogą być później odczytywane i przetwarzane przez program. Dzięki temu aplikacje mogą zachowywać stan między uruchomieniami, przechowywać konfiguracje, logi, a także przetwarzać duże ilości danych wejściowych i wyjściowych.</p>
            <p>Zarówno C, jak i C++ oferują bogaty zestaw funkcji oraz klas do pracy z plikami, co umożliwia programistom efektywne zarządzanie danymi. W zależności od potrzeb aplikacji, można wybrać odpowiednie narzędzia i metody do otwierania, czytania, zapisywania oraz zamykania plików. Poniżej przedstawione zostaną podstawowe operacje związane z obsługą plików w obu językach, wraz z przykładami kodu i omówieniem najważniejszych funkcji.</p>
            <h3 id="praca-z-plikami-w-c">Praca z plikami w C</h3>
            <p>W języku C obsługa plików odbywa się za pomocą funkcji z biblioteki <code>&lt;stdio.h&gt;</code>. Ta biblioteka dostarcza zestaw funkcji, które umożliwiają otwieranie, czytanie, zapisywanie oraz zamykanie plików. Dzięki nim programiści mogą łatwo manipulować danymi zapisanymi na dysku, co jest niezbędne w wielu zastosowaniach, takich jak przetwarzanie danych, logowanie informacji czy tworzenie plików konfiguracyjnych.</p>
            <p>Najważniejsze funkcje do tej operacji to <code>fopen</code>, <code>fclose</code>, <code>fread</code>, <code>fwrite</code>, <code>fprintf</code>, <code>fscanf</code>, <code>fgetc</code>, i <code>fputc</code>. Każda z nich pełni specyficzną rolę w procesie zarządzania plikami, umożliwiając różnorodne operacje na danych. Poniżej omówimy te funkcje szczegółowo, zaczynając od otwierania plików.</p>
            <h4 id="otwieranie-plików">Otwieranie plików</h4>
            <p>Aby rozpocząć pracę z plikiem, należy go najpierw otworzyć. W języku C służy do tego funkcja <code>fopen</code>, która zwraca wskaźnik do pliku. Wskaźnik ten jest niezbędny do dalszych operacji na pliku, takich jak czytanie czy zapisywanie danych. Proces otwierania pliku wymaga podania nazwy pliku oraz trybu, w jakim ma być otwarty.</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;stdio.h&gt;

int main() {
    FILE *f = fopen("plik.txt", "r");
    // ... operacje na pliku ...
    fclose(f);
}</code></pre>
            </div>
            </p>
            <p>Argumenty <code>fopen</code> to nazwa pliku oraz tryb otwarcia:</p>
            <ul>
                <li><code>"r"</code>: odczyt – otwiera plik do odczytu. Plik musi istnieć.</li>
                <li><code>"w"</code>: zapis – otwiera plik do zapisu. Tworzy nowy plik lub nadpisuje istniejący.</li>
                <li><code>"a"</code>: dopisanie do końca pliku – otwiera plik do dopisywania danych na końcu. Jeśli plik nie istnieje, zostaje utworzony.</li>
                <li><code>"rb"</code>, <code>"wb"</code>, <code>"ab"</code>: odpowiednie tryby binarne – używane do otwierania plików w trybie binarnym, co jest przydatne przy pracy z plikami nie-tekstowymi.</li>
            </ul>
            <p>Wybór odpowiedniego trybu otwarcia pliku jest istotny, ponieważ determinuje sposób, w jaki dane będą odczytywane lub zapisywane. Nieprawidłowy tryb może prowadzić do błędów, takich jak utrata danych czy nieudane próby otwariańia pliku.</p>
            <h4 id="czytanie-z-pliku">Czytanie z pliku</h4>
            <p>Po otwarciu pliku w trybie odczytu, można rozpocząć proces czytania danych z niego. Jednym ze sposobów czytania z pliku jest użycie funkcji <code>fgetc</code>, która odczytuje pojedynczy znak z pliku. Poniższy przykład pokazuje, jak można odczytywać plik znak po znaku, a następnie wyświetlać jego zawartość na standardowym wyjściu.</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;stdio.h&gt;

int main() {
    FILE *f = fopen("plik.txt", "r");
    char c;
    
    while ((c = fgetc(f)) != EOF) {
        putchar(c);
    }

    fclose(f);
}</code></pre>
            </div>
            </p>
            <p>Pętla <code>while</code> kontynuuje odczytywanie znaków z pliku aż do napotkania końca pliku (<code>EOF</code>). Funkcja <code>putchar</code> służy do wyświetlania każdego odczytanego znaku na standardowym wyjściu, co pozwala na przeglądanie zawartości pliku w konsoli.</p>
            <h4 id="zapisywanie-do-pliku">Zapisywanie do pliku</h4>
            <p>Zapisywanie danych do pliku jest równie ważną operacją. W języku C można to zrobić za pomocą funkcji <code>fputc</code>, która zapisuje pojedynczy znak do pliku. Alternatywnie, dla bardziej złożonych operacji, można użyć <code>fprintf</code>, która umożliwia formatowane zapisywanie danych, podobnie jak funkcja <code>printf</code>.</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;stdio.h&gt;

int main() {
    FILE *f = fopen("wyjscie.txt", "w");
    
    fputc('H', f);
    fputc('i', f);
    
    fclose(f);
}</code></pre>
            </div>
            </p>
            <p>W powyższym przykładzie otwieramy plik <code>wyjscie.txt</code> w trybie zapisu (<code>"w"</code>) i zapisujemy do niego dwa znaki: <code>H</code> oraz <code>i</code>. Po zakończeniu operacji ważne jest, aby zamknąć plik, co gwarantuje zapisanie wszystkich danych i zwolnienie zasobów systemowych.</p>
            <p>Lub użyj <code>fprintf</code> dla formatowanego wyjścia:</p>
            <p>
            <div>
                <pre><code class="language-clike">FILE *f = fopen("wyjscie.txt", "w");
fprintf(f, "Witaj, %s!", "świecie");
fclose(f);</code></pre>
            </div>
            </p>
            <p>Funkcja <code>fprintf</code> pozwala na zapisanie sformatowanego tekstu do pliku, co jest szczególnie przydatne przy generowaniu bardziej złożonych treści, takich jak raporty czy pliki konfiguracyjne.</p>
            <h4 id="sprawdzanie-błędów">Sprawdzanie błędów</h4>
            <p>Przy pracy z plikami zawsze istnieje ryzyko wystąpienia błędów, takich jak brak dostępu do pliku, nieistniejący plik czy problemy z dyskiem. Dlatego zawsze warto sprawdzić, czy otwarie pliku powiodło się przed przystąpieniem do dalszych operacji.</p>
            <p>
            <div>
                <pre><code class="language-clike">FILE *f = fopen("plik.txt", "r");
if (!f) {
    perror("Błąd podczas otwierania pliku");
    return 1;
}</code></pre>
            </div>
            </p>
            <p>Funkcja <code>perror</code> wyświetla komunikat o błędzie związanym z ostatnią operacją systemową, co pomaga w diagnozowaniu problemów podczas pracy z plikami. Dzięki temu program może odpowiednio zareagować na błędy, na przykład poprzez zakończenie działania lub próbę ponownego otwariańia pliku.</p>
            <p>W języku C obsługa plików opiera się na wskaźnikach do plików i zestawie funkcji z <code>&lt;stdio.h&gt;</code>. Często używaną funkcją jest <code>fopen</code>, która zwraca wskaźnik do pliku, a także <code>fclose</code>, która zamyka plik. Pamiętaj, aby zawsze zamykać pliki po zakończeniu pracy, co pozwala na prawidłowe zarządzanie zasobami systemowymi i unikanie problemów z dostępem do plików przez inne procesy.</p>
            <h3 id="praca-z-plikami-w-c-">Praca z plikami w C++</h3>
            <p>Obsługa plików w C++ odbywa się głównie za pomocą klas <code>ifstream</code>, <code>ofstream</code> i <code>fstream</code> z biblioteki <code>&lt;fstream&gt;</code>. Te klasy są częścią standardowej biblioteki C++ i oferują obiektowo-zorientowane podejście do pracy z plikami, co ułatwia zarządzanie zasobami i integrację z resztą kodu.</p>
            <p>W przeciwieństwie do C, gdzie operacje na plikach są funkcjami proceduralnymi, C++ pozwala na używanie strumieni, które można łatwo łączyć i manipulować nimi w bardziej intuicyjny sposób. Dzięki temu programiści mogą pisać bardziej czytelny i zorganizowany kod, co jest szczególnie ważne w większych projektach.</p>
            <h4 id="otwieranie-plików">Otwieranie plików</h4>
            <p>Aby rozpocząć pracę z plikiem w C++, należy stworzyć obiekt jednej z klas <code>ifstream</code> (do czytania), <code>ofstream</code> (do pisania) lub <code>fstream</code> (do obu operacji). Podczas tworzenia obiektu można od razu podać nazwę pliku oraz tryb otwarcia, co upraszcza proces inicjalizacji.</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;fstream&gt;

int main() {
  std::ifstream plik_wejsciowy("plik.txt");
  std::ofstream plik_wyjsciowy("wyjscie.txt");
}</code></pre>
            </div>
            </p>
            <p>W powyższym przykładzie tworzymy dwa obiekty: <code>plik_wejsciowy</code> do odczytu z pliku <code>plik.txt</code> oraz <code>plik_wyjsciowy</code> do zapisu do pliku <code>wyjscie.txt</code>. Dzięki temu możemy łatwo zarządzać różnymi operacjami na plikach w naszym programie.</p>
            <h4 id="czytanie-z-pliku">Czytanie z pliku</h4>
            <p>Do czytania z pliku w C++ często używa się pętli <code>while</code> w połączeniu z metodą <code>getline()</code>, która odczytuje kolejne linie z pliku. Jest to wygodny sposób na przetwarzanie danych tekstowych linia po linii, co jest często potrzebne w aplikacjach przetwarzających duże pliki tekstowe.</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;

int main() {
  std::ifstream plik("plik.txt");
  std::string linia;
  
  while (std::getline(plik, linia)) {
    std::cout &lt;&lt; linia &lt;&lt; std::endl;
  }

  plik.close();
}</code></pre>
            </div>
            </p>
            <p>W tym przykładzie otwieramy plik <code>plik.txt</code> do odczytu, a następnie w pętli <code>while</code> odczytujemy każdą linię i wyświetlamy ją na standardowym wyjściu. Po zakończeniu operacji zamykamy plik, co jest dobrą praktyką zapewniającą prawidłowe zarządzanie zasobami.</p>
            <h4 id="zapisywanie-do-pliku">Zapisywanie do pliku</h4>
            <p>Zapisywanie danych do pliku w C++ jest równie proste jak odczytywanie. Możemy użyć operatora <code>&lt;&lt;</code>, który umożliwia łatwe i intuicyjne zapisywanie danych do strumienia wyjściowego.</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;fstream&gt;

int main() {
  std::ofstream plik("wyjscie.txt");
  
  plik &lt;&lt; "Witaj, świecie!" &lt;&lt; std::endl;
  
  plik.close();
}</code></pre>
            </div>
            </p>
            <p>W tym przykładzie otwieramy plik <code>wyjscie.txt</code> w trybie zapisu i zapisujemy do niego tekst <code>"Witaj, świecie!"</code>. Operator <code>&lt;&lt;</code> automatycznie konwertuje dane do formatu odpowiedniego dla pliku, co upraszcza proces zapisywania danych.</p>
            <h4 id="sprawdzanie-błędów">Sprawdzanie błędów</h4>
            <p>Podobnie jak w języku C, w C++ również warto sprawdzić, czy otwarie pliku powiodło się przed przystąpieniem do dalszych operacji. Pozwala to na odpowiednie reagowanie na ewentualne problemy, takie jak brak dostępu do pliku czy błędy dysku.</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;fstream&gt;
#include &lt;iostream&gt;

int main() {
  std::ifstream plik("plik.txt");
  
  if (!plik) {
    std::cerr &lt;&lt; "Błąd podczas otwierania pliku!" &lt;&lt; std::endl;
    return 1;
  }
  
  // reszta kodu

  plik.close();
}</code></pre>
            </div>
            </p>
            <p>W tym przykładzie sprawdzamy, czy plik <code>plik.txt</code> został poprawnie otwarty. Jeśli nie, wyświetlamy komunikat o błędzie na standardowym wyjściu błędów (<code>std::cerr</code>) i kończymy działanie programu z kodem błędu <code>1</code>. Dzięki temu unikamy prób operacji na nieotwartym pliku, co mogłoby prowadzić do nieprzewidywalnych zachowań programu.</p>
            <h4 id="binary-mode">Binary Mode</h4>
            <p>Domyślnie pliki są otwierane w trybie tekstowym, co oznacza, że dane są interpretowane jako tekst. Jednak w niektórych przypadkach, zwłaszcza przy pracy z plikami binarnymi, konieczne jest otwarie pliku w trybie binarnym. W C++ można to zrobić, dodając flagę <code>std::ios::binary</code> jako drugi argument podczas otwierania pliku.</p>
            <p>
            <div>
                <pre><code class="language-clike">std::ofstream binarny_plik("plik.bin", std::ios::binary);</code></pre>
            </div>
            </p>
            <p>Otwieranie pliku w trybie binarnym jest niezbędne, gdy chcemy pracować z danymi nie-tekstowymi, takimi jak obrazy, pliki dźwiękowe czy inne formaty binarne. Tryb binarny zapewnia, że dane są zapisywane i odczytywane dokładnie w takiej formie, w jakiej są przechowywane, bez żadnych modyfikacji czy konwersji.</p>
            <p>Obsługa plików w C++ jest prosta i intuicyjna dzięki zastosowaniu klas <code>ifstream</code>, <code>ofstream</code> i <code>fstream</code>. Te klasy umożliwiają odpowiednio czytanie, zapisywanie lub wykonywanie obu tych operacji na plikach. Nie zapominaj też o zamykaniu plików po zakończeniu pracy, co zapewnia prawidłowe zarządzanie zasobami systemowymi i unikanie potencjalnych problemów z dostępem do plików przez inne procesy.</p>
            <h3 id="gwarancja-bezpiecznego-zamknięcia-pliku">Gwarancja bezpiecznego zamknięcia pliku</h3>
            <p>Prawidłowe zarządzanie zasobami, takimi jak pliki, jest ważne dla stabilności i wydajności programu. W językach programowania, które nie mają wbudowanego zarządzania pamięcią, jak C++, błędy w obsłudze zasobów mogą prowadzić do wycieków pamięci, błędów dostępu lub blokowania zasobów. Dlatego ważne jest, aby zawsze dbać o zamknięcie plików po zakończeniu ich używania oraz korzystać z technik programistycznych, które zapewniają bezpieczeństwo i niezawodność w zarządzaniu zasobami.</p>
            <h4 id="dlaczego-bezpieczne-zamykanie-pliku-jest-ważne-">Dlaczego bezpieczne zamykanie pliku jest ważne?</h4>
            <p>Bezpieczne zamykanie pliku jest istotne z kilku powodów:</p>
            <ul>
                <li>Zamykanie plików zapewnia <strong>integralność danych</strong>, ponieważ gwarantuje, że wszystkie zapisane dane zostaną prawidłowo zapisane na dysku. Nieprawidłowo zamknięty plik może prowadzić do utraty danych lub ich uszkodzenia, co jest szczególnie istotne w przypadku krytycznych informacji.</li>
                <li>Proces ten pozwala na <strong>zwolnienie zasobów systemowych</strong>, takich jak uchwyty plików. Brak zamykania plików może doprowadzić do osiągnięcia limitu otwartych plików, uniemożliwiając otwieranie nowych plików przez programy.</li>
                <li>Zamykanie plików eliminuje <strong>blokady plików</strong>, które mogą ograniczać dostęp dla innych aplikacji. Otwarte pliki często blokują możliwość modyfikacji przez inne programy, co może prowadzić do błędów.</li>
                <li>W niektórych przypadkach zamykanie plików pozwala na <strong>zwalnianie pamięci</strong>, ponieważ otwarte pliki mogą zajmować zasoby pamięciowe. Nieprawidłowe zarządzanie tymi plikami może prowadzić do wycieków pamięci, co w dłuższej perspektywie może skutkować awariami aplikacji.</li>
            </ul>
            <p>Ważne jest, aby programiści dbali o prawidłowe zamykanie plików oraz stosowali techniki zapewniające, że pliki zostaną zamknięte nawet w przypadku wystąpienia błędów czy wyjątków.</p>
            <h3 id="raii-w-c-">RAII w C++</h3>
            <p><strong>RAII (Resource Acquisition Is Initialization)</strong> to wzorzec projektowy i zarazem podejście, w którym przejęcie zasobów (np. pamięci, gniazda sieciowego czy uchwytu do pliku) następuje podczas inicjalizacji obiektu, a zwolnienie tych zasobów jest gwarantowane w jego destruktorze. Dzięki temu:</p>
            <ol>
                <li><strong>Obiekt jest uznawany za w pełni zainicjalizowany dopiero wtedy, gdy z powodzeniem uda się nabyć wszystkie potrzebne zasoby.</strong> Jeżeli pozyskanie któregokolwiek z nich się nie powiedzie (np. nie uda się otworzyć pliku czy nawiązać połączenia sieciowego), konstruktor może zgłosić błąd poprzez wyjątek, a obiekt nie zostanie w pełni utworzony. </li>
                <li><strong>Zwalnianie zasobów odbywa się automatycznie w destruktorze</strong>, gdy obiekt wychodzi z zasięgu (scope) – na przykład po zakończeniu funkcji lub bloku, w którym został zadeklarowany. </li>
                <li><strong>Nie ma potrzeby wywoływania jawnych operacji zwalniania</strong> (np. zamykania pliku czy zwalniania pamięci), co znacząco minimalizuje ryzyko wycieków zasobów. </li>
            </ol>
            <p>Przykładowymi zasobami, które często są „opakowywane” w obiekty RAII, mogą być:</p>
            <ul>
                <li><strong>Pamięć</strong> (zazwyczaj zarządzana przy pomocy inteligentnych wskaźników, takich jak <code>std::unique_ptr</code> czy <code>std::shared_ptr</code> w C++), </li>
                <li><strong>Gniazda sieciowe (sockets)</strong> do komunikacji przez sieć, </li>
                <li><strong>Uchwyty do plików</strong> (otwarte strumienie wejścia/wyjścia), </li>
                <li><strong>Blokady (locki) i muteksy</strong> w środowiskach wielowątkowych, </li>
                <li><strong>Dowolne inne zasoby systemowe</strong>, takie jak uchwyty do baz danych czy identyfikatory procesów.</li>
            </ul>
            <p>Kluczową zaletą RAII jest to, że <strong>dopóki obiekt istnieje, zasób pozostaje w użytecznym stanie</strong>, a gdy obiekt przestaje istnieć, zasób jest zwalniany. Podejście to ściśle współgra z mechanizmem wyjątków w C++ – jeśli nie uda się pozyskać zasobu, konstruktor zgłasza wyjątek, a wszystkie wcześniej pobrane zasoby są natychmiast zwalniane w ramach stack unwinding (cofania stosu wywołań).</p>
            <p><strong>Przykład z klasą <code>File</code></strong></p>
            <p>Aby zilustrować ideę RAII na prostym przykładzie, można zaprezentować klasę <code>File</code>, która odpowiada za otwieranie i zamykanie pliku:</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;fstream&gt;
#include &lt;stdexcept&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;

class File {
 public:
  File(const std::string&amp; filename, const std::string&amp; mode = "r") 
    : m_filename(filename) {
      if (mode == "r") {
          m_file.open(filename, std::ios::in);
      } else if (mode == "w") {
          m_file.open(filename, std::ios::out);
      } else if (mode == "a") {
          m_file.open(filename, std::ios::app);
      } else {
          throw std::invalid_argument("Nieznany tryb otwarcia pliku");
      }

      if (!m_file.is_open()) {
          throw std::runtime_error("Nie można otworzyć pliku");
      }
  }

  ~File() {
    if (m_file.is_open()) {
      m_file.close();
    }
  }

  std::fstream&amp; stream() {
    return m_file;
  }

 private:
  std::string m_filename;
  std::fstream m_file;
};

int main() {
  try {
      File file("plik.txt", "r");
      char znak;
      while (file.stream().get(znak)) {
        std::cout &lt;&lt; znak;
      }
  } catch (const std::exception&amp; e) {
      std::cerr &lt;&lt; "Błąd: " &lt;&lt; e.what() &lt;&lt; std::endl;
  }

  return 0;
}</code></pre>
            </div>
            </p>
            <ol>
                <li><strong>Konstruktor</strong> próbuje otworzyć plik w zadanym trybie. Jeśli wskazany tryb jest niepoprawny, zgłasza wyjątek <code>std::invalid_argument</code>. W przypadku nieudanego otwarcia pliku rzuca <code>std::runtime_error</code>. </li>
                <li><strong>Obiekt</strong> będzie uznany za w pełni zainicjalizowany wyłącznie wówczas, gdy uda się skutecznie otworzyć plik. Gdyby pojawił się błąd, konstrukcja obiektu zostanie przerwana, a kod w <code>main</code> może przechwycić wyjątek i odpowiednio na niego zareagować. </li>
                <li><strong>Destruktor</strong> sprawdza, czy plik wciąż jest otwarty, i zamyka go, gdy obiekt wyjdzie z zasięgu. Ma to miejsce zarówno przy normalnym zakończeniu funkcji, jak i w przypadku wyjątku. Dzięki temu programista nie musi pamiętać o ręcznym zamykaniu pliku. </li>
                <li>Metoda <code>stream()</code> zwraca referencję do strumienia <code>std::fstream</code>, co umożliwia czytanie i pisanie do pliku za pomocą dostępnych w C++ operacji na strumieniach.</li>
            </ol>
            <h4 id="raii-a-wyjątki">RAII a wyjątki</h4>
            <p>RAII i obsługa wyjątków w C++ stanowią spójny mechanizm. Jeśli konstruktor obiektu nie jest w stanie pozyskać wszystkich zasobów (na przykład plik nie może zostać otwarty, brakuje pamięci lub nie udało się nawiązać połączenia sieciowego), to wyjątek zgłoszony w konstruktorze zapewnia:</p>
            <ul>
                <li><strong>Automatyczne wycofanie</strong> już zarezerwowanych zasobów (jeśli zdążono je zainicjalizować przed wystąpieniem błędu). </li>
                <li><strong>Brak wycieków</strong>: obiekt „nie powstaje” w niekompletnym stanie, więc nie pozostaje w pamięci. </li>
                <li><strong>Łatwiejszą kontrolę logiki błędów</strong>: tam, gdzie tworzymy obiekt, możemy uchwycić wyjątek i podjąć decyzję, co zrobić dalej (np. przerwać działanie programu, wyświetlić komunikat, spróbować innej ścieżki, itp.).</li>
            </ul>
            <h4 id="krytyka-i-praktyczne-wskazówki">Krytyka i praktyczne wskazówki</h4>
            <p>Chociaż RAII jest bardzo pomocne, czasem krytykuje się je za to, że:</p>
            <ol>
                <li><strong>Wszystkie scenariusze obsługi błędu mogą trafiać do konstruktorów i destruktorów</strong>, co bywa trudne do rozbudowanej personalizacji. W niektórych przypadkach chcemy np. po nieudanej próbie otwarcia pliku spróbować ponownie po kilku sekundach, w innych – zapisać komunikat do dziennika zdarzeń lub całkowicie zakończyć działanie programu. </li>
                <li><strong>Zbyt duże obciążenie logiką błędów</strong> wewnątrz klasy może prowadzić do zbytniej komplikacji. Zamiast ograniczać się do prostego „otwórz plik → w razie niepowodzenia rzuć wyjątek”, możemy potrzebować bardziej złożonych ścieżek decyzyjnych (np. warunkowe retry, praca w trybie awaryjnym, przełączenie na inny plik itd.). </li>
                <li><strong>W niektórych sytuacjach</strong> konieczna jest bardziej rozproszona obsługa zasobów – np. kiedy żywotność zasobu nie jest ściśle powiązana z żywotnością pojedynczego obiektu (możemy mieć duży system, w którym zasób jest współdzielony między wieloma komponentami). Wtedy konstrukcja typu RAII bywa niewystarczająca lub nadmiernie skomplikowana do utrzymania.</li>
            </ol>
            <p>W praktycznych projektach często stosuje się RAII do tych zasobów, które są wyraźnie powiązane z czasem życia obiektu i nie wymagają skomplikowanej logiki w sytuacjach awaryjnych. Jeśli jednak potrzeby aplikacji wykraczają poza standardowy „otwórz-wykorzystaj-zamknij”, należy rozważyć uzupełnienie RAII o inny mechanizm obsługi błędów (np. dedykowane metody zarządzania pewnymi zasobami lub rozbudowany system odroczonego przywracania/zwalniania zasobu).</p>
        </section>
        <div id="table-of-contents">
            <h2>Spis Treści</h2>
            <ol><a href="#praca-z-plikami">Praca z plikami</a>
                <ol>
                    <li><a href="#praca-z-plikami-w-c">Praca z plikami w C</a>
                        <ol>
                            <li><a href="#otwieranie-plików">Otwieranie plików</a></li>
                            <li><a href="#czytanie-z-pliku">Czytanie z pliku</a></li>
                            <li><a href="#zapisywanie-do-pliku">Zapisywanie do pliku</a></li>
                            <li><a href="#sprawdzanie-błędów">Sprawdzanie błędów</a></li>
                        </ol>
                    </li>
                    <li><a href="#praca-z-plikami-w-c-">Praca z plikami w C++</a>
                        <ol>
                            <li><a href="#otwieranie-plików">Otwieranie plików</a></li>
                            <li><a href="#czytanie-z-pliku">Czytanie z pliku</a></li>
                            <li><a href="#zapisywanie-do-pliku">Zapisywanie do pliku</a></li>
                            <li><a href="#sprawdzanie-błędów">Sprawdzanie błędów</a></li>
                            <li><a href="#binary-mode">Binary Mode</a></li>
                        </ol>
                    </li>
                    <li><a href="#gwarancja-bezpiecznego-zamknięcia-pliku">Gwarancja bezpiecznego zamknięcia pliku</a>
                        <ol>
                            <li><a href="#dlaczego-bezpieczne-zamykanie-pliku-jest-ważne-">Dlaczego bezpieczne zamykanie pliku jest ważne?</a></li>
                        </ol>
                    </li>
                    <li><a href="#raii-w-c-">RAII w C++</a>
                        <ol>
                            <li><a href="#raii-a-wyjątki">RAII a wyjątki</a></li>
                            <li><a href="#krytyka-i-praktyczne-wskazówki">Krytyka i praktyczne wskazówki</a></li>
                        </ol>
                    </li>
                </ol>
            </ol>
            <div id="related-articles">
                <h2>Related Articles</h2>
                <ol>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/01_proces_kompilacji.html">Proces Kompilacji</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/02_preprocesor.html">Preprocesor</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/03_zmienne_i_typy_danych.html">Zmienne i Typy Danych</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/04_interakcja_z_konsola.html">Interakcja z Konsola</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/05_instrukcja_warunkowa.html">Instrukcja Warunkowa</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/06_petle.html">Petle</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/07_liczby_losowe.html">Liczby Losowe</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/08_typ_wyliczeniowy.html">Typ Wyliczeniowy</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/09_funkcje.html">Funkcje</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/10_l_wartosci_r_wartosci.html">L Wartosci R Wartosci</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/11_wskazniki.html">Wskazniki</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/12_tablice.html">Tablice</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/13_napisy.html">Napisy</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/14_operacje_bitowe.html">Operacje Bitowe</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/15_programowanie_obietkowe.html">Programowanie Obietkowe</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/16_dziedziczenie.html">Dziedziczenie</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/17_zaawansowane_wskazniki.html">Zaawansowane Wskazniki</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/18_przeciazanie.html">Przeciazanie</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/19_konwersje.html">Konwersje</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/20_lambdy.html">Lambdy</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/21_szablony.html">Szablony</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/22_wyjatki.html">Wyjatki</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/23_stl.html">Stl</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/24_praca_z_plikami.html">Praca z Plikami</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/25_c_vs_cpp.html">C vs Cpp</a></li>
                </ol>
            </div>
        </div>
    </div>
    <footer>
        <div class="footer-columns">
            <div class="footer-column">
                <img alt="Adam Djellouli Symbol" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/symbol.png" />
            </div>
            <div class="footer-column">
                <h2><a href="https://adamdjellouli.com/core/privacy_policy.html" title="Privacy Policy">Our Privacy Policy</a></h2>
                <p>
                    Thank you for visiting my personal website. All of the <br />
                    content on this site is free to use, but please remember <br />
                    to be a good human being and refrain from any abuse<br />
                    of the site. If you would like to contact me, please use <br />
                    my <a href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" title="LinkedIn Profile">LinkedIn profile</a> or my <a href="https://github.com/djeada" title="GitHub Profile">GitHub</a> if you have any technical <br />
                    issues or ideas to share. I wish you the best and hope you <br />
                    have a fantastic life. <br />
                </p>
            </div>
            <div class="footer-column">
                <h2>Follow me</h2>
                <ul class="social-media">
                    <li>
                        <a class="fa fa-youtube" href="https://www.youtube.com/channel/UCGPoHTVjMN77wcGknXPHl1Q" target="_blank" title="YouTube">
                        </a>YouTube
                    </li>
                    <li>
                        <a class="fa fa-linkedin" href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" target="_blank" title="LinkedIn">
                        </a>LinkedIn
                    </li>
                    <li>
                        <a class="fa fa-instagram" href="https://www.instagram.com/linuxchallenges/" target="_blank" title="Instagram">
                        </a>Instagram
                    </li>
                    <li>
                        <a class="fa fa-github" href="https://github.com/djeada" title="GitHub">
                        </a>Github
                    </li>
                </ul>
            </div>
        </div>
        <div>
            <p id="copyright">
                © Adam Djellouli. All rights reserved.
            </p>
        </div>
        <script>
            document.getElementById("copyright").innerHTML = "&copy; " + new Date().getFullYear() + " Adam Djellouli. All rights reserved.";
        </script>
        <script src="../../app.js"></script>
    </footer>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-bash.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-cpp.min.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
jax: ["input/TeX", "output/HTML-CSS"],
extensions: ["tex2jax.js"],
"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] },
tex2jax: { inlineMath: [ ["$", "$"] ], displayMath: [ ["$$","$$"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
TeX: { noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } } },
messageStyle: "none"
});
</script>
<script async="" id="MathJax-script" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>

</html>