<!DOCTYPE html>

<html lang="pl">

<head>
    <script async="" crossorigin="anonymous" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5593122079896089"></script>
    <meta charset="utf-8" />
    <title>Napisy w języku C i C++</title>
    <meta content="Napisy są fundamentalnym elementem wielu aplikacji programistycznych, służąc do przechowywania i manipulacji tekstem, takim jak dane wejściowe użytkownika, komunikaty systemowe, informacje o błędach i wiele innych." name="description" />
    <meta content="Adam Djellouli" name="author" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <meta content="IE=edge" http-equiv="X-UA-Compatible" />
    <link crossorigin="" href="https://fonts.googleapis.com" rel="preconnect" />
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/icon.ico" rel="icon" />
    <link href="../../resources/style.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
</head>

<body>
    <nav aria-label="Main navigation">
        <a class="logo" href="https://adamdjellouli.com">
            <img alt="Adam Djellouli - Home Page Logo" id="logo-image" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/logo.PNG" />
        </a>
        <input aria-label="Toggle navigation menu" id="navbar-toggle" type="checkbox" />
        <ul aria-labelledby="navbar-toggle" role="menu">
            <li role="menuitem">
                <a href="../../index.html" title="Go to Home Page"> Home </a>
            </li>
            <li role="menuitem">
                <a class="active" href="../../core/blog.html" title="Read Adam Djellouli Blog on Programming and Technology"> Blog </a>
            </li>
            <li role="menuitem">
                <a href="../../core/tools.html" title="Discover Tools Created by Adam Djellouli"> Tools </a>
            </li>
            <li role="menuitem">
                <a href="../../core/projects.html" title="Explore Projects Developed by Adam Djellouli"> Projects </a>
            </li>
            <li role="menuitem">
                <a href="../../core/resume.html" title="View Adam Djellouli Professional Resume"> Resume </a>
            </li>
            <li>
                <script async="" src="https://cse.google.com/cse.js?cx=8160ef9bb935f4f68"></script>
                <div class="gcse-search"></div>
            </li>
            <li>
                <button aria-label="Toggle dark mode" id="dark-mode-button"></button>
            </li>
        </ul>
    </nav>
    <div id="article-wrapper">
        <section id="article-body">
            <div class="article-action-buttons"><button class="btn-suggest-edit" title="Suggest Edit">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <path d="M4 21h4l11-11-4-4L4 17v4z" stroke="currentColor" stroke-width="2"></path>
                    </svg>
                </button><button class="btn-create-issue" title="Create Issue">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2"></circle>
                        <line stroke="currentColor" stroke-width="2" x1="12" x2="12" y1="8" y2="12"></line>
                        <circle cx="12" cy="16" fill="currentColor" r="1"></circle>
                    </svg>
                </button><button class="btn-download" title="Download">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <path d="M12 5v14m0 0l-6-6m6 6l6-6" stroke="currentColor" stroke-width="2"></path>
                    </svg>
                </button></div>
            <p style="text-align: right;"><i>Last modified: January 20, 2024</i></p>
            <p style="text-align: right;"><i>This article is written in: 🇵🇱</i></p>
            <h2 id="napisy-w-języku-c-i-c-">Napisy w języku C i C++</h2>
            <p>Napisy są fundamentalnym elementem wielu aplikacji programistycznych, służąc do przechowywania i manipulacji tekstem, takim jak dane wejściowe użytkownika, komunikaty systemowe, informacje o błędach i wiele innych. W językach C i C++, napisy są reprezentowane na różne sposoby, co wynika z ewolucji tych języków oraz dążenia do zwiększenia bezpieczeństwa i łatwości użycia.</p>
            <h3 id="napisy-w-języku-c-c-string-">Napisy w języku C (C-string)</h3>
            <p>W języku C napisy są reprezentowane jako tablice znaków typu <code>char</code>, zakończone specjalnym znakiem <code>'\0'</code>, znanym jako znak null (null terminator). Ten znak wskazuje koniec napisu i pozwala funkcjom bibliotecznym na określenie długości napisu w czasie wykonania.</p>
            <h4 id="deklaracja-i-inicjalizacja-napisów-w-c">Deklaracja i inicjalizacja napisów w C</h4>
            <p>Istnieje kilka sposobów deklarowania i inicjalizacji napisów w C:</p>
            <p>I. <strong>Wskaźnik do stałego łańcucha znaków:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">const char *napisA = "Ala ma kota";</code></pre>
            </div>
            </p>
            <p>W tym przypadku <code>napisA</code> jest wskaźnikiem do stałego łańcucha znaków przechowywanego w pamięci tylko do odczytu (zazwyczaj w segmencie tekstowym programu). Próba modyfikacji tego napisu prowadzi do niezdefiniowanego zachowania.</p>
            <p>II. <strong>Tablica znaków z inicjalizacją literałem:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">char napisB[] = "Ala ma kota";</code></pre>
            </div>
            </p>
            <p>Tutaj <code>napisB</code> jest tablicą znaków, która jest kopią literału napisu. Ta tablica może być modyfikowana, ponieważ jest przechowywana w pamięci dostępnej do zapisu (zazwyczaj na stosie lub w pamięci dynamicznej).</p>
            <p>III. <strong>Tablica znaków z inicjalizacją listą znaków:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">char napisC[] = {'A', 'l', 'a', ' ', 'm', 'a', ' ', 'k', 'o', 't', 'a', '\0'};</code></pre>
            </div>
            </p>
            <p>Ten sposób jest równoważny poprzedniemu, ale wymaga jawnego dodania znaku null na końcu tablicy.</p>
            <h4 id="znaczenie-znaku-null">Znaczenie znaku null</h4>
            <p>Znak null <code>'\0'</code> jest kluczowy w reprezentacji napisów w C. Funkcje biblioteczne operujące na napisach zakładają, że napisy są zakończone tym znakiem. Brak znaku null może prowadzić do błędów, takich jak odczyt poza granicami tablicy (buffer overrun), co może skutkować naruszeniem ochrony pamięci i awarią programu.</p>
            <h4 id="operacje-na-napisach-w-c">Operacje na napisach w C</h4>
            <p>Język C dostarcza bogaty zestaw funkcji w standardowych bibliotekach do manipulacji napisami. Kluczowe biblioteki to <code>&lt;string.h&gt;</code>, <code>&lt;ctype.h&gt;</code> i <code>&lt;stdlib.h&gt;</code>.</p>
            <h5>Biblioteka <code>&lt;string.h&gt;</code></h5>
            <p>Funkcje w tej bibliotece służą do manipulacji i porównywania napisów:</p>
            <p>
            <table>
                <tr>
                    <td>Funkcja</td>
                    <td>Opis</td>
                </tr>
                <tr>
                    <td><code>size_t strlen(const char *s);</code></td>
                    <td>Zwraca długość napisu <code>s</code>, czyli liczbę znaków przed znakiem null.</td>
                </tr>
                <tr>
                    <td><code>char *strcpy(char *dest, const char *src);</code></td>
                    <td>Kopiuje napis <code>src</code> do bufora <code>dest</code>. Uwaga: <code>dest</code> musi mieć wystarczający rozmiar, aby pomieścić <code>src</code>.</td>
                </tr>
                <tr>
                    <td><code>char *strncpy(char *dest, const char *src, size_t n);</code></td>
                    <td>Kopiuje maksymalnie <code>n</code> znaków z <code>src</code> do <code>dest</code>.</td>
                </tr>
                <tr>
                    <td><code>char *strcat(char *dest, const char *src);</code></td>
                    <td>Dołącza napis <code>src</code> do końca <code>dest</code>. <code>dest</code> musi mieć wystarczający rozmiar.</td>
                </tr>
                <tr>
                    <td><code>char *strncat(char *dest, const char *src, size_t n);</code></td>
                    <td>Dołącza maksymalnie <code>n</code> znaków z <code>src</code> do <code>dest</code>.</td>
                </tr>
                <tr>
                    <td><code>int strcmp(const char *s1, const char *s2);</code></td>
                    <td>Porównuje napisy <code>s1</code> i <code>s2</code>. Zwraca wartość ujemną, zero lub dodatnią w zależności od wyniku porównania.</td>
                </tr>
                <tr>
                    <td><code>int strncmp(const char *s1, const char *s2, size_t n);</code></td>
                    <td>Porównuje maksymalnie <code>n</code> znaków z <code>s1</code> i <code>s2</code>.</td>
                </tr>
                <tr>
                    <td><code>char *strchr(const char *s, int c);</code></td>
                    <td>Wyszukuje pierwsze wystąpienie znaku <code>c</code> w napisie <code>s</code>.</td>
                </tr>
                <tr>
                    <td><code>char *strrchr(const char *s, int c);</code></td>
                    <td>Wyszukuje ostatnie wystąpienie znaku <code>c</code> w napisie <code>s</code>.</td>
                </tr>
                <tr>
                    <td><code>char *strstr(const char *haystack, const char *needle);</code></td>
                    <td>Wyszukuje podciąg <code>needle</code> w napisie <code>haystack</code>.</td>
                </tr>
            </table>
            </p>
            <p><strong>Uwaga dotycząca bezpieczeństwa:</strong> Funkcje takie jak <code>strcpy</code> i <code>strcat</code> są podatne na błędy przepełnienia bufora (buffer overflow) i nie powinny być używane w nowym kodzie. Bezpieczniejsze alternatywy to <code>strncpy</code> i <code>strncat</code>, jednak one również mają swoje ograniczenia. W praktyce zaleca się korzystanie z funkcji takich jak <code>strlcpy</code> i <code>strlcat</code> (jeśli są dostępne) lub funkcji specyficznych dla danego systemu operacyjnego.</p>
            <h5>Biblioteka <code>&lt;ctype.h&gt;</code></h5>
            <p>Ta biblioteka zawiera funkcje do klasyfikacji i manipulacji znakami:</p>
            <p>
            <table>
                <tr>
                    <td>Funkcja</td>
                    <td>Opis</td>
                </tr>
                <tr>
                    <td><code>int isalpha(int c);</code></td>
                    <td>Sprawdza, czy znak <code>c</code> jest literą alfabetu.</td>
                </tr>
                <tr>
                    <td><code>int isdigit(int c);</code></td>
                    <td>Sprawdza, czy znak <code>c</code> jest cyfrą.</td>
                </tr>
                <tr>
                    <td><code>int isalnum(int c);</code></td>
                    <td>Sprawdza, czy znak <code>c</code> jest alfanumeryczny.</td>
                </tr>
                <tr>
                    <td><code>int isspace(int c);</code></td>
                    <td>Sprawdza, czy znak <code>c</code> jest znakiem białym (spacja, tabulacja, nowa linia itp.).</td>
                </tr>
                <tr>
                    <td><code>int toupper(int c);</code></td>
                    <td>Konwertuje znak <code>c</code> do wielkiej litery, jeśli to możliwe.</td>
                </tr>
                <tr>
                    <td><code>int tolower(int c);</code></td>
                    <td>Konwertuje znak <code>c</code> do małej litery, jeśli to możliwe.</td>
                </tr>
            </table>
            </p>
            <h5>Biblioteka <code>&lt;stdlib.h&gt;</code></h5>
            <p>Zawiera funkcje do konwersji napisów na wartości liczbowe i odwrotnie:</p>
            <p>
            <table>
                <tr>
                    <td>Funkcja</td>
                    <td>Opis</td>
                </tr>
                <tr>
                    <td><code>int atoi(const char *nptr);</code></td>
                    <td>Konwertuje napis <code>nptr</code> na wartość <code>int</code>.</td>
                </tr>
                <tr>
                    <td><code>long int strtol(const char *nptr, char **endptr, int base);</code></td>
                    <td>Konwertuje napis <code>nptr</code> na wartość <code>long int</code>, z możliwością określenia podstawy systemu liczbowego.</td>
                </tr>
                <tr>
                    <td><code>double atof(const char *nptr);</code></td>
                    <td>Konwertuje napis <code>nptr</code> na wartość <code>double</code>.</td>
                </tr>
                <tr>
                    <td><code>double strtod(const char *nptr, char **endptr);</code></td>
                    <td>Konwertuje napis <code>nptr</code> na wartość <code>double</code>, zwracając wskaźnik do pierwszego znaku po liczbie w <code>*endptr</code>.</td>
                </tr>
                <tr>
                    <td><code>char *strtok(char *str, const char *delim);</code></td>
                    <td>Dzieli napis <code>str</code> na tokeny, używając separatorów zdefiniowanych w <code>delim</code>.</td>
                </tr>
            </table>
            </p>
            <p><strong>Uwaga dotycząca bezpieczeństwa:</strong> Funkcja <code>atoi</code> nie obsługuje błędów i nie jest bezpieczna. Zaleca się użycie <code>strtol</code> lub <code>strtod</code>, które pozwalają na wykrycie błędów konwersji.</p>
            <h4 id="przykłady-użycia-napisów-w-c">Przykłady użycia napisów w C</h4>
            <p><strong>Inicjalizacja i wypisanie napisu:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;stdio.h&gt;

int main() {
    char napis[] = "Witaj, świecie!";
    printf("%s\n", napis);
    return 0;
}</code></pre>
            </div>
            </p>
            <p><strong>Łączenie dwóch napisów:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
    char napis1[50] = "Witaj, ";
    char napis2[] = "świecie!";

    strcat(napis1, napis2);

    printf("%s\n", napis1); // "Witaj, świecie!"
    return 0;
}</code></pre>
            </div>
            </p>
            <p><strong>Obliczanie długości napisu:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
    char napis[] = "Programowanie";
    size_t dlugosc = strlen(napis);

    printf("Długość napisu: %zu\n", dlugosc);
    return 0;
}</code></pre>
            </div>
            </p>
            <p><strong>Porównywanie dwóch napisów:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
    char napis1[] = "ABC";
    char napis2[] = "ABC";

    if (strcmp(napis1, napis2) == 0) {
        printf("Napisy są identyczne.\n");
    } else {
        printf("Napisy są różne.\n");
    }
    return 0;
}</code></pre>
            </div>
            </p>
            <h4 id="zarządzanie-pamięcią-i-bezpieczeństwo">Zarządzanie pamięcią i bezpieczeństwo</h4>
            <p>Podczas pracy z napisami w C należy zwrócić szczególną uwagę na alokację pamięci i zarządzanie buforami. Błędy takie jak przepełnienie bufora mogą prowadzić do poważnych luk bezpieczeństwa, w tym możliwości wykonania złośliwego kodu.</p>
            <p>Aby uniknąć takich problemów:</p>
            <ul>
                <li><strong>Zawsze sprawdzaj długości napisów</strong> przed kopiowaniem lub łączeniem, aby zapobiec błędom przepełnienia bufora i zapewnić bezpieczeństwo pamięci.</li>
                <li><strong>Używaj bezpiecznych funkcji</strong> lub bibliotek, które automatycznie zarządzają pamięcią, aby uniknąć ręcznego zarządzania wskaźnikami i potencjalnych błędów.</li>
                <li><strong>Rozważ użycie dynamicznej alokacji pamięci</strong>, jeśli rozmiar napisu nie jest znany z góry, co pozwala na bardziej elastyczne zarządzanie pamięcią w programie.</li>
            </ul>
            <h3 id="napisy-w-języku-c-std-string-">Napisy w języku C++ (<code>std::string</code>)</h3>
            <p>Chociaż język C++ jest zgodny z C i pozwala na użycie tradycyjnych C-stringów, oferuje również bardziej zaawansowaną i bezpieczniejszą klasę <code>std::string</code> do reprezentacji napisów. Klasa ta jest częścią standardowej biblioteki C++ i znajduje się w nagłówku <code>&lt;string&gt;</code>.</p>
            <h4 id="zalety-użycia-std-string">Zalety użycia <code>std::string</code></h4>
            <ul>
                <li><strong><code>std::string</code> automatycznie zarządza alokacją i dealokacją pamięci</strong>, co zmniejsza ryzyko wystąpienia błędów, takich jak wycieki pamięci, dzięki czemu program jest bardziej bezpieczny i stabilny.</li>
                <li><strong>Metody klasy <code>std::string</code> zazwyczaj sprawdzają granice buforów</strong>, co chroni przed błędami przepełnienia bufora, zwiększając bezpieczeństwo operacji na napisach.</li>
                <li><strong>Klasa <code>std::string</code> oferuje bogatą funkcjonalność</strong>, w tym metody do takich operacji jak konkatenacja, wyszukiwanie, czy zamiana podłańcuchów, co upraszcza manipulację tekstem.</li>
                <li><strong><code>std::string</code> jest dobrze zintegrowany z innymi komponentami STL</strong>, co pozwala na jego efektywne użycie z kontenerami i algorytmami biblioteki standardowej C++.</li>
            </ul>
            <h4 id="tworzenie-i-inicjalizacja-std-string">Tworzenie i inicjalizacja <code>std::string</code></h4>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;string&gt;

std::string napis1; // Pusty napis
std::string napis2("Ala ma kota"); // Inicjalizacja napisem
std::string napis3(napis2); // Kopia istniejącego napisu</code></pre>
            </div>
            </p>
            <h4 id="podstawowe-operacje-na-std-string">Podstawowe operacje na <code>std::string</code></h4>
            <p>I. <strong>Dodawanie napisów:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">std::string napis1 = "Ala";
std::string napis2 = " ma kota";
std::string wynik = napis1 + napis2; // "Ala ma kota"</code></pre>
            </div>
            </p>
            <p>II. <strong>Dostęp do znaków:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">char znak = napis1[0]; // 'A'
napis1[0] = 'E'; // napis1 teraz to "Ela"</code></pre>
            </div>
            </p>
            <p><strong>Uwaga:</strong> Dostęp poza granicami napisu (<code>napis1.at(index)</code>) generuje wyjątek <code>std::out_of_range</code>.</p>
            <p>III. <strong>Pobieranie długości napisu:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">size_t dlugosc = napis1.length();</code></pre>
            </div>
            </p>
            <p>IV. <strong>Porównywanie napisów:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">if (napis1 == napis2) {
// Napisy są identyczne
}</code></pre>
            </div>
            </p>
            <p>V. <strong>Wyszukiwanie w napisie:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">size_t pozycja = napis1.find("ma");
if (pozycja != std::string::npos) {
// Znaleziono podnapis
}</code></pre>
            </div>
            </p>
            <p>VI. <strong>Zamiana podnapisu:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">napis1.replace(0, 3, "Ola"); // Zamienia pierwsze 3 znaki na "Ola"</code></pre>
            </div>
            </p>
            <p>VII. <strong>Wydzielanie podnapisu:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">std::string podnapis = napis1.substr(4, 2); // Wydziela 2 znaki od pozycji 4</code></pre>
            </div>
            </p>
            <h4 id="interoperacyjność-z-c-stringami">Interoperacyjność z C-stringami</h4>
            <p>Chociaż <code>std::string</code> jest wygodny w użyciu, czasami konieczna jest interakcja z kodem, który wymaga tradycyjnych C-stringów (np. funkcje biblioteki C). Klasa <code>std::string</code> udostępnia metodę <code>c_str()</code>, która zwraca wskaźnik do tablicy znaków zakończonej znakiem null:</p>
            <p>
            <div>
                <pre><code class="language-clike">const char *c_napis = napis1.c_str();</code></pre>
            </div>
            </p>
            <p><strong>Uwaga:</strong> Wskaźnik zwrócony przez <code>c_str()</code> jest ważny tylko do momentu zmodyfikowania napisu. Jeśli planujesz modyfikować napis po pobraniu wskaźnika, musisz skopiować ciąg znaków do osobnego bufora.</p>
            <h4 id="bezpieczeństwo-i-wydajność">Bezpieczeństwo i wydajność</h4>
            <ul>
                <li><strong><code>std::string</code> automatycznie zarządza pamięcią</strong>, jednak w przypadku operacji na bardzo dużych napisach lub częstych operacjach w pętlach, może to negatywnie wpływać na wydajność. W takich przypadkach warto z wyprzedzeniem zarezerwować pamięć za pomocą metody <code>reserve(size_t n);</code>, aby zminimalizować koszt dynamicznej alokacji.</li>
                <li>Metody klasy <code>std::string</code> mogą rzucać <strong>wyjątki</strong>, takie jak <code>std::bad_alloc</code> w przypadku braku pamięci czy <code>std::out_of_range</code> przy dostępie poza granicami. Ważne jest uwzględnienie tych wyjątków w kodzie, zwłaszcza w środowiskach, gdzie stabilność jest kluczowa.</li>
                <li>W C++11 i nowszych wersjach wprowadzono <strong>semantykę przenoszenia</strong>, co umożliwia efektywne przenoszenie zasobów zamiast ich kopiowania. Warto korzystać z konstruktorów i operatorów przenoszących, aby poprawić wydajność w miejscach, gdzie kopiowanie jest zbędne.</li>
            </ul>
            <h4 id="przykłady-użycia-std-string">Przykłady użycia <code>std::string</code></h4>
            <p><strong>Łączenie i manipulacja napisami:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
    std::string napis = "Ala ma kota";
    std::string napis2 = " i psa";

    // Połączenie napisów
    napis += napis2;

    std::cout &lt;&lt; napis &lt;&lt; std::endl; // "Ala ma kota i psa"

    // Zamiana fragmentu napisu
    napis.replace(4, 2, "nie ma");

    std::cout &lt;&lt; napis &lt;&lt; std::endl; // "Ala nie ma kota i psa"

    // Wyszukiwanie
    size_t pozycja = napis.find("kota");
    if (pozycja != std::string::npos) {
        std::cout &lt;&lt; "Znaleziono 'kota' na pozycji: " &lt;&lt; pozycja &lt;&lt; std::endl;
    }

    // Wydzielanie podnapisu
    std::string zwierze = napis.substr(pozycja, 4); // "kota"
    std::cout &lt;&lt; "Zwierzę: " &lt;&lt; zwierze &lt;&lt; std::endl;

    return 0;
}</code></pre>
            </div>
            </p>
            <p><strong>Konwersja liczb na napisy i odwrotnie:</strong></p>
            <p>W C++11 i nowszych dostępne są funkcje takie jak <code>std::to_string</code>, które ułatwiają konwersję liczb na napisy:</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
    int liczba = 42;
    std::string napis = "Liczba: " + std::to_string(liczba);

    std::cout &lt;&lt; napis &lt;&lt; std::endl; // "Liczba: 42"

    // Konwersja napisu na liczbę
    std::string liczba_napis = "123";
    int liczba2 = std::stoi(liczba_napis);

    std::cout &lt;&lt; "Liczba2: " &lt;&lt; liczba2 &lt;&lt; std::endl; // 123

    return 0;
}</code></pre>
            </div>
            </p>
            <h4 id="zaawansowane-operacje-na-napisach">Zaawansowane operacje na napisach</h4>
            <p>Operacje na napisach w C++ to kluczowy element przetwarzania tekstu, szczególnie w aplikacjach związanych z analizą danych, przetwarzaniem języka naturalnego oraz systemami wielojęzycznymi. Poniżej opisano kilka zaawansowanych technik operacji na napisach, które znacznie rozszerzają możliwości programisty.</p>
            <p>I. <strong>Wyrażenia regularne:</strong> </p>
            <p>W C++11 wprowadzono bibliotekę <code>&lt;regex&gt;</code>, która umożliwia manipulację napisami za pomocą wyrażeń regularnych. Jest to niezwykle potężne narzędzie, które pozwala na dopasowywanie wzorców, wyszukiwanie i manipulację fragmentami tekstu. Wyrażenia regularne mogą być stosowane do walidacji danych, ekstrakcji informacji oraz skomplikowanej manipulacji tekstu.</p>
            <p>Przykład poniżej demonstruje podstawową operację wyszukiwania dopasowań w tekście za pomocą wyrażenia regularnego. Program dopasowuje wzorzec, który identyfikuje kto posiada jakie zwierzę, a następnie wyświetla wyniki.</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;regex&gt;

int main() {
   std::string tekst = "Ala ma kota i psa";
   std::regex wzorzec("(\\w+) ma (\\w+)");
   std::smatch dopasowanie;
   
   if (std::regex_search(tekst, dopasowanie, wzorzec)) {
      std::cout &lt;&lt; "Dopasowanie: " &lt;&lt; dopasowanie[0] &lt;&lt; std::endl;
      std::cout &lt;&lt; "Osoba: " &lt;&lt; dopasowanie[1] &lt;&lt; std::endl;
      std::cout &lt;&lt; "Zwierzę: " &lt;&lt; dopasowanie[2] &lt;&lt; std::endl;
   }
   
   return 0;
}</code></pre>
            </div>
            </p>
            <p>Wyrażenia regularne umożliwiają również bardziej zaawansowane operacje, takie jak:</p>
            <ul>
                <li><strong>Wyrażenia regularne umożliwiają znajdowanie i zamienianie fragmentów tekstu</strong> na podstawie określonych wzorców, co jest przydatne w operacjach edycji i transformacji danych.</li>
                <li>Można wyszukiwać <strong>wielokrotne dopasowania w tekście</strong>, co pozwala na iteracyjne przeszukiwanie np. logów lub dokumentów, aby znaleźć wszystkie wystąpienia określonych wzorców.</li>
                <li><strong>Walidacja formatu</strong> jest możliwa dzięki wyrażeniom regularnym, które mogą być używane do sprawdzania poprawności danych takich jak adresy e-mail, numery telefonów czy inne dane o określonym formacie.</li>
            </ul>
            <p>II. <strong>Unicode i międzynarodowe napisy:</strong> </p>
            <p>W świecie globalizacji obsługa napisów w różnych kodowaniach jest kluczowa. Standard C++11 wprowadził wsparcie dla literałów Unicode, co umożliwia pracę z tekstem w takich kodowaniach jak UTF-8, UTF-16 i UTF-32. Jest to istotne przy tworzeniu aplikacji wielojęzycznych, gdzie wymagane jest poprawne wyświetlanie znaków z różnych alfabetów, takich jak cyrylica, chińskie znaki czy znaki diakrytyczne.</p>
            <p>Przykład wykorzystania literałów Unicode w C++:</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
   std::u16string tekst = u"Привет мир!";  // UTF-16
   std::u32string innyTekst = U"你好，世界！";  // UTF-32
   
   std::cout &lt;&lt; "Długość tekstu w UTF-16: " &lt;&lt; tekst.length() &lt;&lt; std::endl;
   std::cout &lt;&lt; "Długość tekstu w UTF-32: " &lt;&lt; innyTekst.length() &lt;&lt; std::endl;
   
   return 0;
}</code></pre>
            </div>
            </p>
            <p>Chociaż wsparcie dla Unicode w C++ jest wbudowane, manipulowanie takimi napisami może być wyzwaniem. Długość napisów w UTF-16 czy UTF-32 nie zawsze odpowiada liczbie znaków, ponieważ niektóre znaki mogą być kodowane jako wieloznakowe sekwencje. Dlatego w wielu przypadkach programiści sięgają po zewnętrzne biblioteki, takie jak ICU (International Components for Unicode), które oferują kompleksowe narzędzia do manipulacji napisami Unicode.</p>
            <p><strong>ICU (International Components for Unicode):</strong> ICU to popularna biblioteka open-source zapewniająca zaawansowane wsparcie dla międzynarodowych formatów tekstowych, sortowania według lokalnych porządków, konwersji kodowań, obsługi dat i liczb oraz innych aspektów pracy z wielojęzycznymi aplikacjami.</p>
            <p>III. <strong>Operacje na napisach za pomocą <code>std::string_view</code>:</strong> </p>
            <p><code>std::string_view</code> to typ dodany w C++17, który umożliwia efektywniejsze operacje na napisach bez kopiowania danych. <code>std::string_view</code> reprezentuje widok na fragment napisu (ciąg znaków), co pozwala na szybszą i bardziej pamięciooszczędną manipulację tekstem.</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;string_view&gt;

void wypisz_fragment(std::string_view tekst) {
   std::cout &lt;&lt; "Fragment tekstu: " &lt;&lt; tekst &lt;&lt; std::endl;
}

int main() {
   std::string calyTekst = "To jest długi tekst.";
   wypisz_fragment(std::string_view(calyTekst).substr(3, 7));  // "jest d"

   return 0;
}</code></pre>
            </div>
            </p>
            <p><code>std::string_view</code> jest idealny w sytuacjach, gdy chcemy jedynie analizować fragmenty tekstu bez potrzeby tworzenia nowych obiektów typu <code>std::string</code>. Jest to często wykorzystywane w sytuacjach, gdzie wydajność jest kluczowa, jak w analizie danych lub podczas operacji na dużych plikach tekstowych.</p>
            <p>IV. <strong>Biblioteki zewnętrzne do operacji na napisach:</strong> </p>
            <p>Chociaż standardowa biblioteka C++ oferuje bogate wsparcie dla operacji na napisach, czasem może okazać się niewystarczająca. W takich przypadkach, do bardziej zaawansowanych zastosowań, istnieje wiele zewnętrznych bibliotek, takich jak:</p>
            <ul>
                <li><strong>Boost.StringAlgo</strong> jest częścią biblioteki Boost i oferuje bogaty zestaw narzędzi do pracy z napisami, w tym funkcje do przeszukiwania, zamiany, transformacji oraz cięcia i dołączania tekstów, co zwiększa elastyczność operacji na ciągach znaków.</li>
                <li><strong>fmt</strong> to biblioteka do formatowania napisów, która zapewnia zaawansowane możliwości formatowania podobne do <code>printf</code>, ale oferuje bardziej bezpieczne i elastyczne podejście, zwiększając wygodę i bezpieczeństwo przy formatowaniu tekstów.</li>
                <li><strong>ICU (International Components for Unicode)</strong> to jedna z najbardziej zaawansowanych bibliotek do pracy z napisami Unicode oraz międzynarodowymi formatami tekstowymi, co czyni ją niezbędnym narzędziem w aplikacjach wielojęzycznych.</li>
            </ul>
        </section>
        <div id="table-of-contents">
            <h2>Spis Treści</h2>
            <ol><a href="#napisy-w-języku-c-i-c-">Napisy w języku C i C++</a>
                <ol>
                    <li><a href="#napisy-w-języku-c-c-string-">Napisy w języku C (C-string)</a>
                        <ol>
                            <li><a href="#deklaracja-i-inicjalizacja-napisów-w-c">Deklaracja i inicjalizacja napisów w C</a></li>
                            <li><a href="#znaczenie-znaku-null">Znaczenie znaku null</a></li>
                            <li><a href="#operacje-na-napisach-w-c">Operacje na napisach w C</a></li>
                            <li><a href="#przykłady-użycia-napisów-w-c">Przykłady użycia napisów w C</a></li>
                            <li><a href="#zarządzanie-pamięcią-i-bezpieczeństwo">Zarządzanie pamięcią i bezpieczeństwo</a></li>
                        </ol>
                    </li>
                    <li><a href="#napisy-w-języku-c-std-string-">Napisy w języku C++ (std::string)</a>
                        <ol>
                            <li><a href="#zalety-użycia-std-string">Zalety użycia std::string</a></li>
                            <li><a href="#tworzenie-i-inicjalizacja-std-string">Tworzenie i inicjalizacja std::string</a></li>
                            <li><a href="#podstawowe-operacje-na-std-string">Podstawowe operacje na std::string</a></li>
                            <li><a href="#interoperacyjność-z-c-stringami">Interoperacyjność z C-stringami</a></li>
                            <li><a href="#bezpieczeństwo-i-wydajność">Bezpieczeństwo i wydajność</a></li>
                            <li><a href="#przykłady-użycia-std-string">Przykłady użycia std::string</a></li>
                            <li><a href="#zaawansowane-operacje-na-napisach">Zaawansowane operacje na napisach</a></li>
                        </ol>
                    </li>
                </ol>
            </ol>
            <div id="related-articles">
                <h2>Related Articles</h2>
                <ol>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/01_proces_kompilacji.html">Proces Kompilacji</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/02_preprocesor.html">Preprocesor</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/03_zmienne_i_typy_danych.html">Zmienne i Typy Danych</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/04_interakcja_z_konsola.html">Interakcja z Konsola</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/05_instrukcja_warunkowa.html">Instrukcja Warunkowa</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/06_petle.html">Petle</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/07_liczby_losowe.html">Liczby Losowe</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/08_typ_wyliczeniowy.html">Typ Wyliczeniowy</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/09_funkcje.html">Funkcje</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/10_l_wartosci_r_wartosci.html">L Wartosci R Wartosci</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/11_wskazniki.html">Wskazniki</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/12_tablice.html">Tablice</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/13_napisy.html">Napisy</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/14_operacje_bitowe.html">Operacje Bitowe</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/15_programowanie_obietkowe.html">Programowanie Obietkowe</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/16_dziedziczenie.html">Dziedziczenie</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/17_zaawansowane_wskazniki.html">Zaawansowane Wskazniki</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/18_przeciazanie.html">Przeciazanie</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/19_konwersje.html">Konwersje</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/20_lambdy.html">Lambdy</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/21_szablony.html">Szablony</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/22_wyjatki.html">Wyjatki</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/23_stl.html">Stl</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/24_praca_z_plikami.html">Praca z Plikami</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/25_c_vs_cpp.html">C vs Cpp</a></li>
                </ol>
            </div>
        </div>
    </div>
    <footer>
        <div class="footer-columns">
            <div class="footer-column">
                <img alt="Adam Djellouli Symbol" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/symbol.png" />
            </div>
            <div class="footer-column">
                <h2><a href="https://adamdjellouli.com/core/privacy_policy.html" title="Privacy Policy">Our Privacy Policy</a></h2>
                <p>Thank you for visiting my personal website. All content here is free to use, but please remember to be respectful and avoid any misuse of the site. If you’d like to get in touch, feel free to reach out via my <a href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" title="LinkedIn Profile">LinkedIn profile</a> or connect with me on <a href="https://github.com/djeada" title="GitHub Profile">GitHub</a> if you have technical questions or ideas to share. Wishing you all the best and a fantastic life ahead!</p>
            </div>
            <div class="footer-column">
                <h2>Follow me</h2>
                <ul class="social-media">
                    <li>
                        <a class="fa fa-youtube" href="https://www.youtube.com/channel/UCGPoHTVjMN77wcGknXPHl1Q" target="_blank" title="YouTube">
                        </a>YouTube
                    </li>
                    <li>
                        <a class="fa fa-linkedin" href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" target="_blank" title="LinkedIn">
                        </a>LinkedIn
                    </li>
                    <li>
                        <a class="fa fa-instagram" href="https://www.instagram.com/linuxchallenges/" target="_blank" title="Instagram">
                        </a>Instagram
                    </li>
                    <li>
                        <a class="fa fa-github" href="https://github.com/djeada" title="GitHub">
                        </a>Github
                    </li>
                </ul>
            </div>
        </div>
        <div>
            <p id="copyright">
                © Adam Djellouli. All rights reserved.
            </p>
        </div>
        <script>
            document.getElementById("copyright").innerHTML = "&copy; " + new Date().getFullYear() + " Adam Djellouli. All rights reserved.";
        </script>
        <script src="../../app.js"></script>
    </footer>
    <div id="pdf-spinner-overlay">
        <div class="spinner"></div>
    </div>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-bash.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-cpp.min.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
jax: ["input/TeX", "output/HTML-CSS"],
extensions: ["tex2jax.js"],
"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] },
tex2jax: { inlineMath: [ ["$", "$"] ], displayMath: [ ["$$","$$"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
TeX: { noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } } },
messageStyle: "none"
});
</script>
<script async="" id="MathJax-script" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>

</html>