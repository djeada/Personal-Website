<!DOCTYPE html>

<html lang="pl">
<head>
<script async="" crossorigin="anonymous" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5593122079896089"></script>
<meta charset="utf-8"/>
<title>Napisy w jzyku C i C++</title>
<meta content="Napisy s fundamentalnym elementem wielu aplikacji programistycznych, su偶c do przechowywania i manipulacji tekstem, takim jak dane wejciowe u偶ytkownika, komunikaty systemowe, informacje o bdach i wiele innych." name="description"/>
<meta content="Adam Djellouli" name="author"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<link crossorigin="" href="https://fonts.googleapis.com" rel="preconnect"/>
<link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.0/themes/prism.min.css" rel="stylesheet"/>
<link href="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/icon.ico" rel="icon"/>
<link href="../../resources/style.css" rel="stylesheet"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
</head>
<body><nav aria-label="Main navigation">
<a class="logo" href="https://adamdjellouli.com">
<img alt="Adam Djellouli - Home Page Logo" id="logo-image" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/logo.PNG"/>
</a>
<input aria-label="Toggle navigation menu" id="navbar-toggle" type="checkbox"/>
<ul aria-labelledby="navbar-toggle" role="menu">
<li role="menuitem">
<a href="../../index.html" title="Go to Home Page"> Home </a>
</li>
<li role="menuitem">
<a class="active" href="../../core/blog.html" title="Read Adam Djellouli Blog on Programming and Technology"> Blog </a>
</li>
<li role="menuitem">
<a href="../../core/tools.html" title="Discover Tools Created by Adam Djellouli"> Tools </a>
</li>
<li role="menuitem">
<a href="../../core/projects.html" title="Explore Projects Developed by Adam Djellouli"> Projects </a>
</li>
<li role="menuitem">
<a href="../../core/resume.html" title="View Adam Djellouli Professional Resume"> Resume </a>
</li>
<li>
<script async="" src="https://cse.google.com/cse.js?cx=8160ef9bb935f4f68"></script>
<div class="gcse-search"></div>
</li>
<li>
<button aria-label="Toggle dark mode" id="dark-mode-button"></button>
</li>
</ul>
</nav>
<div id="article-wrapper"><article-section id="article-body">
<p style="text-align: right;"><i>Last modified: December 25, 2025</i></p>
<p style="text-align: right;"><i>This article is written in: 叼</i></p>
<h2 id="napisy-w-jzyku-c-i-c-">Napisy w jzyku C i C++</h2>
<p>Napisy s fundamentalnym elementem wielu aplikacji programistycznych, su偶c do przechowywania i manipulacji tekstem, takim jak dane wejciowe u偶ytkownika, komunikaty systemowe, informacje o bdach i wiele innych. W jzykach C i C++, napisy s reprezentowane na r贸偶ne sposoby, co wynika z ewolucji tych jzyk贸w oraz d偶enia do zwikszenia bezpieczestwa i atwoci u偶ycia.</p>
<h3 id="napisy-w-jzyku-c-c-string-">Napisy w jzyku C (C-string)</h3>
<p>W jzyku C napisy s reprezentowane jako tablice znak贸w typu <code>char</code>, zakoczone specjalnym znakiem <code>'\0'</code>, znanym jako znak null (null terminator). Ten znak wskazuje koniec napisu i pozwala funkcjom bibliotecznym na okrelenie dugoci napisu w czasie wykonania.</p>
<h4 id="deklaracja-i-inicjalizacja-napis贸w-w-c">Deklaracja i inicjalizacja napis贸w w C</h4>
<p>Istnieje kilka sposob贸w deklarowania i inicjalizacji napis贸w w C:</p>
<p>I. <strong>Wska藕nik do staego acucha znak贸w:</strong></p>
<p><div><pre><code class="language-clike">const char *napisA = "Ala ma kota";</code></pre></div></p>
<p>W tym przypadku <code>napisA</code> jest wska藕nikiem do staego acucha znak贸w przechowywanego w pamici tylko do odczytu (zazwyczaj w segmencie tekstowym programu). Pr贸ba modyfikacji tego napisu prowadzi do niezdefiniowanego zachowania.</p>
<p>II. <strong>Tablica znak贸w z inicjalizacj literaem:</strong></p>
<p><div><pre><code class="language-clike">char napisB[] = "Ala ma kota";</code></pre></div></p>
<p>Tutaj <code>napisB</code> jest tablic znak贸w, kt贸ra jest kopi literau napisu. Ta tablica mo偶e by modyfikowana, poniewa偶 jest przechowywana w pamici dostpnej do zapisu (zazwyczaj na stosie lub w pamici dynamicznej).</p>
<p>III. <strong>Tablica znak贸w z inicjalizacj list znak贸w:</strong></p>
<p><div><pre><code class="language-clike">char napisC[] = {'A', 'l', 'a', ' ', 'm', 'a', ' ', 'k', 'o', 't', 'a', '\0'};</code></pre></div></p>
<p>Ten spos贸b jest r贸wnowa偶ny poprzedniemu, ale wymaga jawnego dodania znaku null na kocu tablicy.</p>
<h4 id="znaczenie-znaku-null">Znaczenie znaku null</h4>
<p>Znak null <code>'\0'</code> jest kluczowy w reprezentacji napis贸w w C. Funkcje biblioteczne operujce na napisach zakadaj, 偶e napisy s zakoczone tym znakiem. Brak znaku null mo偶e prowadzi do bd贸w, takich jak odczyt poza granicami tablicy (buffer overrun), co mo偶e skutkowa naruszeniem ochrony pamici i awari programu.</p>
<h4 id="operacje-na-napisach-w-c">Operacje na napisach w C</h4>
<p>Jzyk C dostarcza bogaty zestaw funkcji w standardowych bibliotekach do manipulacji napisami. Kluczowe biblioteki to <code>&lt;string.h&gt;</code>, <code>&lt;ctype.h&gt;</code> i <code>&lt;stdlib.h&gt;</code>.</p>
<h5>Biblioteka <code>&lt;string.h&gt;</code></h5>
<p>Funkcje w tej bibliotece su偶 do manipulacji i por贸wnywania napis贸w:</p>
<p>
<table><tr><td>Funkcja</td><td>Opis</td></tr><tr><td><code>size_t strlen(const char *s);</code></td><td>Zwraca dugo napisu <code>s</code>, czyli liczb znak贸w przed znakiem null.</td></tr><tr><td><code>char *strcpy(char *dest, const char *src);</code></td><td>Kopiuje napis <code>src</code> do bufora <code>dest</code>. Uwaga: <code>dest</code> musi mie wystarczajcy rozmiar, aby pomieci <code>src</code>.</td></tr><tr><td><code>char *strncpy(char *dest, const char *src, size_t n);</code></td><td>Kopiuje maksymalnie <code>n</code> znak贸w z <code>src</code> do <code>dest</code>.</td></tr><tr><td><code>char *strcat(char *dest, const char *src);</code></td><td>Docza napis <code>src</code> do koca <code>dest</code>. <code>dest</code> musi mie wystarczajcy rozmiar.</td></tr><tr><td><code>char *strncat(char *dest, const char *src, size_t n);</code></td><td>Docza maksymalnie <code>n</code> znak贸w z <code>src</code> do <code>dest</code>.</td></tr><tr><td><code>int strcmp(const char *s1, const char *s2);</code></td><td>Por贸wnuje napisy <code>s1</code> i <code>s2</code>. Zwraca warto ujemn, zero lub dodatni w zale偶noci od wyniku por贸wnania.</td></tr><tr><td><code>int strncmp(const char *s1, const char *s2, size_t n);</code></td><td>Por贸wnuje maksymalnie <code>n</code> znak贸w z <code>s1</code> i <code>s2</code>.</td></tr><tr><td><code>char *strchr(const char *s, int c);</code></td><td>Wyszukuje pierwsze wystpienie znaku <code>c</code> w napisie <code>s</code>.</td></tr><tr><td><code>char *strrchr(const char *s, int c);</code></td><td>Wyszukuje ostatnie wystpienie znaku <code>c</code> w napisie <code>s</code>.</td></tr><tr><td><code>char *strstr(const char *haystack, const char *needle);</code></td><td>Wyszukuje podcig <code>needle</code> w napisie <code>haystack</code>.</td></tr></table>
</p>
<p><strong>Uwaga dotyczca bezpieczestwa:</strong> Funkcje takie jak <code>strcpy</code> i <code>strcat</code> s podatne na bdy przepenienia bufora (buffer overflow) i nie powinny by u偶ywane w nowym kodzie. Bezpieczniejsze alternatywy to <code>strncpy</code> i <code>strncat</code>, jednak one r贸wnie偶 maj swoje ograniczenia. W praktyce zaleca si korzystanie z funkcji takich jak <code>strlcpy</code> i <code>strlcat</code> (jeli s dostpne) lub funkcji specyficznych dla danego systemu operacyjnego.</p>
<h5>Biblioteka <code>&lt;ctype.h&gt;</code></h5>
<p>Ta biblioteka zawiera funkcje do klasyfikacji i manipulacji znakami:</p>
<p>
<table><tr><td>Funkcja</td><td>Opis</td></tr><tr><td><code>int isalpha(int c);</code></td><td>Sprawdza, czy znak <code>c</code> jest liter alfabetu.</td></tr><tr><td><code>int isdigit(int c);</code></td><td>Sprawdza, czy znak <code>c</code> jest cyfr.</td></tr><tr><td><code>int isalnum(int c);</code></td><td>Sprawdza, czy znak <code>c</code> jest alfanumeryczny.</td></tr><tr><td><code>int isspace(int c);</code></td><td>Sprawdza, czy znak <code>c</code> jest znakiem biaym (spacja, tabulacja, nowa linia itp.).</td></tr><tr><td><code>int toupper(int c);</code></td><td>Konwertuje znak <code>c</code> do wielkiej litery, jeli to mo偶liwe.</td></tr><tr><td><code>int tolower(int c);</code></td><td>Konwertuje znak <code>c</code> do maej litery, jeli to mo偶liwe.</td></tr></table>
</p>
<h5>Biblioteka <code>&lt;stdlib.h&gt;</code></h5>
<p>Zawiera funkcje do konwersji napis贸w na wartoci liczbowe i odwrotnie:</p>
<p>
<table><tr><td>Funkcja</td><td>Opis</td></tr><tr><td><code>int atoi(const char *nptr);</code></td><td>Konwertuje napis <code>nptr</code> na warto <code>int</code>.</td></tr><tr><td><code>long int strtol(const char *nptr, char **endptr, int base);</code></td><td>Konwertuje napis <code>nptr</code> na warto <code>long int</code>, z mo偶liwoci okrelenia podstawy systemu liczbowego.</td></tr><tr><td><code>double atof(const char *nptr);</code></td><td>Konwertuje napis <code>nptr</code> na warto <code>double</code>.</td></tr><tr><td><code>double strtod(const char *nptr, char **endptr);</code></td><td>Konwertuje napis <code>nptr</code> na warto <code>double</code>, zwracajc wska藕nik do pierwszego znaku po liczbie w <code>*endptr</code>.</td></tr><tr><td><code>char *strtok(char *str, const char *delim);</code></td><td>Dzieli napis <code>str</code> na tokeny, u偶ywajc separator贸w zdefiniowanych w <code>delim</code>.</td></tr></table>
</p>
<p><strong>Uwaga dotyczca bezpieczestwa:</strong> Funkcja <code>atoi</code> nie obsuguje bd贸w i nie jest bezpieczna. Zaleca si u偶ycie <code>strtol</code> lub <code>strtod</code>, kt贸re pozwalaj na wykrycie bd贸w konwersji.</p>
<h4 id="przykady-u偶ycia-napis贸w-w-c">Przykady u偶ycia napis贸w w C</h4>
<p><strong>Inicjalizacja i wypisanie napisu:</strong></p>
<p><div><pre><code class="language-clike">#include &lt;stdio.h&gt;

int main() {
    char napis[] = "Witaj, wiecie!";
    printf("%s\n", napis);
    return 0;
}</code></pre></div></p>
<p><strong>czenie dw贸ch napis贸w:</strong></p>
<p><div><pre><code class="language-clike">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
    char napis1[50] = "Witaj, ";
    char napis2[] = "wiecie!";

    strcat(napis1, napis2);

    printf("%s\n", napis1); // "Witaj, wiecie!"
    return 0;
}</code></pre></div></p>
<p><strong>Obliczanie dugoci napisu:</strong></p>
<p><div><pre><code class="language-clike">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
    char napis[] = "Programowanie";
    size_t dlugosc = strlen(napis);

    printf("Dugo napisu: %zu\n", dlugosc);
    return 0;
}</code></pre></div></p>
<p><strong>Por贸wnywanie dw贸ch napis贸w:</strong></p>
<p><div><pre><code class="language-clike">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
    char napis1[] = "ABC";
    char napis2[] = "ABC";

    if (strcmp(napis1, napis2) == 0) {
        printf("Napisy s identyczne.\n");
    } else {
        printf("Napisy s r贸偶ne.\n");
    }
    return 0;
}</code></pre></div></p>
<h4 id="zarzdzanie-pamici-i-bezpieczestwo">Zarzdzanie pamici i bezpieczestwo</h4>
<p>Podczas pracy z napisami w C nale偶y zwr贸ci szczeg贸ln uwag na alokacj pamici i zarzdzanie buforami. Bdy takie jak przepenienie bufora mog prowadzi do powa偶nych luk bezpieczestwa, w tym mo偶liwoci wykonania zoliwego kodu.</p>
<p>Aby unikn takich problem贸w:</p>
<ul>
<li><strong>Zawsze sprawdzaj dugoci napis贸w</strong> przed kopiowaniem lub czeniem, aby zapobiec bdom przepenienia bufora i zapewni bezpieczestwo pamici.</li>
<li><strong>U偶ywaj bezpiecznych funkcji</strong> lub bibliotek, kt贸re automatycznie zarzdzaj pamici, aby unikn rcznego zarzdzania wska藕nikami i potencjalnych bd贸w.</li>
<li><strong>Rozwa偶 u偶ycie dynamicznej alokacji pamici</strong>, jeli rozmiar napisu nie jest znany z g贸ry, co pozwala na bardziej elastyczne zarzdzanie pamici w programie.</li>
</ul>
<h3 id="napisy-w-jzyku-c-std-string-">Napisy w jzyku C++ (<code>std::string</code>)</h3>
<p>Chocia偶 jzyk C++ jest zgodny z C i pozwala na u偶ycie tradycyjnych C-string贸w, oferuje r贸wnie偶 bardziej zaawansowan i bezpieczniejsz klas <code>std::string</code> do reprezentacji napis贸w. Klasa ta jest czci standardowej biblioteki C++ i znajduje si w nag贸wku <code>&lt;string&gt;</code>.</p>
<h4 id="zalety-u偶ycia-std-string">Zalety u偶ycia <code>std::string</code></h4>
<ul>
<li><strong><code>std::string</code> automatycznie zarzdza alokacj i dealokacj pamici</strong>, co zmniejsza ryzyko wystpienia bd贸w, takich jak wycieki pamici, dziki czemu program jest bardziej bezpieczny i stabilny.</li>
<li><strong>Metody klasy <code>std::string</code> zazwyczaj sprawdzaj granice bufor贸w</strong>, co chroni przed bdami przepenienia bufora, zwikszajc bezpieczestwo operacji na napisach.</li>
<li><strong>Klasa <code>std::string</code> oferuje bogat funkcjonalno</strong>, w tym metody do takich operacji jak konkatenacja, wyszukiwanie, czy zamiana podacuch贸w, co upraszcza manipulacj tekstem.</li>
<li><strong><code>std::string</code> jest dobrze zintegrowany z innymi komponentami STL</strong>, co pozwala na jego efektywne u偶ycie z kontenerami i algorytmami biblioteki standardowej C++.</li>
</ul>
<h4 id="tworzenie-i-inicjalizacja-std-string">Tworzenie i inicjalizacja <code>std::string</code></h4>
<p><div><pre><code class="language-clike">#include &lt;string&gt;

std::string napis1; // Pusty napis
std::string napis2("Ala ma kota"); // Inicjalizacja napisem
std::string napis3(napis2); // Kopia istniejcego napisu</code></pre></div></p>
<h4 id="podstawowe-operacje-na-std-string">Podstawowe operacje na <code>std::string</code></h4>
<p>I. <strong>Dodawanie napis贸w:</strong></p>
<p><div><pre><code class="language-clike">std::string napis1 = "Ala";
std::string napis2 = " ma kota";
std::string wynik = napis1 + napis2; // "Ala ma kota"</code></pre></div></p>
<p>II. <strong>Dostp do znak贸w:</strong></p>
<p><div><pre><code class="language-clike">char znak = napis1[0]; // 'A'
napis1[0] = 'E'; // napis1 teraz to "Ela"</code></pre></div></p>
<p><strong>Uwaga:</strong> Dostp poza granicami napisu (<code>napis1.at(index)</code>) generuje wyjtek <code>std::out_of_range</code>.</p>
<p>III. <strong>Pobieranie dugoci napisu:</strong></p>
<p><div><pre><code class="language-clike">size_t dlugosc = napis1.length();</code></pre></div></p>
<p>IV. <strong>Por贸wnywanie napis贸w:</strong></p>
<p><div><pre><code class="language-clike">if (napis1 == napis2) {
// Napisy s identyczne
}</code></pre></div></p>
<p>V. <strong>Wyszukiwanie w napisie:</strong></p>
<p><div><pre><code class="language-clike">size_t pozycja = napis1.find("ma");
if (pozycja != std::string::npos) {
// Znaleziono podnapis
}</code></pre></div></p>
<p>VI. <strong>Zamiana podnapisu:</strong></p>
<p><div><pre><code class="language-clike">napis1.replace(0, 3, "Ola"); // Zamienia pierwsze 3 znaki na "Ola"</code></pre></div></p>
<p>VII. <strong>Wydzielanie podnapisu:</strong></p>
<p><div><pre><code class="language-clike">std::string podnapis = napis1.substr(4, 2); // Wydziela 2 znaki od pozycji 4</code></pre></div></p>
<h4 id="interoperacyjno-z-c-stringami">Interoperacyjno z C-stringami</h4>
<p>Chocia偶 <code>std::string</code> jest wygodny w u偶yciu, czasami konieczna jest interakcja z kodem, kt贸ry wymaga tradycyjnych C-string贸w (np. funkcje biblioteki C). Klasa <code>std::string</code> udostpnia metod <code>c_str()</code>, kt贸ra zwraca wska藕nik do tablicy znak贸w zakoczonej znakiem null:</p>
<p><div><pre><code class="language-clike">const char *c_napis = napis1.c_str();</code></pre></div></p>
<p><strong>Uwaga:</strong> Wska藕nik zwr贸cony przez <code>c_str()</code> jest wa偶ny tylko do momentu zmodyfikowania napisu. Jeli planujesz modyfikowa napis po pobraniu wska藕nika, musisz skopiowa cig znak贸w do osobnego bufora.</p>
<h4 id="bezpieczestwo-i-wydajno">Bezpieczestwo i wydajno</h4>
<ul>
<li><strong><code>std::string</code> automatycznie zarzdza pamici</strong>, jednak w przypadku operacji na bardzo du偶ych napisach lub czstych operacjach w ptlach, mo偶e to negatywnie wpywa na wydajno. W takich przypadkach warto z wyprzedzeniem zarezerwowa pami za pomoc metody <code>reserve(size_t n);</code>, aby zminimalizowa koszt dynamicznej alokacji.</li>
<li>Metody klasy <code>std::string</code> mog rzuca <strong>wyjtki</strong>, takie jak <code>std::bad_alloc</code> w przypadku braku pamici czy <code>std::out_of_range</code> przy dostpie poza granicami. Wa偶ne jest uwzgldnienie tych wyjtk贸w w kodzie, zwaszcza w rodowiskach, gdzie stabilno jest kluczowa.</li>
<li>W C++11 i nowszych wersjach wprowadzono <strong>semantyk przenoszenia</strong>, co umo偶liwia efektywne przenoszenie zasob贸w zamiast ich kopiowania. Warto korzysta z konstruktor贸w i operator贸w przenoszcych, aby poprawi wydajno w miejscach, gdzie kopiowanie jest zbdne.</li>
</ul>
<h4 id="przykady-u偶ycia-std-string">Przykady u偶ycia <code>std::string</code></h4>
<p><strong>czenie i manipulacja napisami:</strong></p>
<p><div><pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
    std::string napis = "Ala ma kota";
    std::string napis2 = " i psa";

    // Poczenie napis贸w
    napis += napis2;

    std::cout &lt;&lt; napis &lt;&lt; std::endl; // "Ala ma kota i psa"

    // Zamiana fragmentu napisu
    napis.replace(4, 2, "nie ma");

    std::cout &lt;&lt; napis &lt;&lt; std::endl; // "Ala nie ma kota i psa"

    // Wyszukiwanie
    size_t pozycja = napis.find("kota");
    if (pozycja != std::string::npos) {
        std::cout &lt;&lt; "Znaleziono 'kota' na pozycji: " &lt;&lt; pozycja &lt;&lt; std::endl;
    }

    // Wydzielanie podnapisu
    std::string zwierze = napis.substr(pozycja, 4); // "kota"
    std::cout &lt;&lt; "Zwierz: " &lt;&lt; zwierze &lt;&lt; std::endl;

    return 0;
}</code></pre></div></p>
<p><strong>Konwersja liczb na napisy i odwrotnie:</strong></p>
<p>W C++11 i nowszych dostpne s funkcje takie jak <code>std::to_string</code>, kt贸re uatwiaj konwersj liczb na napisy:</p>
<p><div><pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
    int liczba = 42;
    std::string napis = "Liczba: " + std::to_string(liczba);

    std::cout &lt;&lt; napis &lt;&lt; std::endl; // "Liczba: 42"

    // Konwersja napisu na liczb
    std::string liczba_napis = "123";
    int liczba2 = std::stoi(liczba_napis);

    std::cout &lt;&lt; "Liczba2: " &lt;&lt; liczba2 &lt;&lt; std::endl; // 123

    return 0;
}</code></pre></div></p>
<h4 id="zaawansowane-operacje-na-napisach">Zaawansowane operacje na napisach</h4>
<p>Operacje na napisach w C++ to kluczowy element przetwarzania tekstu, szczeg贸lnie w aplikacjach zwizanych z analiz danych, przetwarzaniem jzyka naturalnego oraz systemami wielojzycznymi. Poni偶ej opisano kilka zaawansowanych technik operacji na napisach, kt贸re znacznie rozszerzaj mo偶liwoci programisty.</p>
<p>I. <strong>Wyra偶enia regularne:</strong> </p>
<p>W C++11 wprowadzono bibliotek <code>&lt;regex&gt;</code>, kt贸ra umo偶liwia manipulacj napisami za pomoc wyra偶e regularnych. Jest to niezwykle pot偶ne narzdzie, kt贸re pozwala na dopasowywanie wzorc贸w, wyszukiwanie i manipulacj fragmentami tekstu. Wyra偶enia regularne mog by stosowane do walidacji danych, ekstrakcji informacji oraz skomplikowanej manipulacji tekstu.</p>
<p>Przykad poni偶ej demonstruje podstawow operacj wyszukiwania dopasowa w tekcie za pomoc wyra偶enia regularnego. Program dopasowuje wzorzec, kt贸ry identyfikuje kto posiada jakie zwierz, a nastpnie wywietla wyniki.</p>
<p><div><pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;regex&gt;

int main() {
   std::string tekst = "Ala ma kota i psa";
   std::regex wzorzec("(\\w+) ma (\\w+)");
   std::smatch dopasowanie;
   
   if (std::regex_search(tekst, dopasowanie, wzorzec)) {
      std::cout &lt;&lt; "Dopasowanie: " &lt;&lt; dopasowanie[0] &lt;&lt; std::endl;
      std::cout &lt;&lt; "Osoba: " &lt;&lt; dopasowanie[1] &lt;&lt; std::endl;
      std::cout &lt;&lt; "Zwierz: " &lt;&lt; dopasowanie[2] &lt;&lt; std::endl;
   }
   
   return 0;
}</code></pre></div></p>
<p>Wyra偶enia regularne umo偶liwiaj r贸wnie偶 bardziej zaawansowane operacje, takie jak:</p>
<ul>
<li><strong>Wyra偶enia regularne umo偶liwiaj znajdowanie i zamienianie fragment贸w tekstu</strong> na podstawie okrelonych wzorc贸w, co jest przydatne w operacjach edycji i transformacji danych.</li>
<li>Mo偶na wyszukiwa <strong>wielokrotne dopasowania w tekcie</strong>, co pozwala na iteracyjne przeszukiwanie np. log贸w lub dokument贸w, aby znale藕 wszystkie wystpienia okrelonych wzorc贸w.</li>
<li><strong>Walidacja formatu</strong> jest mo偶liwa dziki wyra偶eniom regularnym, kt贸re mog by u偶ywane do sprawdzania poprawnoci danych takich jak adresy e-mail, numery telefon贸w czy inne dane o okrelonym formacie.</li>
</ul>
<p>II. <strong>Unicode i midzynarodowe napisy:</strong> </p>
<p>W wiecie globalizacji obsuga napis贸w w r贸偶nych kodowaniach jest kluczowa. Standard C++11 wprowadzi wsparcie dla litera贸w Unicode, co umo偶liwia prac z tekstem w takich kodowaniach jak UTF-8, UTF-16 i UTF-32. Jest to istotne przy tworzeniu aplikacji wielojzycznych, gdzie wymagane jest poprawne wywietlanie znak贸w z r贸偶nych alfabet贸w, takich jak cyrylica, chiskie znaki czy znaki diakrytyczne.</p>
<p>Przykad wykorzystania litera贸w Unicode w C++:</p>
<p><div><pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
   std::u16string tekst = u"懈胁械 屑懈!";  // UTF-16
   std::u32string innyTekst = U"浣濂斤涓锛";  // UTF-32
   
   std::cout &lt;&lt; "Dugo tekstu w UTF-16: " &lt;&lt; tekst.length() &lt;&lt; std::endl;
   std::cout &lt;&lt; "Dugo tekstu w UTF-32: " &lt;&lt; innyTekst.length() &lt;&lt; std::endl;
   
   return 0;
}</code></pre></div></p>
<p>Chocia偶 wsparcie dla Unicode w C++ jest wbudowane, manipulowanie takimi napisami mo偶e by wyzwaniem. Dugo napis贸w w UTF-16 czy UTF-32 nie zawsze odpowiada liczbie znak贸w, poniewa偶 niekt贸re znaki mog by kodowane jako wieloznakowe sekwencje. Dlatego w wielu przypadkach programici sigaj po zewntrzne biblioteki, takie jak ICU (International Components for Unicode), kt贸re oferuj kompleksowe narzdzia do manipulacji napisami Unicode.</p>
<p><strong>ICU (International Components for Unicode):</strong> ICU to popularna biblioteka open-source zapewniajca zaawansowane wsparcie dla midzynarodowych format贸w tekstowych, sortowania wedug lokalnych porzdk贸w, konwersji kodowa, obsugi dat i liczb oraz innych aspekt贸w pracy z wielojzycznymi aplikacjami.</p>
<p>III. <strong>Operacje na napisach za pomoc <code>std::string_view</code>:</strong> </p>
<p><code>std::string_view</code> to typ dodany w C++17, kt贸ry umo偶liwia efektywniejsze operacje na napisach bez kopiowania danych. <code>std::string_view</code> reprezentuje widok na fragment napisu (cig znak贸w), co pozwala na szybsz i bardziej pamiciooszczdn manipulacj tekstem.</p>
<p><div><pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;string_view&gt;

void wypisz_fragment(std::string_view tekst) {
   std::cout &lt;&lt; "Fragment tekstu: " &lt;&lt; tekst &lt;&lt; std::endl;
}

int main() {
   std::string calyTekst = "To jest dugi tekst.";
   wypisz_fragment(std::string_view(calyTekst).substr(3, 7));  // "jest d"

   return 0;
}</code></pre></div></p>
<p><code>std::string_view</code> jest idealny w sytuacjach, gdy chcemy jedynie analizowa fragmenty tekstu bez potrzeby tworzenia nowych obiekt贸w typu <code>std::string</code>. Jest to czsto wykorzystywane w sytuacjach, gdzie wydajno jest kluczowa, jak w analizie danych lub podczas operacji na du偶ych plikach tekstowych.</p>
<p>IV. <strong>Biblioteki zewntrzne do operacji na napisach:</strong> </p>
<p>Chocia偶 standardowa biblioteka C++ oferuje bogate wsparcie dla operacji na napisach, czasem mo偶e okaza si niewystarczajca. W takich przypadkach, do bardziej zaawansowanych zastosowa, istnieje wiele zewntrznych bibliotek, takich jak:</p>
<ul>
<li><strong>Boost.StringAlgo</strong> jest czci biblioteki Boost i oferuje bogaty zestaw narzdzi do pracy z napisami, w tym funkcje do przeszukiwania, zamiany, transformacji oraz cicia i doczania tekst贸w, co zwiksza elastyczno operacji na cigach znak贸w.</li>
<li><strong>fmt</strong> to biblioteka do formatowania napis贸w, kt贸ra zapewnia zaawansowane mo偶liwoci formatowania podobne do <code>printf</code>, ale oferuje bardziej bezpieczne i elastyczne podejcie, zwikszajc wygod i bezpieczestwo przy formatowaniu tekst贸w.</li>
<li><strong>ICU (International Components for Unicode)</strong> to jedna z najbardziej zaawansowanych bibliotek do pracy z napisami Unicode oraz midzynarodowymi formatami tekstowymi, co czyni j niezbdnym narzdziem w aplikacjach wielojzycznych.</li>
</ul>
</article-section><div id="table-of-contents"><h2>Spis Treci</h2><ol><a href="#napisy-w-jzyku-c-i-c-">Napisy w jzyku C i C++</a><ol><li><a href="#napisy-w-jzyku-c-c-string-">Napisy w jzyku C (C-string)</a><ol><li><a href="#deklaracja-i-inicjalizacja-napis贸w-w-c">Deklaracja i inicjalizacja napis贸w w C</a></li><li><a href="#znaczenie-znaku-null">Znaczenie znaku null</a></li><li><a href="#operacje-na-napisach-w-c">Operacje na napisach w C</a></li><li><a href="#przykady-u偶ycia-napis贸w-w-c">Przykady u偶ycia napis贸w w C</a></li><li><a href="#zarzdzanie-pamici-i-bezpieczestwo">Zarzdzanie pamici i bezpieczestwo</a></li></ol></li><li><a href="#napisy-w-jzyku-c-std-string-">Napisy w jzyku C++ (std::string)</a><ol><li><a href="#zalety-u偶ycia-std-string">Zalety u偶ycia std::string</a></li><li><a href="#tworzenie-i-inicjalizacja-std-string">Tworzenie i inicjalizacja std::string</a></li><li><a href="#podstawowe-operacje-na-std-string">Podstawowe operacje na std::string</a></li><li><a href="#interoperacyjno-z-c-stringami">Interoperacyjno z C-stringami</a></li><li><a href="#bezpieczestwo-i-wydajno">Bezpieczestwo i wydajno</a></li><li><a href="#przykady-u偶ycia-std-string">Przykady u偶ycia std::string</a></li><li><a href="#zaawansowane-operacje-na-napisach">Zaawansowane operacje na napisach</a></li></ol></li></ol></ol><div id="related-articles"><h2>Related Articles</h2><ol><li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/01_proces_kompilacji.html">Proces Kompilacji</a></li><li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/02_preprocesor.html">Preprocesor</a></li><li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/03_zmienne_i_typy_danych.html">Zmienne i Typy Danych</a></li><li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/04_interakcja_z_konsola.html">Interakcja z Konsola</a></li><li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/05_instrukcja_warunkowa.html">Instrukcja Warunkowa</a></li><li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/06_petle.html">Petle</a></li><li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/07_liczby_losowe.html">Liczby Losowe</a></li><li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/08_typ_wyliczeniowy.html">Typ Wyliczeniowy</a></li><li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/09_funkcje.html">Funkcje</a></li><li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/10_l_wartosci_r_wartosci.html">L Wartosci R Wartosci</a></li><li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/11_wskazniki.html">Wskazniki</a></li><li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/12_tablice.html">Tablice</a></li><li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/13_napisy.html">Napisy</a></li><li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/14_operacje_bitowe.html">Operacje Bitowe</a></li><li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/15_programowanie_obietkowe.html">Programowanie Obietkowe</a></li><li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/16_dziedziczenie.html">Dziedziczenie</a></li><li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/17_zaawansowane_wskazniki.html">Zaawansowane Wskazniki</a></li><li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/18_przeciazanie.html">Przeciazanie</a></li><li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/19_konwersje.html">Konwersje</a></li><li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/20_lambdy.html">Lambdy</a></li><li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/21_szablony.html">Szablony</a></li><li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/22_wyjatki.html">Wyjatki</a></li><li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/23_stl.html">Stl</a></li><li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/24_praca_z_plikami.html">Praca z Plikami</a></li><li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/25_c_vs_cpp.html">C vs Cpp</a></li></ol></div></div></div><footer>
<div class="footer-columns">
<div class="footer-column">
<img alt="Adam Djellouli Symbol" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/symbol.png"/>
</div>
<div class="footer-column">
<h2><a href="https://adamdjellouli.com/core/privacy_policy.html" title="Privacy Policy">Our Privacy Policy</a></h2>
<p>Thank you for visiting my personal website. All content here is free to use, but please remember to be respectful and avoid any misuse of the site. If youd like to get in touch, feel free to reach out via my <a href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" title="LinkedIn Profile">LinkedIn profile</a> or connect with me on <a href="https://github.com/djeada" title="GitHub Profile">GitHub</a> if you have technical questions or ideas to share. Wishing you all the best and a fantastic life ahead!</p>
</div>
<div class="footer-column">
<h2>Follow me</h2>
<ul class="social-media">
<li>
<a class="fa fa-youtube" href="https://www.youtube.com/channel/UCGPoHTVjMN77wcGknXPHl1Q" target="_blank" title="YouTube">
</a>YouTube
                </li>
<li>
<a class="fa fa-linkedin" href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" target="_blank" title="LinkedIn">
</a>LinkedIn
                </li>
<li>
<a class="fa fa-instagram" href="https://www.instagram.com/linuxchallenges/" target="_blank" title="Instagram">
</a>Instagram
                </li>
<li>
<a class="fa fa-github" href="https://github.com/djeada" title="GitHub">
</a>Github
                </li>
</ul>
</div>
</div>
<div>
<p id="copyright">
            漏 Adam Djellouli. All rights reserved.
        </p>
</div>
<script>
        document.getElementById("copyright").innerHTML = "&copy; " + new Date().getFullYear() + " Adam Djellouli. All rights reserved.";
    </script>
<script src="../../app.js"></script>
</footer></body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-bash.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-cpp.min.js"></script><script type="text/x-mathjax-config">
MathJax.Hub.Config({
jax: ["input/TeX", "output/HTML-CSS"],
extensions: ["tex2jax.js"],
"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] },
tex2jax: { inlineMath: [ ["$", "$"] ], displayMath: [ ["$$","$$"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
TeX: { noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } } },
messageStyle: "none"
});
</script>
<script async="" id="MathJax-script" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script></html>