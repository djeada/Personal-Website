<!DOCTYPE html>

<html lang="pl">

<head>
    <script async="" crossorigin="anonymous" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5593122079896089"></script>
    <meta charset="utf-8" />
    <title>STL (Standard Template Library)</title>
    <meta content="STL to biblioteka szablonów w języku C++, która dostarcza gotowych do użycia implementacji wielu funkcji, algorytmów i struktur danych." name="description" />
    <meta content="Adam Djellouli" name="author" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <meta content="IE=edge" http-equiv="X-UA-Compatible" />
    <link crossorigin="" href="https://fonts.googleapis.com" rel="preconnect" />
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/icon.ico" rel="icon" />
    <link href="../../resources/style.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />
</head>

<body>
    <nav aria-label="Main navigation">
        <a class="logo" href="https://adamdjellouli.com">
            <img alt="Adam Djellouli - Home Page Logo" id="logo-image" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/logo.PNG" />
        </a>
        <input aria-label="Toggle navigation menu" id="navbar-toggle" type="checkbox" />
        <ul aria-labelledby="navbar-toggle" role="menu">
            <li role="menuitem">
                <a href="../../index.html" title="Go to Home Page"> Home </a>
            </li>
            <li role="menuitem">
                <a class="active" href="../../core/blog.html" title="Read Adam Djellouli Blog on Programming and Technology"> Blog </a>
            </li>
            <li role="menuitem">
                <a href="../../core/tools.html" title="Discover Tools Created by Adam Djellouli"> Tools </a>
            </li>
            <li role="menuitem">
                <a href="../../core/projects.html" title="Explore Projects Developed by Adam Djellouli"> Projects </a>
            </li>
            <li role="menuitem">
                <a href="../../core/resume.html" title="View Adam Djellouli Professional Resume"> Resume </a>
            </li>
            <li>
                <script async="" src="https://cse.google.com/cse.js?cx=8160ef9bb935f4f68"></script>
                <div class="gcse-search"></div>
            </li>
            <li>
                <button aria-label="Toggle dark mode" id="dark-mode-button"></button>
            </li>
        </ul>
    </nav>
    <div id="article-wrapper">
        <section id="article-body">
            <p style="text-align: right;"><i>Last modified: September 25, 2024</i></p>
            <p style="text-align: right;"><i>This article is written in: 🇵🇱</i></p>
            <h2 id="stl-standard-template-library-">STL (Standard Template Library)</h2>
            <p>STL to biblioteka szablonów w języku C++, która dostarcza gotowych do użycia implementacji wielu funkcji, algorytmów i struktur danych. Najważniejsze komponenty biblioteki STL to:</p>
            <ul>
                <li><code>vector</code></li>
                <li><code>list</code></li>
                <li><code>map</code></li>
                <li><code>set</code></li>
                <li><code>queue</code></li>
                <li><code>stack</code></li>
                <li><code>algorithm</code></li>
                <li><code>iterator</code></li>
                <li><code>memory</code></li>
            </ul>
            <h3 id="kolekcje-w-stl">Kolekcje w STL</h3>
            <p>Kolekcje w STL to zbiory implementacji struktur danych wraz z funkcjami operującymi na tych strukturach.</p>
            <h3 id="stl-standard-template-library-">STL (Standard Template Library)</h3>
            <p>STL to biblioteka szablonów w języku C++, która dostarcza gotowych do użycia implementacji wielu funkcji, algorytmów i struktur danych. Najważniejsze komponenty biblioteki STL to:</p>
            <ul>
                <li><code>vector</code></li>
                <li><code>list</code></li>
                <li><code>map</code></li>
                <li><code>set</code></li>
                <li><code>unordered_map</code></li>
                <li><code>unordered_set</code></li>
                <li><code>priority_queue</code></li>
                <li><code>queue</code></li>
                <li><code>stack</code></li>
                <li><code>algorithm</code></li>
                <li><code>iterator</code></li>
                <li><code>memory</code></li>
            </ul>
            <p>Dodanie kolumny "Złożoność czasowa" do każdej tabeli może pomóc lepiej zrozumieć wydajność różnych operacji. Oto zaktualizowane tabele:</p>
            <h3 id="kolekcje-w-stl">Kolekcje w STL</h3>
            <p>Kolekcje w STL to zbiory implementacji struktur danych wraz z funkcjami operującymi na tych strukturach.</p>
            <h4 id="vector"><strong>vector</strong></h4>
            <p><code>vector</code> to dynamiczna tablica, która może zmieniać swój rozmiar. Jest jednym z najczęściej używanych kontenerów w STL.</p>
            <p>Operacje:</p>
            <p>
            <table>
                <tr>
                    <td>Metoda</td>
                    <td>Opis</td>
                    <td>Przykład użycia</td>
                    <td>Złożoność czasowa</td>
                </tr>
                <tr>
                    <td><code>push_back(value)</code></td>
                    <td>Dodaje element na końcu</td>
                    <td><code>vec.push_back(10);</code></td>
                    <td>Amortyzowane O(1)</td>
                </tr>
                <tr>
                    <td><code>pop_back()</code></td>
                    <td>Usuwa element z końca</td>
                    <td><code>vec.pop_back();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>size()</code></td>
                    <td>Zwraca liczbę elementów</td>
                    <td><code>auto s = vec.size();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>empty()</code></td>
                    <td>Sprawdza, czy kontener jest pusty</td>
                    <td><code>if (vec.empty()) {}</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>clear()</code></td>
                    <td>Usuwa wszystkie elementy</td>
                    <td><code>vec.clear();</code></td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><code>insert(pos, value)</code></td>
                    <td>Wstawia element na podanej pozycji</td>
                    <td><code>vec.insert(vec.begin() + 1, 20);</code></td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><code>erase(pos)</code></td>
                    <td>Usuwa element z podanej pozycji</td>
                    <td><code>vec.erase(vec.begin() + 1);</code></td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><code>at(index)</code></td>
                    <td>Zwraca referencję do elementu na podanym indeksie</td>
                    <td><code>int val = vec.at(2);</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>operator[]</code></td>
                    <td>Zwraca referencję do elementu na podanym indeksie</td>
                    <td><code>int val = vec[2];</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>front()</code></td>
                    <td>Zwraca referencję do pierwszego elementu</td>
                    <td><code>int val = vec.front();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>back()</code></td>
                    <td>Zwraca referencję do ostatniego elementu</td>
                    <td><code>int val = vec.back();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>begin()</code></td>
                    <td>Zwraca iterator na początek</td>
                    <td><code>auto it = vec.begin();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>end()</code></td>
                    <td>Zwraca iterator na koniec</td>
                    <td><code>auto it = vec.end();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>reserve(n)</code></td>
                    <td>Rezerwuje miejsce na n elementów</td>
                    <td><code>vec.reserve(100);</code></td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><code>resize(n)</code></td>
                    <td>Zmienia rozmiar wektora</td>
                    <td><code>vec.resize(10);</code></td>
                    <td>O(n)</td>
                </tr>
            </table>
            </p>
            <p>Przykład:</p>
            <p>
            <div>
                <pre><code class="language-clike">std::vector&lt;int&gt; vec = {1, 2, 3};
vec.push_back(4);
vec.insert(vec.begin() + 1, 10);
for(auto it = vec.begin(); it != vec.end(); ++it) {
std::cout &lt;&lt; *it &lt;&lt; " ";
}</code></pre>
            </div>
            </p>
            <h4 id="list"><strong>list</strong></h4>
            <p><code>list</code> to dwukierunkowa lista wiązana, która umożliwia szybkie wstawianie i usuwanie elementów.</p>
            <p>Operacje:</p>
            <p>
            <table>
                <tr>
                    <td>Metoda</td>
                    <td>Opis</td>
                    <td>Przykład użycia</td>
                    <td>Złożoność czasowa</td>
                </tr>
                <tr>
                    <td><code>push_back(value)</code></td>
                    <td>Dodaje element na końcu</td>
                    <td><code>lst.push_back(10);</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>push_front(value)</code></td>
                    <td>Dodaje element na początku</td>
                    <td><code>lst.push_front(5);</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>pop_back()</code></td>
                    <td>Usuwa element z końca</td>
                    <td><code>lst.pop_back();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>pop_front()</code></td>
                    <td>Usuwa element z początku</td>
                    <td><code>lst.pop_front();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>size()</code></td>
                    <td>Zwraca liczbę elementów</td>
                    <td><code>auto s = lst.size();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>empty()</code></td>
                    <td>Sprawdza, czy kontener jest pusty</td>
                    <td><code>if (lst.empty()) {}</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>clear()</code></td>
                    <td>Usuwa wszystkie elementy</td>
                    <td><code>lst.clear();</code></td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><code>insert(pos, value)</code></td>
                    <td>Wstawia element na podanej pozycji</td>
                    <td><code>lst.insert(++lst.begin(), 20);</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>erase(pos)</code></td>
                    <td>Usuwa element z podanej pozycji</td>
                    <td><code>lst.erase(++lst.begin());</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>front()</code></td>
                    <td>Zwraca referencję do pierwszego elementu</td>
                    <td><code>int val = lst.front();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>back()</code></td>
                    <td>Zwraca referencję do ostatniego elementu</td>
                    <td><code>int val = lst.back();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>begin()</code></td>
                    <td>Zwraca iterator na początek</td>
                    <td><code>auto it = lst.begin();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>end()</code></td>
                    <td>Zwraca iterator na koniec</td>
                    <td><code>auto it = lst.end();</code></td>
                    <td>O(1)</td>
                </tr>
            </table>
            </p>
            <p>Przykład:</p>
            <p>
            <div>
                <pre><code class="language-clike">std::list&lt;int&gt; lst = {1, 2, 3};
lst.push_back(4);
lst.push_front(0);
lst.insert(++lst.begin(), 10);
for(auto it = lst.begin(); it != lst.end(); ++it) {
std::cout &lt;&lt; *it &lt;&lt; " ";
}</code></pre>
            </div>
            </p>
            <h4 id="map"><strong>map</strong></h4>
            <p><code>map</code> to kontener asocjacyjny, który przechowuje pary klucz-wartość w uporządkowanej formie, wykorzystując drzewo czerwono-czarne.</p>
            <p>Operacje:</p>
            <p>
            <table>
                <tr>
                    <td>Metoda</td>
                    <td>Opis</td>
                    <td>Przykład użycia</td>
                    <td>Złożoność czasowa</td>
                </tr>
                <tr>
                    <td><code>insert({key, value})</code></td>
                    <td>Wstawia parę klucz-wartość</td>
                    <td><code>mp.insert({1, "one"});</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>erase(key)</code></td>
                    <td>Usuwa element o podanym kluczu</td>
                    <td><code>mp.erase(1);</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>find(key)</code></td>
                    <td>Zwraca iterator na element o podanym kluczu</td>
                    <td><code>auto it = mp.find(1);</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>size()</code></td>
                    <td>Zwraca liczbę elementów</td>
                    <td><code>auto s = mp.size();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>empty()</code></td>
                    <td>Sprawdza, czy kontener jest pusty</td>
                    <td><code>if (mp.empty()) {}</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>clear()</code></td>
                    <td>Usuwa wszystkie elementy</td>
                    <td><code>mp.clear();</code></td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><code>operator[]</code></td>
                    <td>Zwraca referencję do wartości o podanym kluczu</td>
                    <td><code>std::string val = mp[1];</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>begin()</code></td>
                    <td>Zwraca iterator na początek</td>
                    <td><code>auto it = mp.begin();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>end()</code></td>
                    <td>Zwraca iterator na koniec</td>
                    <td><code>auto it = mp.end();</code></td>
                    <td>O(1)</td>
                </tr>
            </table>
            </p>
            <p>Przykład:</p>
            <p>
            <div>
                <pre><code class="language-clike">std::map&lt;int, std::string=""&gt; mp;
mp.insert({1, "one"});
mp[2] = "two";
mp.erase(1);
for(auto it = mp.begin(); it != mp.end(); ++it) {
std::cout &lt;&lt; it-&gt;first &lt;&lt; ": " &lt;&lt; it-&gt;second &lt;&lt; " ";
}</code></pre>
            </div>
            </p>
            <h4 id="unordered_map"><strong>unordered_map</strong></h4>
            <p><code>unordered_map</code> to kontener asocjacyjny, który przechowuje pary klucz-wartość w nieuporządkowanej formie, wykorzystując tablicę mieszającą (hash table).</p>
            <p>Operacje:</p>
            <p>
            <table>
                <tr>
                    <td>Metoda</td>
                    <td>Opis</td>
                    <td>Przykład użycia</td>
                    <td>Złożoność czasowa</td>
                </tr>
                <tr>
                    <td><code>insert({key, value})</code></td>
                    <td>Wstawia parę klucz-wartość</td>
                    <td><code>ump.insert({1, "one"});</code></td>
                    <td>O(1) amortyzowane</td>
                </tr>
                <tr>
                    <td><code>erase(key)</code></td>
                    <td>Usuwa element o podanym kluczu</td>
                    <td><code>ump.erase(1);</code></td>
                    <td>O(1) amortyzowane</td>
                </tr>
                <tr>
                    <td><code>find(key)</code></td>
                    <td>Zwraca iterator na element o podanym kluczu</td>
                    <td><code>auto it = ump.find(1);</code></td>
                    <td>O(1) amortyzowane</td>
                </tr>
                <tr>
                    <td><code>size()</code></td>
                    <td>Zwraca liczbę elementów</td>
                    <td><code>auto s = ump.size();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>empty()</code></td>
                    <td>Sprawdza, czy kontener jest pusty</td>
                    <td><code>if (ump.empty()) {}</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>clear()</code></td>
                    <td>Usuwa wszystkie elementy</td>
                    <td><code>ump.clear();</code></td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><code>operator[]</code></td>
                    <td>Zwraca referencję do wartości o podanym kluczu</td>
                    <td><code>std::string val = ump[1];</code></td>
                    <td>O(1) amortyzowane</td>
                </tr>
                <tr>
                    <td><code>begin()</code></td>
                    <td>Zwraca iterator na początek</td>
                    <td><code>auto it = ump.begin();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>end()</code></td>
                    <td>Zwraca iterator na koniec</td>
                    <td><code>auto it = ump.end();</code></td>
                    <td>O(1)</td>
                </tr>
            </table>
            </p>
            <p>Przykład:</p>
            <p>
            <div>
                <pre><code class="language-clike">std::unordered_map&lt;int, std::string=""&gt; ump;
ump.insert({1, "one"});
ump[2] = "two";
ump.erase(1);
for(auto it = ump.begin(); it != ump.end(); ++it) {
std::cout &lt;&lt; it-&gt;first &lt;&lt; ": " &lt;&lt; it-&gt;second &lt;&lt; " ";
}</code></pre>
            </div>
            </p>
            <h4 id="set"><strong>set</strong></h4>
            <p><code>set</code> to kontener, który przechowuje unikalne elementy w uporządkowanej formie, wykorzystując drzewo czerwono-czarne.</p>
            <p>Operacje:</p>
            <p>Oto poprawiona tabela:</p>
            <p>
            <table>
                <tr>
                    <td>Metoda</td>
                    <td>Opis</td>
                    <td>Przykład użycia</td>
                    <td>Złożoność czasowa</td>
                </tr>
                <tr>
                    <td><code>insert(value)</code></td>
                    <td>Wstawia element</td>
                    <td><code>st.insert(10);</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>erase(value)</code></td>
                    <td>Usuwa element</td>
                    <td><code>st.erase(10);</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>find(value)</code></td>
                    <td>Zwraca iterator na element</td>
                    <td><code>auto it = st.find(10);</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>size()</code></td>
                    <td>Zwraca liczbę elementów</td>
                    <td><code>auto s = st.size();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>empty()</code></td>
                    <td>Sprawdza, czy kontener jest pusty</td>
                    <td><code>if (st.empty()) {}</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>clear()</code></td>
                    <td>Usuwa wszystkie elementy</td>
                    <td><code>st.clear();</code></td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><code>begin()</code></td>
                    <td>Zwraca iterator na początek</td>
                    <td><code>auto it = st.begin();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>end()</code></td>
                    <td>Zwraca iterator na koniec</td>
                    <td><code>auto it = st.end();</code></td>
                    <td>O(1)</td>
                </tr>
            </table>
            </p>
            <p>Przykład:</p>
            <p>
            <div>
                <pre><code class="language-clike">std::set&lt;int&gt; st;
st.insert(10);
st.insert(20);
st.erase(10);
for(auto it = st.begin(); it != st.end(); ++it) {
std::cout &lt;&lt; *it &lt;&lt; " ";
}</code></pre>
            </div>
            </p>
            <h4 id="unordered_set"><strong>unordered_set</strong></h4>
            <p><code>unordered_set</code> to kontener, który przechowuje unikalne elementy w nieuporządkowanej formie, wykorzystując tablicę mieszającą (hash table).</p>
            <p>Operacje:</p>
            <p>
            <table>
                <tr>
                    <td>Metoda</td>
                    <td>Opis</td>
                    <td>Przykład użycia</td>
                    <td>Złożoność czasowa</td>
                </tr>
                <tr>
                    <td><code>insert(value)</code></td>
                    <td>Wstawia element</td>
                    <td><code>ust.insert(10);</code></td>
                    <td>O(1) amortyzowane</td>
                </tr>
                <tr>
                    <td><code>erase(value)</code></td>
                    <td>Usuwa element</td>
                    <td><code>ust.erase(10);</code></td>
                    <td>O(1) amortyzowane</td>
                </tr>
                <tr>
                    <td><code>find(value)</code></td>
                    <td>Zwraca iterator na element</td>
                    <td><code>auto it = ust.find(10);</code></td>
                    <td>O(1) amortyzowane</td>
                </tr>
                <tr>
                    <td><code>size()</code></td>
                    <td>Zwraca liczbę elementów</td>
                    <td><code>auto s = ust.size();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>empty()</code></td>
                    <td>Sprawdza, czy kontener jest pusty</td>
                    <td><code>if (ust.empty()) {}</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>clear()</code></td>
                    <td>Usuwa wszystkie elementy</td>
                    <td><code>ust.clear();</code></td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><code>begin()</code></td>
                    <td>Zwraca iterator na początek</td>
                    <td><code>auto it = ust.begin();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>end()</code></td>
                    <td>Zwraca iterator na koniec</td>
                    <td><code>auto it = ust.end();</code></td>
                    <td>O(1)</td>
                </tr>
            </table>
            </p>
            <p>Przykład:</p>
            <p>
            <div>
                <pre><code class="language-clike">std::unordered_set&lt;int&gt; ust;
ust.insert(10);
ust.insert(20);
ust.erase(10);
for(auto it = ust.begin(); it != ust.end(); ++it) {
std::cout &lt;&lt; *it &lt;&lt; " ";
}</code></pre>
            </div>
            </p>
            <h4 id="priority_queue"><strong>priority_queue</strong></h4>
            <p><code>priority_queue</code> to kontener, który implementuje kopiec binarny i pozwala na szybkie wyciąganie największego (lub najmniejszego) elementu.</p>
            <p>Operacje:</p>
            <p>
            <table>
                <tr>
                    <td>Metoda</td>
                    <td>Opis</td>
                    <td>Przykład użycia</td>
                    <td>Złożoność czasowa</td>
                </tr>
                <tr>
                    <td><code>push(value)</code></td>
                    <td>Dodaje element</td>
                    <td><code>pq.push(10);</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>pop()</code></td>
                    <td>Usuwa największy element</td>
                    <td><code>pq.pop();</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>top()</code></td>
                    <td>Zwraca referencję do największego elementu</td>
                    <td><code>int val = pq.top();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>size()</code></td>
                    <td>Zwraca liczbę elementów</td>
                    <td><code>auto s = pq.size();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>empty()</code></td>
                    <td>Sprawdza, czy kontener jest pusty</td>
                    <td><code>if (pq.empty()) {}</code></td>
                    <td>O(1)</td>
                </tr>
            </table>
            </p>
            <p>Przykład:</p>
            <p>
            <div>
                <pre><code class="language-clike">std::priority_queue&lt;int&gt; pq;
pq.push(10);
pq.push(20);
pq.push(5);
std::cout &lt;&lt; pq.top() &lt;&lt; " "; // wyświetli 20
pq.pop();
std::cout &lt;&lt; pq.top() &lt;&lt; " "; // wyświetli 10</code></pre>
            </div>
            </p>
            <h4 id="queue"><strong>queue</strong></h4>
            <p><code>queue</code> to kontener, który implementuje kolejkę FIFO (First In, First Out).</p>
            <p>Operacje:</p>
            <p>
            <table>
                <tr>
                    <td>Metoda</td>
                    <td>Opis</td>
                    <td>Przykład użycia</td>
                    <td>Złożoność czasowa</td>
                </tr>
                <tr>
                    <td><code>push(value)</code></td>
                    <td>Dodaje element</td>
                    <td><code>q.push(10);</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>pop()</code></td>
                    <td>Usuwa element z początku</td>
                    <td><code>q.pop();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>front()</code></td>
                    <td>Zwraca referencję do pierwszego elementu</td>
                    <td><code>int val = q.front();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>back()</code></td>
                    <td>Zwraca referencję do ostatniego elementu</td>
                    <td><code>int val = q.back();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>size()</code></td>
                    <td>Zwraca liczbę elementów</td>
                    <td><code>auto s = q.size();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>empty()</code></td>
                    <td>Sprawdza, czy kontener jest pusty</td>
                    <td><code>if (q.empty()) {}</code></td>
                    <td>O(1)</td>
                </tr>
            </table>
            </p>
            <p>Przykład:</p>
            <p>
            <div>
                <pre><code class="language-clike">std::queue&lt;int&gt; q;
q.push(10);
q.push(20);
std::cout &lt;&lt; q.front() &lt;&lt; " "; // wyświetli 10
q.pop();
std::cout &lt;&lt; q.front() &lt;&lt; " "; // wyświetli 20</code></pre>
            </div>
            </p>
            <h4 id="stack"><strong>stack</strong></h4>
            <p><code>stack</code> to kontener, który implementuje stos LIFO (Last In, First Out).</p>
            <p>Operacje:</p>
            <p>
            <table>
                <tr>
                    <td>Metoda</td>
                    <td>Opis</td>
                    <td>Przykład użycia</td>
                    <td>Złożoność czasowa</td>
                </tr>
                <tr>
                    <td><code>push(value)</code></td>
                    <td>Dodaje element</td>
                    <td><code>st.push(10);</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>pop()</code></td>
                    <td>Usuwa element z końca</td>
                    <td><code>st.pop();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>top()</code></td>
                    <td>Zwraca referencję do ostatniego elementu</td>
                    <td><code>int val = st.top();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>size()</code></td>
                    <td>Zwraca liczbę elementów</td>
                    <td><code>auto s = st.size();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>empty()</code></td>
                    <td>Sprawdza, czy kontener jest pusty</td>
                    <td><code>if (st.empty()) {}</code></td>
                    <td>O(1)</td>
                </tr>
            </table>
            </p>
            <p>Przykład:</p>
            <p>
            <div>
                <pre><code class="language-clike">std::stack&lt;int&gt; st;
st.push(10);
st.push(20);
std::cout &lt;&lt; st.top() &lt;&lt; " "; // wyświetli 20
st.pop();
std::cout &lt;&lt; st.top() &lt;&lt; " "; // wyświetli 10</code></pre>
            </div>
            </p>
            <h3 id="iteratory">Iteratory</h3>
            <p>Iteratory w języku C++ to obiekty umożliwiające sekwencyjny dostęp do elementów kontenerów. Dzięki nim możliwe jest jednolite przeglądanie zawartości różnych typów kolekcji, niezależnie od ich wewnętrznej implementacji. Iteratory pełnią podobną rolę do wskaźników, ale są bardziej elastyczne i bezpieczne w użyciu.</p>
            <h4 id="rodzaje-iteratorów">Rodzaje iteratorów</h4>
            <p>
            <table>
                <tr>
                    <td>Typ iteratora</td>
                    <td>Opis</td>
                </tr>
                <tr>
                    <td><strong>Input Iterator</strong></td>
                    <td>Służy do odczytu danych z kontenera.</td>
                </tr>
                <tr>
                    <td><strong>Output Iterator</strong></td>
                    <td>Służy do zapisu danych do kontenera.</td>
                </tr>
                <tr>
                    <td><strong>Forward Iterator</strong></td>
                    <td>Łączy możliwości iteratorów input i output, może przemieszczać się tylko do przodu.</td>
                </tr>
                <tr>
                    <td><strong>Bidirectional Iterator</strong></td>
                    <td>Umożliwia przemieszczanie się zarówno do przodu, jak i do tyłu.</td>
                </tr>
                <tr>
                    <td><strong>Random Access Iterator</strong></td>
                    <td>Oferuje wszystkie możliwości Bidirectional Iterator oraz umożliwia dostęp do dowolnego elementu kontenera w stałym czasie.</td>
                </tr>
            </table>
            </p>
            <h4 id="podstawowe-operacje-na-iteratorach">Podstawowe operacje na iteratorach</h4>
            <ul>
                <li>Inicjalizacja iteratora początkowym elementem kontenera: <code>kontener.begin()</code></li>
                <li>Inicjalizacja iteratora elementem za ostatnim w kontenerze: <code>kontener.end()</code></li>
                <li>Odwołanie do elementu, na który wskazuje iterator: <code>*it</code></li>
                <li>Przesunięcie iteratora do następnego elementu: <code>++it</code></li>
                <li>Przesunięcie iteratora do poprzedniego elementu: <code>--it</code> (dla Bidirectional Iterator)</li>
                <li>Przesunięcie iteratora o określoną liczbę pozycji: <code>it += n</code> lub <code>it -= n</code> (dla Random Access Iterator)</li>
                <li>Wstawienie elementu w miejscu wskazywanym przez iterator: <code>it = kontener.insert(it, wartość)</code></li>
                <li>Usunięcie elementu w miejscu wskazywanym przez iterator: <code>it = kontener.erase(it)</code></li>
            </ul>
            <h4 id="przykład-użycia-iteratora">Przykład użycia iteratora</h4>
            <p>Poniższy przykład ilustruje operacje na wektorze <code>std::vector</code> typu <code>std::string</code>. Najpierw tworzy i inicjalizuje wektor trzema elementami: "ala", "ma", "kota", a następnie wyświetla jego zawartość za pomocą iteratora. Następnie dodaje nowy element "nie" przed drugim elementem wektora, czyli przed "ma". Po tym usuwa pierwszy element wektora, którym jest "ala". Na koniec, program ponownie wyświetla zmodyfikowaną zawartość wektora.</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;std::string&gt; v = {"ala", "ma", "kota"};

    // Wyświetlenie zawartości wektora przy użyciu iteratora
    for (auto it = v.begin(); it != v.end(); ++it) {
        std::cout &lt;&lt; *it &lt;&lt; std::endl;
    }

    // Dodanie nowego elementu przed "ma"
    auto it = v.begin() + 1;
    v.insert(it, "nie");

    // Usunięcie słowa "ala"
    it = v.begin();
    v.erase(it);

    std::cout &lt;&lt; "\nPo modyfikacjach:\n";
    for (const auto&amp; word : v) {
        std::cout &lt;&lt; word &lt;&lt; std::endl;
    }

    return 0;
}</code></pre>
            </div>
            </p>
            <p>Warto pamiętać, że po niektórych operacjach, takich jak insert czy erase, używane wcześniej iteratory mogą stać się nieaktualne i ich dalsze użycie może prowadzić do niezdefiniowanego zachowania programu.</p>
            <h3 id="algorytmy-w-standardowej-bibliotece-c-stl-">Algorytmy w Standardowej Bibliotece C++ (STL)</h3>
            <p>Biblioteka <code>algorithm</code> w standardowej bibliotece C++ (STL) dostarcza bogaty zestaw funkcji szablonowych, które służą do manipulacji i analizy danych przechowywanych w kontenerach. Algorytmy te są zaprojektowane w sposób generyczny, co oznacza, że mogą działać z różnymi typami danych i kontenerami, pod warunkiem spełnienia określonych wymagań. W tej sekcji przyjrzymy się kilku kluczowym algorytmom, ich implementacji, zastosowaniu oraz analizie matematycznej wydajności.</p>
            <h4 id="wprowadzenie-do-algorytmów-stl">Wprowadzenie do Algorytmów STL</h4>
            <p>Algorytmy w STL są zaimplementowane jako funkcje szablonowe, co pozwala na ich użycie z różnymi typami danych i kontenerami. Działają one na zakresach określonych przez iteratory, co zapewnia elastyczność i niezależność od konkretnego typu kontenera. Dzięki temu możliwe jest pisanie kodu, który jest jednocześnie uniwersalny i wydajny.</p>
            <h4 id="klasyfikacja-algorytmów">Klasyfikacja Algorytmów</h4>
            <p>Algorytmy STL można podzielić na kilka kategorii:</p>
            <p>
            <table>
                <tr>
                    <td>Kategoria algorytmów</td>
                    <td>Przykłady</td>
                </tr>
                <tr>
                    <td><strong>Algorytmy modyfikujące</strong></td>
                    <td><code>std::copy</code>, <code>std::fill</code>, <code>std::transform</code></td>
                </tr>
                <tr>
                    <td><strong>Algorytmy przeszukujące</strong></td>
                    <td><code>std::find</code>, <code>std::count</code>, <code>std::search</code></td>
                </tr>
                <tr>
                    <td><strong>Algorytmy sortujące i porządkujące</strong></td>
                    <td><code>std::sort</code>, <code>std::stable_sort</code>, <code>std::partial_sort</code></td>
                </tr>
                <tr>
                    <td><strong>Algorytmy numeryczne</strong></td>
                    <td><code>std::accumulate</code>, <code>std::inner_product</code>, <code>std::partial_sum</code></td>
                </tr>
                <tr>
                    <td><strong>Algorytmy usuwające</strong></td>
                    <td><code>std::remove</code>, <code>std::unique</code>, <code>std::remove_if</code></td>
                </tr>
            </table>
            </p>
            <h4 id="std-sort-"><code>std::sort()</code></h4>
            <p>Funkcja <code>std::sort()</code> służy do sortowania elementów w określonym zakresie. Jest to jeden z najczęściej używanych algorytmów w STL. Wykorzystuje algorytm sortowania introspektywnego (introsort), który łączy zalety sortowania szybkiego (quick sort), sortowania kopcowego (heap sort) i sortowania przez wstawianie (insertion sort).</p>
            <p><strong>Prototyp:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">template&lt; class RandomIt &gt;
void sort( RandomIt first, RandomIt last );

template&lt; class RandomIt, class Compare &gt;
void sort( RandomIt first, RandomIt last, Compare comp );</code></pre>
            </div>
            </p>
            <ul>
                <li><code>RandomIt</code>: Typ iteratora losowego dostępu.</li>
                <li><code>Compare</code>: Funkcja lub funktor służący do porównywania elementów.</li>
            </ul>
            <p><strong>Wymagania:</strong></p>
            <ul>
                <li>Elementy muszą być porównywalne za pomocą operatora <code>&lt;</code> lub funkcji <code>Compare</code>.</li>
                <li>Iteratory muszą być iteratorami losowego dostępu (np. z <code>std::vector</code>, <code>std::array</code>).</li>
            </ul>
            <p><strong>Przykład Użycia:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; wektor{8, 3, 5, 1, 2, 4, 6, 7};
    auto kopia = wektor;

    // Sortowanie pierwszych trzech elementów
    std::sort(wektor.begin(), wektor.begin() + 3);

    // Sortowanie całego wektora
    std::sort(kopia.begin(), kopia.end());

    // Wyświetlanie wyników
    std::cout &lt;&lt; "Wektor po częściowym sortowaniu: ";
    for (const auto&amp; val : wektor) {
        std::cout &lt;&lt; val &lt;&lt; " ";
    }
    std::cout &lt;&lt; "\n";

    std::cout &lt;&lt; "Wektor po pełnym sortowaniu: ";
    for (const auto&amp; val : kopia) {
        std::cout &lt;&lt; val &lt;&lt; " ";
    }

    return 0;
}</code></pre>
            </div>
            </p>
            <p><strong>Analiza Matematyczna:</strong></p>
            <ul>
                <li><strong>Złożoność czasowa</strong> dla tego algorytmu wynosi średnio $O(nlogn)$, co jest charakterystyczne dla wydajnych algorytmów sortowania.</li>
                <li>W najgorszym przypadku złożoność czasowa również wynosi $O(nlog)$, ponieważ algorytm wykorzystuje introsort, który automatycznie przełącza się na sortowanie kopcowe, gdy wykryje niekorzystny podział danych.</li>
                <li><strong>Złożoność pamięciowa</strong> tego algorytmu wymaga $O(logn)$ dodatkowej pamięci, głównie na stos rekurencji, co czyni go efektywnym pod względem użycia zasobów pamięci.</li>
            </ul>
            <p><strong>Dostosowywanie Kryterium Sortowania:</strong></p>
            <p>Możemy dostarczyć własną funkcję porównującą:</p>
            <p>
            <div>
                <pre><code class="language-clike">std::sort(wektor.begin(), wektor.end(), [](int a, int b) {
    return a &gt; b; // Sortowanie malejące
});</code></pre>
            </div>
            </p>
            <p><strong>Uwagi:</strong></p>
            <ul>
                <li><strong>Stabilność</strong> algorytmu <code>std::sort()</code> nie jest zagwarantowana, co oznacza, że kolejność równych elementów może się zmienić. W przypadku, gdy stabilność jest wymagana, należy skorzystać z funkcji <code>std::stable_sort()</code>.</li>
                <li>Typ elementów musi być <strong>zgodny</strong> z wymaganiami funkcji porównującej, co zapewnia poprawność działania algorytmu.</li>
            </ul>
            <h4 id="std-find-"><code>std::find()</code></h4>
            <p>Algorytm <code>std::find()</code> przeszukuje zakres w poszukiwaniu pierwszego wystąpienia określonej wartości. Zwraca iterator wskazujący na znaleziony element lub na koniec zakresu, jeśli element nie został znaleziony.</p>
            <p><strong>Prototyp:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">template&lt; class InputIt, class T &gt;
InputIt find( InputIt first, InputIt last, const T&amp; value );</code></pre>
            </div>
            </p>
            <ul>
                <li><code>InputIt</code>: Typ iteratora wejściowego.</li>
                <li><code>T</code>: Typ poszukiwanej wartości.</li>
            </ul>
            <p><strong>Przykład Użycia:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; wektor{8, 3, 5, 1, 2, 4, 6, 7};

    auto it = std::find(wektor.begin(), wektor.end(), 3);

    if (it != wektor.end())
        std::cout &lt;&lt; "Znaleziono element o wartości 3 na pozycji "
                  &lt;&lt; std::distance(wektor.begin(), it) &lt;&lt; "\n";
    else
        std::cout &lt;&lt; "Nie znaleziono elementu o wartości 3\n";

    return 0;
}</code></pre>
            </div>
            </p>
            <p><strong>Analiza Matematyczna:</strong></p>
            <ul>
                <li><strong>Złożoność czasowa</strong> wynosi $O(n)$, gdzie n oznacza liczbę elementów w przetwarzanym zakresie, co sprawia, że algorytm działa liniowo względem liczby danych.</li>
                <li><strong>Złożoność pamięciowa</strong> wynosi $O(1)$, co oznacza, że algorytm nie wymaga dodatkowej pamięci poza tą używaną przez same dane.</li>
            </ul>
            <p><strong>Uwagi:</strong></p>
            <ul>
                <li>Algorytm przeszukuje liniowo zakres od <code>first</code> do <code>last</code>.</li>
                <li>Możemy użyć <code>std::find_if()</code> lub <code>std::find_if_not()</code> do przeszukiwania z warunkiem predykatu.</li>
            </ul>
            <h4 id="std-for_each-"><code>std::for_each()</code></h4>
            <p>Funkcja <code>std::for_each()</code> stosuje podaną funkcję lub funktor do każdego elementu w zakresie. Jest to alternatywa dla pętli <code>for</code> i pozwala na bardziej funkcyjne podejście do iteracji.</p>
            <p><strong>Prototyp:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">template&lt; class InputIt, class UnaryFunction &gt;
UnaryFunction for_each( InputIt first, InputIt last, UnaryFunction f );</code></pre>
            </div>
            </p>
            <ul>
                <li><code>InputIt</code>: Typ iteratora wejściowego.</li>
                <li><code>UnaryFunction</code>: Typ funkcji lub funktora akceptującego element typu dereferowanego iteratora.</li>
            </ul>
            <p><strong>Przykład Użycia:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; wektor{8, 3, 5, 1, 2, 4, 6, 7};

    // Modyfikacja każdego elementu przez jego podwojenie
    std::for_each(wektor.begin(), wektor.end(), [](int &amp;x) { x *= 2; });

    // Wyświetlanie wyników
    std::cout &lt;&lt; "Wektor po modyfikacji: ";
    for (const auto&amp; val : wektor) {
        std::cout &lt;&lt; val &lt;&lt; " ";
    }

    return 0;
}</code></pre>
            </div>
            </p>
            <p><strong>Analiza Matematyczna:</strong></p>
            <ul>
                <li><strong>Złożoność czasowa</strong> wynosi <strong>O(n)</strong>, ponieważ funkcja jest wywoływana dokładnie n razy, co oznacza liniowy wzrost liczby operacji w zależności od liczby elementów.</li>
                <li><strong>Złożoność pamięciowa</strong> wynosi <strong>O(1)</strong>, gdyż algorytm nie wymaga dodatkowej pamięci poza ewentualnymi zmiennymi lokalnymi w funkcji.</li>
            </ul>
            <p><strong>Uwagi:</strong></p>
            <ul>
                <li>Funkcja <code>UnaryFunction</code> jest przekazywana przez wartość, więc jeśli potrzebujemy zachować stan między wywołaniami, należy użyć referencji lub obiektu zewnętrznego.</li>
                <li>Zwracana jest kopia funkcji <code>UnaryFunction</code> po ostatnim wywołaniu, co może być użyte do akumulacji wyników.</li>
            </ul>
            <h4 id="std-count_if-"><code>std::count_if()</code></h4>
            <p>Algorytm <code>std::count_if()</code> zlicza liczbę elementów w zakresie, dla których predykat jest spełniony.</p>
            <p><strong>Prototyp:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">template&lt; class InputIt, class UnaryPredicate &gt;
typename iterator_traits&lt;inputit&gt;::difference_type
count_if( InputIt first, InputIt last, UnaryPredicate p );</code></pre>
            </div>
            </p>
            <ul>
                <li><code>InputIt</code>: Typ iteratora wejściowego.</li>
                <li><code>UnaryPredicate</code>: Funkcja lub funktor zwracający wartość logiczną.</li>
            </ul>
            <p><strong>Przykład Użycia:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; wektor{8, 3, 5, 1, 2, 4, 6, 7};

    // Zliczanie parzystych elementów
    int parzyste = std::count_if(wektor.begin(), wektor.end(), [](int x) { return x % 2 == 0; });

    std::cout &lt;&lt; "Liczba parzystych elementów: " &lt;&lt; parzyste &lt;&lt; "\n";

    return 0;
}</code></pre>
            </div>
            </p>
            <p><strong>Analiza Matematyczna:</strong></p>
            <ul>
                <li><strong>Złożoność czasowa</strong> wynosi <strong>O(n)</strong>, ponieważ predykat jest wywoływany dokładnie n razy, co sprawia, że liczba operacji rośnie liniowo w zależności od liczby elementów.</li>
                <li><strong>Złożoność pamięciowa</strong> wynosi <strong>O(1)</strong>, co oznacza, że algorytm nie wymaga dodatkowej pamięci poza zmiennymi lokalnymi.</li>
            </ul>
            <p><strong>Uwagi:</strong></p>
            <ul>
                <li>Jeśli chcemy zliczyć wystąpienia konkretnej wartości, możemy użyć <code>std::count()</code>.</li>
            </ul>
            <h4 id="inne-ważne-algorytmy">Inne Ważne Algorytmy</h4>
            <h5><code>std::accumulate()</code></h5>
            <p>Służy do obliczenia sumy wartości w zakresie, z opcjonalnym początkowym akumulatorem i funkcją operacji.</p>
            <p><strong>Prototyp:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">template&lt; class InputIt, class T &gt;
T accumulate( InputIt first, InputIt last, T init );

template&lt; class InputIt, class T, class BinaryOperation &gt;
T accumulate( InputIt first, InputIt last, T init, BinaryOperation op );</code></pre>
            </div>
            </p>
            <p><strong>Przykład:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">int suma = std::accumulate(wektor.begin(), wektor.end(), 0);</code></pre>
            </div>
            </p>
            <h5><code>std::transform()</code></h5>
            <p>Stosuje funkcję do każdego elementu w zakresie i zapisuje wynik w innym zakresie.</p>
            <p><strong>Prototyp:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">template&lt; class InputIt, class OutputIt, class UnaryOperation &gt;
OutputIt transform( InputIt first1, InputIt last1, OutputIt d_first, UnaryOperation unary_op );</code></pre>
            </div>
            </p>
            <p><strong>Przykład:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">std::vector&lt;int&gt; wyniki(wektor.size());
std::transform(wektor.begin(), wektor.end(), wyniki.begin(), [](int x) { return x * x; });</code></pre>
            </div>
            </p>
            <h4 id="kompatybilność-z-iteratorami">Kompatybilność z Iteratorami</h4>
            <p>Algorytmy STL są zaprojektowane tak, aby działać z różnymi kategoriami iteratorów:</p>
            <p>
            <table>
                <tr>
                    <td>Kategoria</td>
                    <td>Przykłady Algorytmów</td>
                </tr>
                <tr>
                    <td>Iteratory wejściowe</td>
                    <td><code>std::find</code>, <code>std::count_if</code></td>
                </tr>
                <tr>
                    <td>Iteratory wyjściowe</td>
                    <td><code>std::copy</code>, <code>std::fill</code></td>
                </tr>
                <tr>
                    <td>Iteratory jedno kierunkowe</td>
                    <td><code>std::for_each</code>, <code>std::remove</code></td>
                </tr>
                <tr>
                    <td>Iteratory dwukierunkowe</td>
                    <td><code>std::reverse</code>, <code>std::rotate</code></td>
                </tr>
                <tr>
                    <td>Iteratory losowego dostępu</td>
                    <td><code>std::sort</code>, <code>std::nth_element</code></td>
                </tr>
            </table>
            </p>
            <h4 id="zastosowanie-algorytmów-w-praktyce">Zastosowanie Algorytmów w Praktyce</h4>
            <p>Algorytmy STL pozwalają na pisanie kodu o wysokim poziomie abstrakcji, co zwiększa czytelność i redukuje ryzyko błędów. Dzięki generyczności i wykorzystaniu szablonów, algorytmy te są niezwykle elastyczne i mogą być stosowane w szerokim zakresie zastosowań.</p>
            <p><strong>Przykład: Analiza Danych Finansowych</strong></p>
            <p>Załóżmy, że mamy wektor reprezentujący dzienne zmiany cen akcji i chcemy przeprowadzić analizę:</p>
            <p>
            <div>
                <pre><code class="language-clike">std::vector&lt;double&gt; zmianyCen = { -0.5, 1.2, 0.3, -0.7, 0.8, -1.0, 0.6 };

// Obliczenie sumarycznej zmiany cen
double sumaZmian = std::accumulate(zmianyCen.begin(), zmianyCen.end(), 0.0);

// Zliczenie dni ze wzrostem cen
int dniWzrostu = std::count_if(zmianyCen.begin(), zmianyCen.end(), [](double x) { return x &gt; 0; });

// Znalezienie największego spadku
auto it = std::min_element(zmianyCen.begin(), zmianyCen.end());

// Wyświetlenie wyników
std::cout &lt;&lt; "Sumaryczna zmiana cen: " &lt;&lt; sumaZmian &lt;&lt; "\n";
std::cout &lt;&lt; "Liczba dni ze wzrostem cen: " &lt;&lt; dniWzrostu &lt;&lt; "\n";
std::cout &lt;&lt; "Największy spadek: " &lt;&lt; *it &lt;&lt; "\n";</code></pre>
            </div>
            </p>
            <h4 id="optymalizacja-za-pomocą-algorytmów">Optymalizacja za Pomocą Algorytmów</h4>
            <p>Korzystanie z algorytmów STL może prowadzić do bardziej wydajnego kodu, ponieważ są one zazwyczaj dobrze zoptymalizowane i wykorzystują najlepsze praktyki implementacyjne. Ponadto, kompilatory mogą dokonywać dodatkowych optymalizacji, gdy używane są standardowe algorytmy.</p>
            <p><strong>Przykład: Porównanie z Pętlą <code>for</code></strong></p>
            <p>Rozważmy zliczanie elementów spełniających określony warunek:</p>
            <p><strong>Tradycyjna pętla <code>for</code>:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">int licznik = 0;
for (size_t i = 0; i &lt; wektor.size(); ++i) {
  if (wektor[i] % 2 == 0) {
      ++licznik;
  }
}</code></pre>
            </div>
            </p>
            <p><strong>Użycie <code>std::count_if()</code>:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">int licznik = std::count_if(wektor.begin(), wektor.end(), [](int x) { return x % 2 == 0; });</code></pre>
            </div>
            </p>
            <p>Korzystanie z <code>std::count_if()</code> nie tylko skraca kod, ale również zwiększa jego czytelność i potencjalnie wydajność.</p>
        </section>
        <div id="table-of-contents">
            <h2>Spis Treści</h2>
            <ol><a href="#stl-standard-template-library-">STL (Standard Template Library)</a>
                <ol>
                    <li><a href="#kolekcje-w-stl">Kolekcje w STL</a></li>
                    <li><a href="#stl-standard-template-library-">STL (Standard Template Library)</a></li>
                    <li><a href="#kolekcje-w-stl">Kolekcje w STL</a>
                        <ol>
                            <li><a href="#vector">vector</a></li>
                            <li><a href="#list">list</a></li>
                            <li><a href="#map">map</a></li>
                            <li><a href="#unordered_map">unordered_map</a></li>
                            <li><a href="#set">set</a></li>
                            <li><a href="#unordered_set">unordered_set</a></li>
                            <li><a href="#priority_queue">priority_queue</a></li>
                            <li><a href="#queue">queue</a></li>
                            <li><a href="#stack">stack</a></li>
                        </ol>
                    </li>
                    <li><a href="#iteratory">Iteratory</a>
                        <ol>
                            <li><a href="#rodzaje-iteratorów">Rodzaje iteratorów</a></li>
                            <li><a href="#podstawowe-operacje-na-iteratorach">Podstawowe operacje na iteratorach</a></li>
                            <li><a href="#przykład-użycia-iteratora">Przykład użycia iteratora</a></li>
                        </ol>
                    </li>
                    <li><a href="#algorytmy-w-standardowej-bibliotece-c-stl-">Algorytmy w Standardowej Bibliotece C++ (STL)</a>
                        <ol>
                            <li><a href="#wprowadzenie-do-algorytmów-stl">Wprowadzenie do Algorytmów STL</a></li>
                            <li><a href="#klasyfikacja-algorytmów">Klasyfikacja Algorytmów</a></li>
                            <li><a href="#std-sort-">std::sort()</a></li>
                            <li><a href="#std-find-">std::find()</a></li>
                            <li><a href="#std-for_each-">std::for_each()</a></li>
                            <li><a href="#std-count_if-">std::count_if()</a></li>
                            <li><a href="#inne-ważne-algorytmy">Inne Ważne Algorytmy</a></li>
                            <li><a href="#kompatybilność-z-iteratorami">Kompatybilność z Iteratorami</a></li>
                            <li><a href="#zastosowanie-algorytmów-w-praktyce">Zastosowanie Algorytmów w Praktyce</a></li>
                            <li><a href="#optymalizacja-za-pomocą-algorytmów">Optymalizacja za Pomocą Algorytmów</a></li>
                        </ol>
                    </li>
                </ol>
            </ol>
            <div id="related-articles">
                <h2>Related Articles</h2>
                <ol>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/01_proces_kompilacji.html">Proces Kompilacji</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/02_preprocesor.html">Preprocesor</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/03_zmienne_i_typy_danych.html">Zmienne i Typy Danych</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/04_interakcja_z_konsola.html">Interakcja z Konsola</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/05_instrukcja_warunkowa.html">Instrukcja Warunkowa</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/06_petle.html">Petle</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/07_liczby_losowe.html">Liczby Losowe</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/08_typ_wyliczeniowy.html">Typ Wyliczeniowy</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/09_funkcje.html">Funkcje</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/10_l_wartosci_r_wartosci.html">L Wartosci R Wartosci</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/11_wskazniki.html">Wskazniki</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/12_tablice.html">Tablice</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/13_napisy.html">Napisy</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/14_operacje_bitowe.html">Operacje Bitowe</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/15_programowanie_obietkowe.html">Programowanie Obietkowe</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/16_dziedziczenie.html">Dziedziczenie</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/17_zaawansowane_wskazniki.html">Zaawansowane Wskazniki</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/18_przeciazanie.html">Przeciazanie</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/19_konwersje.html">Konwersje</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/20_lambdy.html">Lambdy</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/21_szablony.html">Szablony</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/22_wyjatki.html">Wyjatki</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/23_stl.html">Stl</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/24_praca_z_plikami.html">Praca z Plikami</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/25_c_vs_cpp.html">C vs Cpp</a></li>
                </ol>
            </div>
        </div>
    </div>
    <footer>
        <div class="footer-columns">
            <div class="footer-column">
                <img alt="Adam Djellouli Symbol" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/symbol.png" />
            </div>
            <div class="footer-column">
                <h2><a href="https://adamdjellouli.com/core/privacy_policy.html" title="Privacy Policy">Our Privacy Policy</a></h2>
                <p>
                    Thank you for visiting my personal website. All of the <br />
                    content on this site is free to use, but please remember <br />
                    to be a good human being and refrain from any abuse<br />
                    of the site. If you would like to contact me, please use <br />
                    my <a href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" title="LinkedIn Profile">LinkedIn profile</a> or my <a href="https://github.com/djeada" title="GitHub Profile">GitHub</a> if you have any technical <br />
                    issues or ideas to share. I wish you the best and hope you <br />
                    have a fantastic life. <br />
                </p>
            </div>
            <div class="footer-column">
                <h2>Follow me</h2>
                <ul class="social-media">
                    <li>
                        <a class="fa fa-youtube" href="https://www.youtube.com/channel/UCGPoHTVjMN77wcGknXPHl1Q" target="_blank" title="YouTube">
                        </a>YouTube
                    </li>
                    <li>
                        <a class="fa fa-linkedin" href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" target="_blank" title="LinkedIn">
                        </a>LinkedIn
                    </li>
                    <li>
                        <a class="fa fa-instagram" href="https://www.instagram.com/linuxchallenges/" target="_blank" title="Instagram">
                        </a>Instagram
                    </li>
                    <li>
                        <a class="fa fa-github" href="https://github.com/djeada" title="GitHub">
                        </a>Github
                    </li>
                </ul>
            </div>
        </div>
        <div>
            <p id="copyright">
                © Adam Djellouli. All rights reserved.
            </p>
        </div>
        <script>
            document.getElementById("copyright").innerHTML = "&copy; " + new Date().getFullYear() + " Adam Djellouli. All rights reserved.";
        </script>
        <script src="../../app.js"></script>
    </footer>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-bash.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-cpp.min.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
jax: ["input/TeX", "output/HTML-CSS"],
extensions: ["tex2jax.js"],
"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] },
tex2jax: { inlineMath: [ ["$", "$"] ], displayMath: [ ["$$","$$"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
TeX: { noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } } },
messageStyle: "none"
});
</script>
<script async="" id="MathJax-script" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>

</html>