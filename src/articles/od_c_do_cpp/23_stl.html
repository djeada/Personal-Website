<!DOCTYPE html>

<html lang="pl">

<head>
    <script async="" crossorigin="anonymous" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5593122079896089"></script>
    <meta charset="utf-8" />
    <title>STL (Standard Template Library)</title>
    <meta content="STL to biblioteka szablonów w języku C++, która dostarcza gotowych do użycia implementacji wielu funkcji, algorytmów i struktur danych." name="description" />
    <meta content="Adam Djellouli" name="author" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <meta content="IE=edge" http-equiv="X-UA-Compatible" />
    <link crossorigin="" href="https://fonts.googleapis.com" rel="preconnect" />
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/icon.ico" rel="icon" />
    <link href="../../resources/style.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />
</head>

<body>
    <nav aria-label="Main navigation">
        <a class="logo" href="https://adamdjellouli.com">
            <img alt="Adam Djellouli - Home Page Logo" id="logo-image" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/logo.PNG" />
        </a>
        <input aria-label="Toggle navigation menu" id="navbar-toggle" type="checkbox" />
        <ul aria-labelledby="navbar-toggle" role="menu">
            <li role="menuitem">
                <a href="../../index.html" title="Go to Home Page"> Home </a>
            </li>
            <li role="menuitem">
                <a class="active" href="../../core/blog.html" title="Read Adam Djellouli Blog on Programming and Technology"> Blog </a>
            </li>
            <li role="menuitem">
                <a href="../../core/tools.html" title="Discover Tools Created by Adam Djellouli"> Tools </a>
            </li>
            <li role="menuitem">
                <a href="../../core/projects.html" title="Explore Projects Developed by Adam Djellouli"> Projects </a>
            </li>
            <li role="menuitem">
                <a href="../../core/resume.html" title="View Adam Djellouli Professional Resume"> Resume </a>
            </li>
            <li>
                <script async="" src="https://cse.google.com/cse.js?cx=8160ef9bb935f4f68"></script>
                <div class="gcse-search"></div>
            </li>
            <li>
                <button aria-label="Toggle dark mode" id="dark-mode-button"></button>
            </li>
        </ul>
    </nav>
    <div id="article-wrapper">
        <section id="article-body">
            <p style="text-align: right;"><i>Last modified: June 15, 2024</i></p>
            <p style="text-align: right;"><i>This article is written in: 🇵🇱</i></p>
            <h2 id="stl-standard-template-library-">STL (Standard Template Library)</h2>
            <p>STL to biblioteka szablonów w języku C++, która dostarcza gotowych do użycia implementacji wielu funkcji, algorytmów i struktur danych. Najważniejsze komponenty biblioteki STL to:</p>
            <ul>
                <li><code>vector</code></li>
                <li><code>list</code></li>
                <li><code>map</code></li>
                <li><code>set</code></li>
                <li><code>queue</code></li>
                <li><code>stack</code></li>
                <li><code>algorithm</code></li>
                <li><code>iterator</code></li>
                <li><code>memory</code></li>
            </ul>
            <h3 id="kolekcje-w-stl">Kolekcje w STL</h3>
            <p>Kolekcje w STL to zbiory implementacji struktur danych wraz z funkcjami operującymi na tych strukturach.</p>
            <h3 id="stl-standard-template-library-">STL (Standard Template Library)</h3>
            <p>STL to biblioteka szablonów w języku C++, która dostarcza gotowych do użycia implementacji wielu funkcji, algorytmów i struktur danych. Najważniejsze komponenty biblioteki STL to:</p>
            <ul>
                <li><code>vector</code></li>
                <li><code>list</code></li>
                <li><code>map</code></li>
                <li><code>set</code></li>
                <li><code>unordered_map</code></li>
                <li><code>unordered_set</code></li>
                <li><code>priority_queue</code></li>
                <li><code>queue</code></li>
                <li><code>stack</code></li>
                <li><code>algorithm</code></li>
                <li><code>iterator</code></li>
                <li><code>memory</code></li>
            </ul>
            <p>Dodanie kolumny "Złożoność czasowa" do każdej tabeli może pomóc lepiej zrozumieć wydajność różnych operacji. Oto zaktualizowane tabele:</p>
            <h3 id="kolekcje-w-stl">Kolekcje w STL</h3>
            <p>Kolekcje w STL to zbiory implementacji struktur danych wraz z funkcjami operującymi na tych strukturach.</p>
            <h4 id="vector"><strong>vector</strong></h4>
            <p><code>vector</code> to dynamiczna tablica, która może zmieniać swój rozmiar. Jest jednym z najczęściej używanych kontenerów w STL.</p>
            <p>Operacje:</p>
            <p>
            <table>
                <tr>
                    <td>Metoda</td>
                    <td>Opis</td>
                    <td>Przykład użycia</td>
                    <td>Złożoność czasowa</td>
                </tr>
                <tr>
                    <td><code>push_back(value)</code></td>
                    <td>Dodaje element na końcu</td>
                    <td><code>vec.push_back(10);</code></td>
                    <td>Amortyzowane O(1)</td>
                </tr>
                <tr>
                    <td><code>pop_back()</code></td>
                    <td>Usuwa element z końca</td>
                    <td><code>vec.pop_back();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>size()</code></td>
                    <td>Zwraca liczbę elementów</td>
                    <td><code>auto s = vec.size();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>empty()</code></td>
                    <td>Sprawdza, czy kontener jest pusty</td>
                    <td><code>if (vec.empty()) {}</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>clear()</code></td>
                    <td>Usuwa wszystkie elementy</td>
                    <td><code>vec.clear();</code></td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><code>insert(pos, value)</code></td>
                    <td>Wstawia element na podanej pozycji</td>
                    <td><code>vec.insert(vec.begin() + 1, 20);</code></td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><code>erase(pos)</code></td>
                    <td>Usuwa element z podanej pozycji</td>
                    <td><code>vec.erase(vec.begin() + 1);</code></td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><code>at(index)</code></td>
                    <td>Zwraca referencję do elementu na podanym indeksie</td>
                    <td><code>int val = vec.at(2);</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>operator[]</code></td>
                    <td>Zwraca referencję do elementu na podanym indeksie</td>
                    <td><code>int val = vec[2];</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>front()</code></td>
                    <td>Zwraca referencję do pierwszego elementu</td>
                    <td><code>int val = vec.front();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>back()</code></td>
                    <td>Zwraca referencję do ostatniego elementu</td>
                    <td><code>int val = vec.back();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>begin()</code></td>
                    <td>Zwraca iterator na początek</td>
                    <td><code>auto it = vec.begin();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>end()</code></td>
                    <td>Zwraca iterator na koniec</td>
                    <td><code>auto it = vec.end();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>reserve(n)</code></td>
                    <td>Rezerwuje miejsce na n elementów</td>
                    <td><code>vec.reserve(100);</code></td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><code>resize(n)</code></td>
                    <td>Zmienia rozmiar wektora</td>
                    <td><code>vec.resize(10);</code></td>
                    <td>O(n)</td>
                </tr>
            </table>
            </p>
            <p>Przykład:</p>
            <p>
            <div>
                <pre><code class="language-clike">std::vector&lt;int&gt; vec = {1, 2, 3};
vec.push_back(4);
vec.insert(vec.begin() + 1, 10);
for(auto it = vec.begin(); it != vec.end(); ++it) {
std::cout &lt;&lt; *it &lt;&lt; " ";
}</code></pre>
            </div>
            </p>
            <h4 id="list"><strong>list</strong></h4>
            <p><code>list</code> to dwukierunkowa lista wiązana, która umożliwia szybkie wstawianie i usuwanie elementów.</p>
            <p>Operacje:</p>
            <p>| Metoda | Opis | Przykład użycia | Złożoność czasowa |
                |----------------------|----------------------------------------------|-----------------------------------------------------------|-----------------------|
                | <code>push_back(value)</code> | Dodaje element na końcu | <code>lst.push_back(10);</code> | O(1) |
                | <code>push_front(value)</code> | Dodaje element na początku | <code>lst.push_front(5);</code> | O(1) |
                | <code>pop_back()</code> | Usuwa element z końca | <code>lst.pop_back();</code> | O(1) |
                | <code>pop_front()</code> | Usuwa element z początku | <code>lst.pop_front();</code> | O(1) |
                | <code>size()</code> | Zwraca liczbę elementów | <code>auto s = lst.size();</code> | O(1) |
                | <code>empty()</code> | Sprawdza, czy kontener jest pusty | <code>if (lst.empty()) {}</code> | O(1) |
                | <code>clear()</code> | Usuwa wszystkie elementy | <code>lst.clear();</code> | O(n) |
                | <code>insert(pos, value)</code> | Wstawia element na podanej pozycji | <code>lst.insert(++lst.begin(), 20);</code> | O(1) |
                | <code>erase(pos)</code> | Usuwa element z podanej pozycji | <code>lst.erase(++lst.begin());</code> | O(1) |
                | <code>front()</code> | Zwraca referencję do pierwszego elementu | <code>int val = lst.front();</code> | O(1) |
                | <code>back()</code> | Zwraca referencję do ostatniego elementu | <code>int val = lst.back();</code> | O(1) |
                | <code>begin()</code> | Zwraca iterator na początek | <code>auto it = lst.begin();</code> | O(1) |
                | <code>end()</code> | Zwraca iterator na koniec | <code>auto it = lst.end();</code> | O(1) |</p>
            <p>Przykład:</p>
            <p>
            <div>
                <pre><code class="language-clike">std::list&lt;int&gt; lst = {1, 2, 3};
lst.push_back(4);
lst.push_front(0);
lst.insert(++lst.begin(), 10);
for(auto it = lst.begin(); it != lst.end(); ++it) {
std::cout &lt;&lt; *it &lt;&lt; " ";
}</code></pre>
            </div>
            </p>
            <h4 id="map"><strong>map</strong></h4>
            <p><code>map</code> to kontener asocjacyjny, który przechowuje pary klucz-wartość w uporządkowanej formie, wykorzystując drzewo czerwono-czarne.</p>
            <p>Operacje:</p>
            <p>
            <table>
                <tr>
                    <td>Metoda</td>
                    <td>Opis</td>
                    <td>Przykład użycia</td>
                    <td>Złożoność czasowa</td>
                </tr>
                <tr>
                    <td><code>insert({key, value})</code></td>
                    <td>Wstawia parę klucz-wartość</td>
                    <td><code>mp.insert({1, "one"});</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>erase(key)</code></td>
                    <td>Usuwa element o podanym kluczu</td>
                    <td><code>mp.erase(1);</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>find(key)</code></td>
                    <td>Zwraca iterator na element o podanym kluczu</td>
                    <td><code>auto it = mp.find(1);</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>size()</code></td>
                    <td>Zwraca liczbę elementów</td>
                    <td><code>auto s = mp.size();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>empty()</code></td>
                    <td>Sprawdza, czy kontener jest pusty</td>
                    <td><code>if (mp.empty()) {}</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>clear()</code></td>
                    <td>Usuwa wszystkie elementy</td>
                    <td><code>mp.clear();</code></td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><code>operator[]</code></td>
                    <td>Zwraca referencję do wartości o podanym kluczu</td>
                    <td><code>std::string val = mp[1];</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>begin()</code></td>
                    <td>Zwraca iterator na początek</td>
                    <td><code>auto it = mp.begin();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>end()</code></td>
                    <td>Zwraca iterator na koniec</td>
                    <td><code>auto it = mp.end();</code></td>
                    <td>O(1)</td>
                </tr>
            </table>
            </p>
            <p>Przykład:</p>
            <p>
            <div>
                <pre><code class="language-clike">std::map&lt;int, std::string=""&gt; mp;
mp.insert({1, "one"});
mp[2] = "two";
mp.erase(1);
for(auto it = mp.begin(); it != mp.end(); ++it) {
std::cout &lt;&lt; it-&gt;first &lt;&lt; ": " &lt;&lt; it-&gt;second &lt;&lt; " ";
}</code></pre>
            </div>
            </p>
            <h4 id="unordered_map"><strong>unordered_map</strong></h4>
            <p><code>unordered_map</code> to kontener asocjacyjny, który przechowuje pary klucz-wartość w nieuporządkowanej formie, wykorzystując tablicę mieszającą (hash table).</p>
            <p>Operacje:</p>
            <p>| Metoda | Opis | Przykład użycia | Złożoność czasowa |
                |----------------------|----------------------------------------------|-----------------------------------------------------------|-----------------------|
                | <code>insert({key, value})</code>| Wstawia parę klucz-wartość | <code>ump.insert({1, "one"});</code> | O(1) amortyzowane |
                | <code>erase(key)</code> | Usuwa element o podanym kluczu | <code>ump.erase(1);</code> | O(1) amortyzowane |
                | <code>find(key)</code> | Zwraca iterator na element o podanym kluczu | <code>auto it = ump.find(1);</code> | O(1) amortyzowane |
                | <code>size()</code> | Zwraca liczbę elementów | <code>auto s = ump.size();</code> | O(1) |
                | <code>empty()</code> | Sprawdza, czy kontener jest pusty | <code>if (ump.empty()) {}</code> | O(1) |
                | <code>clear()</code> | Usuwa wszystkie elementy | <code>ump.clear();</code> | O(n) |
                | <code>operator[]</code> | Zwraca referencję do wartości o podanym kluczu | <code>std::string val = ump[1];</code> | O(1) amortyzowane |
                | <code>begin()</code> | Zwraca iterator na początek | <code>auto it = ump.begin();</code> | O(1) |
                | <code>end()</code> | Zwraca iterator na koniec | <code>auto it = ump.end();</code> | O(1) |</p>
            <p>Przykład:</p>
            <p>
            <div>
                <pre><code class="language-clike">std::unordered_map&lt;int, std::string=""&gt; ump;
ump.insert({1, "one"});
ump[2] = "two";
ump.erase(1);
for(auto it = ump.begin(); it != ump.end(); ++it) {
std::cout &lt;&lt; it-&gt;first &lt;&lt; ": " &lt;&lt; it-&gt;second &lt;&lt; " ";
}</code></pre>
            </div>
            </p>
            <h4 id="set"><strong>set</strong></h4>
            <p><code>set</code> to kontener, który przechowuje unikalne elementy w uporządkowanej formie, wykorzystując drzewo czerwono-czarne.</p>
            <p>Operacje:</p>
            <p>Oto poprawiona tabela:</p>
            <p>
            <table>
                <tr>
                    <td>Metoda</td>
                    <td>Opis</td>
                    <td>Przykład użycia</td>
                    <td>Złożoność czasowa</td>
                </tr>
                <tr>
                    <td><code>insert(value)</code></td>
                    <td>Wstawia element</td>
                    <td><code>st.insert(10);</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>erase(value)</code></td>
                    <td>Usuwa element</td>
                    <td><code>st.erase(10);</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>find(value)</code></td>
                    <td>Zwraca iterator na element</td>
                    <td><code>auto it = st.find(10);</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>size()</code></td>
                    <td>Zwraca liczbę elementów</td>
                    <td><code>auto s = st.size();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>empty()</code></td>
                    <td>Sprawdza, czy kontener jest pusty</td>
                    <td><code>if (st.empty()) {}</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>clear()</code></td>
                    <td>Usuwa wszystkie elementy</td>
                    <td><code>st.clear();</code></td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><code>begin()</code></td>
                    <td>Zwraca iterator na początek</td>
                    <td><code>auto it = st.begin();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>end()</code></td>
                    <td>Zwraca iterator na koniec</td>
                    <td><code>auto it = st.end();</code></td>
                    <td>O(1)</td>
                </tr>
            </table>
            </p>
            <p>Przykład:</p>
            <p>
            <div>
                <pre><code class="language-clike">std::set&lt;int&gt; st;
st.insert(10);
st.insert(20);
st.erase(10);
for(auto it = st.begin(); it != st.end(); ++it) {
std::cout &lt;&lt; *it &lt;&lt; " ";
}</code></pre>
            </div>
            </p>
            <h4 id="unordered_set"><strong>unordered_set</strong></h4>
            <p><code>unordered_set</code> to kontener, który przechowuje unikalne elementy w nieuporządkowanej formie, wykorzystując tablicę mieszającą (hash table).</p>
            <p>Operacje:</p>
            <p>| Metoda | Opis | Przykład użycia | Złożoność czasowa |
                |----------------------|----------------------------------------------|-----------------------------------------------------------|-----------------------|
                | <code>insert(value)</code> | Wstawia element | <code>ust.insert(10);</code> | O(1) amortyzowane |
                | <code>erase(value)</code> | Usuwa element | <code>ust.erase(10);</code> | O(1) amortyzowane |
                | <code>find(value)</code> | Zwraca iterator na element | <code>auto it = ust.find(10);</code> | O(1) amortyzowane |
                | <code>size()</code> | Zwraca liczbę elementów | <code>auto s = ust.size();</code> | O(1) |
                | <code>empty()</code> | Sprawdza, czy kontener jest pusty | <code>if (ust.empty()) {}</code> | O(1) |
                | <code>clear()</code> | Usuwa wszystkie elementy | <code>ust.clear();</code> | O(n) |
                | <code>begin()</code> | Zwraca iterator na początek | <code>auto it = ust.begin();</code> | O(1) |
                | <code>end()</code> | Zwraca iterator na koniec | <code>auto it = ust.end();</code> | O(1) |</p>
            <p>Przykład:</p>
            <p>
            <div>
                <pre><code class="language-clike">std::unordered_set&lt;int&gt; ust;
ust.insert(10);
ust.insert(20);
ust.erase(10);
for(auto it = ust.begin(); it != ust.end(); ++it) {
std::cout &lt;&lt; *it &lt;&lt; " ";
}</code></pre>
            </div>
            </p>
            <h4 id="priority_queue"><strong>priority_queue</strong></h4>
            <p><code>priority_queue</code> to kontener, który implementuje kopiec binarny i pozwala na szybkie wyciąganie największego (lub najmniejszego) elementu.</p>
            <p>Operacje:</p>
            <p>
            <table>
                <tr>
                    <td>Metoda</td>
                    <td>Opis</td>
                    <td>Przykład użycia</td>
                    <td>Złożoność czasowa</td>
                </tr>
                <tr>
                    <td><code>push(value)</code></td>
                    <td>Dodaje element</td>
                    <td><code>pq.push(10);</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>pop()</code></td>
                    <td>Usuwa największy element</td>
                    <td><code>pq.pop();</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>top()</code></td>
                    <td>Zwraca referencję do największego elementu</td>
                    <td><code>int val = pq.top();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>size()</code></td>
                    <td>Zwraca liczbę elementów</td>
                    <td><code>auto s = pq.size();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>empty()</code></td>
                    <td>Sprawdza, czy kontener jest pusty</td>
                    <td><code>if (pq.empty()) {}</code></td>
                    <td>O(1)</td>
                </tr>
            </table>
            </p>
            <p>Przykład:</p>
            <p>
            <div>
                <pre><code class="language-clike">std::priority_queue&lt;int&gt; pq;
pq.push(10);
pq.push(20);
pq.push(5);
std::cout &lt;&lt; pq.top() &lt;&lt; " "; // wyświetli 20
pq.pop();
std::cout &lt;&lt; pq.top() &lt;&lt; " "; // wyświetli 10</code></pre>
            </div>
            </p>
            <h4 id="queue"><strong>queue</strong></h4>
            <p><code>queue</code> to kontener, który implementuje kolejkę FIFO (First In, First Out).</p>
            <p>Operacje:</p>
            <p>| Metoda | Opis | Przykład użycia | Złożoność czasowa |
                |----------------------|----------------------------------------------|-----------------------------------------------------------|-----------------------|
                | <code>push(value)</code> | Dodaje element | <code>q.push(10);</code> | O(1) |
                | <code>pop()</code> | Usuwa element z początku | <code>q.pop();</code> | O(1) |
                | <code>front()</code> | Zwraca referencję do pierwszego elementu | <code>int val = q.front();</code> | O(1) |
                | <code>back()</code> | Zwraca referencję do ostatniego elementu | <code>int val = q.back();</code> | O(1) |
                | <code>size()</code> | Zwraca liczbę elementów | <code>auto s = q.size();</code> | O(1) |
                | <code>empty()</code> | Sprawdza, czy kontener jest pusty | <code>if (q.empty()) {}</code> | O(1) |</p>
            <p>Przykład:</p>
            <p>
            <div>
                <pre><code class="language-clike">std::queue&lt;int&gt; q;
q.push(10);
q.push(20);
std::cout &lt;&lt; q.front() &lt;&lt; " "; // wyświetli 10
q.pop();
std::cout &lt;&lt; q.front() &lt;&lt; " "; // wyświetli 20</code></pre>
            </div>
            </p>
            <h4 id="stack"><strong>stack</strong></h4>
            <p><code>stack</code> to kontener, który implementuje stos LIFO (Last In, First Out).</p>
            <p>Operacje:</p>
            <p>
            <table>
                <tr>
                    <td>Metoda</td>
                    <td>Opis</td>
                    <td>Przykład użycia</td>
                    <td>Złożoność czasowa</td>
                </tr>
                <tr>
                    <td><code>push(value)</code></td>
                    <td>Dodaje element</td>
                    <td><code>st.push(10);</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>pop()</code></td>
                    <td>Usuwa element z końca</td>
                    <td><code>st.pop();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>top()</code></td>
                    <td>Zwraca referencję do ostatniego elementu</td>
                    <td><code>int val = st.top();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>size()</code></td>
                    <td>Zwraca liczbę elementów</td>
                    <td><code>auto s = st.size();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>empty()</code></td>
                    <td>Sprawdza, czy kontener jest pusty</td>
                    <td><code>if (st.empty()) {}</code></td>
                    <td>O(1)</td>
                </tr>
            </table>
            </p>
            <p>Przykład:</p>
            <p>
            <div>
                <pre><code class="language-clike">std::stack&lt;int&gt; st;
st.push(10);
st.push(20);
std::cout &lt;&lt; st.top() &lt;&lt; " "; // wyświetli 20
st.pop();
std::cout &lt;&lt; st.top() &lt;&lt; " "; // wyświetli 10</code></pre>
            </div>
            </p>
            <h3 id="iteratory">Iteratory</h3>
            <p>Iteratory w języku C++ to obiekty umożliwiające sekwencyjny dostęp do elementów kontenerów. Dzięki nim możliwe jest jednolite przeglądanie zawartości różnych typów kolekcji, niezależnie od ich wewnętrznej implementacji. Iteratory pełnią podobną rolę do wskaźników, ale są bardziej elastyczne i bezpieczne w użyciu.</p>
            <h4 id="rodzaje-iteratorów">Rodzaje iteratorów</h4>
            <ol>
                <li><strong>Input Iterator</strong>: Służy do odczytu danych z kontenera.</li>
                <li><strong>Output Iterator</strong>: Służy do zapisu danych do kontenera.</li>
                <li><strong>Forward Iterator</strong>: Łączy możliwości iteratorów input i output, może przemieszczać się tylko do przodu.</li>
                <li><strong>Bidirectional Iterator</strong>: Umożliwia przemieszczanie się zarówno do przodu, jak i do tyłu.</li>
                <li><strong>Random Access Iterator</strong>: Oferuje wszystkie możliwości Bidirectional Iterator oraz umożliwia dostęp do dowolnego elementu kontenera w stałym czasie.</li>
            </ol>
            <h4 id="podstawowe-operacje-na-iteratorach">Podstawowe operacje na iteratorach</h4>
            <ul>
                <li>Inicjalizacja iteratora początkowym elementem kontenera: <code>kontener.begin()</code></li>
                <li>Inicjalizacja iteratora elementem za ostatnim w kontenerze: <code>kontener.end()</code></li>
                <li>Odwołanie do elementu, na który wskazuje iterator: <code>*it</code></li>
                <li>Przesunięcie iteratora do następnego elementu: <code>++it</code></li>
                <li>Przesunięcie iteratora do poprzedniego elementu: <code>--it</code> (dla Bidirectional Iterator)</li>
                <li>Przesunięcie iteratora o określoną liczbę pozycji: <code>it += n</code> lub <code>it -= n</code> (dla Random Access Iterator)</li>
                <li>Wstawienie elementu w miejscu wskazywanym przez iterator: <code>it = kontener.insert(it, wartość)</code></li>
                <li>Usunięcie elementu w miejscu wskazywanym przez iterator: <code>it = kontener.erase(it)</code></li>
            </ul>
            <h4 id="przykład-użycia-iteratora">Przykład użycia iteratora</h4>
            <p>Poniższy przykład ilustruje operacje na wektorze <code>std::vector</code> typu <code>std::string</code>. Najpierw tworzy i inicjalizuje wektor trzema elementami: "ala", "ma", "kota", a następnie wyświetla jego zawartość za pomocą iteratora. Następnie dodaje nowy element "nie" przed drugim elementem wektora, czyli przed "ma". Po tym usuwa pierwszy element wektora, którym jest "ala". Na koniec, program ponownie wyświetla zmodyfikowaną zawartość wektora.</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;std::string&gt; v = {"ala", "ma", "kota"};

    // Wyświetlenie zawartości wektora przy użyciu iteratora
    for (auto it = v.begin(); it != v.end(); ++it) {
        std::cout &lt;&lt; *it &lt;&lt; std::endl;
    }

    // Dodanie nowego elementu przed "ma"
    auto it = v.begin() + 1;
    v.insert(it, "nie");

    // Usunięcie słowa "ala"
    it = v.begin();
    v.erase(it);

    std::cout &lt;&lt; "\nPo modyfikacjach:\n";
    for (const auto&amp; word : v) {
        std::cout &lt;&lt; word &lt;&lt; std::endl;
    }

    return 0;
}</code></pre>
            </div>
            </p>
            <p>Warto pamiętać, że po niektórych operacjach, takich jak insert czy erase, używane wcześniej iteratory mogą stać się nieaktualne i ich dalsze użycie może prowadzić do niezdefiniowanego zachowania programu.</p>
            <h3 id="algorytmy">Algorytmy</h3>
            <p>Biblioteka <code>algorithm</code> dostarcza bogaty zestaw funkcji, które służą do manipulacji i analizy kolekcji. Oto kilka przykładów najbardziej popularnych algorytmów z tej biblioteki:</p>
            <h4 id="sort-">sort()</h4>
            <p>Funkcja <code>sort()</code> służy do sortowania elementów kolekcji. Jej podstawowe użycie polega na przekazaniu dwóch iteratorów: początkowego i końcowego, określających zakres sortowania.</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; wektor{8, 3, 5, 1, 2, 4, 6, 7};
    auto kopia = wektor;

    std::sort(wektor.begin(), wektor.begin() + 3); // posortowane zostaną pierwsze 3 elementy
    std::sort(kopia.begin(), kopia.end());         // posortowane zostaną wszystkie elementy

    for (const auto&amp; val : wektor) {
        std::cout &lt;&lt; val &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;

    for (const auto&amp; val : kopia) {
        std::cout &lt;&lt; val &lt;&lt; " ";
    }

    return 0;
}</code></pre>
            </div>
            </p>
            <h4 id="find-">find()</h4>
            <p>Algorytm <code>find()</code> przeszukuje kolekcję w poszukiwaniu określonego elementu i zwraca iterator wskazujący na pierwsze wystąpienie tego elementu.</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; wektor{8, 3, 5, 1, 2, 4, 6, 7};

    auto it = std::find(wektor.begin(), wektor.end(), 3);

    if (it != wektor.end())
        std::cout &lt;&lt; "Znaleziono element o wartości 3 na pozycji " &lt;&lt; std::distance(wektor.begin(), it) &lt;&lt; std::endl;
    else
        std::cout &lt;&lt; "Nie znaleziono elementu o wartości 3" &lt;&lt; std::endl;

    return 0;
}</code></pre>
            </div>
            </p>
            <h4 id="for_each-">for_each()</h4>
            <p>Funkcja <code>for_each()</code> pozwala na wykonanie określonej operacji na każdym elemencie kolekcji. Operacja ta jest określana za pomocą funkcji lub wyrażenia lambda.</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; wektor{8, 3, 5, 1, 2, 4, 6, 7};
    std::for_each(wektor.begin(), wektor.end(), [](int &amp;x) { x *= 2; });

    for (const auto&amp; val : wektor) {
        std::cout &lt;&lt; val &lt;&lt; " ";
    }

    return 0;
}</code></pre>
            </div>
            </p>
            <h4 id="count_if-">count_if()</h4>
            <p>Algorytm <code>count_if()</code> pozwala zliczyć, ile razy spełniony jest określony warunek w kolekcji.</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; wektor{8, 3, 5, 1, 2, 4, 6, 7};
    int parzyste = std::count_if(wektor.begin(), wektor.end(), [](int x) { return x % 2 == 0; });

    std::cout &lt;&lt; "Liczba parzystych elementów: " &lt;&lt; parzyste &lt;&lt; std::endl;

    return 0;
}</code></pre>
            </div>
            </p>
            <p>Powyższy kod wykorzystuje <code>count_if()</code> do zliczenia parzystych elementów w wektorze. Algorytmy w STL są potężnym narzędziem umożliwiającym efektywne i wygodne operacje na kontenerach, minimalizując ilość kodu potrzebnego do wykonania złożonych zadań.</p>
        </section>
        <div id="table-of-contents">
            <h2>Spis Treści</h2>
            <ol><a href="#stl-standard-template-library-">STL (Standard Template Library)</a>
                <ol>
                    <li><a href="#kolekcje-w-stl">Kolekcje w STL</a></li>
                    <li><a href="#stl-standard-template-library-">STL (Standard Template Library)</a></li>
                    <li><a href="#kolekcje-w-stl">Kolekcje w STL</a>
                        <ol>
                            <li><a href="#vector">vector</a></li>
                            <li><a href="#list">list</a></li>
                            <li><a href="#map">map</a></li>
                            <li><a href="#unordered_map">unordered_map</a></li>
                            <li><a href="#set">set</a></li>
                            <li><a href="#unordered_set">unordered_set</a></li>
                            <li><a href="#priority_queue">priority_queue</a></li>
                            <li><a href="#queue">queue</a></li>
                            <li><a href="#stack">stack</a></li>
                        </ol>
                    </li>
                    <li><a href="#iteratory">Iteratory</a>
                        <ol>
                            <li><a href="#rodzaje-iteratorów">Rodzaje iteratorów</a></li>
                            <li><a href="#podstawowe-operacje-na-iteratorach">Podstawowe operacje na iteratorach</a></li>
                            <li><a href="#przykład-użycia-iteratora">Przykład użycia iteratora</a></li>
                        </ol>
                    </li>
                    <li><a href="#algorytmy">Algorytmy</a>
                        <ol>
                            <li><a href="#sort-">sort()</a></li>
                            <li><a href="#find-">find()</a></li>
                            <li><a href="#for_each-">for_each()</a></li>
                            <li><a href="#count_if-">count_if()</a></li>
                        </ol>
                    </li>
                </ol>
            </ol>
            <div id="related-articles">
                <h2>Related Articles</h2>
                <ol>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/01_proces_kompilacji.html">Proces Kompilacji</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/02_preprocesor.html">Preprocesor</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/03_zmienne_i_typy_danych.html">Zmienne i Typy Danych</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/04_interakcja_z_konsola.html">Interakcja z Konsola</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/05_instrukcja_warunkowa.html">Instrukcja Warunkowa</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/06_petle.html">Petle</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/07_liczby_losowe.html">Liczby Losowe</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/08_typ_wyliczeniowy.html">Typ Wyliczeniowy</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/09_funkcje.html">Funkcje</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/10_l_wartosci_r_wartosci.html">L Wartosci R Wartosci</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/11_wskazniki.html">Wskazniki</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/12_tablice.html">Tablice</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/13_napisy.html">Napisy</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/14_operacje_bitowe.html">Operacje Bitowe</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/15_programowanie_obietkowe.html">Programowanie Obietkowe</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/16_dziedziczenie.html">Dziedziczenie</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/17_zaawansowane_wskazniki.html">Zaawansowane Wskazniki</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/18_przeciazanie.html">Przeciazanie</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/19_konwersje.html">Konwersje</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/20_lambdy.html">Lambdy</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/21_szablony.html">Szablony</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/22_wyjatki.html">Wyjatki</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/23_stl.html">Stl</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/24_praca_z_plikami.html">Praca z Plikami</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/25_c_vs_cpp.html">C vs Cpp</a></li>
                </ol>
            </div>
        </div>
    </div>
    <footer>
        <div class="footer-columns">
            <div class="footer-column">
                <img alt="Adam Djellouli Symbol" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/symbol.png" />
            </div>
            <div class="footer-column">
                <h2><a href="https://adamdjellouli.com/core/privacy_policy.html" title="Privacy Policy">Our Privacy Policy</a></h2>
                <p>
                    Thank you for visiting my personal website. All of the <br />
                    content on this site is free to use, but please remember <br />
                    to be a good human being and refrain from any abuse<br />
                    of the site. If you would like to contact me, please use <br />
                    my <a href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" title="LinkedIn Profile">LinkedIn profile</a> or my <a href="https://github.com/djeada" title="GitHub Profile">GitHub</a> if you have any technical <br />
                    issues or ideas to share. I wish you the best and hope you <br />
                    have a fantastic life. <br />
                </p>
            </div>
            <div class="footer-column">
                <h2>Follow me</h2>
                <ul class="social-media">
                    <li>
                        <a class="fa fa-youtube" href="https://www.youtube.com/channel/UCGPoHTVjMN77wcGknXPHl1Q" target="_blank" title="YouTube">
                        </a>YouTube
                    </li>
                    <li>
                        <a class="fa fa-linkedin" href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" target="_blank" title="LinkedIn">
                        </a>LinkedIn
                    </li>
                    <li>
                        <a class="fa fa-instagram" href="https://www.instagram.com/linuxchallenges/" target="_blank" title="Instagram">
                        </a>Instagram
                    </li>
                    <li>
                        <a class="fa fa-github" href="https://github.com/djeada" title="GitHub">
                        </a>Github
                    </li>
                </ul>
            </div>
        </div>
        <div>
            <p id="copyright">
                © Adam Djellouli. All rights reserved.
            </p>
        </div>
        <script>
            document.getElementById("copyright").innerHTML = "&copy; " + new Date().getFullYear() + " Adam Djellouli. All rights reserved.";
        </script>
        <script src="../../app.js"></script>
    </footer>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-bash.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-cpp.min.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
jax: ["input/TeX", "output/HTML-CSS"],
extensions: ["tex2jax.js"],
"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] },
tex2jax: { inlineMath: [ ["$", "$"] ], displayMath: [ ["$$","$$"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
TeX: { noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } } },
messageStyle: "none"
});
</script>
<script async="" id="MathJax-script" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>

</html>