<!DOCTYPE html>

<html lang="pl">

<head>
    <script async="" crossorigin="anonymous" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5593122079896089"></script>
    <meta charset="utf-8" />
    <title>STL (Standard Template Library)</title>
    <meta content="Standard Template Library (STL) to jedna z najwa偶niejszych czci jzyka C++, kt贸ra znaczco uatwia programowanie dziki dostpowi do gotowych, wydajnych i elastycznych struktur danych oraz algorytm贸w." name="description" />
    <meta content="Adam Djellouli" name="author" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <meta content="IE=edge" http-equiv="X-UA-Compatible" />
    <link crossorigin="" href="https://fonts.googleapis.com" rel="preconnect" />
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/icon.ico" rel="icon" />
    <link href="../../resources/style.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
</head>

<body>
    <nav aria-label="Main navigation">
        <a class="logo" href="https://adamdjellouli.com">
            <img alt="Adam Djellouli - Home Page Logo" id="logo-image" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/logo.PNG" />
        </a>
        <input aria-label="Toggle navigation menu" id="navbar-toggle" type="checkbox" />
        <ul aria-labelledby="navbar-toggle" role="menu">
            <li role="menuitem">
                <a href="../../index.html" title="Go to Home Page"> Home </a>
            </li>
            <li role="menuitem">
                <a class="active" href="../../core/blog.html" title="Read Adam Djellouli Blog on Programming and Technology"> Blog </a>
            </li>
            <li role="menuitem">
                <a href="../../core/tools.html" title="Discover Tools Created by Adam Djellouli"> Tools </a>
            </li>
            <li role="menuitem">
                <a href="../../core/projects.html" title="Explore Projects Developed by Adam Djellouli"> Projects </a>
            </li>
            <li role="menuitem">
                <a href="../../core/resume.html" title="View Adam Djellouli Professional Resume"> Resume </a>
            </li>
            <li>
                <script async="" src="https://cse.google.com/cse.js?cx=8160ef9bb935f4f68"></script>
                <div class="gcse-search"></div>
            </li>
            <li>
                <button aria-label="Toggle dark mode" id="dark-mode-button"></button>
            </li>
        </ul>
    </nav>
    <div id="article-wrapper"><article-section id="article-body">
            <div class="article-action-buttons"><button class="btn-suggest-edit" title="Suggest Edit">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <path d="M4 21h4l11-11-4-4L4 17v4z" stroke="currentColor" stroke-width="2"></path>
                    </svg>
                </button><button class="btn-create-issue" title="Create Issue">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2"></circle>
                        <line stroke="currentColor" stroke-width="2" x1="12" x2="12" y1="8" y2="12"></line>
                        <circle cx="12" cy="16" fill="currentColor" r="1"></circle>
                    </svg>
                </button><button class="btn-download" title="Download">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <path d="M12 5v14m0 0l-6-6m6 6l6-6" stroke="currentColor" stroke-width="2"></path>
                    </svg>
                </button></div>
            <p style="text-align: right;"><i>Last modified: March 10, 2016</i></p>
            <p style="text-align: right;"><i>This article is written in: 叼</i></p>
            <h2 id="stl-standard-template-library-">STL (Standard Template Library)</h2>
            <p>Standard Template Library (STL) to jedna z najwa偶niejszych czci jzyka C++, kt贸ra znaczco uatwia programowanie dziki dostpowi do gotowych, wydajnych i elastycznych struktur danych oraz algorytm贸w. STL jest bibliotek szablon贸w, co oznacza, 偶e jej komponenty s generyczne i mog pracowa z r贸偶nymi typami danych bez koniecznoci pisania dodatkowego kodu. Dziki STL programici mog skupi si na logice aplikacji, zamiast na implementacji podstawowych struktur danych i algorytm贸w.</p>
            <p>STL zostaa zaprojektowana tak, aby wspiera tr贸jskadnikowy model: <strong>algorytmy</strong>, <strong>kontenery</strong> i <strong>iteratory</strong>. Algorytmy operuj na danych przechowywanych w kontenerach, a iteratory su偶 do przechodzenia przez te dane. Ta modularno pozwala na atwe czenie r贸偶nych komponent贸w STL w celu tworzenia zo偶onych operacji na danych.</p>
            <h3 id="g贸wne-komponenty-biblioteki-stl">G贸wne komponenty biblioteki STL</h3>
            <p>STL dostarcza szerokiego wachlarza kontener贸w i algorytm贸w, kt贸re mo偶na dostosowa do r贸偶nych potrzeb programistycznych. Najwa偶niejsze komponenty biblioteki STL to:</p>
            <ul>
                <li><strong>Kontenery sekwencyjne</strong>: <code>vector</code>, <code>list</code>, <code>deque</code></li>
                <li><strong>Kontenery asocjacyjne</strong>: <code>map</code>, <code>set</code>, <code>unordered_map</code>, <code>unordered_set</code></li>
                <li><strong>Kontenery kolejki</strong>: <code>queue</code>, <code>priority_queue</code>, <code>stack</code></li>
                <li><strong>Algorytmy</strong>: funkcje do sortowania, wyszukiwania, modyfikowania danych</li>
                <li><strong>Iteratory</strong>: narzdzia do przechodzenia przez elementy kontener贸w</li>
            </ul>
            <p>Ka偶dy z tych komponent贸w jest zoptymalizowany pod ktem okrelonych operacji, co pozwala na efektywne zarzdzanie danymi w r贸偶nych scenariuszach.</p>
            <h3 id="kolekcje-w-stl">Kolekcje w STL</h3>
            <p>Kolekcje w STL to zbiory implementacji struktur danych wraz z funkcjami operujcymi na tych strukturach. STL oferuje r贸偶norodne kontenery, kt贸re mo偶na wykorzysta w zale偶noci od specyficznych wymaga aplikacji. Wyb贸r odpowiedniego kontenera jest kluczowy dla osignicia optymalnej wydajnoci i efektywnoci pamiciowej. Poni偶ej przedstawione s najczciej u偶ywane kontenery w STL wraz z ich podstawowymi operacjami, przykadami u偶ycia oraz analiz zo偶onoci czasowej.</p>
            <h4 id="vector"><strong>vector</strong></h4>
            <p><code>vector</code> to dynamiczna tablica, kt贸ra mo偶e zmienia sw贸j rozmiar w trakcie dziaania programu. Jest jednym z najczciej u偶ywanych kontener贸w w STL ze wzgldu na swoj prostot i wydajno w wikszoci przypadk贸w. <code>vector</code> przechowuje elementy w spos贸b cigy w pamici, co umo偶liwia szybki dostp do dowolnego elementu poprzez indeks.</p>
            <p>Operacje:</p>
            <p>
            <table>
                <tr>
                    <td>Metoda</td>
                    <td>Opis</td>
                    <td>Przykad u偶ycia</td>
                    <td>Zo偶ono czasowa</td>
                </tr>
                <tr>
                    <td><code>push_back(value)</code></td>
                    <td>Dodaje element na kocu</td>
                    <td><code>vec.push_back(10);</code></td>
                    <td>Amortyzowane O(1)</td>
                </tr>
                <tr>
                    <td><code>pop_back()</code></td>
                    <td>Usuwa element z koca</td>
                    <td><code>vec.pop_back();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>size()</code></td>
                    <td>Zwraca liczb element贸w</td>
                    <td><code>auto s = vec.size();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>empty()</code></td>
                    <td>Sprawdza, czy kontener jest pusty</td>
                    <td><code>if (vec.empty()) {}</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>clear()</code></td>
                    <td>Usuwa wszystkie elementy</td>
                    <td><code>vec.clear();</code></td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><code>insert(pos, value)</code></td>
                    <td>Wstawia element na podanej pozycji</td>
                    <td><code>vec.insert(vec.begin() + 1, 20);</code></td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><code>erase(pos)</code></td>
                    <td>Usuwa element z podanej pozycji</td>
                    <td><code>vec.erase(vec.begin() + 1);</code></td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><code>at(index)</code></td>
                    <td>Zwraca referencj do elementu na podanym indeksie</td>
                    <td><code>int val = vec.at(2);</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>operator[]</code></td>
                    <td>Zwraca referencj do elementu na podanym indeksie</td>
                    <td><code>int val = vec[2];</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>front()</code></td>
                    <td>Zwraca referencj do pierwszego elementu</td>
                    <td><code>int val = vec.front();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>back()</code></td>
                    <td>Zwraca referencj do ostatniego elementu</td>
                    <td><code>int val = vec.back();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>begin()</code></td>
                    <td>Zwraca iterator na pocztek</td>
                    <td><code>auto it = vec.begin();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>end()</code></td>
                    <td>Zwraca iterator na koniec</td>
                    <td><code>auto it = vec.end();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>reserve(n)</code></td>
                    <td>Rezerwuje miejsce na n element贸w</td>
                    <td><code>vec.reserve(100);</code></td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><code>resize(n)</code></td>
                    <td>Zmienia rozmiar wektora</td>
                    <td><code>vec.resize(10);</code></td>
                    <td>O(n)</td>
                </tr>
            </table>
            </p>
            <p><code>vector</code> jest idealnym wyborem, gdy potrzebujemy dynamicznej tablicy z szybkim dostpem do element贸w przez indeks. Dziki cigemu rozmieszczeniu w pamici, operacje takie jak iterowanie czy dostp losowy s bardzo wydajne. Jednak wstawianie lub usuwanie element贸w w rodku <code>vector</code> mo偶e by kosztowne ze wzgldu na konieczno przesuwania innych element贸w.</p>
            <p>Przykad:</p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; vec = {1, 2, 3};
    vec.push_back(4);
    vec.insert(vec.begin() + 1, 10);
    for(auto it = vec.begin(); it != vec.end(); ++it) {
        std::cout &lt;&lt; *it &lt;&lt; " ";
    }
    return 0;
}</code></pre>
            </div>
            <p>W powy偶szym przykadzie tworzymy <code>vector</code> z trzema elementami, dodajemy czwarty element za pomoc <code>push_back</code>, wstawiamy nowy element na drug pozycj za pomoc <code>insert</code>, a nastpnie iterujemy przez wszystkie elementy i je wywietlamy.</p>
            <h4 id="list"><strong>list</strong></h4>
            <p><code>list</code> to dwukierunkowa lista wizana, kt贸ra umo偶liwia szybkie wstawianie i usuwanie element贸w w dowolnym miejscu listy. W przeciwiestwie do <code>vector</code>, <code>list</code> nie zapewnia cigego rozmieszczenia w pamici, co sprawia, 偶e dostp do element贸w przez indeks jest mniej wydajny, ale operacje wstawiania i usuwania s bardzo szybkie.</p>
            <p>Operacje:</p>
            <p>
            <table>
                <tr>
                    <td>Metoda</td>
                    <td>Opis</td>
                    <td>Przykad u偶ycia</td>
                    <td>Zo偶ono czasowa</td>
                </tr>
                <tr>
                    <td><code>push_back(value)</code></td>
                    <td>Dodaje element na kocu</td>
                    <td><code>lst.push_back(10);</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>push_front(value)</code></td>
                    <td>Dodaje element na pocztku</td>
                    <td><code>lst.push_front(5);</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>pop_back()</code></td>
                    <td>Usuwa element z koca</td>
                    <td><code>lst.pop_back();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>pop_front()</code></td>
                    <td>Usuwa element z pocztku</td>
                    <td><code>lst.pop_front();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>size()</code></td>
                    <td>Zwraca liczb element贸w</td>
                    <td><code>auto s = lst.size();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>empty()</code></td>
                    <td>Sprawdza, czy kontener jest pusty</td>
                    <td><code>if (lst.empty()) {}</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>clear()</code></td>
                    <td>Usuwa wszystkie elementy</td>
                    <td><code>lst.clear();</code></td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><code>insert(pos, value)</code></td>
                    <td>Wstawia element na podanej pozycji</td>
                    <td><code>lst.insert(++lst.begin(), 20);</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>erase(pos)</code></td>
                    <td>Usuwa element z podanej pozycji</td>
                    <td><code>lst.erase(++lst.begin());</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>front()</code></td>
                    <td>Zwraca referencj do pierwszego elementu</td>
                    <td><code>int val = lst.front();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>back()</code></td>
                    <td>Zwraca referencj do ostatniego elementu</td>
                    <td><code>int val = lst.back();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>begin()</code></td>
                    <td>Zwraca iterator na pocztek</td>
                    <td><code>auto it = lst.begin();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>end()</code></td>
                    <td>Zwraca iterator na koniec</td>
                    <td><code>auto it = lst.end();</code></td>
                    <td>O(1)</td>
                </tr>
            </table>
            </p>
            <p><code>list</code> jest idealnym wyborem, gdy potrzebujemy czstych operacji wstawiania i usuwania element贸w w r贸偶nych miejscach kolekcji. Ze wzgldu na brak cigego rozmieszczenia w pamici, iterowanie przez list jest nieco mniej wydajne ni偶 w przypadku <code>vector</code>, ale korzyci pynce z szybkich operacji wstawiania i usuwania czsto przewa偶aj w zastosowaniach wymagajcych dynamicznej modyfikacji danych.</p>
            <p>Przykad:</p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;list&gt;

int main() {
    std::list&lt;int&gt; lst = {1, 2, 3};
    lst.push_back(4);
    lst.push_front(0);
    lst.insert(++lst.begin(), 10);
    for(auto it = lst.begin(); it != lst.end(); ++it) {
        std::cout &lt;&lt; *it &lt;&lt; " ";
    }
    return 0;
}</code></pre>
            </div>
            <p>W tym przykadzie tworzymy list z trzema elementami, dodajemy element na kocu i na pocztku, wstawiamy nowy element na drug pozycj, a nastpnie iterujemy przez wszystkie elementy i je wywietlamy.</p>
            <h4 id="map"><strong>map</strong></h4>
            <p><code>map</code> to kontener asocjacyjny, kt贸ry przechowuje pary klucz-warto w uporzdkowanej formie, wykorzystujc drzewo czerwono-czarne. Dziki temu <code>map</code> zapewnia szybki dostp do wartoci na podstawie klucza oraz automatyczne utrzymanie porzdku element贸w.</p>
            <p>Operacje:</p>
            <p>
            <table>
                <tr>
                    <td>Metoda</td>
                    <td>Opis</td>
                    <td>Przykad u偶ycia</td>
                    <td>Zo偶ono czasowa</td>
                </tr>
                <tr>
                    <td><code>insert({key, value})</code></td>
                    <td>Wstawia par klucz-warto</td>
                    <td><code>mp.insert({1, "one"});</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>erase(key)</code></td>
                    <td>Usuwa element o podanym kluczu</td>
                    <td><code>mp.erase(1);</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>find(key)</code></td>
                    <td>Zwraca iterator na element o podanym kluczu</td>
                    <td><code>auto it = mp.find(1);</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>size()</code></td>
                    <td>Zwraca liczb element贸w</td>
                    <td><code>auto s = mp.size();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>empty()</code></td>
                    <td>Sprawdza, czy kontener jest pusty</td>
                    <td><code>if (mp.empty()) {}</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>clear()</code></td>
                    <td>Usuwa wszystkie elementy</td>
                    <td><code>mp.clear();</code></td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><code>operator[]</code></td>
                    <td>Zwraca referencj do wartoci o podanym kluczu</td>
                    <td><code>std::string val = mp[1];</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>begin()</code></td>
                    <td>Zwraca iterator na pocztek</td>
                    <td><code>auto it = mp.begin();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>end()</code></td>
                    <td>Zwraca iterator na koniec</td>
                    <td><code>auto it = mp.end();</code></td>
                    <td>O(1)</td>
                </tr>
            </table>
            </p>
            <p><code>map</code> jest niezwykle przydatny, gdy potrzebujemy przechowywa dane w spos贸b, kt贸ry umo偶liwia szybki dostp do wartoci na podstawie unikalnego klucza. Dziki utrzymaniu uporzdkowanego porzdku element贸w, iterowanie przez <code>map</code> pozwala na przegldanie danych w spos贸b logiczny i przewidywalny. <code>map</code> automatycznie sortuje elementy wedug kluczy, co uatwia wykonywanie operacji takich jak przeszukiwanie zakres贸w czy sortowanie.</p>
            <p>Przykad:</p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;string&gt;

int main() {
    std::map&lt;int, std::string&gt; mp;
    mp.insert({1, "one"});
    mp[2] = "two";
    mp.erase(1);
    for(auto it = mp.begin(); it != mp.end(); ++it) {
        std::cout &lt;&lt; it-&gt;first &lt;&lt; ": " &lt;&lt; it-&gt;second &lt;&lt; " ";
    }
    return 0;
}</code></pre>
            </div>
            <p>W tym przykadzie tworzymy <code>map</code> z kluczami typu <code>int</code> i wartociami typu <code>std::string</code>. Wstawiamy par klucz-warto za pomoc <code>insert</code>, dodajemy kolejn par za pomoc operatora <code>[]</code>, usuwamy element o kluczu <code>1</code>, a nastpnie iterujemy przez wszystkie elementy i je wywietlamy.</p>
            <h4 id="unordered_map"><strong>unordered_map</strong></h4>
            <p><code>unordered_map</code> to kontener asocjacyjny, kt贸ry przechowuje pary klucz-warto w nieuporzdkowanej formie, wykorzystujc tablic mieszajc (hash table). Dziki temu <code>unordered_map</code> oferuje bardzo szybki dostp do element贸w na podstawie klucza, zazwyczaj w czasie staym.</p>
            <p>Operacje:</p>
            <p>
            <table>
                <tr>
                    <td>Metoda</td>
                    <td>Opis</td>
                    <td>Przykad u偶ycia</td>
                    <td>Zo偶ono czasowa</td>
                </tr>
                <tr>
                    <td><code>insert({key, value})</code></td>
                    <td>Wstawia par klucz-warto</td>
                    <td><code>ump.insert({1, "one"});</code></td>
                    <td>O(1) amortyzowane</td>
                </tr>
                <tr>
                    <td><code>erase(key)</code></td>
                    <td>Usuwa element o podanym kluczu</td>
                    <td><code>ump.erase(1);</code></td>
                    <td>O(1) amortyzowane</td>
                </tr>
                <tr>
                    <td><code>find(key)</code></td>
                    <td>Zwraca iterator na element o podanym kluczu</td>
                    <td><code>auto it = ump.find(1);</code></td>
                    <td>O(1) amortyzowane</td>
                </tr>
                <tr>
                    <td><code>size()</code></td>
                    <td>Zwraca liczb element贸w</td>
                    <td><code>auto s = ump.size();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>empty()</code></td>
                    <td>Sprawdza, czy kontener jest pusty</td>
                    <td><code>if (ump.empty()) {}</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>clear()</code></td>
                    <td>Usuwa wszystkie elementy</td>
                    <td><code>ump.clear();</code></td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><code>operator[]</code></td>
                    <td>Zwraca referencj do wartoci o podanym kluczu</td>
                    <td><code>std::string val = ump[1];</code></td>
                    <td>O(1) amortyzowane</td>
                </tr>
                <tr>
                    <td><code>begin()</code></td>
                    <td>Zwraca iterator na pocztek</td>
                    <td><code>auto it = ump.begin();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>end()</code></td>
                    <td>Zwraca iterator na koniec</td>
                    <td><code>auto it = ump.end();</code></td>
                    <td>O(1)</td>
                </tr>
            </table>
            </p>
            <p><code>unordered_map</code> jest doskonaym wyborem, gdy potrzebujemy bardzo szybkiego dostpu do danych na podstawie klucza, bez koniecznoci utrzymywania uporzdkowanego porzdku element贸w. Jest idealny do implementacji sownik贸w, bufor贸w pamici podrcznej i innych struktur, kt贸re wymagaj szybkiego wyszukiwania. Jednak w przeciwiestwie do <code>map</code>, <code>unordered_map</code> nie zapewnia uporzdkowanego przechowywania element贸w, co mo偶e by wad w niekt贸rych zastosowaniach.</p>
            <p>Przykad:</p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;unordered_map&gt;
#include &lt;string&gt;

int main() {
    std::unordered_map&lt;int, std::string&gt; ump;
    ump.insert({1, "one"});
    ump[2] = "two";
    ump.erase(1);
    for(auto it = ump.begin(); it != ump.end(); ++it) {
        std::cout &lt;&lt; it-&gt;first &lt;&lt; ": " &lt;&lt; it-&gt;second &lt;&lt; " ";
    }
    return 0;
}</code></pre>
            </div>
            <p>W tym przykadzie tworzymy <code>unordered_map</code> z kluczami typu <code>int</code> i wartociami typu <code>std::string</code>. Wstawiamy par klucz-warto za pomoc <code>insert</code>, dodajemy kolejn par za pomoc operatora <code>[]</code>, usuwamy element o kluczu <code>1</code>, a nastpnie iterujemy przez wszystkie elementy i je wywietlamy.</p>
            <h4 id="set"><strong>set</strong></h4>
            <p><code>set</code> to kontener, kt贸ry przechowuje unikalne elementy w uporzdkowanej formie, wykorzystujc drzewo czerwono-czarne. <code>set</code> zapewnia szybkie wyszukiwanie, wstawianie i usuwanie element贸w, utrzymujc jednoczenie elementy w uporzdkowanym porzdku.</p>
            <p>Operacje:</p>
            <p>
            <table>
                <tr>
                    <td>Metoda</td>
                    <td>Opis</td>
                    <td>Przykad u偶ycia</td>
                    <td>Zo偶ono czasowa</td>
                </tr>
                <tr>
                    <td><code>insert(value)</code></td>
                    <td>Wstawia element</td>
                    <td><code>st.insert(10);</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>erase(value)</code></td>
                    <td>Usuwa element</td>
                    <td><code>st.erase(10);</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>find(value)</code></td>
                    <td>Zwraca iterator na element</td>
                    <td><code>auto it = st.find(10);</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>size()</code></td>
                    <td>Zwraca liczb element贸w</td>
                    <td><code>auto s = st.size();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>empty()</code></td>
                    <td>Sprawdza, czy kontener jest pusty</td>
                    <td><code>if (st.empty()) {}</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>clear()</code></td>
                    <td>Usuwa wszystkie elementy</td>
                    <td><code>st.clear();</code></td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><code>begin()</code></td>
                    <td>Zwraca iterator na pocztek</td>
                    <td><code>auto it = st.begin();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>end()</code></td>
                    <td>Zwraca iterator na koniec</td>
                    <td><code>auto it = st.end();</code></td>
                    <td>O(1)</td>
                </tr>
            </table>
            </p>
            <p><code>set</code> jest u偶yteczny, gdy potrzebujemy przechowywa zbi贸r unikalnych element贸w i czsto wykonywa operacje takie jak sprawdzanie obecnoci elementu, wstawianie czy usuwanie. Utrzymanie uporzdkowanego porzdku element贸w umo偶liwia efektywne iterowanie w okrelonej kolejnoci oraz wykonywanie operacji zakresowych.</p>
            <p>Przykad:</p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;set&gt;

int main() {
    std::set&lt;int&gt; st;
    st.insert(10);
    st.insert(20);
    st.erase(10);
    for(auto it = st.begin(); it != st.end(); ++it) {
        std::cout &lt;&lt; *it &lt;&lt; " ";
    }
    return 0;
}</code></pre>
            </div>
            <p>W tym przykadzie tworzymy <code>set</code> z elementami typu <code>int</code>, wstawiamy kilka element贸w, usuwamy jeden z nich, a nastpnie iterujemy przez wszystkie pozostae elementy i je wywietlamy.</p>
            <h4 id="unordered_set"><strong>unordered_set</strong></h4>
            <p><code>unordered_set</code> to kontener, kt贸ry przechowuje unikalne elementy w nieuporzdkowanej formie, wykorzystujc tablic mieszajc (hash table). Dziki temu <code>unordered_set</code> oferuje bardzo szybkie operacje wyszukiwania, wstawiania i usuwania element贸w, zazwyczaj w czasie staym.</p>
            <p>Operacje:</p>
            <p>
            <table>
                <tr>
                    <td>Metoda</td>
                    <td>Opis</td>
                    <td>Przykad u偶ycia</td>
                    <td>Zo偶ono czasowa</td>
                </tr>
                <tr>
                    <td><code>insert(value)</code></td>
                    <td>Wstawia element</td>
                    <td><code>ust.insert(10);</code></td>
                    <td>O(1) amortyzowane</td>
                </tr>
                <tr>
                    <td><code>erase(value)</code></td>
                    <td>Usuwa element</td>
                    <td><code>ust.erase(10);</code></td>
                    <td>O(1) amortyzowane</td>
                </tr>
                <tr>
                    <td><code>find(value)</code></td>
                    <td>Zwraca iterator na element</td>
                    <td><code>auto it = ust.find(10);</code></td>
                    <td>O(1) amortyzowane</td>
                </tr>
                <tr>
                    <td><code>size()</code></td>
                    <td>Zwraca liczb element贸w</td>
                    <td><code>auto s = ust.size();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>empty()</code></td>
                    <td>Sprawdza, czy kontener jest pusty</td>
                    <td><code>if (ust.empty()) {}</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>clear()</code></td>
                    <td>Usuwa wszystkie elementy</td>
                    <td><code>ust.clear();</code></td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><code>begin()</code></td>
                    <td>Zwraca iterator na pocztek</td>
                    <td><code>auto it = ust.begin();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>end()</code></td>
                    <td>Zwraca iterator na koniec</td>
                    <td><code>auto it = ust.end();</code></td>
                    <td>O(1)</td>
                </tr>
            </table>
            </p>
            <p><code>unordered_set</code> jest idealnym wyborem, gdy potrzebujemy przechowywa unikalne elementy i wykonywa szybkie operacje wyszukiwania bez koniecznoci utrzymywania uporzdkowanego porzdku. Jest szczeg贸lnie przydatny w sytuacjach, gdzie kolejno element贸w nie ma znaczenia, a kluczowa jest szybko dostpu do danych.</p>
            <p>Przykad:</p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;unordered_set&gt;

int main() {
    std::unordered_set&lt;int&gt; ust;
    ust.insert(10);
    ust.insert(20);
    ust.erase(10);
    for(auto it = ust.begin(); it != ust.end(); ++it) {
        std::cout &lt;&lt; *it &lt;&lt; " ";
    }
    return 0;
}</code></pre>
            </div>
            <p>W tym przykadzie tworzymy <code>unordered_set</code> z elementami typu <code>int</code>, wstawiamy kilka element贸w, usuwamy jeden z nich, a nastpnie iterujemy przez wszystkie pozostae elementy i je wywietlamy.</p>
            <h4 id="priority_queue"><strong>priority_queue</strong></h4>
            <p><code>priority_queue</code> to kontener, kt贸ry implementuje kopiec binarny i pozwala na szybkie wyciganie najwikszego (lub najmniejszego) elementu. <code>priority_queue</code> jest przydatny w zastosowaniach, gdzie potrzebujemy dynamicznie utrzymywa zbi贸r element贸w w taki spos贸b, aby zawsze mie szybki dostp do najwy偶szego priorytetu.</p>
            <p>Operacje:</p>
            <p>
            <table>
                <tr>
                    <td>Metoda</td>
                    <td>Opis</td>
                    <td>Przykad u偶ycia</td>
                    <td>Zo偶ono czasowa</td>
                </tr>
                <tr>
                    <td><code>push(value)</code></td>
                    <td>Dodaje element</td>
                    <td><code>pq.push(10);</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>pop()</code></td>
                    <td>Usuwa najwikszy element</td>
                    <td><code>pq.pop();</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>top()</code></td>
                    <td>Zwraca referencj do najwikszego elementu</td>
                    <td><code>int val = pq.top();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>size()</code></td>
                    <td>Zwraca liczb element贸w</td>
                    <td><code>auto s = pq.size();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>empty()</code></td>
                    <td>Sprawdza, czy kontener jest pusty</td>
                    <td><code>if (pq.empty()) {}</code></td>
                    <td>O(1)</td>
                </tr>
            </table>
            </p>
            <p><code>priority_queue</code> jest u偶yteczny w algorytmach takich jak Dijkstra czy Huffman, gdzie konieczne jest szybkie wyciganie element贸w o najwy偶szym priorytecie. Dziki strukturze kopca binarnego, <code>priority_queue</code> zapewnia efektywne zarzdzanie elementami i szybki dostp do najbardziej istotnych danych.</p>
            <p>Przykad:</p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;queue&gt;

int main() {
    std::priority_queue&lt;int&gt; pq;
    pq.push(10);
    pq.push(20);
    pq.push(5);
    std::cout &lt;&lt; pq.top() &lt;&lt; " "; // wywietli 20
    pq.pop();
    std::cout &lt;&lt; pq.top() &lt;&lt; " "; // wywietli 10
    return 0;
}</code></pre>
            </div>
            <p>W tym przykadzie tworzymy <code>priority_queue</code> z elementami typu <code>int</code>, dodajemy kilka element贸w, a nastpnie wycigamy i wywietlamy najwikszy element za pomoc <code>top</code> oraz <code>pop</code>.</p>
            <h4 id="queue"><strong>queue</strong></h4>
            <p><code>queue</code> to kontener, kt贸ry implementuje kolejk FIFO (First In, First Out). <code>queue</code> jest idealny do sytuacji, gdzie kolejno przetwarzania element贸w jest istotna, na przykad w symulacjach system贸w kolejkowych czy zarzdzaniu zadaniami.</p>
            <p>Operacje:</p>
            <p>
            <table>
                <tr>
                    <td>Metoda</td>
                    <td>Opis</td>
                    <td>Przykad u偶ycia</td>
                    <td>Zo偶ono czasowa</td>
                </tr>
                <tr>
                    <td><code>push(value)</code></td>
                    <td>Dodaje element</td>
                    <td><code>q.push(10);</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>pop()</code></td>
                    <td>Usuwa element z pocztku</td>
                    <td><code>q.pop();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>front()</code></td>
                    <td>Zwraca referencj do pierwszego elementu</td>
                    <td><code>int val = q.front();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>back()</code></td>
                    <td>Zwraca referencj do ostatniego elementu</td>
                    <td><code>int val = q.back();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>size()</code></td>
                    <td>Zwraca liczb element贸w</td>
                    <td><code>auto s = q.size();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>empty()</code></td>
                    <td>Sprawdza, czy kontener jest pusty</td>
                    <td><code>if (q.empty()) {}</code></td>
                    <td>O(1)</td>
                </tr>
            </table>
            </p>
            <p><code>queue</code> jest prostym i efektywnym narzdziem do zarzdzania danymi w spos贸b kolejnociowy. Dziki temu kontenerowi mo偶emy atwo implementowa mechanizmy przetwarzania danych, gdzie pierwszy element w kolejce jest przetwarzany jako pierwszy, a ostatni jako ostatni.</p>
            <p>Przykad:</p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;queue&gt;

int main() {
    std::queue&lt;int&gt; q;
    q.push(10);
    q.push(20);
    std::cout &lt;&lt; q.front() &lt;&lt; " "; // wywietli 10
    q.pop();
    std::cout &lt;&lt; q.front() &lt;&lt; " "; // wywietli 20
    return 0;
}</code></pre>
            </div>
            <p>W tym przykadzie tworzymy <code>queue</code> z elementami typu <code>int</code>, dodajemy kilka element贸w, a nastpnie wycigamy i wywietlamy pierwszy element za pomoc <code>front</code> oraz <code>pop</code>.</p>
            <h4 id="stack"><strong>stack</strong></h4>
            <p><code>stack</code> to kontener, kt贸ry implementuje stos LIFO (Last In, First Out). <code>stack</code> jest u偶yteczny w sytuacjach, gdzie potrzebujemy struktury danych dziaajcej na zasadzie ostatniego przyjtego elementu jako pierwszego do przetworzenia, na przykad w algorytmach rekurencyjnych czy przetwarzaniu wyra偶e.</p>
            <p>Operacje:</p>
            <p>
            <table>
                <tr>
                    <td>Metoda</td>
                    <td>Opis</td>
                    <td>Przykad u偶ycia</td>
                    <td>Zo偶ono czasowa</td>
                </tr>
                <tr>
                    <td><code>push(value)</code></td>
                    <td>Dodaje element</td>
                    <td><code>st.push(10);</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>pop()</code></td>
                    <td>Usuwa element z koca</td>
                    <td><code>st.pop();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>top()</code></td>
                    <td>Zwraca referencj do ostatniego elementu</td>
                    <td><code>int val = st.top();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>size()</code></td>
                    <td>Zwraca liczb element贸w</td>
                    <td><code>auto s = st.size();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>empty()</code></td>
                    <td>Sprawdza, czy kontener jest pusty</td>
                    <td><code>if (st.empty()) {}</code></td>
                    <td>O(1)</td>
                </tr>
            </table>
            </p>
            <p><code>stack</code> jest doskonaym wyborem, gdy potrzebujemy prostego mechanizmu do przechowywania danych w odwrotnej kolejnoci. Dziki swojej prostocie i wydajnoci, <code>stack</code> znajduje zastosowanie w wielu algorytmach, takich jak przetwarzanie wyra偶e matematycznych, czy implementacja funkcji rekurencyjnych.</p>
            <p>Przykad:</p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;stack&gt;

int main() {
    std::stack&lt;int&gt; st;
    st.push(10);
    st.push(20);
    std::cout &lt;&lt; st.top() &lt;&lt; " "; // wywietli 20
    st.pop();
    std::cout &lt;&lt; st.top() &lt;&lt; " "; // wywietli 10
    return 0;
}</code></pre>
            </div>
            <p>W tym przykadzie tworzymy <code>stack</code> z elementami typu <code>int</code>, dodajemy kilka element贸w, a nastpnie wycigamy i wywietlamy ostatni dodany element za pomoc <code>top</code> oraz <code>pop</code>.</p>
            <h3 id="iteratory">Iteratory</h3>
            <p>Iteratory w jzyku C++ s fundamentem, kt贸ry umo偶liwia efektywn i elastyczn prac z r贸偶norodnymi kontenerami dostarczanymi przez Standard Template Library (STL). Iteratory to obiekty, kt贸re umo偶liwiaj sekwencyjny dostp do element贸w kontener贸w, takich jak <code>vector</code>, <code>list</code>, <code>map</code> i inne. Dziki nim mo偶liwe jest pisanie generycznego kodu, kt贸ry dziaa niezale偶nie od konkretnego typu kontenera, co znacznie zwiksza reu偶ywalno i elastyczno kodu.</p>
            <p>Podobnie jak wska藕niki, iteratory mog by dereferencjonowane, aby uzyska dostp do wartoci przechowywanych w kontenerze, oraz mog by inkrementowane lub dekrementowane, aby przechodzi do nastpnych lub poprzednich element贸w. Jednak iteratory oferuj wicej mo偶liwoci i bezpieczestwa, poniewa偶 s zaprojektowane tak, aby wsp贸pracowa bezporednio z kontenerami STL, zapewniajc zgodno typ贸w i chronic przed nieprawidowymi operacjami.</p>
            <p>Iteratory s niezbdne do korzystania z algorytm贸w STL, kt贸re operuj na zakresach okrelonych przez iteratory. Dziki temu mo偶na atwo przetwarza dane w kontenerach za pomoc gotowych funkcji, bez koniecznoci implementowania wasnych ptli czy struktur kontrolnych.</p>
            <h4 id="rodzaje-iterator贸w">Rodzaje iterator贸w</h4>
            <p>W STL istnieje kilka kategorii iterator贸w, z kt贸rych ka偶da oferuje r贸偶ne mo偶liwoci i jest przeznaczona do okrelonych zastosowa. Znajomo tych rodzaj贸w iterator贸w pozwala na lepsze zrozumienie, jak efektywnie korzysta z kontener贸w i algorytm贸w STL.</p>
            <p>
            <table>
                <tr>
                    <td>Typ iteratora</td>
                    <td>Opis</td>
                </tr>
                <tr>
                    <td><strong>Input Iterator</strong></td>
                    <td>Su偶y do odczytu danych z kontenera. Mo偶na go u偶ywa do jednorazowego przechodzenia przez elementy w jednym kierunku. Idealny do przetwarzania danych w sekwencji bez modyfikacji.</td>
                </tr>
                <tr>
                    <td><strong>Output Iterator</strong></td>
                    <td>Su偶y do zapisu danych do kontenera. Pozwala na jednorazowe przechodzenie przez elementy i modyfikowanie ich wartoci.</td>
                </tr>
                <tr>
                    <td><strong>Forward Iterator</strong></td>
                    <td>czy mo偶liwoci iterator贸w input i output. Mo偶e przemieszcza si tylko do przodu, ale mo偶e zar贸wno czyta, jak i pisa dane.</td>
                </tr>
                <tr>
                    <td><strong>Bidirectional Iterator</strong></td>
                    <td>Umo偶liwia przemieszczanie si zar贸wno do przodu, jak i do tyu. Przydatny w kontenerach, kt贸re wspieraj dwukierunkowy dostp, takich jak <code>list</code>.</td>
                </tr>
                <tr>
                    <td><strong>Random Access Iterator</strong></td>
                    <td>Oferuje wszystkie mo偶liwoci Bidirectional Iterator oraz umo偶liwia dostp do dowolnego elementu kontenera w staym czasie. Pozwala na operacje arytmetyczne na iteratorach, takie jak przesunicie o okrelon liczb pozycji. Idealny dla kontener贸w takich jak <code>vector</code> czy <code>deque</code>.</td>
                </tr>
            </table>
            </p>
            <h4 id="podstawowe-operacje-na-iteratorach">Podstawowe operacje na iteratorach</h4>
            <p>Praca z iteratorami obejmuje kilka podstawowych operacji, kt贸re umo偶liwiaj manipulowanie i przegldanie element贸w kontener贸w. Poni偶ej przedstawiono najwa偶niejsze z nich:</p>
            <ul>
                <li><strong>Inicjalizacja iteratora pocztkowym elementem kontenera:</strong> Aby rozpocz iteracj, nale偶y zainicjalizowa iterator na pocztku kontenera za pomoc <code>kontener.begin()</code>. To pozwala na dostp do pierwszego elementu.</li>
            </ul>
            <div>
                <pre><code class="language-clike">auto it = kontener.begin();</code></pre>
            </div>
            <ul>
                <li><strong>Inicjalizacja iteratora elementem za ostatnim w kontenerze:</strong> Iterator <code>kontener.end()</code> wskazuje na element za ostatnim elementem w kontenerze. Jest to przydatne do oznaczania koca zakresu podczas iteracji.</li>
            </ul>
            <div>
                <pre><code class="language-clike">auto it_end = kontener.end();</code></pre>
            </div>
            <ul>
                <li><strong>Odwoanie do elementu, na kt贸ry wskazuje iterator:</strong> U偶ywajc operatora dereferencji <code>*</code>, mo偶emy uzyska dostp do wartoci przechowywanej w elemencie, na kt贸ry wskazuje iterator.</li>
            </ul>
            <div>
                <pre><code class="language-clike">auto element = *it;</code></pre>
            </div>
            <ul>
                <li><strong>Przesunicie iteratora do nastpnego elementu:</strong> Operator <code>++</code> umo偶liwia przejcie do kolejnego elementu w kontenerze.</li>
            </ul>
            <div>
                <pre><code class="language-clike">++it;</code></pre>
            </div>
            <ul>
                <li><strong>Przesunicie iteratora do poprzedniego elementu:</strong> Operator <code>--</code> pozwala na powr贸t do poprzedniego elementu. Jest dostpny tylko dla iterator贸w dwukierunkowych i iterator贸w o losowym dostpie.</li>
            </ul>
            <div>
                <pre><code class="language-clike">--it;</code></pre>
            </div>
            <ul>
                <li><strong>Przesunicie iteratora o okrelon liczb pozycji:</strong> Dla iterator贸w o losowym dostpie, mo偶emy przesuwa iterator o okrelon liczb pozycji za pomoc operator贸w arytmetycznych.</li>
            </ul>
            <div>
                <pre><code class="language-clike">it += n; // Przesunicie do przodu o n pozycji
  it -= n; // Przesunicie do tyu o n pozycji</code></pre>
            </div>
            <ul>
                <li><strong>Wstawienie elementu w miejscu wskazywanym przez iterator:</strong> Metoda <code>insert</code> umo偶liwia dodanie nowego elementu przed pozycj wskazywan przez iterator.</li>
            </ul>
            <div>
                <pre><code class="language-clike">it = kontener.insert(it, warto);</code></pre>
            </div>
            <ul>
                <li><strong>Usunicie elementu w miejscu wskazywanym przez iterator:</strong> Metoda <code>erase</code> pozwala na usunicie elementu na pozycji wskazywanej przez iterator i zwraca iterator do nastpnego elementu.</li>
            </ul>
            <div>
                <pre><code class="language-clike">it = kontener.erase(it);</code></pre>
            </div>
            <h4 id="przykad-u偶ycia-iteratora">Przykad u偶ycia iteratora</h4>
            <p>Poni偶szy przykad ilustruje podstawowe operacje na iteratorech w kontekcie kontenera <code>std::vector</code> typu <code>std::string</code>. Program tworzy wektor z trzema elementami, wywietla jego zawarto przy u偶yciu iteratora, dodaje nowy element przed drugim elementem, usuwa pierwszy element, a nastpnie ponownie wywietla zmodyfikowan zawarto wektora.</p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;std::string&gt; v = {"ala", "ma", "kota"};

    // Wywietlenie zawartoci wektora przy u偶yciu iteratora
    std::cout &lt;&lt; "Zawarto wektora przed modyfikacjami:\n";
    for (auto it = v.begin(); it != v.end(); ++it) {
        std::cout &lt;&lt; *it &lt;&lt; std::endl;
    }

    // Dodanie nowego elementu przed "ma"
    auto it = v.begin() + 1;
    v.insert(it, "nie");

    // Usunicie sowa "ala"
    it = v.begin();
    v.erase(it);

    std::cout &lt;&lt; "\nPo modyfikacjach:\n";
    for (const auto&amp; word : v) {
        std::cout &lt;&lt; word &lt;&lt; std::endl;
    }

    return 0;
}</code></pre>
            </div>
            <p><strong>Wyjcie programu:</strong></p>
            <div>
                <pre><code class="language-shell">Zawarto wektora przed modyfikacjami:
ala
ma
kota

Po modyfikacjach:
ma
nie
kota</code></pre>
            </div>
            <p>Warto pamita, 偶e po niekt贸rych operacjach, takich jak <code>insert</code> czy <code>erase</code>, u偶ywane wczeniej iteratory mog sta si nieaktualne i ich dalsze u偶ycie mo偶e prowadzi do niezdefiniowanego zachowania programu. Dlatego zaleca si ponowne inicjalizowanie iterator贸w po modyfikacji kontenera.</p>
            <h3 id="algorytmy-w-standardowej-bibliotece-c-stl-">Algorytmy w Standardowej Bibliotece C++ (STL)</h3>
            <p>Biblioteka <code>algorithm</code> w standardowej bibliotece C++ (STL) dostarcza bogaty zestaw funkcji szablonowych, kt贸re su偶 do manipulacji i analizy danych przechowywanych w kontenerach. Algorytmy te s zaprojektowane w spos贸b generyczny, co oznacza, 偶e mog dziaa z r贸偶nymi typami danych i kontenerami, pod warunkiem spenienia okrelonych wymaga. W tej sekcji przyjrzymy si kilku kluczowym algorytmom, ich implementacji, zastosowaniu oraz analizie matematycznej wydajnoci.</p>
            <h4 id="wprowadzenie-do-algorytm贸w-stl">Wprowadzenie do Algorytm贸w STL</h4>
            <p>Algorytmy w STL s zaimplementowane jako funkcje szablonowe, co pozwala na ich u偶ycie z r贸偶nymi typami danych i kontenerami. Dziaaj one na zakresach okrelonych przez iteratory, co zapewnia elastyczno i niezale偶no od konkretnego typu kontenera. Dziki temu mo偶liwe jest pisanie kodu, kt贸ry jest jednoczenie uniwersalny i wydajny.</p>
            <p>Algorytmy STL s zoptymalizowane pod ktem wydajnoci oraz zgodnoci z r贸偶nymi typami iterator贸w. Pozwalaj na wykonywanie zo偶onych operacji na danych w spos贸b zwizy i czytelny, redukujc potrzeb pisania wasnych implementacji podstawowych funkcji przetwarzania danych.</p>
            <h4 id="klasyfikacja-algorytm贸w">Klasyfikacja Algorytm贸w</h4>
            <p>Algorytmy STL mo偶na podzieli na kilka kategorii, w zale偶noci od rodzaju operacji, kt贸re wykonuj na danych:</p>
            <p>
            <table>
                <tr>
                    <td>Kategoria algorytm贸w</td>
                    <td>Przykady</td>
                </tr>
                <tr>
                    <td><strong>Algorytmy modyfikujce</strong></td>
                    <td><code>std::copy</code>, <code>std::fill</code>, <code>std::transform</code></td>
                </tr>
                <tr>
                    <td><strong>Algorytmy przeszukujce</strong></td>
                    <td><code>std::find</code>, <code>std::count</code>, <code>std::search</code></td>
                </tr>
                <tr>
                    <td><strong>Algorytmy sortujce i porzdkujce</strong></td>
                    <td><code>std::sort</code>, <code>std::stable_sort</code>, <code>std::partial_sort</code></td>
                </tr>
                <tr>
                    <td><strong>Algorytmy numeryczne</strong></td>
                    <td><code>std::accumulate</code>, <code>std::inner_product</code>, <code>std::partial_sum</code></td>
                </tr>
                <tr>
                    <td><strong>Algorytmy usuwajce</strong></td>
                    <td><code>std::remove</code>, <code>std::unique</code>, <code>std::remove_if</code></td>
                </tr>
            </table>
            </p>
            <p>Ka偶da z tych kategorii obejmuje algorytmy, kt贸re s zoptymalizowane do wykonywania specyficznych operacji na danych, co pozwala na efektywne zarzdzanie i przetwarzanie informacji w aplikacjach.</p>
            <h4 id="std-sort-"><code>std::sort()</code></h4>
            <p>Funkcja <code>std::sort()</code> su偶y do sortowania element贸w w okrelonym zakresie. Jest to jeden z najczciej u偶ywanych algorytm贸w w STL ze wzgldu na swoj uniwersalno i wydajno. <code>std::sort()</code> wykorzystuje algorytm sortowania introspektywnego (introsort), kt贸ry czy zalety sortowania szybkiego (quick sort), sortowania kopcowego (heap sort) i sortowania przez wstawianie (insertion sort).</p>
            <p><strong>Prototyp:</strong></p>
            <div>
                <pre><code class="language-clike">template&lt; class RandomIt &gt;
void sort( RandomIt first, RandomIt last );

template&lt; class RandomIt, class Compare &gt;
void sort( RandomIt first, RandomIt last, Compare comp );</code></pre>
            </div>
            <ul>
                <li><code>RandomIt</code>: Typ iteratora losowego dostpu.</li>
                <li><code>Compare</code>: Funkcja lub funktor su偶cy do por贸wnywania element贸w.</li>
            </ul>
            <p><strong>Wymagania:</strong></p>
            <ul>
                <li>Elementy musz by por贸wnywalne za pomoc operatora <code>&lt;</code> lub funkcji <code>Compare</code>.</li>
                <li>Iteratory musz by iteratorami losowego dostpu (np. z <code>std::vector</code>, <code>std::array</code>).</li>
            </ul>
            <p><strong>Przykad U偶ycia:</strong></p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; wektor{8, 3, 5, 1, 2, 4, 6, 7};
    auto kopia = wektor;

    // Sortowanie pierwszych trzech element贸w
    std::sort(wektor.begin(), wektor.begin() + 3);

    // Sortowanie caego wektora
    std::sort(kopia.begin(), kopia.end());

    // Wywietlanie wynik贸w
    std::cout &lt;&lt; "Wektor po czciowym sortowaniu: ";
    for (const auto&amp; val : wektor) {
        std::cout &lt;&lt; val &lt;&lt; " ";
    }
    std::cout &lt;&lt; "\n";

    std::cout &lt;&lt; "Wektor po penym sortowaniu: ";
    for (const auto&amp; val : kopia) {
        std::cout &lt;&lt; val &lt;&lt; " ";
    }

    return 0;
}</code></pre>
            </div>
            <p><strong>Wyjcie programu:</strong></p>
            <div>
                <pre><code class="language-shell">Wektor po czciowym sortowaniu: 3 5 8 1 2 4 6 7 
Wektor po penym sortowaniu: 1 2 3 4 5 6 7 8</code></pre>
            </div>
            <p><strong>Analiza Matematyczna:</strong></p>
            <ul>
                <li><strong>Zo偶ono czasowa</strong> dla tego algorytmu wynosi rednio $O(n \log n)$, co jest charakterystyczne dla wydajnych algorytm贸w sortowania.</li>
                <li>W najgorszym przypadku zo偶ono czasowa r贸wnie偶 wynosi $O(n \log n)$, poniewa偶 algorytm wykorzystuje introsort, kt贸ry automatycznie przecza si na sortowanie kopcowe, gdy wykryje niekorzystny podzia danych.</li>
                <li><strong>Zo偶ono pamiciowa</strong> tego algorytmu wymaga $O(\log n)$ dodatkowej pamici, g贸wnie na stos rekurencji, co czyni go efektywnym pod wzgldem u偶ycia zasob贸w pamici.</li>
            </ul>
            <p><strong>Dostosowywanie Kryterium Sortowania:</strong></p>
            <p>Mo偶emy dostarczy wasn funkcj por贸wnujc, aby zmieni domylne kryterium sortowania. Na przykad, aby posortowa elementy w kolejnoci malejcej:</p>
            <div>
                <pre><code class="language-clike">std::sort(wektor.begin(), wektor.end(), [](int a, int b) {
    return a &gt; b; // Sortowanie malejce
});</code></pre>
            </div>
            <p><strong>Uwagi:</strong></p>
            <ul>
                <li><strong>Stabilno</strong> algorytmu <code>std::sort()</code> nie jest zagwarantowana, co oznacza, 偶e kolejno r贸wnych element贸w mo偶e si zmieni. W przypadku, gdy stabilno jest wymagana, nale偶y skorzysta z funkcji <code>std::stable_sort()</code>.</li>
                <li>Typ element贸w musi by <strong>zgodny</strong> z wymaganiami funkcji por贸wnujcej, co zapewnia poprawno dziaania algorytmu.</li>
            </ul>
            <h4 id="std-find-"><code>std::find()</code></h4>
            <p>Algorytm <code>std::find()</code> przeszukuje zakres w poszukiwaniu pierwszego wystpienia okrelonej wartoci. Zwraca iterator wskazujcy na znaleziony element lub na koniec zakresu, jeli element nie zosta znaleziony.</p>
            <p><strong>Prototyp:</strong></p>
            <div>
                <pre><code class="language-clike">template&lt; class InputIt, class T &gt;
InputIt find( InputIt first, InputIt last, const T&amp; value );</code></pre>
            </div>
            <ul>
                <li><code>InputIt</code>: Typ iteratora wejciowego.</li>
                <li><code>T</code>: Typ poszukiwanej wartoci.</li>
            </ul>
            <p><strong>Przykad U偶ycia:</strong></p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; wektor{8, 3, 5, 1, 2, 4, 6, 7};

    auto it = std::find(wektor.begin(), wektor.end(), 3);

    if (it != wektor.end())
        std::cout &lt;&lt; "Znaleziono element o wartoci 3 na pozycji "
                  &lt;&lt; std::distance(wektor.begin(), it) &lt;&lt; "\n";
    else
        std::cout &lt;&lt; "Nie znaleziono elementu o wartoci 3\n";

    return 0;
}</code></pre>
            </div>
            <p><strong>Wyjcie programu:</strong></p>
            <div>
                <pre><code class="language-shell">Znaleziono element o wartoci 3 na pozycji 1</code></pre>
            </div>
            <p><strong>Analiza Matematyczna:</strong></p>
            <ul>
                <li><strong>Zo偶ono czasowa</strong> wynosi $O(n)$, gdzie n oznacza liczb element贸w w przetwarzanym zakresie, co sprawia, 偶e algorytm dziaa liniowo wzgldem liczby danych.</li>
                <li><strong>Zo偶ono pamiciowa</strong> wynosi $O(1)$, co oznacza, 偶e algorytm nie wymaga dodatkowej pamici poza t u偶ywan przez same dane.</li>
            </ul>
            <p><strong>Uwagi:</strong></p>
            <ul>
                <li>Algorytm przeszukuje liniowo zakres od <code>first</code> do <code>last</code>, co oznacza, 偶e w najgorszym przypadku musi sprawdzi ka偶dy element.</li>
                <li>Mo偶emy u偶y <code>std::find_if()</code> lub <code>std::find_if_not()</code> do przeszukiwania z warunkiem predykatu, co pozwala na bardziej elastyczne wyszukiwanie w oparciu o zo偶one kryteria.</li>
            </ul>
            <h4 id="std-for_each-"><code>std::for_each()</code></h4>
            <p>Funkcja <code>std::for_each()</code> stosuje podan funkcj lub funktor do ka偶dego elementu w zakresie. Jest to alternatywa dla ptli <code>for</code> i pozwala na bardziej funkcyjne podejcie do iteracji.</p>
            <p><strong>Prototyp:</strong></p>
            <div>
                <pre><code class="language-clike">template&lt; class InputIt, class UnaryFunction &gt;
UnaryFunction for_each( InputIt first, InputIt last, UnaryFunction f );</code></pre>
            </div>
            <ul>
                <li><code>InputIt</code>: Typ iteratora wejciowego.</li>
                <li><code>UnaryFunction</code>: Typ funkcji lub funktora akceptujcego element typu dereferowanego iteratora.</li>
            </ul>
            <p><strong>Przykad U偶ycia:</strong></p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; wektor{8, 3, 5, 1, 2, 4, 6, 7};

    // Modyfikacja ka偶dego elementu przez jego podwojenie
    std::for_each(wektor.begin(), wektor.end(), [](int &amp;x) { x *= 2; });

    // Wywietlanie wynik贸w
    std::cout &lt;&lt; "Wektor po modyfikacji: ";
    for (const auto&amp; val : wektor) {
        std::cout &lt;&lt; val &lt;&lt; " ";
    }

    return 0;
}</code></pre>
            </div>
            <p><strong>Wyjcie programu:</strong></p>
            <div>
                <pre><code class="language-shell">Wektor po modyfikacji: 16 6 10 2 4 8 12 14</code></pre>
            </div>
            <p><strong>Analiza Matematyczna:</strong></p>
            <ul>
                <li><strong>Zo偶ono czasowa</strong> wynosi <strong>O(n)</strong>, poniewa偶 funkcja jest wywoywana dokadnie n razy, co oznacza liniowy wzrost liczby operacji w zale偶noci od liczby element贸w.</li>
                <li><strong>Zo偶ono pamiciowa</strong> wynosi <strong>O(1)</strong>, gdy偶 algorytm nie wymaga dodatkowej pamici poza ewentualnymi zmiennymi lokalnymi w funkcji.</li>
            </ul>
            <p><strong>Uwagi:</strong></p>
            <ul>
                <li>Funkcja <code>UnaryFunction</code> jest przekazywana przez warto, wic jeli potrzebujemy zachowa stan midzy wywoaniami, nale偶y u偶y referencji lub obiektu zewntrznego.</li>
                <li>Zwracana jest kopia funkcji <code>UnaryFunction</code> po ostatnim wywoaniu, co mo偶e by u偶yte do akumulacji wynik贸w.</li>
                <li><code>std::for_each()</code> mo偶e by u偶ywany do wykonywania r贸偶nych operacji na elementach kontenera, takich jak modyfikowanie ich wartoci, wywietlanie, czy zbieranie informacji.</li>
            </ul>
            <h4 id="std-count_if-"><code>std::count_if()</code></h4>
            <p>Algorytm <code>std::count_if()</code> zlicza liczb element贸w w zakresie, dla kt贸rych predykat jest speniony.</p>
            <p><strong>Prototyp:</strong></p>
            <div>
                <pre><code class="language-clike">template&lt; class InputIt, class UnaryPredicate &gt;
typename iterator_traits&lt;InputIt&gt;::difference_type
count_if( InputIt first, InputIt last, UnaryPredicate p );</code></pre>
            </div>
            <ul>
                <li><code>InputIt</code>: Typ iteratora wejciowego.</li>
                <li><code>UnaryPredicate</code>: Funkcja lub funktor zwracajcy warto logiczn.</li>
            </ul>
            <p><strong>Przykad U偶ycia:</strong></p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; wektor{8, 3, 5, 1, 2, 4, 6, 7};

    // Zliczanie parzystych element贸w
    int parzyste = std::count_if(wektor.begin(), wektor.end(), [](int x) { return x % 2 == 0; });

    std::cout &lt;&lt; "Liczba parzystych element贸w: " &lt;&lt; parzyste &lt;&lt; "\n";

    return 0;
}</code></pre>
            </div>
            <p><strong>Wyjcie programu:</strong></p>
            <div>
                <pre><code class="language-shell">Liczba parzystych element贸w: 4</code></pre>
            </div>
            <p><strong>Analiza Matematyczna:</strong></p>
            <ul>
                <li><strong>Zo偶ono czasowa</strong> wynosi <strong>O(n)</strong>, poniewa偶 predykat jest wywoywany dokadnie n razy, co sprawia, 偶e liczba operacji ronie liniowo w zale偶noci od liczby element贸w.</li>
                <li><strong>Zo偶ono pamiciowa</strong> wynosi <strong>O(1)</strong>, co oznacza, 偶e algorytm nie wymaga dodatkowej pamici poza zmiennymi lokalnymi.</li>
            </ul>
            <p><strong>Uwagi:</strong></p>
            <ul>
                <li>Jeli chcemy zliczy wystpienia konkretnej wartoci, mo偶emy u偶y <code>std::count()</code>, co jest bardziej efektywne i czytelne w takim przypadku.</li>
                <li><code>std::count_if()</code> jest szczeg贸lnie przydatny, gdy potrzebujemy zliczy elementy speniajce bardziej zo偶one warunki ni偶 prosty r贸wno.</li>
            </ul>
            <h4 id="inne-wa偶ne-algorytmy">Inne Wa偶ne Algorytmy</h4>
            <h5><code>std::accumulate()</code></h5>
            <p>Funkcja <code>std::accumulate()</code> su偶y do obliczenia sumy wartoci w zakresie, z opcjonalnym pocztkowym akumulatorem i funkcj operacji.</p>
            <p><strong>Prototyp:</strong></p>
            <div>
                <pre><code class="language-clike">template&lt; class InputIt, class T &gt;
T accumulate( InputIt first, InputIt last, T init );

template&lt; class InputIt, class T, class BinaryOperation &gt;
T accumulate( InputIt first, InputIt last, T init, BinaryOperation op );</code></pre>
            </div>
            <p><strong>Przykad U偶ycia:</strong></p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;numeric&gt;

int main() {
    std::vector&lt;int&gt; wektor{1, 2, 3, 4, 5};

    // Obliczenie sumy element贸w
    int suma = std::accumulate(wektor.begin(), wektor.end(), 0);
    std::cout &lt;&lt; "Suma element贸w: " &lt;&lt; suma &lt;&lt; "\n";

    // Obliczenie iloczynu element贸w
    int iloczyn = std::accumulate(wektor.begin(), wektor.end(), 1, std::multiplies&lt;int&gt;());
    std::cout &lt;&lt; "Iloczyn element贸w: " &lt;&lt; iloczyn &lt;&lt; "\n";

    return 0;
}</code></pre>
            </div>
            <p><strong>Wyjcie programu:</strong></p>
            <div>
                <pre><code class="language-shell">Suma element贸w: 15
Iloczyn element贸w: 120</code></pre>
            </div>
            <p><strong>Uwagi:</strong></p>
            <ul>
                <li><code>std::accumulate()</code> mo偶e by u偶ywany nie tylko do sumowania wartoci, ale tak偶e do wykonywania bardziej zo偶onych operacji, takich jak obliczanie iloczynu, czenie string贸w czy budowanie innych struktur danych.</li>
                <li>Funkcja <code>BinaryOperation</code> pozwala na zdefiniowanie dowolnej operacji akumulujcej, co zwiksza elastyczno <code>std::accumulate()</code>.</li>
            </ul>
            <h5><code>std::transform()</code></h5>
            <p>Funkcja <code>std::transform()</code> stosuje podan funkcj do ka偶dego elementu w zakresie i zapisuje wynik w innym zakresie.</p>
            <p><strong>Prototyp:</strong></p>
            <div>
                <pre><code class="language-clike">template&lt; class InputIt, class OutputIt, class UnaryOperation &gt;
OutputIt transform( InputIt first1, InputIt last1, OutputIt d_first, UnaryOperation unary_op );

template&lt; class InputIt1, class InputIt2, class OutputIt, class BinaryOperation &gt;
OutputIt transform( InputIt1 first1, InputIt1 last1,
                   InputIt2 first2, OutputIt d_first, BinaryOperation binary_op );</code></pre>
            </div>
            <p><strong>Przykad U偶ycia:</strong></p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; wektor{1, 2, 3, 4, 5};
    std::vector&lt;int&gt; wyniki(wektor.size());

    // Stosowanie funkcji lambda do podwojenia ka偶dego elementu
    std::transform(wektor.begin(), wektor.end(), wyniki.begin(), [](int x) { return x * 2; });

    // Wywietlanie wynik贸w
    std::cout &lt;&lt; "Wyniki po transformacji: ";
    for (const auto&amp; val : wyniki) {
        std::cout &lt;&lt; val &lt;&lt; " ";
    }

    return 0;
}</code></pre>
            </div>
            <p><strong>Wyjcie programu:</strong></p>
            <div>
                <pre><code class="language-shell">Wyniki po transformacji: 2 4 6 8 10</code></pre>
            </div>
            <p><strong>Uwagi:</strong></p>
            <ul>
                <li><code>std::transform()</code> jest niezwykle u偶yteczny do przeksztacania danych w kontenerach, bez koniecznoci tworzenia dodatkowych ptli czy tymczasowych zmiennych.</li>
                <li>Mo偶e by u偶ywany zar贸wno do jednoczesnego przetwarzania jednego, jak i dw贸ch zakres贸w, co pozwala na tworzenie bardziej zo偶onych operacji przeksztacania danych.</li>
            </ul>
            <h4 id="kompatybilno-z-iteratorami">Kompatybilno z Iteratorami</h4>
            <p>Algorytmy STL s zaprojektowane tak, aby dziaa z r贸偶nymi kategoriami iterator贸w, co zapewnia ich szerok kompatybilno z r贸偶nymi typami kontener贸w. Poni偶ej przedstawiono, kt贸re kategorie iterator贸w s obsugiwane przez poszczeg贸lne klasy algorytm贸w:</p>
            <p>
            <table>
                <tr>
                    <td>Kategoria</td>
                    <td>Przykady Algorytm贸w</td>
                </tr>
                <tr>
                    <td>Iteratory wejciowe</td>
                    <td><code>std::find</code>, <code>std::count_if</code></td>
                </tr>
                <tr>
                    <td>Iteratory wyjciowe</td>
                    <td><code>std::copy</code>, <code>std::fill</code></td>
                </tr>
                <tr>
                    <td>Iteratory jedno kierunkowe</td>
                    <td><code>std::for_each</code>, <code>std::remove</code></td>
                </tr>
                <tr>
                    <td>Iteratory dwukierunkowe</td>
                    <td><code>std::reverse</code>, <code>std::rotate</code></td>
                </tr>
                <tr>
                    <td>Iteratory losowego dostpu</td>
                    <td><code>std::sort</code>, <code>std::nth_element</code></td>
                </tr>
            </table>
            </p>
            <p><strong>Przykadowa Implementacja:</strong></p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;

int main() {
    std::vector&lt;int&gt; wektor{1, 2, 3, 4, 5};

    // U偶ycie std::for_each z iteratorami jedno kierunkowymi
    std::for_each(wektor.begin(), wektor.end(), [](int &amp;x) { x += 10; });

    // U偶ycie std::find z iteratorami wejciowymi
    auto it = std::find(wektor.begin(), wektor.end(), 13);
    if (it != wektor.end())
        std::cout &lt;&lt; "Znaleziono element: " &lt;&lt; *it &lt;&lt; "\n";
    else
        std::cout &lt;&lt; "Element nie zosta znaleziony.\n";

    // U偶ycie std::sort z iteratorami losowego dostpu
    std::vector&lt;int&gt; wektor2 = {5, 3, 1, 4, 2};
    std::sort(wektor2.begin(), wektor2.end());

    std::cout &lt;&lt; "Posortowany wektor2: ";
    for (const auto&amp; val : wektor2) {
        std::cout &lt;&lt; val &lt;&lt; " ";
    }

    return 0;
}</code></pre>
            </div>
            <p><strong>Wyjcie programu:</strong></p>
            <div>
                <pre><code class="language-shell">Znaleziono element: 13
Posortowany wektor2: 1 2 3 4 5</code></pre>
            </div>
            <h4 id="zastosowanie-algorytm贸w-w-praktyce">Zastosowanie Algorytm贸w w Praktyce</h4>
            <p>Algorytmy STL pozwalaj na pisanie kodu o wysokim poziomie abstrakcji, co zwiksza czytelno i redukuje ryzyko bd贸w. Dziki generycznoci i wykorzystaniu szablon贸w, algorytmy te s niezwykle elastyczne i mog by stosowane w szerokim zakresie zastosowa.</p>
            <p><strong>Przykad: Analiza Danych Finansowych</strong></p>
            <p>Za贸偶my, 偶e mamy wektor reprezentujcy dzienne zmiany cen akcji i chcemy przeprowadzi analiz:</p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;

int main() {
    std::vector&lt;double&gt; zmianyCen = { -0.5, 1.2, 0.3, -0.7, 0.8, -1.0, 0.6 };

    // Obliczenie sumarycznej zmiany cen
    double sumaZmian = std::accumulate(zmianyCen.begin(), zmianyCen.end(), 0.0);

    // Zliczenie dni ze wzrostem cen
    int dniWzrostu = std::count_if(zmianyCen.begin(), zmianyCen.end(), [](double x) { return x &gt; 0; });

    // Znalezienie najwikszego spadku
    auto it = std::min_element(zmianyCen.begin(), zmianyCen.end());

    // Wywietlenie wynik贸w
    std::cout &lt;&lt; "Sumaryczna zmiana cen: " &lt;&lt; sumaZmian &lt;&lt; "\n";
    std::cout &lt;&lt; "Liczba dni ze wzrostem cen: " &lt;&lt; dniWzrostu &lt;&lt; "\n";
    std::cout &lt;&lt; "Najwikszy spadek: " &lt;&lt; *it &lt;&lt; "\n";

    return 0;
}</code></pre>
            </div>
            <p><strong>Wyjcie programu:</strong></p>
            <div>
                <pre><code class="language-shell">Sumaryczna zmiana cen: -0.3
Liczba dni ze wzrostem cen: 4
Najwikszy spadek: -1</code></pre>
            </div>
            <p>W tym przykadzie wykorzystujemy r贸偶ne algorytmy STL do przeprowadzenia analizy danych finansowych:
                - <code>std::accumulate()</code> oblicza sum wszystkich zmian cen.
                - <code>std::count_if()</code> zlicza liczb dni, w kt贸rych cena wzrosa.
                - <code>std::min_element()</code> znajduje najwikszy spadek w cenach.</p>
            <h4 id="optymalizacja-za-pomoc-algorytm贸w">Optymalizacja za Pomoc Algorytm贸w</h4>
            <p>Korzystanie z algorytm贸w STL mo偶e prowadzi do bardziej wydajnego kodu, poniewa偶 s one zazwyczaj dobrze zoptymalizowane i wykorzystuj najlepsze praktyki implementacyjne. Ponadto, kompilatory mog dokonywa dodatkowych optymalizacji, gdy u偶ywane s standardowe algorytmy.</p>
            <p><strong>Przykad: Por贸wnanie z Ptl <code>for</code></strong></p>
            <p>Rozwa偶my zliczanie element贸w speniajcych okrelony warunek:</p>
            <p><strong>Tradycyjna ptla <code>for</code>:</strong></p>
            <div>
                <pre><code class="language-clike">int licznik = 0;
for (size_t i = 0; i &lt; wektor.size(); ++i) {
    if (wektor[i] % 2 == 0) {
        ++licznik;
    }
}</code></pre>
            </div>
            <p><strong>U偶ycie <code>std::count_if()</code>:</strong></p>
            <div>
                <pre><code class="language-clike">int licznik = std::count_if(wektor.begin(), wektor.end(), [](int x) { return x % 2 == 0; });</code></pre>
            </div>
            <p><strong>Por贸wnanie:</strong></p>
            <p>Korzystanie z <code>std::count_if()</code> nie tylko skraca kod, ale r贸wnie偶 zwiksza jego czytelno i potencjalnie wydajno. Algorytm STL mo偶e by zoptymalizowany lepiej ni偶 rcznie napisane ptle, a dodatkowo kod staje si bardziej zwizy i atwy do zrozumienia.</p>
        </article-section>
        <div id="table-of-contents">
            <h2>Spis Treci</h2>
            <ol><a href="#stl-standard-template-library-">STL (Standard Template Library)</a>
                <ol>
                    <li><a href="#g贸wne-komponenty-biblioteki-stl">G贸wne komponenty biblioteki STL</a></li>
                    <li><a href="#kolekcje-w-stl">Kolekcje w STL</a>
                        <ol>
                            <li><a href="#vector">vector</a></li>
                            <li><a href="#list">list</a></li>
                            <li><a href="#map">map</a></li>
                            <li><a href="#unordered_map">unordered_map</a></li>
                            <li><a href="#set">set</a></li>
                            <li><a href="#unordered_set">unordered_set</a></li>
                            <li><a href="#priority_queue">priority_queue</a></li>
                            <li><a href="#queue">queue</a></li>
                            <li><a href="#stack">stack</a></li>
                        </ol>
                    </li>
                    <li><a href="#iteratory">Iteratory</a>
                        <ol>
                            <li><a href="#rodzaje-iterator贸w">Rodzaje iterator贸w</a></li>
                            <li><a href="#podstawowe-operacje-na-iteratorach">Podstawowe operacje na iteratorach</a></li>
                            <li><a href="#przykad-u偶ycia-iteratora">Przykad u偶ycia iteratora</a></li>
                        </ol>
                    </li>
                    <li><a href="#algorytmy-w-standardowej-bibliotece-c-stl-">Algorytmy w Standardowej Bibliotece C++ (STL)</a>
                        <ol>
                            <li><a href="#wprowadzenie-do-algorytm贸w-stl">Wprowadzenie do Algorytm贸w STL</a></li>
                            <li><a href="#klasyfikacja-algorytm贸w">Klasyfikacja Algorytm贸w</a></li>
                            <li><a href="#std-sort-">std::sort()</a></li>
                            <li><a href="#std-find-">std::find()</a></li>
                            <li><a href="#std-for_each-">std::for_each()</a></li>
                            <li><a href="#std-count_if-">std::count_if()</a></li>
                            <li><a href="#inne-wa偶ne-algorytmy">Inne Wa偶ne Algorytmy</a></li>
                            <li><a href="#kompatybilno-z-iteratorami">Kompatybilno z Iteratorami</a></li>
                            <li><a href="#zastosowanie-algorytm贸w-w-praktyce">Zastosowanie Algorytm贸w w Praktyce</a></li>
                            <li><a href="#optymalizacja-za-pomoc-algorytm贸w">Optymalizacja za Pomoc Algorytm贸w</a></li>
                        </ol>
                    </li>
                </ol>
            </ol>
            <div id="related-articles">
                <h2>Related Articles</h2>
                <ol>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/01_proces_kompilacji.html">Proces Kompilacji</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/02_preprocesor.html">Preprocesor</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/03_zmienne_i_typy_danych.html">Zmienne i Typy Danych</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/04_interakcja_z_konsola.html">Interakcja z Konsola</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/05_instrukcja_warunkowa.html">Instrukcja Warunkowa</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/06_petle.html">Petle</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/07_liczby_losowe.html">Liczby Losowe</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/08_typ_wyliczeniowy.html">Typ Wyliczeniowy</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/09_funkcje.html">Funkcje</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/10_l_wartosci_r_wartosci.html">L Wartosci R Wartosci</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/11_wskazniki.html">Wskazniki</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/12_tablice.html">Tablice</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/13_napisy.html">Napisy</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/14_operacje_bitowe.html">Operacje Bitowe</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/15_programowanie_obietkowe.html">Programowanie Obietkowe</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/16_dziedziczenie.html">Dziedziczenie</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/17_zaawansowane_wskazniki.html">Zaawansowane Wskazniki</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/18_przeciazanie.html">Przeciazanie</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/19_konwersje.html">Konwersje</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/20_lambdy.html">Lambdy</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/21_szablony.html">Szablony</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/22_wyjatki.html">Wyjatki</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/23_stl.html">Stl</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/24_praca_z_plikami.html">Praca z Plikami</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/25_c_vs_cpp.html">C vs Cpp</a></li>
                </ol>
            </div>
        </div>
    </div>
    <footer>
        <div class="footer-columns">
            <div class="footer-column">
                <img alt="Adam Djellouli Symbol" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/symbol.png" />
            </div>
            <div class="footer-column">
                <h2><a href="https://adamdjellouli.com/core/privacy_policy.html" title="Privacy Policy">Our Privacy Policy</a></h2>
                <p>Thank you for visiting my personal website. All content here is free to use, but please remember to be respectful and avoid any misuse of the site. If youd like to get in touch, feel free to reach out via my <a href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" title="LinkedIn Profile">LinkedIn profile</a> or connect with me on <a href="https://github.com/djeada" title="GitHub Profile">GitHub</a> if you have technical questions or ideas to share. Wishing you all the best and a fantastic life ahead!</p>
            </div>
            <div class="footer-column">
                <h2>Follow me</h2>
                <ul class="social-media">
                    <li>
                        <a class="fa fa-youtube" href="https://www.youtube.com/channel/UCGPoHTVjMN77wcGknXPHl1Q" target="_blank" title="YouTube">
                        </a>YouTube
                    </li>
                    <li>
                        <a class="fa fa-linkedin" href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" target="_blank" title="LinkedIn">
                        </a>LinkedIn
                    </li>
                    <li>
                        <a class="fa fa-instagram" href="https://www.instagram.com/linuxchallenges/" target="_blank" title="Instagram">
                        </a>Instagram
                    </li>
                    <li>
                        <a class="fa fa-github" href="https://github.com/djeada" title="GitHub">
                        </a>Github
                    </li>
                </ul>
            </div>
        </div>
        <div>
            <p id="copyright">
                漏 Adam Djellouli. All rights reserved.
            </p>
        </div>
        <script>
            document.getElementById("copyright").innerHTML = "&copy; " + new Date().getFullYear() + " Adam Djellouli. All rights reserved.";
        </script>
        <script src="../../app.js"></script>
    </footer>
    <div id="pdf-spinner-overlay">
        <div class="spinner"></div>
    </div>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-bash.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-cpp.min.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
jax: ["input/TeX", "output/HTML-CSS"],
extensions: ["tex2jax.js"],
"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] },
tex2jax: { inlineMath: [ ["$", "$"] ], displayMath: [ ["$$","$$"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
TeX: { noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } } },
messageStyle: "none"
});
</script>
<script async="" id="MathJax-script" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>

</html>