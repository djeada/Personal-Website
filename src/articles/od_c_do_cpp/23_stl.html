<!DOCTYPE html>

<html lang="pl">

<head>
    <script async="" crossorigin="anonymous" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5593122079896089"></script>
    <meta charset="utf-8" />
    <title>STL (Standard Template Library)</title>
    <meta content="Standard Template Library (STL) to jedna z najważniejszych części języka C++, która znacząco ułatwia programowanie dzięki dostępowi do gotowych, wydajnych i elastycznych struktur danych oraz algorytmów." name="description" />
    <meta content="Adam Djellouli" name="author" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <meta content="IE=edge" http-equiv="X-UA-Compatible" />
    <link crossorigin="" href="https://fonts.googleapis.com" rel="preconnect" />
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/icon.ico" rel="icon" />
    <link href="../../resources/style.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
</head>

<body>
    <nav aria-label="Main navigation">
        <a class="logo" href="https://adamdjellouli.com">
            <img alt="Adam Djellouli - Home Page Logo" id="logo-image" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/logo.PNG" />
        </a>
        <input aria-label="Toggle navigation menu" id="navbar-toggle" type="checkbox" />
        <ul aria-labelledby="navbar-toggle" role="menu">
            <li role="menuitem">
                <a href="../../index.html" title="Go to Home Page"> Home </a>
            </li>
            <li role="menuitem">
                <a class="active" href="../../core/blog.html" title="Read Adam Djellouli Blog on Programming and Technology"> Blog </a>
            </li>
            <li role="menuitem">
                <a href="../../core/tools.html" title="Discover Tools Created by Adam Djellouli"> Tools </a>
            </li>
            <li role="menuitem">
                <a href="../../core/projects.html" title="Explore Projects Developed by Adam Djellouli"> Projects </a>
            </li>
            <li role="menuitem">
                <a href="../../core/resume.html" title="View Adam Djellouli Professional Resume"> Resume </a>
            </li>
            <li>
                <script async="" src="https://cse.google.com/cse.js?cx=8160ef9bb935f4f68"></script>
                <div class="gcse-search"></div>
            </li>
            <li>
                <button aria-label="Toggle dark mode" id="dark-mode-button"></button>
            </li>
        </ul>
    </nav>
    <div id="article-wrapper">
        <section id="article-body">
            <div class="article-action-buttons"><button class="btn-suggest-edit" title="Suggest Edit">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <path d="M4 21h4l11-11-4-4L4 17v4z" stroke="currentColor" stroke-width="2"></path>
                    </svg>
                </button><button class="btn-create-issue" title="Create Issue">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2"></circle>
                        <line stroke="currentColor" stroke-width="2" x1="12" x2="12" y1="8" y2="12"></line>
                        <circle cx="12" cy="16" fill="currentColor" r="1"></circle>
                    </svg>
                </button><button class="btn-download" title="Download">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <path d="M12 5v14m0 0l-6-6m6 6l6-6" stroke="currentColor" stroke-width="2"></path>
                    </svg>
                </button></div>
            <p style="text-align: right;"><i>Last modified: October 10, 2023</i></p>
            <p style="text-align: right;"><i>This article is written in: 🇵🇱</i></p>
            <h2 id="stl-standard-template-library-">STL (Standard Template Library)</h2>
            <p>Standard Template Library (STL) to jedna z najważniejszych części języka C++, która znacząco ułatwia programowanie dzięki dostępowi do gotowych, wydajnych i elastycznych struktur danych oraz algorytmów. STL jest biblioteką szablonów, co oznacza, że jej komponenty są generyczne i mogą pracować z różnymi typami danych bez konieczności pisania dodatkowego kodu. Dzięki STL programiści mogą skupić się na logice aplikacji, zamiast na implementacji podstawowych struktur danych i algorytmów.</p>
            <p>STL została zaprojektowana tak, aby wspierać trójskładnikowy model: <strong>algorytmy</strong>, <strong>kontenery</strong> i <strong>iteratory</strong>. Algorytmy operują na danych przechowywanych w kontenerach, a iteratory służą do przechodzenia przez te dane. Ta modularność pozwala na łatwe łączenie różnych komponentów STL w celu tworzenia złożonych operacji na danych.</p>
            <h3 id="główne-komponenty-biblioteki-stl">Główne komponenty biblioteki STL</h3>
            <p>STL dostarcza szerokiego wachlarza kontenerów i algorytmów, które można dostosować do różnych potrzeb programistycznych. Najważniejsze komponenty biblioteki STL to:</p>
            <ul>
                <li><strong>Kontenery sekwencyjne</strong>: <code>vector</code>, <code>list</code>, <code>deque</code></li>
                <li><strong>Kontenery asocjacyjne</strong>: <code>map</code>, <code>set</code>, <code>unordered_map</code>, <code>unordered_set</code></li>
                <li><strong>Kontenery kolejki</strong>: <code>queue</code>, <code>priority_queue</code>, <code>stack</code></li>
                <li><strong>Algorytmy</strong>: funkcje do sortowania, wyszukiwania, modyfikowania danych</li>
                <li><strong>Iteratory</strong>: narzędzia do przechodzenia przez elementy kontenerów</li>
            </ul>
            <p>Każdy z tych komponentów jest zoptymalizowany pod kątem określonych operacji, co pozwala na efektywne zarządzanie danymi w różnych scenariuszach.</p>
            <h3 id="kolekcje-w-stl">Kolekcje w STL</h3>
            <p>Kolekcje w STL to zbiory implementacji struktur danych wraz z funkcjami operującymi na tych strukturach. STL oferuje różnorodne kontenery, które można wykorzystać w zależności od specyficznych wymagań aplikacji. Wybór odpowiedniego kontenera jest kluczowy dla osiągnięcia optymalnej wydajności i efektywności pamięciowej. Poniżej przedstawione są najczęściej używane kontenery w STL wraz z ich podstawowymi operacjami, przykładami użycia oraz analizą złożoności czasowej.</p>
            <h4 id="vector"><strong>vector</strong></h4>
            <p><code>vector</code> to dynamiczna tablica, która może zmieniać swój rozmiar w trakcie działania programu. Jest jednym z najczęściej używanych kontenerów w STL ze względu na swoją prostotę i wydajność w większości przypadków. <code>vector</code> przechowuje elementy w sposób ciągły w pamięci, co umożliwia szybki dostęp do dowolnego elementu poprzez indeks.</p>
            <p>Operacje:</p>
            <p>
            <table>
                <tr>
                    <td>Metoda</td>
                    <td>Opis</td>
                    <td>Przykład użycia</td>
                    <td>Złożoność czasowa</td>
                </tr>
                <tr>
                    <td><code>push_back(value)</code></td>
                    <td>Dodaje element na końcu</td>
                    <td><code>vec.push_back(10);</code></td>
                    <td>Amortyzowane O(1)</td>
                </tr>
                <tr>
                    <td><code>pop_back()</code></td>
                    <td>Usuwa element z końca</td>
                    <td><code>vec.pop_back();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>size()</code></td>
                    <td>Zwraca liczbę elementów</td>
                    <td><code>auto s = vec.size();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>empty()</code></td>
                    <td>Sprawdza, czy kontener jest pusty</td>
                    <td><code>if (vec.empty()) {}</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>clear()</code></td>
                    <td>Usuwa wszystkie elementy</td>
                    <td><code>vec.clear();</code></td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><code>insert(pos, value)</code></td>
                    <td>Wstawia element na podanej pozycji</td>
                    <td><code>vec.insert(vec.begin() + 1, 20);</code></td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><code>erase(pos)</code></td>
                    <td>Usuwa element z podanej pozycji</td>
                    <td><code>vec.erase(vec.begin() + 1);</code></td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><code>at(index)</code></td>
                    <td>Zwraca referencję do elementu na podanym indeksie</td>
                    <td><code>int val = vec.at(2);</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>operator[]</code></td>
                    <td>Zwraca referencję do elementu na podanym indeksie</td>
                    <td><code>int val = vec[2];</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>front()</code></td>
                    <td>Zwraca referencję do pierwszego elementu</td>
                    <td><code>int val = vec.front();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>back()</code></td>
                    <td>Zwraca referencję do ostatniego elementu</td>
                    <td><code>int val = vec.back();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>begin()</code></td>
                    <td>Zwraca iterator na początek</td>
                    <td><code>auto it = vec.begin();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>end()</code></td>
                    <td>Zwraca iterator na koniec</td>
                    <td><code>auto it = vec.end();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>reserve(n)</code></td>
                    <td>Rezerwuje miejsce na n elementów</td>
                    <td><code>vec.reserve(100);</code></td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><code>resize(n)</code></td>
                    <td>Zmienia rozmiar wektora</td>
                    <td><code>vec.resize(10);</code></td>
                    <td>O(n)</td>
                </tr>
            </table>
            </p>
            <p><code>vector</code> jest idealnym wyborem, gdy potrzebujemy dynamicznej tablicy z szybkim dostępem do elementów przez indeks. Dzięki ciągłemu rozmieszczeniu w pamięci, operacje takie jak iterowanie czy dostęp losowy są bardzo wydajne. Jednak wstawianie lub usuwanie elementów w środku <code>vector</code> może być kosztowne ze względu na konieczność przesuwania innych elementów.</p>
            <p>Przykład:</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; vec = {1, 2, 3};
    vec.push_back(4);
    vec.insert(vec.begin() + 1, 10);
    for(auto it = vec.begin(); it != vec.end(); ++it) {
        std::cout &lt;&lt; *it &lt;&lt; " ";
    }
    return 0;
}</code></pre>
            </div>
            </p>
            <p>W powyższym przykładzie tworzymy <code>vector</code> z trzema elementami, dodajemy czwarty element za pomocą <code>push_back</code>, wstawiamy nowy element na drugą pozycję za pomocą <code>insert</code>, a następnie iterujemy przez wszystkie elementy i je wyświetlamy.</p>
            <h4 id="list"><strong>list</strong></h4>
            <p><code>list</code> to dwukierunkowa lista wiązana, która umożliwia szybkie wstawianie i usuwanie elementów w dowolnym miejscu listy. W przeciwieństwie do <code>vector</code>, <code>list</code> nie zapewnia ciągłego rozmieszczenia w pamięci, co sprawia, że dostęp do elementów przez indeks jest mniej wydajny, ale operacje wstawiania i usuwania są bardzo szybkie.</p>
            <p>Operacje:</p>
            <p>
            <table>
                <tr>
                    <td>Metoda</td>
                    <td>Opis</td>
                    <td>Przykład użycia</td>
                    <td>Złożoność czasowa</td>
                </tr>
                <tr>
                    <td><code>push_back(value)</code></td>
                    <td>Dodaje element na końcu</td>
                    <td><code>lst.push_back(10);</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>push_front(value)</code></td>
                    <td>Dodaje element na początku</td>
                    <td><code>lst.push_front(5);</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>pop_back()</code></td>
                    <td>Usuwa element z końca</td>
                    <td><code>lst.pop_back();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>pop_front()</code></td>
                    <td>Usuwa element z początku</td>
                    <td><code>lst.pop_front();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>size()</code></td>
                    <td>Zwraca liczbę elementów</td>
                    <td><code>auto s = lst.size();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>empty()</code></td>
                    <td>Sprawdza, czy kontener jest pusty</td>
                    <td><code>if (lst.empty()) {}</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>clear()</code></td>
                    <td>Usuwa wszystkie elementy</td>
                    <td><code>lst.clear();</code></td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><code>insert(pos, value)</code></td>
                    <td>Wstawia element na podanej pozycji</td>
                    <td><code>lst.insert(++lst.begin(), 20);</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>erase(pos)</code></td>
                    <td>Usuwa element z podanej pozycji</td>
                    <td><code>lst.erase(++lst.begin());</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>front()</code></td>
                    <td>Zwraca referencję do pierwszego elementu</td>
                    <td><code>int val = lst.front();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>back()</code></td>
                    <td>Zwraca referencję do ostatniego elementu</td>
                    <td><code>int val = lst.back();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>begin()</code></td>
                    <td>Zwraca iterator na początek</td>
                    <td><code>auto it = lst.begin();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>end()</code></td>
                    <td>Zwraca iterator na koniec</td>
                    <td><code>auto it = lst.end();</code></td>
                    <td>O(1)</td>
                </tr>
            </table>
            </p>
            <p><code>list</code> jest idealnym wyborem, gdy potrzebujemy częstych operacji wstawiania i usuwania elementów w różnych miejscach kolekcji. Ze względu na brak ciągłego rozmieszczenia w pamięci, iterowanie przez listę jest nieco mniej wydajne niż w przypadku <code>vector</code>, ale korzyści płynące z szybkich operacji wstawiania i usuwania często przeważają w zastosowaniach wymagających dynamicznej modyfikacji danych.</p>
            <p>Przykład:</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;list&gt;

int main() {
    std::list&lt;int&gt; lst = {1, 2, 3};
    lst.push_back(4);
    lst.push_front(0);
    lst.insert(++lst.begin(), 10);
    for(auto it = lst.begin(); it != lst.end(); ++it) {
        std::cout &lt;&lt; *it &lt;&lt; " ";
    }
    return 0;
}</code></pre>
            </div>
            </p>
            <p>W tym przykładzie tworzymy listę z trzema elementami, dodajemy element na końcu i na początku, wstawiamy nowy element na drugą pozycję, a następnie iterujemy przez wszystkie elementy i je wyświetlamy.</p>
            <h4 id="map"><strong>map</strong></h4>
            <p><code>map</code> to kontener asocjacyjny, który przechowuje pary klucz-wartość w uporządkowanej formie, wykorzystując drzewo czerwono-czarne. Dzięki temu <code>map</code> zapewnia szybki dostęp do wartości na podstawie klucza oraz automatyczne utrzymanie porządku elementów.</p>
            <p>Operacje:</p>
            <p>
            <table>
                <tr>
                    <td>Metoda</td>
                    <td>Opis</td>
                    <td>Przykład użycia</td>
                    <td>Złożoność czasowa</td>
                </tr>
                <tr>
                    <td><code>insert({key, value})</code></td>
                    <td>Wstawia parę klucz-wartość</td>
                    <td><code>mp.insert({1, "one"});</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>erase(key)</code></td>
                    <td>Usuwa element o podanym kluczu</td>
                    <td><code>mp.erase(1);</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>find(key)</code></td>
                    <td>Zwraca iterator na element o podanym kluczu</td>
                    <td><code>auto it = mp.find(1);</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>size()</code></td>
                    <td>Zwraca liczbę elementów</td>
                    <td><code>auto s = mp.size();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>empty()</code></td>
                    <td>Sprawdza, czy kontener jest pusty</td>
                    <td><code>if (mp.empty()) {}</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>clear()</code></td>
                    <td>Usuwa wszystkie elementy</td>
                    <td><code>mp.clear();</code></td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><code>operator[]</code></td>
                    <td>Zwraca referencję do wartości o podanym kluczu</td>
                    <td><code>std::string val = mp[1];</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>begin()</code></td>
                    <td>Zwraca iterator na początek</td>
                    <td><code>auto it = mp.begin();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>end()</code></td>
                    <td>Zwraca iterator na koniec</td>
                    <td><code>auto it = mp.end();</code></td>
                    <td>O(1)</td>
                </tr>
            </table>
            </p>
            <p><code>map</code> jest niezwykle przydatny, gdy potrzebujemy przechowywać dane w sposób, który umożliwia szybki dostęp do wartości na podstawie unikalnego klucza. Dzięki utrzymaniu uporządkowanego porządku elementów, iterowanie przez <code>map</code> pozwala na przeglądanie danych w sposób logiczny i przewidywalny. <code>map</code> automatycznie sortuje elementy według kluczy, co ułatwia wykonywanie operacji takich jak przeszukiwanie zakresów czy sortowanie.</p>
            <p>Przykład:</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;string&gt;

int main() {
    std::map&lt;int, std::string=""&gt; mp;
    mp.insert({1, "one"});
    mp[2] = "two";
    mp.erase(1);
    for(auto it = mp.begin(); it != mp.end(); ++it) {
        std::cout &lt;&lt; it-&gt;first &lt;&lt; ": " &lt;&lt; it-&gt;second &lt;&lt; " ";
    }
    return 0;
}</code></pre>
            </div>
            </p>
            <p>W tym przykładzie tworzymy <code>map</code> z kluczami typu <code>int</code> i wartościami typu <code>std::string</code>. Wstawiamy parę klucz-wartość za pomocą <code>insert</code>, dodajemy kolejną parę za pomocą operatora <code>[]</code>, usuwamy element o kluczu <code>1</code>, a następnie iterujemy przez wszystkie elementy i je wyświetlamy.</p>
            <h4 id="unordered_map"><strong>unordered_map</strong></h4>
            <p><code>unordered_map</code> to kontener asocjacyjny, który przechowuje pary klucz-wartość w nieuporządkowanej formie, wykorzystując tablicę mieszającą (hash table). Dzięki temu <code>unordered_map</code> oferuje bardzo szybki dostęp do elementów na podstawie klucza, zazwyczaj w czasie stałym.</p>
            <p>Operacje:</p>
            <p>
            <table>
                <tr>
                    <td>Metoda</td>
                    <td>Opis</td>
                    <td>Przykład użycia</td>
                    <td>Złożoność czasowa</td>
                </tr>
                <tr>
                    <td><code>insert({key, value})</code></td>
                    <td>Wstawia parę klucz-wartość</td>
                    <td><code>ump.insert({1, "one"});</code></td>
                    <td>O(1) amortyzowane</td>
                </tr>
                <tr>
                    <td><code>erase(key)</code></td>
                    <td>Usuwa element o podanym kluczu</td>
                    <td><code>ump.erase(1);</code></td>
                    <td>O(1) amortyzowane</td>
                </tr>
                <tr>
                    <td><code>find(key)</code></td>
                    <td>Zwraca iterator na element o podanym kluczu</td>
                    <td><code>auto it = ump.find(1);</code></td>
                    <td>O(1) amortyzowane</td>
                </tr>
                <tr>
                    <td><code>size()</code></td>
                    <td>Zwraca liczbę elementów</td>
                    <td><code>auto s = ump.size();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>empty()</code></td>
                    <td>Sprawdza, czy kontener jest pusty</td>
                    <td><code>if (ump.empty()) {}</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>clear()</code></td>
                    <td>Usuwa wszystkie elementy</td>
                    <td><code>ump.clear();</code></td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><code>operator[]</code></td>
                    <td>Zwraca referencję do wartości o podanym kluczu</td>
                    <td><code>std::string val = ump[1];</code></td>
                    <td>O(1) amortyzowane</td>
                </tr>
                <tr>
                    <td><code>begin()</code></td>
                    <td>Zwraca iterator na początek</td>
                    <td><code>auto it = ump.begin();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>end()</code></td>
                    <td>Zwraca iterator na koniec</td>
                    <td><code>auto it = ump.end();</code></td>
                    <td>O(1)</td>
                </tr>
            </table>
            </p>
            <p><code>unordered_map</code> jest doskonałym wyborem, gdy potrzebujemy bardzo szybkiego dostępu do danych na podstawie klucza, bez konieczności utrzymywania uporządkowanego porządku elementów. Jest idealny do implementacji słowników, buforów pamięci podręcznej i innych struktur, które wymagają szybkiego wyszukiwania. Jednak w przeciwieństwie do <code>map</code>, <code>unordered_map</code> nie zapewnia uporządkowanego przechowywania elementów, co może być wadą w niektórych zastosowaniach.</p>
            <p>Przykład:</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;unordered_map&gt;
#include &lt;string&gt;

int main() {
    std::unordered_map&lt;int, std::string=""&gt; ump;
    ump.insert({1, "one"});
    ump[2] = "two";
    ump.erase(1);
    for(auto it = ump.begin(); it != ump.end(); ++it) {
        std::cout &lt;&lt; it-&gt;first &lt;&lt; ": " &lt;&lt; it-&gt;second &lt;&lt; " ";
    }
    return 0;
}</code></pre>
            </div>
            </p>
            <p>W tym przykładzie tworzymy <code>unordered_map</code> z kluczami typu <code>int</code> i wartościami typu <code>std::string</code>. Wstawiamy parę klucz-wartość za pomocą <code>insert</code>, dodajemy kolejną parę za pomocą operatora <code>[]</code>, usuwamy element o kluczu <code>1</code>, a następnie iterujemy przez wszystkie elementy i je wyświetlamy.</p>
            <h4 id="set"><strong>set</strong></h4>
            <p><code>set</code> to kontener, który przechowuje unikalne elementy w uporządkowanej formie, wykorzystując drzewo czerwono-czarne. <code>set</code> zapewnia szybkie wyszukiwanie, wstawianie i usuwanie elementów, utrzymując jednocześnie elementy w uporządkowanym porządku.</p>
            <p>Operacje:</p>
            <p>
            <table>
                <tr>
                    <td>Metoda</td>
                    <td>Opis</td>
                    <td>Przykład użycia</td>
                    <td>Złożoność czasowa</td>
                </tr>
                <tr>
                    <td><code>insert(value)</code></td>
                    <td>Wstawia element</td>
                    <td><code>st.insert(10);</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>erase(value)</code></td>
                    <td>Usuwa element</td>
                    <td><code>st.erase(10);</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>find(value)</code></td>
                    <td>Zwraca iterator na element</td>
                    <td><code>auto it = st.find(10);</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>size()</code></td>
                    <td>Zwraca liczbę elementów</td>
                    <td><code>auto s = st.size();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>empty()</code></td>
                    <td>Sprawdza, czy kontener jest pusty</td>
                    <td><code>if (st.empty()) {}</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>clear()</code></td>
                    <td>Usuwa wszystkie elementy</td>
                    <td><code>st.clear();</code></td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><code>begin()</code></td>
                    <td>Zwraca iterator na początek</td>
                    <td><code>auto it = st.begin();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>end()</code></td>
                    <td>Zwraca iterator na koniec</td>
                    <td><code>auto it = st.end();</code></td>
                    <td>O(1)</td>
                </tr>
            </table>
            </p>
            <p><code>set</code> jest użyteczny, gdy potrzebujemy przechowywać zbiór unikalnych elementów i często wykonywać operacje takie jak sprawdzanie obecności elementu, wstawianie czy usuwanie. Utrzymanie uporządkowanego porządku elementów umożliwia efektywne iterowanie w określonej kolejności oraz wykonywanie operacji zakresowych.</p>
            <p>Przykład:</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;set&gt;

int main() {
    std::set&lt;int&gt; st;
    st.insert(10);
    st.insert(20);
    st.erase(10);
    for(auto it = st.begin(); it != st.end(); ++it) {
        std::cout &lt;&lt; *it &lt;&lt; " ";
    }
    return 0;
}</code></pre>
            </div>
            </p>
            <p>W tym przykładzie tworzymy <code>set</code> z elementami typu <code>int</code>, wstawiamy kilka elementów, usuwamy jeden z nich, a następnie iterujemy przez wszystkie pozostałe elementy i je wyświetlamy.</p>
            <h4 id="unordered_set"><strong>unordered_set</strong></h4>
            <p><code>unordered_set</code> to kontener, który przechowuje unikalne elementy w nieuporządkowanej formie, wykorzystując tablicę mieszającą (hash table). Dzięki temu <code>unordered_set</code> oferuje bardzo szybkie operacje wyszukiwania, wstawiania i usuwania elementów, zazwyczaj w czasie stałym.</p>
            <p>Operacje:</p>
            <p>
            <table>
                <tr>
                    <td>Metoda</td>
                    <td>Opis</td>
                    <td>Przykład użycia</td>
                    <td>Złożoność czasowa</td>
                </tr>
                <tr>
                    <td><code>insert(value)</code></td>
                    <td>Wstawia element</td>
                    <td><code>ust.insert(10);</code></td>
                    <td>O(1) amortyzowane</td>
                </tr>
                <tr>
                    <td><code>erase(value)</code></td>
                    <td>Usuwa element</td>
                    <td><code>ust.erase(10);</code></td>
                    <td>O(1) amortyzowane</td>
                </tr>
                <tr>
                    <td><code>find(value)</code></td>
                    <td>Zwraca iterator na element</td>
                    <td><code>auto it = ust.find(10);</code></td>
                    <td>O(1) amortyzowane</td>
                </tr>
                <tr>
                    <td><code>size()</code></td>
                    <td>Zwraca liczbę elementów</td>
                    <td><code>auto s = ust.size();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>empty()</code></td>
                    <td>Sprawdza, czy kontener jest pusty</td>
                    <td><code>if (ust.empty()) {}</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>clear()</code></td>
                    <td>Usuwa wszystkie elementy</td>
                    <td><code>ust.clear();</code></td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><code>begin()</code></td>
                    <td>Zwraca iterator na początek</td>
                    <td><code>auto it = ust.begin();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>end()</code></td>
                    <td>Zwraca iterator na koniec</td>
                    <td><code>auto it = ust.end();</code></td>
                    <td>O(1)</td>
                </tr>
            </table>
            </p>
            <p><code>unordered_set</code> jest idealnym wyborem, gdy potrzebujemy przechowywać unikalne elementy i wykonywać szybkie operacje wyszukiwania bez konieczności utrzymywania uporządkowanego porządku. Jest szczególnie przydatny w sytuacjach, gdzie kolejność elementów nie ma znaczenia, a kluczowa jest szybkość dostępu do danych.</p>
            <p>Przykład:</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;unordered_set&gt;

int main() {
    std::unordered_set&lt;int&gt; ust;
    ust.insert(10);
    ust.insert(20);
    ust.erase(10);
    for(auto it = ust.begin(); it != ust.end(); ++it) {
        std::cout &lt;&lt; *it &lt;&lt; " ";
    }
    return 0;
}</code></pre>
            </div>
            </p>
            <p>W tym przykładzie tworzymy <code>unordered_set</code> z elementami typu <code>int</code>, wstawiamy kilka elementów, usuwamy jeden z nich, a następnie iterujemy przez wszystkie pozostałe elementy i je wyświetlamy.</p>
            <h4 id="priority_queue"><strong>priority_queue</strong></h4>
            <p><code>priority_queue</code> to kontener, który implementuje kopiec binarny i pozwala na szybkie wyciąganie największego (lub najmniejszego) elementu. <code>priority_queue</code> jest przydatny w zastosowaniach, gdzie potrzebujemy dynamicznie utrzymywać zbiór elementów w taki sposób, aby zawsze mieć szybki dostęp do najwyższego priorytetu.</p>
            <p>Operacje:</p>
            <p>
            <table>
                <tr>
                    <td>Metoda</td>
                    <td>Opis</td>
                    <td>Przykład użycia</td>
                    <td>Złożoność czasowa</td>
                </tr>
                <tr>
                    <td><code>push(value)</code></td>
                    <td>Dodaje element</td>
                    <td><code>pq.push(10);</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>pop()</code></td>
                    <td>Usuwa największy element</td>
                    <td><code>pq.pop();</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>top()</code></td>
                    <td>Zwraca referencję do największego elementu</td>
                    <td><code>int val = pq.top();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>size()</code></td>
                    <td>Zwraca liczbę elementów</td>
                    <td><code>auto s = pq.size();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>empty()</code></td>
                    <td>Sprawdza, czy kontener jest pusty</td>
                    <td><code>if (pq.empty()) {}</code></td>
                    <td>O(1)</td>
                </tr>
            </table>
            </p>
            <p><code>priority_queue</code> jest użyteczny w algorytmach takich jak Dijkstra czy Huffman, gdzie konieczne jest szybkie wyciąganie elementów o najwyższym priorytecie. Dzięki strukturze kopca binarnego, <code>priority_queue</code> zapewnia efektywne zarządzanie elementami i szybki dostęp do najbardziej istotnych danych.</p>
            <p>Przykład:</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;queue&gt;

int main() {
    std::priority_queue&lt;int&gt; pq;
    pq.push(10);
    pq.push(20);
    pq.push(5);
    std::cout &lt;&lt; pq.top() &lt;&lt; " "; // wyświetli 20
    pq.pop();
    std::cout &lt;&lt; pq.top() &lt;&lt; " "; // wyświetli 10
    return 0;
}</code></pre>
            </div>
            </p>
            <p>W tym przykładzie tworzymy <code>priority_queue</code> z elementami typu <code>int</code>, dodajemy kilka elementów, a następnie wyciągamy i wyświetlamy największy element za pomocą <code>top</code> oraz <code>pop</code>.</p>
            <h4 id="queue"><strong>queue</strong></h4>
            <p><code>queue</code> to kontener, który implementuje kolejkę FIFO (First In, First Out). <code>queue</code> jest idealny do sytuacji, gdzie kolejność przetwarzania elementów jest istotna, na przykład w symulacjach systemów kolejkowych czy zarządzaniu zadaniami.</p>
            <p>Operacje:</p>
            <p>
            <table>
                <tr>
                    <td>Metoda</td>
                    <td>Opis</td>
                    <td>Przykład użycia</td>
                    <td>Złożoność czasowa</td>
                </tr>
                <tr>
                    <td><code>push(value)</code></td>
                    <td>Dodaje element</td>
                    <td><code>q.push(10);</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>pop()</code></td>
                    <td>Usuwa element z początku</td>
                    <td><code>q.pop();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>front()</code></td>
                    <td>Zwraca referencję do pierwszego elementu</td>
                    <td><code>int val = q.front();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>back()</code></td>
                    <td>Zwraca referencję do ostatniego elementu</td>
                    <td><code>int val = q.back();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>size()</code></td>
                    <td>Zwraca liczbę elementów</td>
                    <td><code>auto s = q.size();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>empty()</code></td>
                    <td>Sprawdza, czy kontener jest pusty</td>
                    <td><code>if (q.empty()) {}</code></td>
                    <td>O(1)</td>
                </tr>
            </table>
            </p>
            <p><code>queue</code> jest prostym i efektywnym narzędziem do zarządzania danymi w sposób kolejnościowy. Dzięki temu kontenerowi możemy łatwo implementować mechanizmy przetwarzania danych, gdzie pierwszy element w kolejce jest przetwarzany jako pierwszy, a ostatni jako ostatni.</p>
            <p>Przykład:</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;queue&gt;

int main() {
    std::queue&lt;int&gt; q;
    q.push(10);
    q.push(20);
    std::cout &lt;&lt; q.front() &lt;&lt; " "; // wyświetli 10
    q.pop();
    std::cout &lt;&lt; q.front() &lt;&lt; " "; // wyświetli 20
    return 0;
}</code></pre>
            </div>
            </p>
            <p>W tym przykładzie tworzymy <code>queue</code> z elementami typu <code>int</code>, dodajemy kilka elementów, a następnie wyciągamy i wyświetlamy pierwszy element za pomocą <code>front</code> oraz <code>pop</code>.</p>
            <h4 id="stack"><strong>stack</strong></h4>
            <p><code>stack</code> to kontener, który implementuje stos LIFO (Last In, First Out). <code>stack</code> jest użyteczny w sytuacjach, gdzie potrzebujemy struktury danych działającej na zasadzie ostatniego przyjętego elementu jako pierwszego do przetworzenia, na przykład w algorytmach rekurencyjnych czy przetwarzaniu wyrażeń.</p>
            <p>Operacje:</p>
            <p>
            <table>
                <tr>
                    <td>Metoda</td>
                    <td>Opis</td>
                    <td>Przykład użycia</td>
                    <td>Złożoność czasowa</td>
                </tr>
                <tr>
                    <td><code>push(value)</code></td>
                    <td>Dodaje element</td>
                    <td><code>st.push(10);</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>pop()</code></td>
                    <td>Usuwa element z końca</td>
                    <td><code>st.pop();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>top()</code></td>
                    <td>Zwraca referencję do ostatniego elementu</td>
                    <td><code>int val = st.top();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>size()</code></td>
                    <td>Zwraca liczbę elementów</td>
                    <td><code>auto s = st.size();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>empty()</code></td>
                    <td>Sprawdza, czy kontener jest pusty</td>
                    <td><code>if (st.empty()) {}</code></td>
                    <td>O(1)</td>
                </tr>
            </table>
            </p>
            <p><code>stack</code> jest doskonałym wyborem, gdy potrzebujemy prostego mechanizmu do przechowywania danych w odwrotnej kolejności. Dzięki swojej prostocie i wydajności, <code>stack</code> znajduje zastosowanie w wielu algorytmach, takich jak przetwarzanie wyrażeń matematycznych, czy implementacja funkcji rekurencyjnych.</p>
            <p>Przykład:</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;stack&gt;

int main() {
    std::stack&lt;int&gt; st;
    st.push(10);
    st.push(20);
    std::cout &lt;&lt; st.top() &lt;&lt; " "; // wyświetli 20
    st.pop();
    std::cout &lt;&lt; st.top() &lt;&lt; " "; // wyświetli 10
    return 0;
}</code></pre>
            </div>
            </p>
            <p>W tym przykładzie tworzymy <code>stack</code> z elementami typu <code>int</code>, dodajemy kilka elementów, a następnie wyciągamy i wyświetlamy ostatni dodany element za pomocą <code>top</code> oraz <code>pop</code>.</p>
            <h3 id="iteratory">Iteratory</h3>
            <p>Iteratory w języku C++ są fundamentem, który umożliwia efektywną i elastyczną pracę z różnorodnymi kontenerami dostarczanymi przez Standard Template Library (STL). Iteratory to obiekty, które umożliwiają sekwencyjny dostęp do elementów kontenerów, takich jak <code>vector</code>, <code>list</code>, <code>map</code> i inne. Dzięki nim możliwe jest pisanie generycznego kodu, który działa niezależnie od konkretnego typu kontenera, co znacznie zwiększa reużywalność i elastyczność kodu.</p>
            <p>Podobnie jak wskaźniki, iteratory mogą być dereferencjonowane, aby uzyskać dostęp do wartości przechowywanych w kontenerze, oraz mogą być inkrementowane lub dekrementowane, aby przechodzić do następnych lub poprzednich elementów. Jednak iteratory oferują więcej możliwości i bezpieczeństwa, ponieważ są zaprojektowane tak, aby współpracować bezpośrednio z kontenerami STL, zapewniając zgodność typów i chroniąc przed nieprawidłowymi operacjami.</p>
            <p>Iteratory są niezbędne do korzystania z algorytmów STL, które operują na zakresach określonych przez iteratory. Dzięki temu można łatwo przetwarzać dane w kontenerach za pomocą gotowych funkcji, bez konieczności implementowania własnych pętli czy struktur kontrolnych.</p>
            <h4 id="rodzaje-iteratorów">Rodzaje iteratorów</h4>
            <p>W STL istnieje kilka kategorii iteratorów, z których każda oferuje różne możliwości i jest przeznaczona do określonych zastosowań. Znajomość tych rodzajów iteratorów pozwala na lepsze zrozumienie, jak efektywnie korzystać z kontenerów i algorytmów STL.</p>
            <p>
            <table>
                <tr>
                    <td>Typ iteratora</td>
                    <td>Opis</td>
                </tr>
                <tr>
                    <td><strong>Input Iterator</strong></td>
                    <td>Służy do odczytu danych z kontenera. Można go używać do jednorazowego przechodzenia przez elementy w jednym kierunku. Idealny do przetwarzania danych w sekwencji bez modyfikacji.</td>
                </tr>
                <tr>
                    <td><strong>Output Iterator</strong></td>
                    <td>Służy do zapisu danych do kontenera. Pozwala na jednorazowe przechodzenie przez elementy i modyfikowanie ich wartości.</td>
                </tr>
                <tr>
                    <td><strong>Forward Iterator</strong></td>
                    <td>Łączy możliwości iteratorów input i output. Może przemieszczać się tylko do przodu, ale może zarówno czytać, jak i pisać dane.</td>
                </tr>
                <tr>
                    <td><strong>Bidirectional Iterator</strong></td>
                    <td>Umożliwia przemieszczanie się zarówno do przodu, jak i do tyłu. Przydatny w kontenerach, które wspierają dwukierunkowy dostęp, takich jak <code>list</code>.</td>
                </tr>
                <tr>
                    <td><strong>Random Access Iterator</strong></td>
                    <td>Oferuje wszystkie możliwości Bidirectional Iterator oraz umożliwia dostęp do dowolnego elementu kontenera w stałym czasie. Pozwala na operacje arytmetyczne na iteratorach, takie jak przesunięcie o określoną liczbę pozycji. Idealny dla kontenerów takich jak <code>vector</code> czy <code>deque</code>.</td>
                </tr>
            </table>
            </p>
            <h4 id="podstawowe-operacje-na-iteratorach">Podstawowe operacje na iteratorach</h4>
            <p>Praca z iteratorami obejmuje kilka podstawowych operacji, które umożliwiają manipulowanie i przeglądanie elementów kontenerów. Poniżej przedstawiono najważniejsze z nich:</p>
            <ul>
                <li><strong>Inicjalizacja iteratora początkowym elementem kontenera:</strong> Aby rozpocząć iterację, należy zainicjalizować iterator na początku kontenera za pomocą <code>kontener.begin()</code>. To pozwala na dostęp do pierwszego elementu.</li>
            </ul>
            <p>
            <div>
                <pre><code class="language-clike">auto it = kontener.begin();</code></pre>
            </div>
            </p>
            <ul>
                <li><strong>Inicjalizacja iteratora elementem za ostatnim w kontenerze:</strong> Iterator <code>kontener.end()</code> wskazuje na element za ostatnim elementem w kontenerze. Jest to przydatne do oznaczania końca zakresu podczas iteracji.</li>
            </ul>
            <p>
            <div>
                <pre><code class="language-clike">auto it_end = kontener.end();</code></pre>
            </div>
            </p>
            <ul>
                <li><strong>Odwołanie do elementu, na który wskazuje iterator:</strong> Używając operatora dereferencji <code>*</code>, możemy uzyskać dostęp do wartości przechowywanej w elemencie, na który wskazuje iterator.</li>
            </ul>
            <p>
            <div>
                <pre><code class="language-clike">auto element = *it;</code></pre>
            </div>
            </p>
            <ul>
                <li><strong>Przesunięcie iteratora do następnego elementu:</strong> Operator <code>++</code> umożliwia przejście do kolejnego elementu w kontenerze.</li>
            </ul>
            <p>
            <div>
                <pre><code class="language-clike">++it;</code></pre>
            </div>
            </p>
            <ul>
                <li><strong>Przesunięcie iteratora do poprzedniego elementu:</strong> Operator <code>--</code> pozwala na powrót do poprzedniego elementu. Jest dostępny tylko dla iteratorów dwukierunkowych i iteratorów o losowym dostępie.</li>
            </ul>
            <p>
            <div>
                <pre><code class="language-clike">--it;</code></pre>
            </div>
            </p>
            <ul>
                <li><strong>Przesunięcie iteratora o określoną liczbę pozycji:</strong> Dla iteratorów o losowym dostępie, możemy przesuwać iterator o określoną liczbę pozycji za pomocą operatorów arytmetycznych.</li>
            </ul>
            <p>
            <div>
                <pre><code class="language-clike">it += n; // Przesunięcie do przodu o n pozycji
  it -= n; // Przesunięcie do tyłu o n pozycji</code></pre>
            </div>
            </p>
            <ul>
                <li><strong>Wstawienie elementu w miejscu wskazywanym przez iterator:</strong> Metoda <code>insert</code> umożliwia dodanie nowego elementu przed pozycją wskazywaną przez iterator.</li>
            </ul>
            <p>
            <div>
                <pre><code class="language-clike">it = kontener.insert(it, wartość);</code></pre>
            </div>
            </p>
            <ul>
                <li><strong>Usunięcie elementu w miejscu wskazywanym przez iterator:</strong> Metoda <code>erase</code> pozwala na usunięcie elementu na pozycji wskazywanej przez iterator i zwraca iterator do następnego elementu.</li>
            </ul>
            <p>
            <div>
                <pre><code class="language-clike">it = kontener.erase(it);</code></pre>
            </div>
            </p>
            <h4 id="przykład-użycia-iteratora">Przykład użycia iteratora</h4>
            <p>Poniższy przykład ilustruje podstawowe operacje na iteratorech w kontekście kontenera <code>std::vector</code> typu <code>std::string</code>. Program tworzy wektor z trzema elementami, wyświetla jego zawartość przy użyciu iteratora, dodaje nowy element przed drugim elementem, usuwa pierwszy element, a następnie ponownie wyświetla zmodyfikowaną zawartość wektora.</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;std::string&gt; v = {"ala", "ma", "kota"};

    // Wyświetlenie zawartości wektora przy użyciu iteratora
    std::cout &lt;&lt; "Zawartość wektora przed modyfikacjami:\n";
    for (auto it = v.begin(); it != v.end(); ++it) {
        std::cout &lt;&lt; *it &lt;&lt; std::endl;
    }

    // Dodanie nowego elementu przed "ma"
    auto it = v.begin() + 1;
    v.insert(it, "nie");

    // Usunięcie słowa "ala"
    it = v.begin();
    v.erase(it);

    std::cout &lt;&lt; "\nPo modyfikacjach:\n";
    for (const auto&amp; word : v) {
        std::cout &lt;&lt; word &lt;&lt; std::endl;
    }

    return 0;
}</code></pre>
            </div>
            </p>
            <p><strong>Wyjście programu:</strong></p>
            <p>
            <div>
                <pre><code class="language-shell">Zawartość wektora przed modyfikacjami:
ala
ma
kota

Po modyfikacjach:
ma
nie
kota</code></pre>
            </div>
            </p>
            <p>Warto pamiętać, że po niektórych operacjach, takich jak <code>insert</code> czy <code>erase</code>, używane wcześniej iteratory mogą stać się nieaktualne i ich dalsze użycie może prowadzić do niezdefiniowanego zachowania programu. Dlatego zaleca się ponowne inicjalizowanie iteratorów po modyfikacji kontenera.</p>
            <h3 id="algorytmy-w-standardowej-bibliotece-c-stl-">Algorytmy w Standardowej Bibliotece C++ (STL)</h3>
            <p>Biblioteka <code>algorithm</code> w standardowej bibliotece C++ (STL) dostarcza bogaty zestaw funkcji szablonowych, które służą do manipulacji i analizy danych przechowywanych w kontenerach. Algorytmy te są zaprojektowane w sposób generyczny, co oznacza, że mogą działać z różnymi typami danych i kontenerami, pod warunkiem spełnienia określonych wymagań. W tej sekcji przyjrzymy się kilku kluczowym algorytmom, ich implementacji, zastosowaniu oraz analizie matematycznej wydajności.</p>
            <h4 id="wprowadzenie-do-algorytmów-stl">Wprowadzenie do Algorytmów STL</h4>
            <p>Algorytmy w STL są zaimplementowane jako funkcje szablonowe, co pozwala na ich użycie z różnymi typami danych i kontenerami. Działają one na zakresach określonych przez iteratory, co zapewnia elastyczność i niezależność od konkretnego typu kontenera. Dzięki temu możliwe jest pisanie kodu, który jest jednocześnie uniwersalny i wydajny.</p>
            <p>Algorytmy STL są zoptymalizowane pod kątem wydajności oraz zgodności z różnymi typami iteratorów. Pozwalają na wykonywanie złożonych operacji na danych w sposób zwięzły i czytelny, redukując potrzebę pisania własnych implementacji podstawowych funkcji przetwarzania danych.</p>
            <h4 id="klasyfikacja-algorytmów">Klasyfikacja Algorytmów</h4>
            <p>Algorytmy STL można podzielić na kilka kategorii, w zależności od rodzaju operacji, które wykonują na danych:</p>
            <p>
            <table>
                <tr>
                    <td>Kategoria algorytmów</td>
                    <td>Przykłady</td>
                </tr>
                <tr>
                    <td><strong>Algorytmy modyfikujące</strong></td>
                    <td><code>std::copy</code>, <code>std::fill</code>, <code>std::transform</code></td>
                </tr>
                <tr>
                    <td><strong>Algorytmy przeszukujące</strong></td>
                    <td><code>std::find</code>, <code>std::count</code>, <code>std::search</code></td>
                </tr>
                <tr>
                    <td><strong>Algorytmy sortujące i porządkujące</strong></td>
                    <td><code>std::sort</code>, <code>std::stable_sort</code>, <code>std::partial_sort</code></td>
                </tr>
                <tr>
                    <td><strong>Algorytmy numeryczne</strong></td>
                    <td><code>std::accumulate</code>, <code>std::inner_product</code>, <code>std::partial_sum</code></td>
                </tr>
                <tr>
                    <td><strong>Algorytmy usuwające</strong></td>
                    <td><code>std::remove</code>, <code>std::unique</code>, <code>std::remove_if</code></td>
                </tr>
            </table>
            </p>
            <p>Każda z tych kategorii obejmuje algorytmy, które są zoptymalizowane do wykonywania specyficznych operacji na danych, co pozwala na efektywne zarządzanie i przetwarzanie informacji w aplikacjach.</p>
            <h4 id="std-sort-"><code>std::sort()</code></h4>
            <p>Funkcja <code>std::sort()</code> służy do sortowania elementów w określonym zakresie. Jest to jeden z najczęściej używanych algorytmów w STL ze względu na swoją uniwersalność i wydajność. <code>std::sort()</code> wykorzystuje algorytm sortowania introspektywnego (introsort), który łączy zalety sortowania szybkiego (quick sort), sortowania kopcowego (heap sort) i sortowania przez wstawianie (insertion sort).</p>
            <p><strong>Prototyp:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">template&lt; class RandomIt &gt;
void sort( RandomIt first, RandomIt last );

template&lt; class RandomIt, class Compare &gt;
void sort( RandomIt first, RandomIt last, Compare comp );</code></pre>
            </div>
            </p>
            <ul>
                <li><code>RandomIt</code>: Typ iteratora losowego dostępu.</li>
                <li><code>Compare</code>: Funkcja lub funktor służący do porównywania elementów.</li>
            </ul>
            <p><strong>Wymagania:</strong></p>
            <ul>
                <li>Elementy muszą być porównywalne za pomocą operatora <code>&lt;</code> lub funkcji <code>Compare</code>.</li>
                <li>Iteratory muszą być iteratorami losowego dostępu (np. z <code>std::vector</code>, <code>std::array</code>).</li>
            </ul>
            <p><strong>Przykład Użycia:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; wektor{8, 3, 5, 1, 2, 4, 6, 7};
    auto kopia = wektor;

    // Sortowanie pierwszych trzech elementów
    std::sort(wektor.begin(), wektor.begin() + 3);

    // Sortowanie całego wektora
    std::sort(kopia.begin(), kopia.end());

    // Wyświetlanie wyników
    std::cout &lt;&lt; "Wektor po częściowym sortowaniu: ";
    for (const auto&amp; val : wektor) {
        std::cout &lt;&lt; val &lt;&lt; " ";
    }
    std::cout &lt;&lt; "\n";

    std::cout &lt;&lt; "Wektor po pełnym sortowaniu: ";
    for (const auto&amp; val : kopia) {
        std::cout &lt;&lt; val &lt;&lt; " ";
    }

    return 0;
}</code></pre>
            </div>
            </p>
            <p><strong>Wyjście programu:</strong></p>
            <p>
            <div>
                <pre><code class="language-shell">Wektor po częściowym sortowaniu: 3 5 8 1 2 4 6 7 
Wektor po pełnym sortowaniu: 1 2 3 4 5 6 7 8</code></pre>
            </div>
            </p>
            <p><strong>Analiza Matematyczna:</strong></p>
            <ul>
                <li><strong>Złożoność czasowa</strong> dla tego algorytmu wynosi średnio $O(n \log n)$, co jest charakterystyczne dla wydajnych algorytmów sortowania.</li>
                <li>W najgorszym przypadku złożoność czasowa również wynosi $O(n \log n)$, ponieważ algorytm wykorzystuje introsort, który automatycznie przełącza się na sortowanie kopcowe, gdy wykryje niekorzystny podział danych.</li>
                <li><strong>Złożoność pamięciowa</strong> tego algorytmu wymaga $O(\log n)$ dodatkowej pamięci, głównie na stos rekurencji, co czyni go efektywnym pod względem użycia zasobów pamięci.</li>
            </ul>
            <p><strong>Dostosowywanie Kryterium Sortowania:</strong></p>
            <p>Możemy dostarczyć własną funkcję porównującą, aby zmienić domyślne kryterium sortowania. Na przykład, aby posortować elementy w kolejności malejącej:</p>
            <p>
            <div>
                <pre><code class="language-clike">std::sort(wektor.begin(), wektor.end(), [](int a, int b) {
    return a &gt; b; // Sortowanie malejące
});</code></pre>
            </div>
            </p>
            <p><strong>Uwagi:</strong></p>
            <ul>
                <li><strong>Stabilność</strong> algorytmu <code>std::sort()</code> nie jest zagwarantowana, co oznacza, że kolejność równych elementów może się zmienić. W przypadku, gdy stabilność jest wymagana, należy skorzystać z funkcji <code>std::stable_sort()</code>.</li>
                <li>Typ elementów musi być <strong>zgodny</strong> z wymaganiami funkcji porównującej, co zapewnia poprawność działania algorytmu.</li>
            </ul>
            <h4 id="std-find-"><code>std::find()</code></h4>
            <p>Algorytm <code>std::find()</code> przeszukuje zakres w poszukiwaniu pierwszego wystąpienia określonej wartości. Zwraca iterator wskazujący na znaleziony element lub na koniec zakresu, jeśli element nie został znaleziony.</p>
            <p><strong>Prototyp:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">template&lt; class InputIt, class T &gt;
InputIt find( InputIt first, InputIt last, const T&amp; value );</code></pre>
            </div>
            </p>
            <ul>
                <li><code>InputIt</code>: Typ iteratora wejściowego.</li>
                <li><code>T</code>: Typ poszukiwanej wartości.</li>
            </ul>
            <p><strong>Przykład Użycia:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; wektor{8, 3, 5, 1, 2, 4, 6, 7};

    auto it = std::find(wektor.begin(), wektor.end(), 3);

    if (it != wektor.end())
        std::cout &lt;&lt; "Znaleziono element o wartości 3 na pozycji "
                  &lt;&lt; std::distance(wektor.begin(), it) &lt;&lt; "\n";
    else
        std::cout &lt;&lt; "Nie znaleziono elementu o wartości 3\n";

    return 0;
}</code></pre>
            </div>
            </p>
            <p><strong>Wyjście programu:</strong></p>
            <p>
            <div>
                <pre><code class="language-shell">Znaleziono element o wartości 3 na pozycji 1</code></pre>
            </div>
            </p>
            <p><strong>Analiza Matematyczna:</strong></p>
            <ul>
                <li><strong>Złożoność czasowa</strong> wynosi $O(n)$, gdzie n oznacza liczbę elementów w przetwarzanym zakresie, co sprawia, że algorytm działa liniowo względem liczby danych.</li>
                <li><strong>Złożoność pamięciowa</strong> wynosi $O(1)$, co oznacza, że algorytm nie wymaga dodatkowej pamięci poza tą używaną przez same dane.</li>
            </ul>
            <p><strong>Uwagi:</strong></p>
            <ul>
                <li>Algorytm przeszukuje liniowo zakres od <code>first</code> do <code>last</code>, co oznacza, że w najgorszym przypadku musi sprawdzić każdy element.</li>
                <li>Możemy użyć <code>std::find_if()</code> lub <code>std::find_if_not()</code> do przeszukiwania z warunkiem predykatu, co pozwala na bardziej elastyczne wyszukiwanie w oparciu o złożone kryteria.</li>
            </ul>
            <h4 id="std-for_each-"><code>std::for_each()</code></h4>
            <p>Funkcja <code>std::for_each()</code> stosuje podaną funkcję lub funktor do każdego elementu w zakresie. Jest to alternatywa dla pętli <code>for</code> i pozwala na bardziej funkcyjne podejście do iteracji.</p>
            <p><strong>Prototyp:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">template&lt; class InputIt, class UnaryFunction &gt;
UnaryFunction for_each( InputIt first, InputIt last, UnaryFunction f );</code></pre>
            </div>
            </p>
            <ul>
                <li><code>InputIt</code>: Typ iteratora wejściowego.</li>
                <li><code>UnaryFunction</code>: Typ funkcji lub funktora akceptującego element typu dereferowanego iteratora.</li>
            </ul>
            <p><strong>Przykład Użycia:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; wektor{8, 3, 5, 1, 2, 4, 6, 7};

    // Modyfikacja każdego elementu przez jego podwojenie
    std::for_each(wektor.begin(), wektor.end(), [](int &amp;x) { x *= 2; });

    // Wyświetlanie wyników
    std::cout &lt;&lt; "Wektor po modyfikacji: ";
    for (const auto&amp; val : wektor) {
        std::cout &lt;&lt; val &lt;&lt; " ";
    }

    return 0;
}</code></pre>
            </div>
            </p>
            <p><strong>Wyjście programu:</strong></p>
            <p>
            <div>
                <pre><code class="language-shell">Wektor po modyfikacji: 16 6 10 2 4 8 12 14</code></pre>
            </div>
            </p>
            <p><strong>Analiza Matematyczna:</strong></p>
            <ul>
                <li><strong>Złożoność czasowa</strong> wynosi <strong>O(n)</strong>, ponieważ funkcja jest wywoływana dokładnie n razy, co oznacza liniowy wzrost liczby operacji w zależności od liczby elementów.</li>
                <li><strong>Złożoność pamięciowa</strong> wynosi <strong>O(1)</strong>, gdyż algorytm nie wymaga dodatkowej pamięci poza ewentualnymi zmiennymi lokalnymi w funkcji.</li>
            </ul>
            <p><strong>Uwagi:</strong></p>
            <ul>
                <li>Funkcja <code>UnaryFunction</code> jest przekazywana przez wartość, więc jeśli potrzebujemy zachować stan między wywołaniami, należy użyć referencji lub obiektu zewnętrznego.</li>
                <li>Zwracana jest kopia funkcji <code>UnaryFunction</code> po ostatnim wywołaniu, co może być użyte do akumulacji wyników.</li>
                <li><code>std::for_each()</code> może być używany do wykonywania różnych operacji na elementach kontenera, takich jak modyfikowanie ich wartości, wyświetlanie, czy zbieranie informacji.</li>
            </ul>
            <h4 id="std-count_if-"><code>std::count_if()</code></h4>
            <p>Algorytm <code>std::count_if()</code> zlicza liczbę elementów w zakresie, dla których predykat jest spełniony.</p>
            <p><strong>Prototyp:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">template&lt; class InputIt, class UnaryPredicate &gt;
typename iterator_traits&lt;inputit&gt;::difference_type
count_if( InputIt first, InputIt last, UnaryPredicate p );</code></pre>
            </div>
            </p>
            <ul>
                <li><code>InputIt</code>: Typ iteratora wejściowego.</li>
                <li><code>UnaryPredicate</code>: Funkcja lub funktor zwracający wartość logiczną.</li>
            </ul>
            <p><strong>Przykład Użycia:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; wektor{8, 3, 5, 1, 2, 4, 6, 7};

    // Zliczanie parzystych elementów
    int parzyste = std::count_if(wektor.begin(), wektor.end(), [](int x) { return x % 2 == 0; });

    std::cout &lt;&lt; "Liczba parzystych elementów: " &lt;&lt; parzyste &lt;&lt; "\n";

    return 0;
}</code></pre>
            </div>
            </p>
            <p><strong>Wyjście programu:</strong></p>
            <p>
            <div>
                <pre><code class="language-shell">Liczba parzystych elementów: 4</code></pre>
            </div>
            </p>
            <p><strong>Analiza Matematyczna:</strong></p>
            <ul>
                <li><strong>Złożoność czasowa</strong> wynosi <strong>O(n)</strong>, ponieważ predykat jest wywoływany dokładnie n razy, co sprawia, że liczba operacji rośnie liniowo w zależności od liczby elementów.</li>
                <li><strong>Złożoność pamięciowa</strong> wynosi <strong>O(1)</strong>, co oznacza, że algorytm nie wymaga dodatkowej pamięci poza zmiennymi lokalnymi.</li>
            </ul>
            <p><strong>Uwagi:</strong></p>
            <ul>
                <li>Jeśli chcemy zliczyć wystąpienia konkretnej wartości, możemy użyć <code>std::count()</code>, co jest bardziej efektywne i czytelne w takim przypadku.</li>
                <li><code>std::count_if()</code> jest szczególnie przydatny, gdy potrzebujemy zliczyć elementy spełniające bardziej złożone warunki niż prosty równość.</li>
            </ul>
            <h4 id="inne-ważne-algorytmy">Inne Ważne Algorytmy</h4>
            <h5><code>std::accumulate()</code></h5>
            <p>Funkcja <code>std::accumulate()</code> służy do obliczenia sumy wartości w zakresie, z opcjonalnym początkowym akumulatorem i funkcją operacji.</p>
            <p><strong>Prototyp:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">template&lt; class InputIt, class T &gt;
T accumulate( InputIt first, InputIt last, T init );

template&lt; class InputIt, class T, class BinaryOperation &gt;
T accumulate( InputIt first, InputIt last, T init, BinaryOperation op );</code></pre>
            </div>
            </p>
            <p><strong>Przykład Użycia:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;numeric&gt;

int main() {
    std::vector&lt;int&gt; wektor{1, 2, 3, 4, 5};

    // Obliczenie sumy elementów
    int suma = std::accumulate(wektor.begin(), wektor.end(), 0);
    std::cout &lt;&lt; "Suma elementów: " &lt;&lt; suma &lt;&lt; "\n";

    // Obliczenie iloczynu elementów
    int iloczyn = std::accumulate(wektor.begin(), wektor.end(), 1, std::multiplies&lt;int&gt;());
    std::cout &lt;&lt; "Iloczyn elementów: " &lt;&lt; iloczyn &lt;&lt; "\n";

    return 0;
}</code></pre>
            </div>
            </p>
            <p><strong>Wyjście programu:</strong></p>
            <p>
            <div>
                <pre><code class="language-shell">Suma elementów: 15
Iloczyn elementów: 120</code></pre>
            </div>
            </p>
            <p><strong>Uwagi:</strong></p>
            <ul>
                <li><code>std::accumulate()</code> może być używany nie tylko do sumowania wartości, ale także do wykonywania bardziej złożonych operacji, takich jak obliczanie iloczynu, łączenie stringów czy budowanie innych struktur danych.</li>
                <li>Funkcja <code>BinaryOperation</code> pozwala na zdefiniowanie dowolnej operacji akumulującej, co zwiększa elastyczność <code>std::accumulate()</code>.</li>
            </ul>
            <h5><code>std::transform()</code></h5>
            <p>Funkcja <code>std::transform()</code> stosuje podaną funkcję do każdego elementu w zakresie i zapisuje wynik w innym zakresie.</p>
            <p><strong>Prototyp:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">template&lt; class InputIt, class OutputIt, class UnaryOperation &gt;
OutputIt transform( InputIt first1, InputIt last1, OutputIt d_first, UnaryOperation unary_op );

template&lt; class InputIt1, class InputIt2, class OutputIt, class BinaryOperation &gt;
OutputIt transform( InputIt1 first1, InputIt1 last1,
                   InputIt2 first2, OutputIt d_first, BinaryOperation binary_op );</code></pre>
            </div>
            </p>
            <p><strong>Przykład Użycia:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; wektor{1, 2, 3, 4, 5};
    std::vector&lt;int&gt; wyniki(wektor.size());

    // Stosowanie funkcji lambda do podwojenia każdego elementu
    std::transform(wektor.begin(), wektor.end(), wyniki.begin(), [](int x) { return x * 2; });

    // Wyświetlanie wyników
    std::cout &lt;&lt; "Wyniki po transformacji: ";
    for (const auto&amp; val : wyniki) {
        std::cout &lt;&lt; val &lt;&lt; " ";
    }

    return 0;
}</code></pre>
            </div>
            </p>
            <p><strong>Wyjście programu:</strong></p>
            <p>
            <div>
                <pre><code class="language-shell">Wyniki po transformacji: 2 4 6 8 10</code></pre>
            </div>
            </p>
            <p><strong>Uwagi:</strong></p>
            <ul>
                <li><code>std::transform()</code> jest niezwykle użyteczny do przekształcania danych w kontenerach, bez konieczności tworzenia dodatkowych pętli czy tymczasowych zmiennych.</li>
                <li>Może być używany zarówno do jednoczesnego przetwarzania jednego, jak i dwóch zakresów, co pozwala na tworzenie bardziej złożonych operacji przekształcania danych.</li>
            </ul>
            <h4 id="kompatybilność-z-iteratorami">Kompatybilność z Iteratorami</h4>
            <p>Algorytmy STL są zaprojektowane tak, aby działać z różnymi kategoriami iteratorów, co zapewnia ich szeroką kompatybilność z różnymi typami kontenerów. Poniżej przedstawiono, które kategorie iteratorów są obsługiwane przez poszczególne klasy algorytmów:</p>
            <p>
            <table>
                <tr>
                    <td>Kategoria</td>
                    <td>Przykłady Algorytmów</td>
                </tr>
                <tr>
                    <td>Iteratory wejściowe</td>
                    <td><code>std::find</code>, <code>std::count_if</code></td>
                </tr>
                <tr>
                    <td>Iteratory wyjściowe</td>
                    <td><code>std::copy</code>, <code>std::fill</code></td>
                </tr>
                <tr>
                    <td>Iteratory jedno kierunkowe</td>
                    <td><code>std::for_each</code>, <code>std::remove</code></td>
                </tr>
                <tr>
                    <td>Iteratory dwukierunkowe</td>
                    <td><code>std::reverse</code>, <code>std::rotate</code></td>
                </tr>
                <tr>
                    <td>Iteratory losowego dostępu</td>
                    <td><code>std::sort</code>, <code>std::nth_element</code></td>
                </tr>
            </table>
            </p>
            <p><strong>Przykładowa Implementacja:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;

int main() {
    std::vector&lt;int&gt; wektor{1, 2, 3, 4, 5};

    // Użycie std::for_each z iteratorami jedno kierunkowymi
    std::for_each(wektor.begin(), wektor.end(), [](int &amp;x) { x += 10; });

    // Użycie std::find z iteratorami wejściowymi
    auto it = std::find(wektor.begin(), wektor.end(), 13);
    if (it != wektor.end())
        std::cout &lt;&lt; "Znaleziono element: " &lt;&lt; *it &lt;&lt; "\n";
    else
        std::cout &lt;&lt; "Element nie został znaleziony.\n";

    // Użycie std::sort z iteratorami losowego dostępu
    std::vector&lt;int&gt; wektor2 = {5, 3, 1, 4, 2};
    std::sort(wektor2.begin(), wektor2.end());

    std::cout &lt;&lt; "Posortowany wektor2: ";
    for (const auto&amp; val : wektor2) {
        std::cout &lt;&lt; val &lt;&lt; " ";
    }

    return 0;
}</code></pre>
            </div>
            </p>
            <p><strong>Wyjście programu:</strong></p>
            <p>
            <div>
                <pre><code class="language-shell">Znaleziono element: 13
Posortowany wektor2: 1 2 3 4 5</code></pre>
            </div>
            </p>
            <h4 id="zastosowanie-algorytmów-w-praktyce">Zastosowanie Algorytmów w Praktyce</h4>
            <p>Algorytmy STL pozwalają na pisanie kodu o wysokim poziomie abstrakcji, co zwiększa czytelność i redukuje ryzyko błędów. Dzięki generyczności i wykorzystaniu szablonów, algorytmy te są niezwykle elastyczne i mogą być stosowane w szerokim zakresie zastosowań.</p>
            <p><strong>Przykład: Analiza Danych Finansowych</strong></p>
            <p>Załóżmy, że mamy wektor reprezentujący dzienne zmiany cen akcji i chcemy przeprowadzić analizę:</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;

int main() {
    std::vector&lt;double&gt; zmianyCen = { -0.5, 1.2, 0.3, -0.7, 0.8, -1.0, 0.6 };

    // Obliczenie sumarycznej zmiany cen
    double sumaZmian = std::accumulate(zmianyCen.begin(), zmianyCen.end(), 0.0);

    // Zliczenie dni ze wzrostem cen
    int dniWzrostu = std::count_if(zmianyCen.begin(), zmianyCen.end(), [](double x) { return x &gt; 0; });

    // Znalezienie największego spadku
    auto it = std::min_element(zmianyCen.begin(), zmianyCen.end());

    // Wyświetlenie wyników
    std::cout &lt;&lt; "Sumaryczna zmiana cen: " &lt;&lt; sumaZmian &lt;&lt; "\n";
    std::cout &lt;&lt; "Liczba dni ze wzrostem cen: " &lt;&lt; dniWzrostu &lt;&lt; "\n";
    std::cout &lt;&lt; "Największy spadek: " &lt;&lt; *it &lt;&lt; "\n";

    return 0;
}</code></pre>
            </div>
            </p>
            <p><strong>Wyjście programu:</strong></p>
            <p>
            <div>
                <pre><code class="language-shell">Sumaryczna zmiana cen: -0.3
Liczba dni ze wzrostem cen: 4
Największy spadek: -1</code></pre>
            </div>
            </p>
            <p>W tym przykładzie wykorzystujemy różne algorytmy STL do przeprowadzenia analizy danych finansowych:
                - <code>std::accumulate()</code> oblicza sumę wszystkich zmian cen.
                - <code>std::count_if()</code> zlicza liczbę dni, w których cena wzrosła.
                - <code>std::min_element()</code> znajduje największy spadek w cenach.</p>
            <h4 id="optymalizacja-za-pomocą-algorytmów">Optymalizacja za Pomocą Algorytmów</h4>
            <p>Korzystanie z algorytmów STL może prowadzić do bardziej wydajnego kodu, ponieważ są one zazwyczaj dobrze zoptymalizowane i wykorzystują najlepsze praktyki implementacyjne. Ponadto, kompilatory mogą dokonywać dodatkowych optymalizacji, gdy używane są standardowe algorytmy.</p>
            <p><strong>Przykład: Porównanie z Pętlą <code>for</code></strong></p>
            <p>Rozważmy zliczanie elementów spełniających określony warunek:</p>
            <p><strong>Tradycyjna pętla <code>for</code>:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">int licznik = 0;
for (size_t i = 0; i &lt; wektor.size(); ++i) {
    if (wektor[i] % 2 == 0) {
        ++licznik;
    }
}</code></pre>
            </div>
            </p>
            <p><strong>Użycie <code>std::count_if()</code>:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">int licznik = std::count_if(wektor.begin(), wektor.end(), [](int x) { return x % 2 == 0; });</code></pre>
            </div>
            </p>
            <p><strong>Porównanie:</strong></p>
            <p>Korzystanie z <code>std::count_if()</code> nie tylko skraca kod, ale również zwiększa jego czytelność i potencjalnie wydajność. Algorytm STL może być zoptymalizowany lepiej niż ręcznie napisane pętle, a dodatkowo kod staje się bardziej zwięzły i łatwy do zrozumienia.</p>
        </section>
        <div id="table-of-contents">
            <h2>Spis Treści</h2>
            <ol><a href="#stl-standard-template-library-">STL (Standard Template Library)</a>
                <ol>
                    <li><a href="#główne-komponenty-biblioteki-stl">Główne komponenty biblioteki STL</a></li>
                    <li><a href="#kolekcje-w-stl">Kolekcje w STL</a>
                        <ol>
                            <li><a href="#vector">vector</a></li>
                            <li><a href="#list">list</a></li>
                            <li><a href="#map">map</a></li>
                            <li><a href="#unordered_map">unordered_map</a></li>
                            <li><a href="#set">set</a></li>
                            <li><a href="#unordered_set">unordered_set</a></li>
                            <li><a href="#priority_queue">priority_queue</a></li>
                            <li><a href="#queue">queue</a></li>
                            <li><a href="#stack">stack</a></li>
                        </ol>
                    </li>
                    <li><a href="#iteratory">Iteratory</a>
                        <ol>
                            <li><a href="#rodzaje-iteratorów">Rodzaje iteratorów</a></li>
                            <li><a href="#podstawowe-operacje-na-iteratorach">Podstawowe operacje na iteratorach</a></li>
                            <li><a href="#przykład-użycia-iteratora">Przykład użycia iteratora</a></li>
                        </ol>
                    </li>
                    <li><a href="#algorytmy-w-standardowej-bibliotece-c-stl-">Algorytmy w Standardowej Bibliotece C++ (STL)</a>
                        <ol>
                            <li><a href="#wprowadzenie-do-algorytmów-stl">Wprowadzenie do Algorytmów STL</a></li>
                            <li><a href="#klasyfikacja-algorytmów">Klasyfikacja Algorytmów</a></li>
                            <li><a href="#std-sort-">std::sort()</a></li>
                            <li><a href="#std-find-">std::find()</a></li>
                            <li><a href="#std-for_each-">std::for_each()</a></li>
                            <li><a href="#std-count_if-">std::count_if()</a></li>
                            <li><a href="#inne-ważne-algorytmy">Inne Ważne Algorytmy</a></li>
                            <li><a href="#kompatybilność-z-iteratorami">Kompatybilność z Iteratorami</a></li>
                            <li><a href="#zastosowanie-algorytmów-w-praktyce">Zastosowanie Algorytmów w Praktyce</a></li>
                            <li><a href="#optymalizacja-za-pomocą-algorytmów">Optymalizacja za Pomocą Algorytmów</a></li>
                        </ol>
                    </li>
                </ol>
            </ol>
            <div id="related-articles">
                <h2>Related Articles</h2>
                <ol>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/01_proces_kompilacji.html">Proces Kompilacji</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/02_preprocesor.html">Preprocesor</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/03_zmienne_i_typy_danych.html">Zmienne i Typy Danych</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/04_interakcja_z_konsola.html">Interakcja z Konsola</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/05_instrukcja_warunkowa.html">Instrukcja Warunkowa</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/06_petle.html">Petle</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/07_liczby_losowe.html">Liczby Losowe</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/08_typ_wyliczeniowy.html">Typ Wyliczeniowy</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/09_funkcje.html">Funkcje</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/10_l_wartosci_r_wartosci.html">L Wartosci R Wartosci</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/11_wskazniki.html">Wskazniki</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/12_tablice.html">Tablice</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/13_napisy.html">Napisy</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/14_operacje_bitowe.html">Operacje Bitowe</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/15_programowanie_obietkowe.html">Programowanie Obietkowe</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/16_dziedziczenie.html">Dziedziczenie</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/17_zaawansowane_wskazniki.html">Zaawansowane Wskazniki</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/18_przeciazanie.html">Przeciazanie</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/19_konwersje.html">Konwersje</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/20_lambdy.html">Lambdy</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/21_szablony.html">Szablony</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/22_wyjatki.html">Wyjatki</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/23_stl.html">Stl</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/24_praca_z_plikami.html">Praca z Plikami</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/25_c_vs_cpp.html">C vs Cpp</a></li>
                </ol>
            </div>
        </div>
    </div>
    <footer>
        <div class="footer-columns">
            <div class="footer-column">
                <img alt="Adam Djellouli Symbol" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/symbol.png" />
            </div>
            <div class="footer-column">
                <h2><a href="https://adamdjellouli.com/core/privacy_policy.html" title="Privacy Policy">Our Privacy Policy</a></h2>
                <p>Thank you for visiting my personal website. All content here is free to use, but please remember to be respectful and avoid any misuse of the site. If you’d like to get in touch, feel free to reach out via my <a href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" title="LinkedIn Profile">LinkedIn profile</a> or connect with me on <a href="https://github.com/djeada" title="GitHub Profile">GitHub</a> if you have technical questions or ideas to share. Wishing you all the best and a fantastic life ahead!</p>
            </div>
            <div class="footer-column">
                <h2>Follow me</h2>
                <ul class="social-media">
                    <li>
                        <a class="fa fa-youtube" href="https://www.youtube.com/channel/UCGPoHTVjMN77wcGknXPHl1Q" target="_blank" title="YouTube">
                        </a>YouTube
                    </li>
                    <li>
                        <a class="fa fa-linkedin" href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" target="_blank" title="LinkedIn">
                        </a>LinkedIn
                    </li>
                    <li>
                        <a class="fa fa-instagram" href="https://www.instagram.com/linuxchallenges/" target="_blank" title="Instagram">
                        </a>Instagram
                    </li>
                    <li>
                        <a class="fa fa-github" href="https://github.com/djeada" title="GitHub">
                        </a>Github
                    </li>
                </ul>
            </div>
        </div>
        <div>
            <p id="copyright">
                © Adam Djellouli. All rights reserved.
            </p>
        </div>
        <script>
            document.getElementById("copyright").innerHTML = "&copy; " + new Date().getFullYear() + " Adam Djellouli. All rights reserved.";
        </script>
        <script src="../../app.js"></script>
    </footer>
    <div id="pdf-spinner-overlay">
        <div class="spinner"></div>
    </div>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-bash.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-cpp.min.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
jax: ["input/TeX", "output/HTML-CSS"],
extensions: ["tex2jax.js"],
"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] },
tex2jax: { inlineMath: [ ["$", "$"] ], displayMath: [ ["$$","$$"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
TeX: { noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } } },
messageStyle: "none"
});
</script>
<script async="" id="MathJax-script" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>

</html>