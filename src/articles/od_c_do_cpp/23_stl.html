<!DOCTYPE html>

<html lang="pl">

<head>
    <script async="" crossorigin="anonymous" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5593122079896089"></script>
    <meta charset="utf-8" />
    <title>STL (Standard Template Library)</title>
    <meta content="STL to biblioteka szablon贸w w jzyku C++, kt贸ra dostarcza gotowych do u偶ycia implementacji wielu funkcji, algorytm贸w i struktur danych." name="description" />
    <meta content="Adam Djellouli" name="author" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <meta content="IE=edge" http-equiv="X-UA-Compatible" />
    <link crossorigin="" href="https://fonts.googleapis.com" rel="preconnect" />
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/icon.ico" rel="icon" />
    <link href="../../resources/style.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />
</head>

<body>
    <nav aria-label="Main navigation">
        <a class="logo" href="https://adamdjellouli.com">
            <img alt="Adam Djellouli - Home Page Logo" id="logo-image" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/logo.PNG" />
        </a>
        <input aria-label="Toggle navigation menu" id="navbar-toggle" type="checkbox" />
        <ul aria-labelledby="navbar-toggle" role="menu">
            <li role="menuitem">
                <a href="../../index.html" title="Go to Home Page"> Home </a>
            </li>
            <li role="menuitem">
                <a class="active" href="../../core/blog.html" title="Read Adam Djellouli Blog on Programming and Technology"> Blog </a>
            </li>
            <li role="menuitem">
                <a href="../../core/tools.html" title="Discover Tools Created by Adam Djellouli"> Tools </a>
            </li>
            <li role="menuitem">
                <a href="../../core/projects.html" title="Explore Projects Developed by Adam Djellouli"> Projects </a>
            </li>
            <li role="menuitem">
                <a href="../../core/resume.html" title="View Adam Djellouli Professional Resume"> Resume </a>
            </li>
            <li>
                <script async="" src="https://cse.google.com/cse.js?cx=8160ef9bb935f4f68"></script>
                <div class="gcse-search"></div>
            </li>
            <li>
                <button aria-label="Toggle dark mode" id="dark-mode-button"></button>
            </li>
        </ul>
    </nav>
    <div id="article-wrapper">
        <section id="article-body">
            <p style="text-align: right;"><i>Last modified: June 15, 2024</i></p>
            <p style="text-align: right;"><i>This article is written in: 叼</i></p>
            <h2 id="stl-standard-template-library-">STL (Standard Template Library)</h2>
            <p>STL to biblioteka szablon贸w w jzyku C++, kt贸ra dostarcza gotowych do u偶ycia implementacji wielu funkcji, algorytm贸w i struktur danych. Najwa偶niejsze komponenty biblioteki STL to:</p>
            <ul>
                <li><code>vector</code></li>
                <li><code>list</code></li>
                <li><code>map</code></li>
                <li><code>set</code></li>
                <li><code>queue</code></li>
                <li><code>stack</code></li>
                <li><code>algorithm</code></li>
                <li><code>iterator</code></li>
                <li><code>memory</code></li>
            </ul>
            <h3 id="kolekcje-w-stl">Kolekcje w STL</h3>
            <p>Kolekcje w STL to zbiory implementacji struktur danych wraz z funkcjami operujcymi na tych strukturach.</p>
            <h3 id="stl-standard-template-library-">STL (Standard Template Library)</h3>
            <p>STL to biblioteka szablon贸w w jzyku C++, kt贸ra dostarcza gotowych do u偶ycia implementacji wielu funkcji, algorytm贸w i struktur danych. Najwa偶niejsze komponenty biblioteki STL to:</p>
            <ul>
                <li><code>vector</code></li>
                <li><code>list</code></li>
                <li><code>map</code></li>
                <li><code>set</code></li>
                <li><code>unordered_map</code></li>
                <li><code>unordered_set</code></li>
                <li><code>priority_queue</code></li>
                <li><code>queue</code></li>
                <li><code>stack</code></li>
                <li><code>algorithm</code></li>
                <li><code>iterator</code></li>
                <li><code>memory</code></li>
            </ul>
            <p>Dodanie kolumny "Zo偶ono czasowa" do ka偶dej tabeli mo偶e pom贸c lepiej zrozumie wydajno r贸偶nych operacji. Oto zaktualizowane tabele:</p>
            <h3 id="kolekcje-w-stl">Kolekcje w STL</h3>
            <p>Kolekcje w STL to zbiory implementacji struktur danych wraz z funkcjami operujcymi na tych strukturach.</p>
            <h4 id="vector"><strong>vector</strong></h4>
            <p><code>vector</code> to dynamiczna tablica, kt贸ra mo偶e zmienia sw贸j rozmiar. Jest jednym z najczciej u偶ywanych kontener贸w w STL.</p>
            <p>Operacje:</p>
            <p>
            <table>
                <tr>
                    <td>Metoda</td>
                    <td>Opis</td>
                    <td>Przykad u偶ycia</td>
                    <td>Zo偶ono czasowa</td>
                </tr>
                <tr>
                    <td><code>push_back(value)</code></td>
                    <td>Dodaje element na kocu</td>
                    <td><code>vec.push_back(10);</code></td>
                    <td>Amortyzowane O(1)</td>
                </tr>
                <tr>
                    <td><code>pop_back()</code></td>
                    <td>Usuwa element z koca</td>
                    <td><code>vec.pop_back();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>size()</code></td>
                    <td>Zwraca liczb element贸w</td>
                    <td><code>auto s = vec.size();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>empty()</code></td>
                    <td>Sprawdza, czy kontener jest pusty</td>
                    <td><code>if (vec.empty()) {}</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>clear()</code></td>
                    <td>Usuwa wszystkie elementy</td>
                    <td><code>vec.clear();</code></td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><code>insert(pos, value)</code></td>
                    <td>Wstawia element na podanej pozycji</td>
                    <td><code>vec.insert(vec.begin() + 1, 20);</code></td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><code>erase(pos)</code></td>
                    <td>Usuwa element z podanej pozycji</td>
                    <td><code>vec.erase(vec.begin() + 1);</code></td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><code>at(index)</code></td>
                    <td>Zwraca referencj do elementu na podanym indeksie</td>
                    <td><code>int val = vec.at(2);</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>operator[]</code></td>
                    <td>Zwraca referencj do elementu na podanym indeksie</td>
                    <td><code>int val = vec[2];</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>front()</code></td>
                    <td>Zwraca referencj do pierwszego elementu</td>
                    <td><code>int val = vec.front();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>back()</code></td>
                    <td>Zwraca referencj do ostatniego elementu</td>
                    <td><code>int val = vec.back();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>begin()</code></td>
                    <td>Zwraca iterator na pocztek</td>
                    <td><code>auto it = vec.begin();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>end()</code></td>
                    <td>Zwraca iterator na koniec</td>
                    <td><code>auto it = vec.end();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>reserve(n)</code></td>
                    <td>Rezerwuje miejsce na n element贸w</td>
                    <td><code>vec.reserve(100);</code></td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><code>resize(n)</code></td>
                    <td>Zmienia rozmiar wektora</td>
                    <td><code>vec.resize(10);</code></td>
                    <td>O(n)</td>
                </tr>
            </table>
            </p>
            <p>Przykad:</p>
            <p>
            <div>
                <pre><code class="language-clike">std::vector&lt;int&gt; vec = {1, 2, 3};
vec.push_back(4);
vec.insert(vec.begin() + 1, 10);
for(auto it = vec.begin(); it != vec.end(); ++it) {
std::cout &lt;&lt; *it &lt;&lt; " ";
}</code></pre>
            </div>
            </p>
            <h4 id="list"><strong>list</strong></h4>
            <p><code>list</code> to dwukierunkowa lista wizana, kt贸ra umo偶liwia szybkie wstawianie i usuwanie element贸w.</p>
            <p>Operacje:</p>
            <p>| Metoda | Opis | Przykad u偶ycia | Zo偶ono czasowa |
                |----------------------|----------------------------------------------|-----------------------------------------------------------|-----------------------|
                | <code>push_back(value)</code> | Dodaje element na kocu | <code>lst.push_back(10);</code> | O(1) |
                | <code>push_front(value)</code> | Dodaje element na pocztku | <code>lst.push_front(5);</code> | O(1) |
                | <code>pop_back()</code> | Usuwa element z koca | <code>lst.pop_back();</code> | O(1) |
                | <code>pop_front()</code> | Usuwa element z pocztku | <code>lst.pop_front();</code> | O(1) |
                | <code>size()</code> | Zwraca liczb element贸w | <code>auto s = lst.size();</code> | O(1) |
                | <code>empty()</code> | Sprawdza, czy kontener jest pusty | <code>if (lst.empty()) {}</code> | O(1) |
                | <code>clear()</code> | Usuwa wszystkie elementy | <code>lst.clear();</code> | O(n) |
                | <code>insert(pos, value)</code> | Wstawia element na podanej pozycji | <code>lst.insert(++lst.begin(), 20);</code> | O(1) |
                | <code>erase(pos)</code> | Usuwa element z podanej pozycji | <code>lst.erase(++lst.begin());</code> | O(1) |
                | <code>front()</code> | Zwraca referencj do pierwszego elementu | <code>int val = lst.front();</code> | O(1) |
                | <code>back()</code> | Zwraca referencj do ostatniego elementu | <code>int val = lst.back();</code> | O(1) |
                | <code>begin()</code> | Zwraca iterator na pocztek | <code>auto it = lst.begin();</code> | O(1) |
                | <code>end()</code> | Zwraca iterator na koniec | <code>auto it = lst.end();</code> | O(1) |</p>
            <p>Przykad:</p>
            <p>
            <div>
                <pre><code class="language-clike">std::list&lt;int&gt; lst = {1, 2, 3};
lst.push_back(4);
lst.push_front(0);
lst.insert(++lst.begin(), 10);
for(auto it = lst.begin(); it != lst.end(); ++it) {
std::cout &lt;&lt; *it &lt;&lt; " ";
}</code></pre>
            </div>
            </p>
            <h4 id="map"><strong>map</strong></h4>
            <p><code>map</code> to kontener asocjacyjny, kt贸ry przechowuje pary klucz-warto w uporzdkowanej formie, wykorzystujc drzewo czerwono-czarne.</p>
            <p>Operacje:</p>
            <p>
            <table>
                <tr>
                    <td>Metoda</td>
                    <td>Opis</td>
                    <td>Przykad u偶ycia</td>
                    <td>Zo偶ono czasowa</td>
                </tr>
                <tr>
                    <td><code>insert({key, value})</code></td>
                    <td>Wstawia par klucz-warto</td>
                    <td><code>mp.insert({1, "one"});</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>erase(key)</code></td>
                    <td>Usuwa element o podanym kluczu</td>
                    <td><code>mp.erase(1);</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>find(key)</code></td>
                    <td>Zwraca iterator na element o podanym kluczu</td>
                    <td><code>auto it = mp.find(1);</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>size()</code></td>
                    <td>Zwraca liczb element贸w</td>
                    <td><code>auto s = mp.size();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>empty()</code></td>
                    <td>Sprawdza, czy kontener jest pusty</td>
                    <td><code>if (mp.empty()) {}</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>clear()</code></td>
                    <td>Usuwa wszystkie elementy</td>
                    <td><code>mp.clear();</code></td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><code>operator[]</code></td>
                    <td>Zwraca referencj do wartoci o podanym kluczu</td>
                    <td><code>std::string val = mp[1];</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>begin()</code></td>
                    <td>Zwraca iterator na pocztek</td>
                    <td><code>auto it = mp.begin();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>end()</code></td>
                    <td>Zwraca iterator na koniec</td>
                    <td><code>auto it = mp.end();</code></td>
                    <td>O(1)</td>
                </tr>
            </table>
            </p>
            <p>Przykad:</p>
            <p>
            <div>
                <pre><code class="language-clike">std::map&lt;int, std::string=""&gt; mp;
mp.insert({1, "one"});
mp[2] = "two";
mp.erase(1);
for(auto it = mp.begin(); it != mp.end(); ++it) {
std::cout &lt;&lt; it-&gt;first &lt;&lt; ": " &lt;&lt; it-&gt;second &lt;&lt; " ";
}</code></pre>
            </div>
            </p>
            <h4 id="unordered_map"><strong>unordered_map</strong></h4>
            <p><code>unordered_map</code> to kontener asocjacyjny, kt贸ry przechowuje pary klucz-warto w nieuporzdkowanej formie, wykorzystujc tablic mieszajc (hash table).</p>
            <p>Operacje:</p>
            <p>| Metoda | Opis | Przykad u偶ycia | Zo偶ono czasowa |
                |----------------------|----------------------------------------------|-----------------------------------------------------------|-----------------------|
                | <code>insert({key, value})</code>| Wstawia par klucz-warto | <code>ump.insert({1, "one"});</code> | O(1) amortyzowane |
                | <code>erase(key)</code> | Usuwa element o podanym kluczu | <code>ump.erase(1);</code> | O(1) amortyzowane |
                | <code>find(key)</code> | Zwraca iterator na element o podanym kluczu | <code>auto it = ump.find(1);</code> | O(1) amortyzowane |
                | <code>size()</code> | Zwraca liczb element贸w | <code>auto s = ump.size();</code> | O(1) |
                | <code>empty()</code> | Sprawdza, czy kontener jest pusty | <code>if (ump.empty()) {}</code> | O(1) |
                | <code>clear()</code> | Usuwa wszystkie elementy | <code>ump.clear();</code> | O(n) |
                | <code>operator[]</code> | Zwraca referencj do wartoci o podanym kluczu | <code>std::string val = ump[1];</code> | O(1) amortyzowane |
                | <code>begin()</code> | Zwraca iterator na pocztek | <code>auto it = ump.begin();</code> | O(1) |
                | <code>end()</code> | Zwraca iterator na koniec | <code>auto it = ump.end();</code> | O(1) |</p>
            <p>Przykad:</p>
            <p>
            <div>
                <pre><code class="language-clike">std::unordered_map&lt;int, std::string=""&gt; ump;
ump.insert({1, "one"});
ump[2] = "two";
ump.erase(1);
for(auto it = ump.begin(); it != ump.end(); ++it) {
std::cout &lt;&lt; it-&gt;first &lt;&lt; ": " &lt;&lt; it-&gt;second &lt;&lt; " ";
}</code></pre>
            </div>
            </p>
            <h4 id="set"><strong>set</strong></h4>
            <p><code>set</code> to kontener, kt贸ry przechowuje unikalne elementy w uporzdkowanej formie, wykorzystujc drzewo czerwono-czarne.</p>
            <p>Operacje:</p>
            <p>Oto poprawiona tabela:</p>
            <p>
            <table>
                <tr>
                    <td>Metoda</td>
                    <td>Opis</td>
                    <td>Przykad u偶ycia</td>
                    <td>Zo偶ono czasowa</td>
                </tr>
                <tr>
                    <td><code>insert(value)</code></td>
                    <td>Wstawia element</td>
                    <td><code>st.insert(10);</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>erase(value)</code></td>
                    <td>Usuwa element</td>
                    <td><code>st.erase(10);</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>find(value)</code></td>
                    <td>Zwraca iterator na element</td>
                    <td><code>auto it = st.find(10);</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>size()</code></td>
                    <td>Zwraca liczb element贸w</td>
                    <td><code>auto s = st.size();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>empty()</code></td>
                    <td>Sprawdza, czy kontener jest pusty</td>
                    <td><code>if (st.empty()) {}</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>clear()</code></td>
                    <td>Usuwa wszystkie elementy</td>
                    <td><code>st.clear();</code></td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><code>begin()</code></td>
                    <td>Zwraca iterator na pocztek</td>
                    <td><code>auto it = st.begin();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>end()</code></td>
                    <td>Zwraca iterator na koniec</td>
                    <td><code>auto it = st.end();</code></td>
                    <td>O(1)</td>
                </tr>
            </table>
            </p>
            <p>Przykad:</p>
            <p>
            <div>
                <pre><code class="language-clike">std::set&lt;int&gt; st;
st.insert(10);
st.insert(20);
st.erase(10);
for(auto it = st.begin(); it != st.end(); ++it) {
std::cout &lt;&lt; *it &lt;&lt; " ";
}</code></pre>
            </div>
            </p>
            <h4 id="unordered_set"><strong>unordered_set</strong></h4>
            <p><code>unordered_set</code> to kontener, kt贸ry przechowuje unikalne elementy w nieuporzdkowanej formie, wykorzystujc tablic mieszajc (hash table).</p>
            <p>Operacje:</p>
            <p>| Metoda | Opis | Przykad u偶ycia | Zo偶ono czasowa |
                |----------------------|----------------------------------------------|-----------------------------------------------------------|-----------------------|
                | <code>insert(value)</code> | Wstawia element | <code>ust.insert(10);</code> | O(1) amortyzowane |
                | <code>erase(value)</code> | Usuwa element | <code>ust.erase(10);</code> | O(1) amortyzowane |
                | <code>find(value)</code> | Zwraca iterator na element | <code>auto it = ust.find(10);</code> | O(1) amortyzowane |
                | <code>size()</code> | Zwraca liczb element贸w | <code>auto s = ust.size();</code> | O(1) |
                | <code>empty()</code> | Sprawdza, czy kontener jest pusty | <code>if (ust.empty()) {}</code> | O(1) |
                | <code>clear()</code> | Usuwa wszystkie elementy | <code>ust.clear();</code> | O(n) |
                | <code>begin()</code> | Zwraca iterator na pocztek | <code>auto it = ust.begin();</code> | O(1) |
                | <code>end()</code> | Zwraca iterator na koniec | <code>auto it = ust.end();</code> | O(1) |</p>
            <p>Przykad:</p>
            <p>
            <div>
                <pre><code class="language-clike">std::unordered_set&lt;int&gt; ust;
ust.insert(10);
ust.insert(20);
ust.erase(10);
for(auto it = ust.begin(); it != ust.end(); ++it) {
std::cout &lt;&lt; *it &lt;&lt; " ";
}</code></pre>
            </div>
            </p>
            <h4 id="priority_queue"><strong>priority_queue</strong></h4>
            <p><code>priority_queue</code> to kontener, kt贸ry implementuje kopiec binarny i pozwala na szybkie wyciganie najwikszego (lub najmniejszego) elementu.</p>
            <p>Operacje:</p>
            <p>
            <table>
                <tr>
                    <td>Metoda</td>
                    <td>Opis</td>
                    <td>Przykad u偶ycia</td>
                    <td>Zo偶ono czasowa</td>
                </tr>
                <tr>
                    <td><code>push(value)</code></td>
                    <td>Dodaje element</td>
                    <td><code>pq.push(10);</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>pop()</code></td>
                    <td>Usuwa najwikszy element</td>
                    <td><code>pq.pop();</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>top()</code></td>
                    <td>Zwraca referencj do najwikszego elementu</td>
                    <td><code>int val = pq.top();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>size()</code></td>
                    <td>Zwraca liczb element贸w</td>
                    <td><code>auto s = pq.size();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>empty()</code></td>
                    <td>Sprawdza, czy kontener jest pusty</td>
                    <td><code>if (pq.empty()) {}</code></td>
                    <td>O(1)</td>
                </tr>
            </table>
            </p>
            <p>Przykad:</p>
            <p>
            <div>
                <pre><code class="language-clike">std::priority_queue&lt;int&gt; pq;
pq.push(10);
pq.push(20);
pq.push(5);
std::cout &lt;&lt; pq.top() &lt;&lt; " "; // wywietli 20
pq.pop();
std::cout &lt;&lt; pq.top() &lt;&lt; " "; // wywietli 10</code></pre>
            </div>
            </p>
            <h4 id="queue"><strong>queue</strong></h4>
            <p><code>queue</code> to kontener, kt贸ry implementuje kolejk FIFO (First In, First Out).</p>
            <p>Operacje:</p>
            <p>| Metoda | Opis | Przykad u偶ycia | Zo偶ono czasowa |
                |----------------------|----------------------------------------------|-----------------------------------------------------------|-----------------------|
                | <code>push(value)</code> | Dodaje element | <code>q.push(10);</code> | O(1) |
                | <code>pop()</code> | Usuwa element z pocztku | <code>q.pop();</code> | O(1) |
                | <code>front()</code> | Zwraca referencj do pierwszego elementu | <code>int val = q.front();</code> | O(1) |
                | <code>back()</code> | Zwraca referencj do ostatniego elementu | <code>int val = q.back();</code> | O(1) |
                | <code>size()</code> | Zwraca liczb element贸w | <code>auto s = q.size();</code> | O(1) |
                | <code>empty()</code> | Sprawdza, czy kontener jest pusty | <code>if (q.empty()) {}</code> | O(1) |</p>
            <p>Przykad:</p>
            <p>
            <div>
                <pre><code class="language-clike">std::queue&lt;int&gt; q;
q.push(10);
q.push(20);
std::cout &lt;&lt; q.front() &lt;&lt; " "; // wywietli 10
q.pop();
std::cout &lt;&lt; q.front() &lt;&lt; " "; // wywietli 20</code></pre>
            </div>
            </p>
            <h4 id="stack"><strong>stack</strong></h4>
            <p><code>stack</code> to kontener, kt贸ry implementuje stos LIFO (Last In, First Out).</p>
            <p>Operacje:</p>
            <p>
            <table>
                <tr>
                    <td>Metoda</td>
                    <td>Opis</td>
                    <td>Przykad u偶ycia</td>
                    <td>Zo偶ono czasowa</td>
                </tr>
                <tr>
                    <td><code>push(value)</code></td>
                    <td>Dodaje element</td>
                    <td><code>st.push(10);</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>pop()</code></td>
                    <td>Usuwa element z koca</td>
                    <td><code>st.pop();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>top()</code></td>
                    <td>Zwraca referencj do ostatniego elementu</td>
                    <td><code>int val = st.top();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>size()</code></td>
                    <td>Zwraca liczb element贸w</td>
                    <td><code>auto s = st.size();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>empty()</code></td>
                    <td>Sprawdza, czy kontener jest pusty</td>
                    <td><code>if (st.empty()) {}</code></td>
                    <td>O(1)</td>
                </tr>
            </table>
            </p>
            <p>Przykad:</p>
            <p>
            <div>
                <pre><code class="language-clike">std::stack&lt;int&gt; st;
st.push(10);
st.push(20);
std::cout &lt;&lt; st.top() &lt;&lt; " "; // wywietli 20
st.pop();
std::cout &lt;&lt; st.top() &lt;&lt; " "; // wywietli 10</code></pre>
            </div>
            </p>
            <h3 id="iteratory">Iteratory</h3>
            <p>Iteratory w jzyku C++ to obiekty umo偶liwiajce sekwencyjny dostp do element贸w kontener贸w. Dziki nim mo偶liwe jest jednolite przegldanie zawartoci r贸偶nych typ贸w kolekcji, niezale偶nie od ich wewntrznej implementacji. Iteratory peni podobn rol do wska藕nik贸w, ale s bardziej elastyczne i bezpieczne w u偶yciu.</p>
            <h4 id="rodzaje-iterator贸w">Rodzaje iterator贸w</h4>
            <ol>
                <li><strong>Input Iterator</strong>: Su偶y do odczytu danych z kontenera.</li>
                <li><strong>Output Iterator</strong>: Su偶y do zapisu danych do kontenera.</li>
                <li><strong>Forward Iterator</strong>: czy mo偶liwoci iterator贸w input i output, mo偶e przemieszcza si tylko do przodu.</li>
                <li><strong>Bidirectional Iterator</strong>: Umo偶liwia przemieszczanie si zar贸wno do przodu, jak i do tyu.</li>
                <li><strong>Random Access Iterator</strong>: Oferuje wszystkie mo偶liwoci Bidirectional Iterator oraz umo偶liwia dostp do dowolnego elementu kontenera w staym czasie.</li>
            </ol>
            <h4 id="podstawowe-operacje-na-iteratorach">Podstawowe operacje na iteratorach</h4>
            <ul>
                <li>Inicjalizacja iteratora pocztkowym elementem kontenera: <code>kontener.begin()</code></li>
                <li>Inicjalizacja iteratora elementem za ostatnim w kontenerze: <code>kontener.end()</code></li>
                <li>Odwoanie do elementu, na kt贸ry wskazuje iterator: <code>*it</code></li>
                <li>Przesunicie iteratora do nastpnego elementu: <code>++it</code></li>
                <li>Przesunicie iteratora do poprzedniego elementu: <code>--it</code> (dla Bidirectional Iterator)</li>
                <li>Przesunicie iteratora o okrelon liczb pozycji: <code>it += n</code> lub <code>it -= n</code> (dla Random Access Iterator)</li>
                <li>Wstawienie elementu w miejscu wskazywanym przez iterator: <code>it = kontener.insert(it, warto)</code></li>
                <li>Usunicie elementu w miejscu wskazywanym przez iterator: <code>it = kontener.erase(it)</code></li>
            </ul>
            <h4 id="przykad-u偶ycia-iteratora">Przykad u偶ycia iteratora</h4>
            <p>Poni偶szy przykad ilustruje operacje na wektorze <code>std::vector</code> typu <code>std::string</code>. Najpierw tworzy i inicjalizuje wektor trzema elementami: "ala", "ma", "kota", a nastpnie wywietla jego zawarto za pomoc iteratora. Nastpnie dodaje nowy element "nie" przed drugim elementem wektora, czyli przed "ma". Po tym usuwa pierwszy element wektora, kt贸rym jest "ala". Na koniec, program ponownie wywietla zmodyfikowan zawarto wektora.</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;std::string&gt; v = {"ala", "ma", "kota"};

    // Wywietlenie zawartoci wektora przy u偶yciu iteratora
    for (auto it = v.begin(); it != v.end(); ++it) {
        std::cout &lt;&lt; *it &lt;&lt; std::endl;
    }

    // Dodanie nowego elementu przed "ma"
    auto it = v.begin() + 1;
    v.insert(it, "nie");

    // Usunicie sowa "ala"
    it = v.begin();
    v.erase(it);

    std::cout &lt;&lt; "\nPo modyfikacjach:\n";
    for (const auto&amp; word : v) {
        std::cout &lt;&lt; word &lt;&lt; std::endl;
    }

    return 0;
}</code></pre>
            </div>
            </p>
            <p>Warto pamita, 偶e po niekt贸rych operacjach, takich jak insert czy erase, u偶ywane wczeniej iteratory mog sta si nieaktualne i ich dalsze u偶ycie mo偶e prowadzi do niezdefiniowanego zachowania programu.</p>
            <h3 id="algorytmy">Algorytmy</h3>
            <p>Biblioteka <code>algorithm</code> dostarcza bogaty zestaw funkcji, kt贸re su偶 do manipulacji i analizy kolekcji. Oto kilka przykad贸w najbardziej popularnych algorytm贸w z tej biblioteki:</p>
            <h4 id="sort-">sort()</h4>
            <p>Funkcja <code>sort()</code> su偶y do sortowania element贸w kolekcji. Jej podstawowe u偶ycie polega na przekazaniu dw贸ch iterator贸w: pocztkowego i kocowego, okrelajcych zakres sortowania.</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; wektor{8, 3, 5, 1, 2, 4, 6, 7};
    auto kopia = wektor;

    std::sort(wektor.begin(), wektor.begin() + 3); // posortowane zostan pierwsze 3 elementy
    std::sort(kopia.begin(), kopia.end());         // posortowane zostan wszystkie elementy

    for (const auto&amp; val : wektor) {
        std::cout &lt;&lt; val &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;

    for (const auto&amp; val : kopia) {
        std::cout &lt;&lt; val &lt;&lt; " ";
    }

    return 0;
}</code></pre>
            </div>
            </p>
            <h4 id="find-">find()</h4>
            <p>Algorytm <code>find()</code> przeszukuje kolekcj w poszukiwaniu okrelonego elementu i zwraca iterator wskazujcy na pierwsze wystpienie tego elementu.</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; wektor{8, 3, 5, 1, 2, 4, 6, 7};

    auto it = std::find(wektor.begin(), wektor.end(), 3);

    if (it != wektor.end())
        std::cout &lt;&lt; "Znaleziono element o wartoci 3 na pozycji " &lt;&lt; std::distance(wektor.begin(), it) &lt;&lt; std::endl;
    else
        std::cout &lt;&lt; "Nie znaleziono elementu o wartoci 3" &lt;&lt; std::endl;

    return 0;
}</code></pre>
            </div>
            </p>
            <h4 id="for_each-">for_each()</h4>
            <p>Funkcja <code>for_each()</code> pozwala na wykonanie okrelonej operacji na ka偶dym elemencie kolekcji. Operacja ta jest okrelana za pomoc funkcji lub wyra偶enia lambda.</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; wektor{8, 3, 5, 1, 2, 4, 6, 7};
    std::for_each(wektor.begin(), wektor.end(), [](int &amp;x) { x *= 2; });

    for (const auto&amp; val : wektor) {
        std::cout &lt;&lt; val &lt;&lt; " ";
    }

    return 0;
}</code></pre>
            </div>
            </p>
            <h4 id="count_if-">count_if()</h4>
            <p>Algorytm <code>count_if()</code> pozwala zliczy, ile razy speniony jest okrelony warunek w kolekcji.</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; wektor{8, 3, 5, 1, 2, 4, 6, 7};
    int parzyste = std::count_if(wektor.begin(), wektor.end(), [](int x) { return x % 2 == 0; });

    std::cout &lt;&lt; "Liczba parzystych element贸w: " &lt;&lt; parzyste &lt;&lt; std::endl;

    return 0;
}</code></pre>
            </div>
            </p>
            <p>Powy偶szy kod wykorzystuje <code>count_if()</code> do zliczenia parzystych element贸w w wektorze. Algorytmy w STL s pot偶nym narzdziem umo偶liwiajcym efektywne i wygodne operacje na kontenerach, minimalizujc ilo kodu potrzebnego do wykonania zo偶onych zada.</p>
        </section>
        <div id="table-of-contents">
            <h2>Spis Treci</h2>
            <ol><a href="#stl-standard-template-library-">STL (Standard Template Library)</a>
                <ol>
                    <li><a href="#kolekcje-w-stl">Kolekcje w STL</a></li>
                    <li><a href="#stl-standard-template-library-">STL (Standard Template Library)</a></li>
                    <li><a href="#kolekcje-w-stl">Kolekcje w STL</a>
                        <ol>
                            <li><a href="#vector">vector</a></li>
                            <li><a href="#list">list</a></li>
                            <li><a href="#map">map</a></li>
                            <li><a href="#unordered_map">unordered_map</a></li>
                            <li><a href="#set">set</a></li>
                            <li><a href="#unordered_set">unordered_set</a></li>
                            <li><a href="#priority_queue">priority_queue</a></li>
                            <li><a href="#queue">queue</a></li>
                            <li><a href="#stack">stack</a></li>
                        </ol>
                    </li>
                    <li><a href="#iteratory">Iteratory</a>
                        <ol>
                            <li><a href="#rodzaje-iterator贸w">Rodzaje iterator贸w</a></li>
                            <li><a href="#podstawowe-operacje-na-iteratorach">Podstawowe operacje na iteratorach</a></li>
                            <li><a href="#przykad-u偶ycia-iteratora">Przykad u偶ycia iteratora</a></li>
                        </ol>
                    </li>
                    <li><a href="#algorytmy">Algorytmy</a>
                        <ol>
                            <li><a href="#sort-">sort()</a></li>
                            <li><a href="#find-">find()</a></li>
                            <li><a href="#for_each-">for_each()</a></li>
                            <li><a href="#count_if-">count_if()</a></li>
                        </ol>
                    </li>
                </ol>
            </ol>
            <div id="related-articles">
                <h2>Related Articles</h2>
                <ol>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/01_proces_kompilacji.html">Proces Kompilacji</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/02_preprocesor.html">Preprocesor</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/03_zmienne_i_typy_danych.html">Zmienne i Typy Danych</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/04_interakcja_z_konsola.html">Interakcja z Konsola</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/05_instrukcja_warunkowa.html">Instrukcja Warunkowa</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/06_petle.html">Petle</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/07_liczby_losowe.html">Liczby Losowe</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/08_typ_wyliczeniowy.html">Typ Wyliczeniowy</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/09_funkcje.html">Funkcje</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/10_l_wartosci_r_wartosci.html">L Wartosci R Wartosci</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/11_wskazniki.html">Wskazniki</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/12_tablice.html">Tablice</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/13_napisy.html">Napisy</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/14_operacje_bitowe.html">Operacje Bitowe</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/15_programowanie_obietkowe.html">Programowanie Obietkowe</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/16_dziedziczenie.html">Dziedziczenie</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/17_zaawansowane_wskazniki.html">Zaawansowane Wskazniki</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/18_przeciazanie.html">Przeciazanie</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/19_konwersje.html">Konwersje</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/20_lambdy.html">Lambdy</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/21_szablony.html">Szablony</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/22_wyjatki.html">Wyjatki</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/23_stl.html">Stl</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/24_praca_z_plikami.html">Praca z Plikami</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/25_c_vs_cpp.html">C vs Cpp</a></li>
                </ol>
            </div>
        </div>
    </div>
    <footer>
        <div class="footer-columns">
            <div class="footer-column">
                <img alt="Adam Djellouli Symbol" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/symbol.png" />
            </div>
            <div class="footer-column">
                <h2><a href="https://adamdjellouli.com/core/privacy_policy.html" title="Privacy Policy">Our Privacy Policy</a></h2>
                <p>
                    Thank you for visiting my personal website. All of the <br />
                    content on this site is free to use, but please remember <br />
                    to be a good human being and refrain from any abuse<br />
                    of the site. If you would like to contact me, please use <br />
                    my <a href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" title="LinkedIn Profile">LinkedIn profile</a> or my <a href="https://github.com/djeada" title="GitHub Profile">GitHub</a> if you have any technical <br />
                    issues or ideas to share. I wish you the best and hope you <br />
                    have a fantastic life. <br />
                </p>
            </div>
            <div class="footer-column">
                <h2>Follow me</h2>
                <ul class="social-media">
                    <li>
                        <a class="fa fa-youtube" href="https://www.youtube.com/channel/UCGPoHTVjMN77wcGknXPHl1Q" target="_blank" title="YouTube">
                        </a>YouTube
                    </li>
                    <li>
                        <a class="fa fa-linkedin" href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" target="_blank" title="LinkedIn">
                        </a>LinkedIn
                    </li>
                    <li>
                        <a class="fa fa-instagram" href="https://www.instagram.com/linuxchallenges/" target="_blank" title="Instagram">
                        </a>Instagram
                    </li>
                    <li>
                        <a class="fa fa-github" href="https://github.com/djeada" title="GitHub">
                        </a>Github
                    </li>
                </ul>
            </div>
        </div>
        <div>
            <p id="copyright">
                漏 Adam Djellouli. All rights reserved.
            </p>
        </div>
        <script>
            document.getElementById("copyright").innerHTML = "&copy; " + new Date().getFullYear() + " Adam Djellouli. All rights reserved.";
        </script>
        <script src="../../app.js"></script>
    </footer>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-bash.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-cpp.min.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
jax: ["input/TeX", "output/HTML-CSS"],
extensions: ["tex2jax.js"],
"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] },
tex2jax: { inlineMath: [ ["$", "$"] ], displayMath: [ ["$$","$$"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
TeX: { noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } } },
messageStyle: "none"
});
</script>
<script async="" id="MathJax-script" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>

</html>