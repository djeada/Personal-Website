<!DOCTYPE html>

<html lang="pl">

<head>
    <script async="" crossorigin="anonymous" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5593122079896089"></script>
    <meta charset="utf-8" />
    <title>STL (Standard Template Library)</title>
    <meta content="STL to biblioteka szablon贸w w jzyku C++, kt贸ra dostarcza gotowych do u偶ycia implementacji wielu funkcji, algorytm贸w i struktur danych." name="description" />
    <meta content="Adam Djellouli" name="author" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <meta content="IE=edge" http-equiv="X-UA-Compatible" />
    <link crossorigin="" href="https://fonts.googleapis.com" rel="preconnect" />
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/icon.ico" rel="icon" />
    <link href="../../resources/style.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />
</head>

<body>
    <nav aria-label="Main navigation">
        <a class="logo" href="https://adamdjellouli.com">
            <img alt="Adam Djellouli - Home Page Logo" id="logo-image" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/logo.PNG" />
        </a>
        <input aria-label="Toggle navigation menu" id="navbar-toggle" type="checkbox" />
        <ul aria-labelledby="navbar-toggle" role="menu">
            <li role="menuitem">
                <a href="../../index.html" title="Go to Home Page"> Home </a>
            </li>
            <li role="menuitem">
                <a class="active" href="../../core/blog.html" title="Read Adam Djellouli Blog on Programming and Technology"> Blog </a>
            </li>
            <li role="menuitem">
                <a href="../../core/tools.html" title="Discover Tools Created by Adam Djellouli"> Tools </a>
            </li>
            <li role="menuitem">
                <a href="../../core/projects.html" title="Explore Projects Developed by Adam Djellouli"> Projects </a>
            </li>
            <li role="menuitem">
                <a href="../../core/resume.html" title="View Adam Djellouli Professional Resume"> Resume </a>
            </li>
            <li>
                <script async="" src="https://cse.google.com/cse.js?cx=8160ef9bb935f4f68"></script>
                <div class="gcse-search"></div>
            </li>
            <li>
                <button aria-label="Toggle dark mode" id="dark-mode-button"></button>
            </li>
        </ul>
    </nav>
    <div id="article-wrapper">
        <section id="article-body">
            <p style="text-align: right;"><i>Last modified: September 25, 2024</i></p>
            <p style="text-align: right;"><i>This article is written in: 叼</i></p>
            <h2 id="stl-standard-template-library-">STL (Standard Template Library)</h2>
            <p>STL to biblioteka szablon贸w w jzyku C++, kt贸ra dostarcza gotowych do u偶ycia implementacji wielu funkcji, algorytm贸w i struktur danych. Najwa偶niejsze komponenty biblioteki STL to:</p>
            <ul>
                <li><code>vector</code></li>
                <li><code>list</code></li>
                <li><code>map</code></li>
                <li><code>set</code></li>
                <li><code>queue</code></li>
                <li><code>stack</code></li>
                <li><code>algorithm</code></li>
                <li><code>iterator</code></li>
                <li><code>memory</code></li>
            </ul>
            <h3 id="kolekcje-w-stl">Kolekcje w STL</h3>
            <p>Kolekcje w STL to zbiory implementacji struktur danych wraz z funkcjami operujcymi na tych strukturach.</p>
            <h3 id="stl-standard-template-library-">STL (Standard Template Library)</h3>
            <p>STL to biblioteka szablon贸w w jzyku C++, kt贸ra dostarcza gotowych do u偶ycia implementacji wielu funkcji, algorytm贸w i struktur danych. Najwa偶niejsze komponenty biblioteki STL to:</p>
            <ul>
                <li><code>vector</code></li>
                <li><code>list</code></li>
                <li><code>map</code></li>
                <li><code>set</code></li>
                <li><code>unordered_map</code></li>
                <li><code>unordered_set</code></li>
                <li><code>priority_queue</code></li>
                <li><code>queue</code></li>
                <li><code>stack</code></li>
                <li><code>algorithm</code></li>
                <li><code>iterator</code></li>
                <li><code>memory</code></li>
            </ul>
            <p>Dodanie kolumny "Zo偶ono czasowa" do ka偶dej tabeli mo偶e pom贸c lepiej zrozumie wydajno r贸偶nych operacji. Oto zaktualizowane tabele:</p>
            <h3 id="kolekcje-w-stl">Kolekcje w STL</h3>
            <p>Kolekcje w STL to zbiory implementacji struktur danych wraz z funkcjami operujcymi na tych strukturach.</p>
            <h4 id="vector"><strong>vector</strong></h4>
            <p><code>vector</code> to dynamiczna tablica, kt贸ra mo偶e zmienia sw贸j rozmiar. Jest jednym z najczciej u偶ywanych kontener贸w w STL.</p>
            <p>Operacje:</p>
            <p>
            <table>
                <tr>
                    <td>Metoda</td>
                    <td>Opis</td>
                    <td>Przykad u偶ycia</td>
                    <td>Zo偶ono czasowa</td>
                </tr>
                <tr>
                    <td><code>push_back(value)</code></td>
                    <td>Dodaje element na kocu</td>
                    <td><code>vec.push_back(10);</code></td>
                    <td>Amortyzowane O(1)</td>
                </tr>
                <tr>
                    <td><code>pop_back()</code></td>
                    <td>Usuwa element z koca</td>
                    <td><code>vec.pop_back();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>size()</code></td>
                    <td>Zwraca liczb element贸w</td>
                    <td><code>auto s = vec.size();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>empty()</code></td>
                    <td>Sprawdza, czy kontener jest pusty</td>
                    <td><code>if (vec.empty()) {}</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>clear()</code></td>
                    <td>Usuwa wszystkie elementy</td>
                    <td><code>vec.clear();</code></td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><code>insert(pos, value)</code></td>
                    <td>Wstawia element na podanej pozycji</td>
                    <td><code>vec.insert(vec.begin() + 1, 20);</code></td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><code>erase(pos)</code></td>
                    <td>Usuwa element z podanej pozycji</td>
                    <td><code>vec.erase(vec.begin() + 1);</code></td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><code>at(index)</code></td>
                    <td>Zwraca referencj do elementu na podanym indeksie</td>
                    <td><code>int val = vec.at(2);</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>operator[]</code></td>
                    <td>Zwraca referencj do elementu na podanym indeksie</td>
                    <td><code>int val = vec[2];</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>front()</code></td>
                    <td>Zwraca referencj do pierwszego elementu</td>
                    <td><code>int val = vec.front();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>back()</code></td>
                    <td>Zwraca referencj do ostatniego elementu</td>
                    <td><code>int val = vec.back();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>begin()</code></td>
                    <td>Zwraca iterator na pocztek</td>
                    <td><code>auto it = vec.begin();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>end()</code></td>
                    <td>Zwraca iterator na koniec</td>
                    <td><code>auto it = vec.end();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>reserve(n)</code></td>
                    <td>Rezerwuje miejsce na n element贸w</td>
                    <td><code>vec.reserve(100);</code></td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><code>resize(n)</code></td>
                    <td>Zmienia rozmiar wektora</td>
                    <td><code>vec.resize(10);</code></td>
                    <td>O(n)</td>
                </tr>
            </table>
            </p>
            <p>Przykad:</p>
            <p>
            <div>
                <pre><code class="language-clike">std::vector&lt;int&gt; vec = {1, 2, 3};
vec.push_back(4);
vec.insert(vec.begin() + 1, 10);
for(auto it = vec.begin(); it != vec.end(); ++it) {
std::cout &lt;&lt; *it &lt;&lt; " ";
}</code></pre>
            </div>
            </p>
            <h4 id="list"><strong>list</strong></h4>
            <p><code>list</code> to dwukierunkowa lista wizana, kt贸ra umo偶liwia szybkie wstawianie i usuwanie element贸w.</p>
            <p>Operacje:</p>
            <p>
            <table>
                <tr>
                    <td>Metoda</td>
                    <td>Opis</td>
                    <td>Przykad u偶ycia</td>
                    <td>Zo偶ono czasowa</td>
                </tr>
                <tr>
                    <td><code>push_back(value)</code></td>
                    <td>Dodaje element na kocu</td>
                    <td><code>lst.push_back(10);</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>push_front(value)</code></td>
                    <td>Dodaje element na pocztku</td>
                    <td><code>lst.push_front(5);</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>pop_back()</code></td>
                    <td>Usuwa element z koca</td>
                    <td><code>lst.pop_back();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>pop_front()</code></td>
                    <td>Usuwa element z pocztku</td>
                    <td><code>lst.pop_front();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>size()</code></td>
                    <td>Zwraca liczb element贸w</td>
                    <td><code>auto s = lst.size();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>empty()</code></td>
                    <td>Sprawdza, czy kontener jest pusty</td>
                    <td><code>if (lst.empty()) {}</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>clear()</code></td>
                    <td>Usuwa wszystkie elementy</td>
                    <td><code>lst.clear();</code></td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><code>insert(pos, value)</code></td>
                    <td>Wstawia element na podanej pozycji</td>
                    <td><code>lst.insert(++lst.begin(), 20);</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>erase(pos)</code></td>
                    <td>Usuwa element z podanej pozycji</td>
                    <td><code>lst.erase(++lst.begin());</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>front()</code></td>
                    <td>Zwraca referencj do pierwszego elementu</td>
                    <td><code>int val = lst.front();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>back()</code></td>
                    <td>Zwraca referencj do ostatniego elementu</td>
                    <td><code>int val = lst.back();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>begin()</code></td>
                    <td>Zwraca iterator na pocztek</td>
                    <td><code>auto it = lst.begin();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>end()</code></td>
                    <td>Zwraca iterator na koniec</td>
                    <td><code>auto it = lst.end();</code></td>
                    <td>O(1)</td>
                </tr>
            </table>
            </p>
            <p>Przykad:</p>
            <p>
            <div>
                <pre><code class="language-clike">std::list&lt;int&gt; lst = {1, 2, 3};
lst.push_back(4);
lst.push_front(0);
lst.insert(++lst.begin(), 10);
for(auto it = lst.begin(); it != lst.end(); ++it) {
std::cout &lt;&lt; *it &lt;&lt; " ";
}</code></pre>
            </div>
            </p>
            <h4 id="map"><strong>map</strong></h4>
            <p><code>map</code> to kontener asocjacyjny, kt贸ry przechowuje pary klucz-warto w uporzdkowanej formie, wykorzystujc drzewo czerwono-czarne.</p>
            <p>Operacje:</p>
            <p>
            <table>
                <tr>
                    <td>Metoda</td>
                    <td>Opis</td>
                    <td>Przykad u偶ycia</td>
                    <td>Zo偶ono czasowa</td>
                </tr>
                <tr>
                    <td><code>insert({key, value})</code></td>
                    <td>Wstawia par klucz-warto</td>
                    <td><code>mp.insert({1, "one"});</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>erase(key)</code></td>
                    <td>Usuwa element o podanym kluczu</td>
                    <td><code>mp.erase(1);</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>find(key)</code></td>
                    <td>Zwraca iterator na element o podanym kluczu</td>
                    <td><code>auto it = mp.find(1);</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>size()</code></td>
                    <td>Zwraca liczb element贸w</td>
                    <td><code>auto s = mp.size();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>empty()</code></td>
                    <td>Sprawdza, czy kontener jest pusty</td>
                    <td><code>if (mp.empty()) {}</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>clear()</code></td>
                    <td>Usuwa wszystkie elementy</td>
                    <td><code>mp.clear();</code></td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><code>operator[]</code></td>
                    <td>Zwraca referencj do wartoci o podanym kluczu</td>
                    <td><code>std::string val = mp[1];</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>begin()</code></td>
                    <td>Zwraca iterator na pocztek</td>
                    <td><code>auto it = mp.begin();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>end()</code></td>
                    <td>Zwraca iterator na koniec</td>
                    <td><code>auto it = mp.end();</code></td>
                    <td>O(1)</td>
                </tr>
            </table>
            </p>
            <p>Przykad:</p>
            <p>
            <div>
                <pre><code class="language-clike">std::map&lt;int, std::string=""&gt; mp;
mp.insert({1, "one"});
mp[2] = "two";
mp.erase(1);
for(auto it = mp.begin(); it != mp.end(); ++it) {
std::cout &lt;&lt; it-&gt;first &lt;&lt; ": " &lt;&lt; it-&gt;second &lt;&lt; " ";
}</code></pre>
            </div>
            </p>
            <h4 id="unordered_map"><strong>unordered_map</strong></h4>
            <p><code>unordered_map</code> to kontener asocjacyjny, kt贸ry przechowuje pary klucz-warto w nieuporzdkowanej formie, wykorzystujc tablic mieszajc (hash table).</p>
            <p>Operacje:</p>
            <p>
            <table>
                <tr>
                    <td>Metoda</td>
                    <td>Opis</td>
                    <td>Przykad u偶ycia</td>
                    <td>Zo偶ono czasowa</td>
                </tr>
                <tr>
                    <td><code>insert({key, value})</code></td>
                    <td>Wstawia par klucz-warto</td>
                    <td><code>ump.insert({1, "one"});</code></td>
                    <td>O(1) amortyzowane</td>
                </tr>
                <tr>
                    <td><code>erase(key)</code></td>
                    <td>Usuwa element o podanym kluczu</td>
                    <td><code>ump.erase(1);</code></td>
                    <td>O(1) amortyzowane</td>
                </tr>
                <tr>
                    <td><code>find(key)</code></td>
                    <td>Zwraca iterator na element o podanym kluczu</td>
                    <td><code>auto it = ump.find(1);</code></td>
                    <td>O(1) amortyzowane</td>
                </tr>
                <tr>
                    <td><code>size()</code></td>
                    <td>Zwraca liczb element贸w</td>
                    <td><code>auto s = ump.size();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>empty()</code></td>
                    <td>Sprawdza, czy kontener jest pusty</td>
                    <td><code>if (ump.empty()) {}</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>clear()</code></td>
                    <td>Usuwa wszystkie elementy</td>
                    <td><code>ump.clear();</code></td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><code>operator[]</code></td>
                    <td>Zwraca referencj do wartoci o podanym kluczu</td>
                    <td><code>std::string val = ump[1];</code></td>
                    <td>O(1) amortyzowane</td>
                </tr>
                <tr>
                    <td><code>begin()</code></td>
                    <td>Zwraca iterator na pocztek</td>
                    <td><code>auto it = ump.begin();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>end()</code></td>
                    <td>Zwraca iterator na koniec</td>
                    <td><code>auto it = ump.end();</code></td>
                    <td>O(1)</td>
                </tr>
            </table>
            </p>
            <p>Przykad:</p>
            <p>
            <div>
                <pre><code class="language-clike">std::unordered_map&lt;int, std::string=""&gt; ump;
ump.insert({1, "one"});
ump[2] = "two";
ump.erase(1);
for(auto it = ump.begin(); it != ump.end(); ++it) {
std::cout &lt;&lt; it-&gt;first &lt;&lt; ": " &lt;&lt; it-&gt;second &lt;&lt; " ";
}</code></pre>
            </div>
            </p>
            <h4 id="set"><strong>set</strong></h4>
            <p><code>set</code> to kontener, kt贸ry przechowuje unikalne elementy w uporzdkowanej formie, wykorzystujc drzewo czerwono-czarne.</p>
            <p>Operacje:</p>
            <p>Oto poprawiona tabela:</p>
            <p>
            <table>
                <tr>
                    <td>Metoda</td>
                    <td>Opis</td>
                    <td>Przykad u偶ycia</td>
                    <td>Zo偶ono czasowa</td>
                </tr>
                <tr>
                    <td><code>insert(value)</code></td>
                    <td>Wstawia element</td>
                    <td><code>st.insert(10);</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>erase(value)</code></td>
                    <td>Usuwa element</td>
                    <td><code>st.erase(10);</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>find(value)</code></td>
                    <td>Zwraca iterator na element</td>
                    <td><code>auto it = st.find(10);</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>size()</code></td>
                    <td>Zwraca liczb element贸w</td>
                    <td><code>auto s = st.size();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>empty()</code></td>
                    <td>Sprawdza, czy kontener jest pusty</td>
                    <td><code>if (st.empty()) {}</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>clear()</code></td>
                    <td>Usuwa wszystkie elementy</td>
                    <td><code>st.clear();</code></td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><code>begin()</code></td>
                    <td>Zwraca iterator na pocztek</td>
                    <td><code>auto it = st.begin();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>end()</code></td>
                    <td>Zwraca iterator na koniec</td>
                    <td><code>auto it = st.end();</code></td>
                    <td>O(1)</td>
                </tr>
            </table>
            </p>
            <p>Przykad:</p>
            <p>
            <div>
                <pre><code class="language-clike">std::set&lt;int&gt; st;
st.insert(10);
st.insert(20);
st.erase(10);
for(auto it = st.begin(); it != st.end(); ++it) {
std::cout &lt;&lt; *it &lt;&lt; " ";
}</code></pre>
            </div>
            </p>
            <h4 id="unordered_set"><strong>unordered_set</strong></h4>
            <p><code>unordered_set</code> to kontener, kt贸ry przechowuje unikalne elementy w nieuporzdkowanej formie, wykorzystujc tablic mieszajc (hash table).</p>
            <p>Operacje:</p>
            <p>
            <table>
                <tr>
                    <td>Metoda</td>
                    <td>Opis</td>
                    <td>Przykad u偶ycia</td>
                    <td>Zo偶ono czasowa</td>
                </tr>
                <tr>
                    <td><code>insert(value)</code></td>
                    <td>Wstawia element</td>
                    <td><code>ust.insert(10);</code></td>
                    <td>O(1) amortyzowane</td>
                </tr>
                <tr>
                    <td><code>erase(value)</code></td>
                    <td>Usuwa element</td>
                    <td><code>ust.erase(10);</code></td>
                    <td>O(1) amortyzowane</td>
                </tr>
                <tr>
                    <td><code>find(value)</code></td>
                    <td>Zwraca iterator na element</td>
                    <td><code>auto it = ust.find(10);</code></td>
                    <td>O(1) amortyzowane</td>
                </tr>
                <tr>
                    <td><code>size()</code></td>
                    <td>Zwraca liczb element贸w</td>
                    <td><code>auto s = ust.size();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>empty()</code></td>
                    <td>Sprawdza, czy kontener jest pusty</td>
                    <td><code>if (ust.empty()) {}</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>clear()</code></td>
                    <td>Usuwa wszystkie elementy</td>
                    <td><code>ust.clear();</code></td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><code>begin()</code></td>
                    <td>Zwraca iterator na pocztek</td>
                    <td><code>auto it = ust.begin();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>end()</code></td>
                    <td>Zwraca iterator na koniec</td>
                    <td><code>auto it = ust.end();</code></td>
                    <td>O(1)</td>
                </tr>
            </table>
            </p>
            <p>Przykad:</p>
            <p>
            <div>
                <pre><code class="language-clike">std::unordered_set&lt;int&gt; ust;
ust.insert(10);
ust.insert(20);
ust.erase(10);
for(auto it = ust.begin(); it != ust.end(); ++it) {
std::cout &lt;&lt; *it &lt;&lt; " ";
}</code></pre>
            </div>
            </p>
            <h4 id="priority_queue"><strong>priority_queue</strong></h4>
            <p><code>priority_queue</code> to kontener, kt贸ry implementuje kopiec binarny i pozwala na szybkie wyciganie najwikszego (lub najmniejszego) elementu.</p>
            <p>Operacje:</p>
            <p>
            <table>
                <tr>
                    <td>Metoda</td>
                    <td>Opis</td>
                    <td>Przykad u偶ycia</td>
                    <td>Zo偶ono czasowa</td>
                </tr>
                <tr>
                    <td><code>push(value)</code></td>
                    <td>Dodaje element</td>
                    <td><code>pq.push(10);</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>pop()</code></td>
                    <td>Usuwa najwikszy element</td>
                    <td><code>pq.pop();</code></td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td><code>top()</code></td>
                    <td>Zwraca referencj do najwikszego elementu</td>
                    <td><code>int val = pq.top();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>size()</code></td>
                    <td>Zwraca liczb element贸w</td>
                    <td><code>auto s = pq.size();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>empty()</code></td>
                    <td>Sprawdza, czy kontener jest pusty</td>
                    <td><code>if (pq.empty()) {}</code></td>
                    <td>O(1)</td>
                </tr>
            </table>
            </p>
            <p>Przykad:</p>
            <p>
            <div>
                <pre><code class="language-clike">std::priority_queue&lt;int&gt; pq;
pq.push(10);
pq.push(20);
pq.push(5);
std::cout &lt;&lt; pq.top() &lt;&lt; " "; // wywietli 20
pq.pop();
std::cout &lt;&lt; pq.top() &lt;&lt; " "; // wywietli 10</code></pre>
            </div>
            </p>
            <h4 id="queue"><strong>queue</strong></h4>
            <p><code>queue</code> to kontener, kt贸ry implementuje kolejk FIFO (First In, First Out).</p>
            <p>Operacje:</p>
            <p>
            <table>
                <tr>
                    <td>Metoda</td>
                    <td>Opis</td>
                    <td>Przykad u偶ycia</td>
                    <td>Zo偶ono czasowa</td>
                </tr>
                <tr>
                    <td><code>push(value)</code></td>
                    <td>Dodaje element</td>
                    <td><code>q.push(10);</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>pop()</code></td>
                    <td>Usuwa element z pocztku</td>
                    <td><code>q.pop();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>front()</code></td>
                    <td>Zwraca referencj do pierwszego elementu</td>
                    <td><code>int val = q.front();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>back()</code></td>
                    <td>Zwraca referencj do ostatniego elementu</td>
                    <td><code>int val = q.back();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>size()</code></td>
                    <td>Zwraca liczb element贸w</td>
                    <td><code>auto s = q.size();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>empty()</code></td>
                    <td>Sprawdza, czy kontener jest pusty</td>
                    <td><code>if (q.empty()) {}</code></td>
                    <td>O(1)</td>
                </tr>
            </table>
            </p>
            <p>Przykad:</p>
            <p>
            <div>
                <pre><code class="language-clike">std::queue&lt;int&gt; q;
q.push(10);
q.push(20);
std::cout &lt;&lt; q.front() &lt;&lt; " "; // wywietli 10
q.pop();
std::cout &lt;&lt; q.front() &lt;&lt; " "; // wywietli 20</code></pre>
            </div>
            </p>
            <h4 id="stack"><strong>stack</strong></h4>
            <p><code>stack</code> to kontener, kt贸ry implementuje stos LIFO (Last In, First Out).</p>
            <p>Operacje:</p>
            <p>
            <table>
                <tr>
                    <td>Metoda</td>
                    <td>Opis</td>
                    <td>Przykad u偶ycia</td>
                    <td>Zo偶ono czasowa</td>
                </tr>
                <tr>
                    <td><code>push(value)</code></td>
                    <td>Dodaje element</td>
                    <td><code>st.push(10);</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>pop()</code></td>
                    <td>Usuwa element z koca</td>
                    <td><code>st.pop();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>top()</code></td>
                    <td>Zwraca referencj do ostatniego elementu</td>
                    <td><code>int val = st.top();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>size()</code></td>
                    <td>Zwraca liczb element贸w</td>
                    <td><code>auto s = st.size();</code></td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td><code>empty()</code></td>
                    <td>Sprawdza, czy kontener jest pusty</td>
                    <td><code>if (st.empty()) {}</code></td>
                    <td>O(1)</td>
                </tr>
            </table>
            </p>
            <p>Przykad:</p>
            <p>
            <div>
                <pre><code class="language-clike">std::stack&lt;int&gt; st;
st.push(10);
st.push(20);
std::cout &lt;&lt; st.top() &lt;&lt; " "; // wywietli 20
st.pop();
std::cout &lt;&lt; st.top() &lt;&lt; " "; // wywietli 10</code></pre>
            </div>
            </p>
            <h3 id="iteratory">Iteratory</h3>
            <p>Iteratory w jzyku C++ to obiekty umo偶liwiajce sekwencyjny dostp do element贸w kontener贸w. Dziki nim mo偶liwe jest jednolite przegldanie zawartoci r贸偶nych typ贸w kolekcji, niezale偶nie od ich wewntrznej implementacji. Iteratory peni podobn rol do wska藕nik贸w, ale s bardziej elastyczne i bezpieczne w u偶yciu.</p>
            <h4 id="rodzaje-iterator贸w">Rodzaje iterator贸w</h4>
            <p>
            <table>
                <tr>
                    <td>Typ iteratora</td>
                    <td>Opis</td>
                </tr>
                <tr>
                    <td><strong>Input Iterator</strong></td>
                    <td>Su偶y do odczytu danych z kontenera.</td>
                </tr>
                <tr>
                    <td><strong>Output Iterator</strong></td>
                    <td>Su偶y do zapisu danych do kontenera.</td>
                </tr>
                <tr>
                    <td><strong>Forward Iterator</strong></td>
                    <td>czy mo偶liwoci iterator贸w input i output, mo偶e przemieszcza si tylko do przodu.</td>
                </tr>
                <tr>
                    <td><strong>Bidirectional Iterator</strong></td>
                    <td>Umo偶liwia przemieszczanie si zar贸wno do przodu, jak i do tyu.</td>
                </tr>
                <tr>
                    <td><strong>Random Access Iterator</strong></td>
                    <td>Oferuje wszystkie mo偶liwoci Bidirectional Iterator oraz umo偶liwia dostp do dowolnego elementu kontenera w staym czasie.</td>
                </tr>
            </table>
            </p>
            <h4 id="podstawowe-operacje-na-iteratorach">Podstawowe operacje na iteratorach</h4>
            <ul>
                <li>Inicjalizacja iteratora pocztkowym elementem kontenera: <code>kontener.begin()</code></li>
                <li>Inicjalizacja iteratora elementem za ostatnim w kontenerze: <code>kontener.end()</code></li>
                <li>Odwoanie do elementu, na kt贸ry wskazuje iterator: <code>*it</code></li>
                <li>Przesunicie iteratora do nastpnego elementu: <code>++it</code></li>
                <li>Przesunicie iteratora do poprzedniego elementu: <code>--it</code> (dla Bidirectional Iterator)</li>
                <li>Przesunicie iteratora o okrelon liczb pozycji: <code>it += n</code> lub <code>it -= n</code> (dla Random Access Iterator)</li>
                <li>Wstawienie elementu w miejscu wskazywanym przez iterator: <code>it = kontener.insert(it, warto)</code></li>
                <li>Usunicie elementu w miejscu wskazywanym przez iterator: <code>it = kontener.erase(it)</code></li>
            </ul>
            <h4 id="przykad-u偶ycia-iteratora">Przykad u偶ycia iteratora</h4>
            <p>Poni偶szy przykad ilustruje operacje na wektorze <code>std::vector</code> typu <code>std::string</code>. Najpierw tworzy i inicjalizuje wektor trzema elementami: "ala", "ma", "kota", a nastpnie wywietla jego zawarto za pomoc iteratora. Nastpnie dodaje nowy element "nie" przed drugim elementem wektora, czyli przed "ma". Po tym usuwa pierwszy element wektora, kt贸rym jest "ala". Na koniec, program ponownie wywietla zmodyfikowan zawarto wektora.</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;std::string&gt; v = {"ala", "ma", "kota"};

    // Wywietlenie zawartoci wektora przy u偶yciu iteratora
    for (auto it = v.begin(); it != v.end(); ++it) {
        std::cout &lt;&lt; *it &lt;&lt; std::endl;
    }

    // Dodanie nowego elementu przed "ma"
    auto it = v.begin() + 1;
    v.insert(it, "nie");

    // Usunicie sowa "ala"
    it = v.begin();
    v.erase(it);

    std::cout &lt;&lt; "\nPo modyfikacjach:\n";
    for (const auto&amp; word : v) {
        std::cout &lt;&lt; word &lt;&lt; std::endl;
    }

    return 0;
}</code></pre>
            </div>
            </p>
            <p>Warto pamita, 偶e po niekt贸rych operacjach, takich jak insert czy erase, u偶ywane wczeniej iteratory mog sta si nieaktualne i ich dalsze u偶ycie mo偶e prowadzi do niezdefiniowanego zachowania programu.</p>
            <h3 id="algorytmy-w-standardowej-bibliotece-c-stl-">Algorytmy w Standardowej Bibliotece C++ (STL)</h3>
            <p>Biblioteka <code>algorithm</code> w standardowej bibliotece C++ (STL) dostarcza bogaty zestaw funkcji szablonowych, kt贸re su偶 do manipulacji i analizy danych przechowywanych w kontenerach. Algorytmy te s zaprojektowane w spos贸b generyczny, co oznacza, 偶e mog dziaa z r贸偶nymi typami danych i kontenerami, pod warunkiem spenienia okrelonych wymaga. W tej sekcji przyjrzymy si kilku kluczowym algorytmom, ich implementacji, zastosowaniu oraz analizie matematycznej wydajnoci.</p>
            <h4 id="wprowadzenie-do-algorytm贸w-stl">Wprowadzenie do Algorytm贸w STL</h4>
            <p>Algorytmy w STL s zaimplementowane jako funkcje szablonowe, co pozwala na ich u偶ycie z r贸偶nymi typami danych i kontenerami. Dziaaj one na zakresach okrelonych przez iteratory, co zapewnia elastyczno i niezale偶no od konkretnego typu kontenera. Dziki temu mo偶liwe jest pisanie kodu, kt贸ry jest jednoczenie uniwersalny i wydajny.</p>
            <h4 id="klasyfikacja-algorytm贸w">Klasyfikacja Algorytm贸w</h4>
            <p>Algorytmy STL mo偶na podzieli na kilka kategorii:</p>
            <p>
            <table>
                <tr>
                    <td>Kategoria algorytm贸w</td>
                    <td>Przykady</td>
                </tr>
                <tr>
                    <td><strong>Algorytmy modyfikujce</strong></td>
                    <td><code>std::copy</code>, <code>std::fill</code>, <code>std::transform</code></td>
                </tr>
                <tr>
                    <td><strong>Algorytmy przeszukujce</strong></td>
                    <td><code>std::find</code>, <code>std::count</code>, <code>std::search</code></td>
                </tr>
                <tr>
                    <td><strong>Algorytmy sortujce i porzdkujce</strong></td>
                    <td><code>std::sort</code>, <code>std::stable_sort</code>, <code>std::partial_sort</code></td>
                </tr>
                <tr>
                    <td><strong>Algorytmy numeryczne</strong></td>
                    <td><code>std::accumulate</code>, <code>std::inner_product</code>, <code>std::partial_sum</code></td>
                </tr>
                <tr>
                    <td><strong>Algorytmy usuwajce</strong></td>
                    <td><code>std::remove</code>, <code>std::unique</code>, <code>std::remove_if</code></td>
                </tr>
            </table>
            </p>
            <h4 id="std-sort-"><code>std::sort()</code></h4>
            <p>Funkcja <code>std::sort()</code> su偶y do sortowania element贸w w okrelonym zakresie. Jest to jeden z najczciej u偶ywanych algorytm贸w w STL. Wykorzystuje algorytm sortowania introspektywnego (introsort), kt贸ry czy zalety sortowania szybkiego (quick sort), sortowania kopcowego (heap sort) i sortowania przez wstawianie (insertion sort).</p>
            <p><strong>Prototyp:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">template&lt; class RandomIt &gt;
void sort( RandomIt first, RandomIt last );

template&lt; class RandomIt, class Compare &gt;
void sort( RandomIt first, RandomIt last, Compare comp );</code></pre>
            </div>
            </p>
            <ul>
                <li><code>RandomIt</code>: Typ iteratora losowego dostpu.</li>
                <li><code>Compare</code>: Funkcja lub funktor su偶cy do por贸wnywania element贸w.</li>
            </ul>
            <p><strong>Wymagania:</strong></p>
            <ul>
                <li>Elementy musz by por贸wnywalne za pomoc operatora <code>&lt;</code> lub funkcji <code>Compare</code>.</li>
                <li>Iteratory musz by iteratorami losowego dostpu (np. z <code>std::vector</code>, <code>std::array</code>).</li>
            </ul>
            <p><strong>Przykad U偶ycia:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; wektor{8, 3, 5, 1, 2, 4, 6, 7};
    auto kopia = wektor;

    // Sortowanie pierwszych trzech element贸w
    std::sort(wektor.begin(), wektor.begin() + 3);

    // Sortowanie caego wektora
    std::sort(kopia.begin(), kopia.end());

    // Wywietlanie wynik贸w
    std::cout &lt;&lt; "Wektor po czciowym sortowaniu: ";
    for (const auto&amp; val : wektor) {
        std::cout &lt;&lt; val &lt;&lt; " ";
    }
    std::cout &lt;&lt; "\n";

    std::cout &lt;&lt; "Wektor po penym sortowaniu: ";
    for (const auto&amp; val : kopia) {
        std::cout &lt;&lt; val &lt;&lt; " ";
    }

    return 0;
}</code></pre>
            </div>
            </p>
            <p><strong>Analiza Matematyczna:</strong></p>
            <ul>
                <li><strong>Zo偶ono czasowa</strong> dla tego algorytmu wynosi rednio $O(nlogn)$, co jest charakterystyczne dla wydajnych algorytm贸w sortowania.</li>
                <li>W najgorszym przypadku zo偶ono czasowa r贸wnie偶 wynosi $O(nlog)$, poniewa偶 algorytm wykorzystuje introsort, kt贸ry automatycznie przecza si na sortowanie kopcowe, gdy wykryje niekorzystny podzia danych.</li>
                <li><strong>Zo偶ono pamiciowa</strong> tego algorytmu wymaga $O(logn)$ dodatkowej pamici, g贸wnie na stos rekurencji, co czyni go efektywnym pod wzgldem u偶ycia zasob贸w pamici.</li>
            </ul>
            <p><strong>Dostosowywanie Kryterium Sortowania:</strong></p>
            <p>Mo偶emy dostarczy wasn funkcj por贸wnujc:</p>
            <p>
            <div>
                <pre><code class="language-clike">std::sort(wektor.begin(), wektor.end(), [](int a, int b) {
    return a &gt; b; // Sortowanie malejce
});</code></pre>
            </div>
            </p>
            <p><strong>Uwagi:</strong></p>
            <ul>
                <li><strong>Stabilno</strong> algorytmu <code>std::sort()</code> nie jest zagwarantowana, co oznacza, 偶e kolejno r贸wnych element贸w mo偶e si zmieni. W przypadku, gdy stabilno jest wymagana, nale偶y skorzysta z funkcji <code>std::stable_sort()</code>.</li>
                <li>Typ element贸w musi by <strong>zgodny</strong> z wymaganiami funkcji por贸wnujcej, co zapewnia poprawno dziaania algorytmu.</li>
            </ul>
            <h4 id="std-find-"><code>std::find()</code></h4>
            <p>Algorytm <code>std::find()</code> przeszukuje zakres w poszukiwaniu pierwszego wystpienia okrelonej wartoci. Zwraca iterator wskazujcy na znaleziony element lub na koniec zakresu, jeli element nie zosta znaleziony.</p>
            <p><strong>Prototyp:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">template&lt; class InputIt, class T &gt;
InputIt find( InputIt first, InputIt last, const T&amp; value );</code></pre>
            </div>
            </p>
            <ul>
                <li><code>InputIt</code>: Typ iteratora wejciowego.</li>
                <li><code>T</code>: Typ poszukiwanej wartoci.</li>
            </ul>
            <p><strong>Przykad U偶ycia:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; wektor{8, 3, 5, 1, 2, 4, 6, 7};

    auto it = std::find(wektor.begin(), wektor.end(), 3);

    if (it != wektor.end())
        std::cout &lt;&lt; "Znaleziono element o wartoci 3 na pozycji "
                  &lt;&lt; std::distance(wektor.begin(), it) &lt;&lt; "\n";
    else
        std::cout &lt;&lt; "Nie znaleziono elementu o wartoci 3\n";

    return 0;
}</code></pre>
            </div>
            </p>
            <p><strong>Analiza Matematyczna:</strong></p>
            <ul>
                <li><strong>Zo偶ono czasowa</strong> wynosi $O(n)$, gdzie n oznacza liczb element贸w w przetwarzanym zakresie, co sprawia, 偶e algorytm dziaa liniowo wzgldem liczby danych.</li>
                <li><strong>Zo偶ono pamiciowa</strong> wynosi $O(1)$, co oznacza, 偶e algorytm nie wymaga dodatkowej pamici poza t u偶ywan przez same dane.</li>
            </ul>
            <p><strong>Uwagi:</strong></p>
            <ul>
                <li>Algorytm przeszukuje liniowo zakres od <code>first</code> do <code>last</code>.</li>
                <li>Mo偶emy u偶y <code>std::find_if()</code> lub <code>std::find_if_not()</code> do przeszukiwania z warunkiem predykatu.</li>
            </ul>
            <h4 id="std-for_each-"><code>std::for_each()</code></h4>
            <p>Funkcja <code>std::for_each()</code> stosuje podan funkcj lub funktor do ka偶dego elementu w zakresie. Jest to alternatywa dla ptli <code>for</code> i pozwala na bardziej funkcyjne podejcie do iteracji.</p>
            <p><strong>Prototyp:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">template&lt; class InputIt, class UnaryFunction &gt;
UnaryFunction for_each( InputIt first, InputIt last, UnaryFunction f );</code></pre>
            </div>
            </p>
            <ul>
                <li><code>InputIt</code>: Typ iteratora wejciowego.</li>
                <li><code>UnaryFunction</code>: Typ funkcji lub funktora akceptujcego element typu dereferowanego iteratora.</li>
            </ul>
            <p><strong>Przykad U偶ycia:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; wektor{8, 3, 5, 1, 2, 4, 6, 7};

    // Modyfikacja ka偶dego elementu przez jego podwojenie
    std::for_each(wektor.begin(), wektor.end(), [](int &amp;x) { x *= 2; });

    // Wywietlanie wynik贸w
    std::cout &lt;&lt; "Wektor po modyfikacji: ";
    for (const auto&amp; val : wektor) {
        std::cout &lt;&lt; val &lt;&lt; " ";
    }

    return 0;
}</code></pre>
            </div>
            </p>
            <p><strong>Analiza Matematyczna:</strong></p>
            <ul>
                <li><strong>Zo偶ono czasowa</strong> wynosi <strong>O(n)</strong>, poniewa偶 funkcja jest wywoywana dokadnie n razy, co oznacza liniowy wzrost liczby operacji w zale偶noci od liczby element贸w.</li>
                <li><strong>Zo偶ono pamiciowa</strong> wynosi <strong>O(1)</strong>, gdy偶 algorytm nie wymaga dodatkowej pamici poza ewentualnymi zmiennymi lokalnymi w funkcji.</li>
            </ul>
            <p><strong>Uwagi:</strong></p>
            <ul>
                <li>Funkcja <code>UnaryFunction</code> jest przekazywana przez warto, wic jeli potrzebujemy zachowa stan midzy wywoaniami, nale偶y u偶y referencji lub obiektu zewntrznego.</li>
                <li>Zwracana jest kopia funkcji <code>UnaryFunction</code> po ostatnim wywoaniu, co mo偶e by u偶yte do akumulacji wynik贸w.</li>
            </ul>
            <h4 id="std-count_if-"><code>std::count_if()</code></h4>
            <p>Algorytm <code>std::count_if()</code> zlicza liczb element贸w w zakresie, dla kt贸rych predykat jest speniony.</p>
            <p><strong>Prototyp:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">template&lt; class InputIt, class UnaryPredicate &gt;
typename iterator_traits&lt;inputit&gt;::difference_type
count_if( InputIt first, InputIt last, UnaryPredicate p );</code></pre>
            </div>
            </p>
            <ul>
                <li><code>InputIt</code>: Typ iteratora wejciowego.</li>
                <li><code>UnaryPredicate</code>: Funkcja lub funktor zwracajcy warto logiczn.</li>
            </ul>
            <p><strong>Przykad U偶ycia:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; wektor{8, 3, 5, 1, 2, 4, 6, 7};

    // Zliczanie parzystych element贸w
    int parzyste = std::count_if(wektor.begin(), wektor.end(), [](int x) { return x % 2 == 0; });

    std::cout &lt;&lt; "Liczba parzystych element贸w: " &lt;&lt; parzyste &lt;&lt; "\n";

    return 0;
}</code></pre>
            </div>
            </p>
            <p><strong>Analiza Matematyczna:</strong></p>
            <ul>
                <li><strong>Zo偶ono czasowa</strong> wynosi <strong>O(n)</strong>, poniewa偶 predykat jest wywoywany dokadnie n razy, co sprawia, 偶e liczba operacji ronie liniowo w zale偶noci od liczby element贸w.</li>
                <li><strong>Zo偶ono pamiciowa</strong> wynosi <strong>O(1)</strong>, co oznacza, 偶e algorytm nie wymaga dodatkowej pamici poza zmiennymi lokalnymi.</li>
            </ul>
            <p><strong>Uwagi:</strong></p>
            <ul>
                <li>Jeli chcemy zliczy wystpienia konkretnej wartoci, mo偶emy u偶y <code>std::count()</code>.</li>
            </ul>
            <h4 id="inne-wa偶ne-algorytmy">Inne Wa偶ne Algorytmy</h4>
            <h5><code>std::accumulate()</code></h5>
            <p>Su偶y do obliczenia sumy wartoci w zakresie, z opcjonalnym pocztkowym akumulatorem i funkcj operacji.</p>
            <p><strong>Prototyp:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">template&lt; class InputIt, class T &gt;
T accumulate( InputIt first, InputIt last, T init );

template&lt; class InputIt, class T, class BinaryOperation &gt;
T accumulate( InputIt first, InputIt last, T init, BinaryOperation op );</code></pre>
            </div>
            </p>
            <p><strong>Przykad:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">int suma = std::accumulate(wektor.begin(), wektor.end(), 0);</code></pre>
            </div>
            </p>
            <h5><code>std::transform()</code></h5>
            <p>Stosuje funkcj do ka偶dego elementu w zakresie i zapisuje wynik w innym zakresie.</p>
            <p><strong>Prototyp:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">template&lt; class InputIt, class OutputIt, class UnaryOperation &gt;
OutputIt transform( InputIt first1, InputIt last1, OutputIt d_first, UnaryOperation unary_op );</code></pre>
            </div>
            </p>
            <p><strong>Przykad:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">std::vector&lt;int&gt; wyniki(wektor.size());
std::transform(wektor.begin(), wektor.end(), wyniki.begin(), [](int x) { return x * x; });</code></pre>
            </div>
            </p>
            <h4 id="kompatybilno-z-iteratorami">Kompatybilno z Iteratorami</h4>
            <p>Algorytmy STL s zaprojektowane tak, aby dziaa z r贸偶nymi kategoriami iterator贸w:</p>
            <p>
            <table>
                <tr>
                    <td>Kategoria</td>
                    <td>Przykady Algorytm贸w</td>
                </tr>
                <tr>
                    <td>Iteratory wejciowe</td>
                    <td><code>std::find</code>, <code>std::count_if</code></td>
                </tr>
                <tr>
                    <td>Iteratory wyjciowe</td>
                    <td><code>std::copy</code>, <code>std::fill</code></td>
                </tr>
                <tr>
                    <td>Iteratory jedno kierunkowe</td>
                    <td><code>std::for_each</code>, <code>std::remove</code></td>
                </tr>
                <tr>
                    <td>Iteratory dwukierunkowe</td>
                    <td><code>std::reverse</code>, <code>std::rotate</code></td>
                </tr>
                <tr>
                    <td>Iteratory losowego dostpu</td>
                    <td><code>std::sort</code>, <code>std::nth_element</code></td>
                </tr>
            </table>
            </p>
            <h4 id="zastosowanie-algorytm贸w-w-praktyce">Zastosowanie Algorytm贸w w Praktyce</h4>
            <p>Algorytmy STL pozwalaj na pisanie kodu o wysokim poziomie abstrakcji, co zwiksza czytelno i redukuje ryzyko bd贸w. Dziki generycznoci i wykorzystaniu szablon贸w, algorytmy te s niezwykle elastyczne i mog by stosowane w szerokim zakresie zastosowa.</p>
            <p><strong>Przykad: Analiza Danych Finansowych</strong></p>
            <p>Za贸偶my, 偶e mamy wektor reprezentujcy dzienne zmiany cen akcji i chcemy przeprowadzi analiz:</p>
            <p>
            <div>
                <pre><code class="language-clike">std::vector&lt;double&gt; zmianyCen = { -0.5, 1.2, 0.3, -0.7, 0.8, -1.0, 0.6 };

// Obliczenie sumarycznej zmiany cen
double sumaZmian = std::accumulate(zmianyCen.begin(), zmianyCen.end(), 0.0);

// Zliczenie dni ze wzrostem cen
int dniWzrostu = std::count_if(zmianyCen.begin(), zmianyCen.end(), [](double x) { return x &gt; 0; });

// Znalezienie najwikszego spadku
auto it = std::min_element(zmianyCen.begin(), zmianyCen.end());

// Wywietlenie wynik贸w
std::cout &lt;&lt; "Sumaryczna zmiana cen: " &lt;&lt; sumaZmian &lt;&lt; "\n";
std::cout &lt;&lt; "Liczba dni ze wzrostem cen: " &lt;&lt; dniWzrostu &lt;&lt; "\n";
std::cout &lt;&lt; "Najwikszy spadek: " &lt;&lt; *it &lt;&lt; "\n";</code></pre>
            </div>
            </p>
            <h4 id="optymalizacja-za-pomoc-algorytm贸w">Optymalizacja za Pomoc Algorytm贸w</h4>
            <p>Korzystanie z algorytm贸w STL mo偶e prowadzi do bardziej wydajnego kodu, poniewa偶 s one zazwyczaj dobrze zoptymalizowane i wykorzystuj najlepsze praktyki implementacyjne. Ponadto, kompilatory mog dokonywa dodatkowych optymalizacji, gdy u偶ywane s standardowe algorytmy.</p>
            <p><strong>Przykad: Por贸wnanie z Ptl <code>for</code></strong></p>
            <p>Rozwa偶my zliczanie element贸w speniajcych okrelony warunek:</p>
            <p><strong>Tradycyjna ptla <code>for</code>:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">int licznik = 0;
for (size_t i = 0; i &lt; wektor.size(); ++i) {
  if (wektor[i] % 2 == 0) {
      ++licznik;
  }
}</code></pre>
            </div>
            </p>
            <p><strong>U偶ycie <code>std::count_if()</code>:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">int licznik = std::count_if(wektor.begin(), wektor.end(), [](int x) { return x % 2 == 0; });</code></pre>
            </div>
            </p>
            <p>Korzystanie z <code>std::count_if()</code> nie tylko skraca kod, ale r贸wnie偶 zwiksza jego czytelno i potencjalnie wydajno.</p>
        </section>
        <div id="table-of-contents">
            <h2>Spis Treci</h2>
            <ol><a href="#stl-standard-template-library-">STL (Standard Template Library)</a>
                <ol>
                    <li><a href="#kolekcje-w-stl">Kolekcje w STL</a></li>
                    <li><a href="#stl-standard-template-library-">STL (Standard Template Library)</a></li>
                    <li><a href="#kolekcje-w-stl">Kolekcje w STL</a>
                        <ol>
                            <li><a href="#vector">vector</a></li>
                            <li><a href="#list">list</a></li>
                            <li><a href="#map">map</a></li>
                            <li><a href="#unordered_map">unordered_map</a></li>
                            <li><a href="#set">set</a></li>
                            <li><a href="#unordered_set">unordered_set</a></li>
                            <li><a href="#priority_queue">priority_queue</a></li>
                            <li><a href="#queue">queue</a></li>
                            <li><a href="#stack">stack</a></li>
                        </ol>
                    </li>
                    <li><a href="#iteratory">Iteratory</a>
                        <ol>
                            <li><a href="#rodzaje-iterator贸w">Rodzaje iterator贸w</a></li>
                            <li><a href="#podstawowe-operacje-na-iteratorach">Podstawowe operacje na iteratorach</a></li>
                            <li><a href="#przykad-u偶ycia-iteratora">Przykad u偶ycia iteratora</a></li>
                        </ol>
                    </li>
                    <li><a href="#algorytmy-w-standardowej-bibliotece-c-stl-">Algorytmy w Standardowej Bibliotece C++ (STL)</a>
                        <ol>
                            <li><a href="#wprowadzenie-do-algorytm贸w-stl">Wprowadzenie do Algorytm贸w STL</a></li>
                            <li><a href="#klasyfikacja-algorytm贸w">Klasyfikacja Algorytm贸w</a></li>
                            <li><a href="#std-sort-">std::sort()</a></li>
                            <li><a href="#std-find-">std::find()</a></li>
                            <li><a href="#std-for_each-">std::for_each()</a></li>
                            <li><a href="#std-count_if-">std::count_if()</a></li>
                            <li><a href="#inne-wa偶ne-algorytmy">Inne Wa偶ne Algorytmy</a></li>
                            <li><a href="#kompatybilno-z-iteratorami">Kompatybilno z Iteratorami</a></li>
                            <li><a href="#zastosowanie-algorytm贸w-w-praktyce">Zastosowanie Algorytm贸w w Praktyce</a></li>
                            <li><a href="#optymalizacja-za-pomoc-algorytm贸w">Optymalizacja za Pomoc Algorytm贸w</a></li>
                        </ol>
                    </li>
                </ol>
            </ol>
            <div id="related-articles">
                <h2>Related Articles</h2>
                <ol>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/01_proces_kompilacji.html">Proces Kompilacji</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/02_preprocesor.html">Preprocesor</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/03_zmienne_i_typy_danych.html">Zmienne i Typy Danych</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/04_interakcja_z_konsola.html">Interakcja z Konsola</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/05_instrukcja_warunkowa.html">Instrukcja Warunkowa</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/06_petle.html">Petle</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/07_liczby_losowe.html">Liczby Losowe</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/08_typ_wyliczeniowy.html">Typ Wyliczeniowy</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/09_funkcje.html">Funkcje</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/10_l_wartosci_r_wartosci.html">L Wartosci R Wartosci</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/11_wskazniki.html">Wskazniki</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/12_tablice.html">Tablice</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/13_napisy.html">Napisy</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/14_operacje_bitowe.html">Operacje Bitowe</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/15_programowanie_obietkowe.html">Programowanie Obietkowe</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/16_dziedziczenie.html">Dziedziczenie</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/17_zaawansowane_wskazniki.html">Zaawansowane Wskazniki</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/18_przeciazanie.html">Przeciazanie</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/19_konwersje.html">Konwersje</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/20_lambdy.html">Lambdy</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/21_szablony.html">Szablony</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/22_wyjatki.html">Wyjatki</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/23_stl.html">Stl</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/24_praca_z_plikami.html">Praca z Plikami</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/25_c_vs_cpp.html">C vs Cpp</a></li>
                </ol>
            </div>
        </div>
    </div>
    <footer>
        <div class="footer-columns">
            <div class="footer-column">
                <img alt="Adam Djellouli Symbol" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/symbol.png" />
            </div>
            <div class="footer-column">
                <h2><a href="https://adamdjellouli.com/core/privacy_policy.html" title="Privacy Policy">Our Privacy Policy</a></h2>
                <p>
                    Thank you for visiting my personal website. All of the <br />
                    content on this site is free to use, but please remember <br />
                    to be a good human being and refrain from any abuse<br />
                    of the site. If you would like to contact me, please use <br />
                    my <a href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" title="LinkedIn Profile">LinkedIn profile</a> or my <a href="https://github.com/djeada" title="GitHub Profile">GitHub</a> if you have any technical <br />
                    issues or ideas to share. I wish you the best and hope you <br />
                    have a fantastic life. <br />
                </p>
            </div>
            <div class="footer-column">
                <h2>Follow me</h2>
                <ul class="social-media">
                    <li>
                        <a class="fa fa-youtube" href="https://www.youtube.com/channel/UCGPoHTVjMN77wcGknXPHl1Q" target="_blank" title="YouTube">
                        </a>YouTube
                    </li>
                    <li>
                        <a class="fa fa-linkedin" href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" target="_blank" title="LinkedIn">
                        </a>LinkedIn
                    </li>
                    <li>
                        <a class="fa fa-instagram" href="https://www.instagram.com/linuxchallenges/" target="_blank" title="Instagram">
                        </a>Instagram
                    </li>
                    <li>
                        <a class="fa fa-github" href="https://github.com/djeada" title="GitHub">
                        </a>Github
                    </li>
                </ul>
            </div>
        </div>
        <div>
            <p id="copyright">
                漏 Adam Djellouli. All rights reserved.
            </p>
        </div>
        <script>
            document.getElementById("copyright").innerHTML = "&copy; " + new Date().getFullYear() + " Adam Djellouli. All rights reserved.";
        </script>
        <script src="../../app.js"></script>
    </footer>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-bash.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-cpp.min.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
jax: ["input/TeX", "output/HTML-CSS"],
extensions: ["tex2jax.js"],
"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] },
tex2jax: { inlineMath: [ ["$", "$"] ], displayMath: [ ["$$","$$"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
TeX: { noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } } },
messageStyle: "none"
});
</script>
<script async="" id="MathJax-script" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>

</html>