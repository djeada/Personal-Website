<!DOCTYPE html>

<html lang="pl">

<head>
    <script async="" crossorigin="anonymous" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5593122079896089"></script>
    <meta charset="utf-8" />
    <title>Programowanie Obiektowe</title>
    <meta content="Programowanie obiektowe (ang." name="description" />
    <meta content="Adam Djellouli" name="author" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <meta content="IE=edge" http-equiv="X-UA-Compatible" />
    <link crossorigin="" href="https://fonts.googleapis.com" rel="preconnect" />
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/icon.ico" rel="icon" />
    <link href="../../resources/style.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
</head>

<body>
    <nav aria-label="Main navigation">
        <a class="logo" href="https://adamdjellouli.com">
            <img alt="Adam Djellouli - Home Page Logo" id="logo-image" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/logo.PNG" />
        </a>
        <input aria-label="Toggle navigation menu" id="navbar-toggle" type="checkbox" />
        <ul aria-labelledby="navbar-toggle" role="menu">
            <li role="menuitem">
                <a href="../../index.html" title="Go to Home Page"> Home </a>
            </li>
            <li role="menuitem">
                <a class="active" href="../../core/blog.html" title="Read Adam Djellouli Blog on Programming and Technology"> Blog </a>
            </li>
            <li role="menuitem">
                <a href="../../core/tools.html" title="Discover Tools Created by Adam Djellouli"> Tools </a>
            </li>
            <li role="menuitem">
                <a href="../../core/projects.html" title="Explore Projects Developed by Adam Djellouli"> Projects </a>
            </li>
            <li role="menuitem">
                <a href="../../core/resume.html" title="View Adam Djellouli Professional Resume"> Resume </a>
            </li>
            <li>
                <script async="" src="https://cse.google.com/cse.js?cx=8160ef9bb935f4f68"></script>
                <div class="gcse-search"></div>
            </li>
            <li>
                <button aria-label="Toggle dark mode" id="dark-mode-button"></button>
            </li>
        </ul>
    </nav>
    <div id="article-wrapper">
        <section id="article-body">
            <div class="article-action-buttons"><button class="btn-suggest-edit" title="Suggest Edit">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <path d="M4 21h4l11-11-4-4L4 17v4z" stroke="currentColor" stroke-width="2"></path>
                    </svg>
                </button><button class="btn-create-issue" title="Create Issue">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2"></circle>
                        <line stroke="currentColor" stroke-width="2" x1="12" x2="12" y1="8" y2="12"></line>
                        <circle cx="12" cy="16" fill="currentColor" r="1"></circle>
                    </svg>
                </button><button class="btn-download" title="Download">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <path d="M12 5v14m0 0l-6-6m6 6l6-6" stroke="currentColor" stroke-width="2"></path>
                    </svg>
                </button></div>
            <p style="text-align: right;"><i>Last modified: January 21, 2020</i></p>
            <p style="text-align: right;"><i>This article is written in: 🇵🇱</i></p>
            <h2 id="programowanie-obiektowe">Programowanie Obiektowe</h2>
            <p>Programowanie obiektowe (ang. <strong>Object-Oriented Programming</strong>, OOP) to obecnie jeden z najważniejszych i najpowszechniej stosowanych paradygmatów w inżynierii oprogramowania. Jego główne założenie polega na tym, aby w procesie tworzenia oprogramowania dzielić skomplikowane problemy na mniejsze, łatwiejsze do zrozumienia fragmenty, które reprezentujemy w postaci <strong>obiektów</strong>. Takie podejście prowadzi do tworzenia bardziej modularnych, czytelnych i łatwiejszych w utrzymaniu aplikacji, zwłaszcza w dużych projektach programistycznych. </p>
            <p>W języku C++ idea obiektowości jest mocno zakorzeniona; klasa czy obiekt to pojęcia pierwszoplanowe. Dzięki temu możliwe jest wykorzystanie takich mechanizmów jak dziedziczenie, polimorfizm czy enkapsulacja, co z kolei pozwala na efektywną organizację kodu. W niniejszych notatkach omówimy fundamentalne aspekty programowania obiektowego w C++ – od klas, obiektów i konstruktorów, przez destruktory, poziomy dostępu, aż po wskaźniki na obiekty i mechanizmy takie jak <strong>przeciążanie operatorów</strong>, <strong>pola statyczne</strong>, <strong>funkcje zaprzyjaźnione</strong>, <strong>struktury</strong>, <strong>unie</strong> i <strong>pola bitowe</strong>. </p>
            <p>Dzięki temu zestawowi informacji będziesz w stanie zrozumieć, jak poprawnie definiować klasy i obiekty w C++, jak zarządzać ich cyklem życia (tworzenie i usuwanie), oraz jakie są zasady rządzące dostępem do prywatnych (i chronionych) składników. Dodatkowo przekonasz się, jak można nadawać operatorom nowe znaczenia, jakie korzyści daje stosowanie pól i metod statycznych, a także kiedy warto sięgnąć po struktury, unie i pola bitowe.</p>
            <h3 id="klasy-i-obiekty">Klasy i Obiekty</h3>
            <p><strong>Klasa</strong> to szablon definiujący strukturę i zachowanie obiektów, czyli zbiór pól (przechowujących dane) oraz metod (zapewniających zestaw operacji na tych danych). <strong>Obiekt</strong> to konkretny egzemplarz (instancja) klasy, posiadający własny stan, zależny od wartości pól. W C++ deklarację klasy rozpoczynamy słowem kluczowym <code>class</code> wraz z nazwą klasy, po której następują sekcje określające modyfikatory dostępu (<code>public</code>, <code>private</code>, <code>protected</code>) i odpowiadające im pola oraz metody.</p>
            <p><strong>Przykład prostej klasy</strong></p>
            <p>Poniższy przykład prezentuje klasę <code>Prostokat</code>, która posiada dwa pola (długości boków <code>a</code> i <code>b</code>), a także metodę <code>pole()</code> służącą do wyliczania pola prostokąta:</p>
            <p>
            <div>
                <pre><code class="language-clike">class Prostokat {
private:
  int a;
  int b;

public:

  Prostokat(int a, int b) : a(a), b(b) {}

  int pole() const { 
    return a * b; 

  }

};</code></pre>
            </div>
            </p>
            <p>Możemy następnie tworzyć obiekty tej klasy i korzystać z metod, np.:</p>
            <p>
            <div>
                <pre><code class="language-clike">Prostokat p(3, 4);
std::cout &lt;&lt; p.pole() &lt;&lt; std::endl; // Wyświetli: 12</code></pre>
            </div>
            </p>
            <p><strong>Zalety</strong> tworzenia klas i obiektów:</p>
            <ul>
                <li>Kod staje się <strong>bardziej zorganizowany</strong> – różne elementy aplikacji mają swoje odpowiedzialności.</li>
                <li>Umożliwia tworzenie <strong>wielu obiektów</strong> na podstawie jednego projektu (klasy), przy czym każdy obiekt może mieć własny, unikalny stan.</li>
                <li>Zapewnia duże możliwości rozbudowy i modyfikacji kodu bez naruszania innych jego części.</li>
            </ul>
            <h3 id="dlaczego-programowanie-obiektowe-">Dlaczego Programowanie Obiektowe?</h3>
            <p>Programowanie obiektowe wyróżnia się spośród innych paradygmatów (np. proceduralnego, funkcyjnego) przede wszystkim koncentracją na <strong>modelowaniu rzeczywistości</strong> za pomocą obiektów odzwierciedlających elementy świata lub abstrakcyjne koncepty. Do najważniejszych zalet należą:</p>
            <ol>
                <li><strong>Enkapsulacja</strong> (ang. <em>encapsulation</em>) – łączenie danych i metod w klasach oraz ukrywanie informacji wewnątrz obiektów. Zapobiega to bezpośredniej manipulacji stanem obiektu przez zewnętrzny kod, co ułatwia zachowanie spójności danych.</li>
                <li><strong>Reużywalność kodu</strong> (ang. <em>reusability</em>) – raz zdefiniowana klasa może być wykorzystywana w różnych częściach projektu, a także w innych projektach. Sprzyja to oszczędności czasu i nakładu pracy.</li>
                <li><strong>Modularność</strong> – rozbijanie problemu na mniejsze, bardziej zrozumiałe elementy. Każda klasa odpowiada za precyzyjnie zdefiniowaną część funkcjonalności.</li>
                <li><strong>Polimorfizm</strong> – możliwość tworzenia interfejsów, które są implementowane w różny sposób przez różne klasy pochodne. Ułatwia to rozbudowę i modyfikację istniejącego kodu.</li>
                <li><strong>Dziedziczenie</strong> – tworzenie nowych klas na bazie już istniejących, przy zachowaniu i możliwościach rozszerzania ich funkcjonalności. Sprzyja hierarchizacji i ponownemu wykorzystaniu wspólnych fragmentów.</li>
            </ol>
            <h3 id="konstruktory">Konstruktory</h3>
            <p>Konstruktory to specjalne metody wywoływane <strong>automatycznie</strong> w chwili tworzenia nowego obiektu klasy. Odpowiadają za <strong>inicjalizację</strong> pól i przygotowanie obiektu do użycia. Wyróżniamy kilka rodzajów konstruktorów:</p>
            <ul>
                <li><strong>Konstruktor domyślny</strong> – nie przyjmuje argumentów; tworzy obiekt z założonymi wartościami początkowymi.</li>
                <li><strong>Konstruktor z parametrami</strong> – pozwala przekazać wartości początkowe dla pól. </li>
                <li><strong>Konstruktor kopiujący</strong> – tworzy nowy obiekt będący kopią już istniejącego obiektu tej samej klasy.</li>
                <li><strong>Konstruktor przenoszący</strong> – optymalizuje proces tworzenia obiektu z innego, tymczasowego obiektu, zwłaszcza gdy obiekt zarządza <strong>zasobami dynamicznymi</strong> (np. dużą tablicą w pamięci).</li>
            </ul>
            <p><strong>Przykład klas z różnymi konstruktorami</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">class Prostokat {
private:
  int a;
  int b;

public:

  // Konstruktor domyślny

  Prostokat() : a(1), b(1) {} 

  // Konstruktor z parametrami

  Prostokat(int a, int b) : a(a), b(b) {}

  // Konstruktor kopiujący

  Prostokat(const Prostokat &amp;p) : a(p.a), b(p.b) {}

  // Konstruktor przenoszący

  Prostokat(Prostokat &amp;&amp;p) : a(p.a), b(p.b) {
    p.a = 0;
    p.b = 0;

  }

};</code></pre>
            </div>
            </p>
            <p>W powyższym przykładzie pokazano wszystkie cztery rodzaje konstruktorów. Dzięki nim możemy tworzyć obiekty zarówno z domyślnymi wartościami (np. <code>(1,1)</code>), jak i z wartościami przekazanymi podczas tworzenia, a także kopiować i przenosić obiekty w bardziej zaawansowanych scenariuszach.</p>
            <h3 id="destruktor">Destruktor</h3>
            <p>Destruktor to specjalna metoda klasy, wywoływana <strong>automatycznie</strong> w momencie niszczenia obiektu, np. gdy wychodzi on poza zakres widoczności lub gdy używamy operatora <code>delete</code>. Jej nazwa pokrywa się z nazwą klasy, ale jest poprzedzona znakiem <code>~</code> (tylda). Głównym zadaniem destruktora jest <strong>zwalnianie zasobów</strong> przydzielonych w trakcie życia obiektu oraz wykonywanie innych niezbędnych operacji porządkowych.</p>
            <p><strong>Przykład użycia destruktora</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">class Prostokat {
private:
  int a;
  int b;

public:
  Prostokat(int a, int b) : a(a), b(b) {}

  ~Prostokat() { 
    std::cout &lt;&lt; "Destruktor wywołany" &lt;&lt; std::endl; 
  }
};

int main() {
  {
    Prostokat p(2,3);
    // W tym bloku p istnieje 
  }
  // Po zakończeniu bloku p zostaje zniszczony i wywołany destruktor
  return 0;
}</code></pre>
            </div>
            </p>
            <p>Gdy obiekt <code>p</code> zostanie zniszczony, na ekranie zostanie wyświetlony komunikat. W sytuacjach, kiedy klasa zarządza zasobami (np. pamięcią dynamicznie przydzieloną przez <code>new</code>), w destruktorze należy zadbać o ich prawidłowe zwolnienie.</p>
            <h3 id="poziomy-dostępu-w-klasie">Poziomy Dostępu w Klasie</h3>
            <p>W C++ dostęp do członków klasy (pól i metod) regulują trzy modyfikatory:</p>
            <p>I. <strong>public</strong> </p>
            <p>Składniki publiczne są dostępne dla wszystkich, również spoza klasy. Zazwyczaj deklarujemy tutaj metody, które tworzą zewnętrzny interfejs klasy (np. <code>pole()</code>).</p>
            <p>II. <strong>private</strong> </p>
            <p>Składniki prywatne są dostępne wyłącznie dla metod wewnątrz tej samej klasy (oraz dla funkcji zaprzyjaźnionych). Używamy tego poziomu, by ukryć „wnętrzności” klasy przed kodem zewnętrznym.</p>
            <p>III. <strong>protected</strong> </p>
            <p>Składniki chronione są widoczne w klasie bazowej i wszystkich klasach pochodnych (w dziedziczeniu), lecz nie są dostępne dla innych klas czy funkcji spoza hierarchii dziedziczenia.</p>
            <p>Domyślnie, jeśli nie określimy modyfikatora, składniki klasy w C++ są <strong>prywatne</strong>. </p>
            <p><strong>Przykład ilustrujący poziomy dostępu</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">class Prostokat {
private:
  int a;
  int b;

public:

  Prostokat(int a, int b) : a(a), b(b) {}

  int pole() const { 
    return a * b; 

  }

};

int main() {

  Prostokat prostokat(2, 3);
  std::cout &lt;&lt; prostokat.pole() &lt;&lt; std::endl; // OK, metoda publiczna

  // std::cout &lt;&lt; prostokat.a &lt;&lt; std::endl;  // Błąd! 'a' jest prywatne
  return 0;

}</code></pre>
            </div>
            </p>
            <p>Powyższy przykład obrazuje, że do <code>pole()</code> mamy pełny dostęp, natomiast bezpośrednie odczytanie pola <code>a</code> jest niemożliwe spoza klasy.</p>
            <h3 id="wskaźnik-na-obiekt">Wskaźnik na Obiekt</h3>
            <p>Wskaźniki (ang. <em>pointers</em>) to jeden z podstawowych elementów C++. Możemy za ich pomocą stworzyć wskaźnik na obiekt konkretnej klasy. Umożliwia to m.in. dynamiczne tworzenie obiektów w trakcie działania programu, przekazywanie obiektów do funkcji „po referencji” czy zarządzanie tablicami obiektów.</p>
            <p><strong>Przykład wykorzystania wskaźnika</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;

class Foo {
private:
  int bar;

public:
  Foo() : bar(0) {}

  void setBar(int value) { 
    bar = value; 
  }
  int getBar() const { 
    return bar; 
  }
};

int main() {
  Foo fooInstance;
  Foo* fooPointer = &amp;fooInstance  // wskaźnik na istniejący obiekt
  
  fooPointer-&gt;setBar(10);
  std::cout &lt;&lt; fooPointer-&gt;getBar() &lt;&lt; std::endl; // Wyświetli 10

  return 0;
}</code></pre>
            </div>
            </p>
            <p>W powyższym kodzie operator <code>-&gt;</code> pozwala wywołać metodę <code>setBar()</code> i odczytać wartość <code>getBar()</code> na obiekcie wskazywanym przez <code>fooPointer</code>. Wskaźniki pozwalają także na manualne zarządzanie pamięcią, np. przy użyciu operatora <code>new</code>.</p>
            <h3 id="przeciążanie-operatorów">Przeciążanie Operatorów</h3>
            <p>Przeciążanie operatorów (ang. <em>operator overloading</em>) umożliwia zdefiniowanie, jak dany <strong>operator</strong> (np. <code>+</code>, <code>-</code>, <code>*</code>, <code>==</code>, <code>&lt;&lt;</code>, <code>()</code>, <code>[]</code>) powinien zachować się w kontekście obiektów naszej klasy. W efekcie możemy pisać kod bliższy naturalnej notacji matematycznej lub poprawiający czytelność.</p>
            <p><strong>Przykład przeciążenia operatora <code>+</code></strong></p>
            <p>
            <div>
                <pre><code class="language-clike">class Prostokat {
private:
  int a;
  int b;

public:

  Prostokat(int width, int height) : a(width), b(height) {}

  // Przeciążenie operatora +

  Prostokat operator+(const Prostokat &amp;other) const {
    return Prostokat(a + other.a, b + other.b);

  }

  void display() const {
    std::cout &lt;&lt; "Prostokat(" &lt;&lt; a &lt;&lt; ", " &lt;&lt; b &lt;&lt; ")" &lt;&lt; std::endl;

  }

};

int main() {

  Prostokat rect1(2, 3);

  Prostokat rect2(4, 5);

  Prostokat rectSum = rect1 + rect2;
  rectSum.display();  // Wyświetli: Prostokat(6, 8)

  return 0;

}</code></pre>
            </div>
            </p>
            <p>Dzięki przeciążeniu operatora <code>+</code>, zapis <code>rect1 + rect2</code> staje się intuicyjny, a jednocześnie zwraca nowy obiekt o odpowiednio obliczonych wymiarach.</p>
            <h3 id="pola-i-metody-statyczne">Pola i Metody Statyczne</h3>
            <p>Pola i metody <strong>statyczne</strong> (ang. <em>static</em>) związane są z całą klasą, a nie z konkretnymi jej egzemplarzami. Oznacza to, że istnieje <strong>jedna wspólna kopia</strong> takiego pola dla wszystkich obiektów danej klasy. Metody statyczne mogą być wywoływane niezależnie od istnienia konkretnych instancji, używając składni <code>NazwaKlasy::nazwaMetody()</code>.</p>
            <p><strong>Przykład pola statycznego liczącego obiekty</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;

class Prostokat {
private:
  static int liczbaProstokatow; // Statyczne pole klasy

public:
  Prostokat() { 
    liczbaProstokatow++; 
  }
  ~Prostokat() { 
    liczbaProstokatow--; 
  }

  static int getLiczbaProstokatow() { 
    return liczbaProstokatow; 
  }
};

// Inicjalizacja pola statycznego
int Prostokat::liczbaProstokatow = 0;

int main() {
  {
    Prostokat p1;
    Prostokat p2;
    Prostokat p3;
    std::cout &lt;&lt; "Aktualna liczba obiektów: "
              &lt;&lt; Prostokat::getLiczbaProstokatow() &lt;&lt; std::endl;  // 3
  }
  std::cout &lt;&lt; "Aktualna liczba obiektów: "
            &lt;&lt; Prostokat::getLiczbaProstokatow() &lt;&lt; std::endl;    // 0

  return 0;
}</code></pre>
            </div>
            </p>
            <p>Dzięki polom statycznym możemy łatwo śledzić, ile obiektów danej klasy zostało stworzonych w danej chwili. W niektórych zastosowaniach (np. zarządzanie ograniczonymi zasobami) taka informacja może być kluczowa.</p>
            <h3 id="funkcje-zaprzyjaźnione">Funkcje Zaprzyjaźnione</h3>
            <p><strong>Funkcje zaprzyjaźnione</strong> (ang. <em>friend functions</em>) to funkcje lub całe klasy, którym dana klasa „ufa” na tyle, że zezwala im na dostęp do swoich <strong>prywatnych</strong> i <strong>chronionych</strong> pól i metod. Stosuje się je w sytuacjach, gdy dwie (lub więcej) struktur danych muszą bardzo ściśle ze sobą współpracować albo gdy potrzebna jest specjalna funkcja naruszająca normalne reguły enkapsulacji, ale nadal mająca uzasadnienie projektowe.</p>
            <p><strong>Przykład funkcji zaprzyjaźnionej <code>swap</code></strong></p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;

class Prostokat {
private:
  int a;
  int b;

public:

  Prostokat(int width, int height) : a(width), b(height) {}

  // Deklaracja funkcji zaprzyjaźnionej
  friend void swap(Prostokat &amp;p1, Prostokat &amp;p2);

};

void swap(Prostokat &amp;p1, Prostokat &amp;p2) {
  std::swap(p1.a, p2.a);
  std::swap(p1.b, p2.b);

}

int main() {

  Prostokat p1(1, 2);

  Prostokat p2(3, 4);
  swap(p1, p2);

  // Aby potwierdzić zamianę, można by dodać metody getA() czy getB() i je wywołać
  return 0;

}</code></pre>
            </div>
            </p>
            <p>W powyższym kodzie funkcja <code>swap</code> może bezpośrednio modyfikować prywatne pola <code>a</code> i <code>b</code>, ponieważ klasa <code>Prostokat</code> zadeklarowała ją jako zaprzyjaźnioną. </p>
            <h3 id="struktury">Struktury</h3>
            <p>W C++ <strong>struktura</strong> (ang. <em>struct</em>) jest bardzo zbliżona do klasy. Kluczowa różnica polega na tym, że domyślny poziom dostępu w strukturze to <strong>public</strong>, a w klasie – <strong>private</strong>. Struktury, podobnie jak klasy, mogą zawierać zarówno pola, jak i metody czy konstruktory.</p>
            <h4 id="struktury-w-stylu-c">Struktury w stylu C</h4>
            <p>W języku C, <code>struct</code> służyła głównie do grupowania danych. Przykład:</p>
            <p>
            <div>
                <pre><code class="language-clike">struct Foo {
  int bar;
};

int main() {
  struct Foo foo;
  foo.bar = 10;
  return 0;
}</code></pre>
            </div>
            </p>
            <h4 id="struktury-w-c-">Struktury w C++</h4>
            <p>W C++ struktura może wyglądać i zachowywać się niemal tak samo jak klasa:</p>
            <p>
            <div>
                <pre><code class="language-clike">struct Foo {
  int bar;

  Foo(int val) : bar(val) {}
  void wyswietl() {
    std::cout &lt;&lt; bar &lt;&lt; std::endl;

  }

};

int main() {

  Foo obiekt_foo(10);
  obiekt_foo.wyswietl();  // Wyświetli 10
  return 0;

}</code></pre>
            </div>
            </p>
            <p>Z racji braku domyślnego <code>private</code>, struktury są często stosowane jako <strong>agregaty danych</strong> (tzn. publiczne „paczki” informacji), natomiast do bardziej zaawansowanego modelowania z reguły wybierane są klasy.</p>
            <h3 id="unie">Unie</h3>
            <p><strong>Unie</strong> (ang. <em>unions</em>) to szczególny typ danych, w którym wszystkie pola współdzielą ten sam obszar pamięci. Przeznaczone są do sytuacji, w których w jednym miejscu przechowujemy kilka typów danych, ale w danym momencie aktywne jest tylko jedno z tych pól. Umożliwiają oszczędność pamięci, ale trzeba ostrożnie z nich korzystać, ponieważ zapis do jednego pola „nadpisuje” pamięć używaną przez pozostałe pola.</p>
            <p><strong>Przykład unii</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;

union Przyklad {
  int a;
  float b;
};

int main() {
  Przyklad unia;
  unia.a = 10;
  std::cout &lt;&lt; unia.a &lt;&lt; std::endl; // 10

  unia.b = 3.14;
  std::cout &lt;&lt; unia.b &lt;&lt; std::endl; // 3.14
  // unia.a jest teraz niezdefiniowana

  return 0;
}</code></pre>
            </div>
            </p>
            <p>Po zapisaniu wartości do <code>unia.b</code> nie możemy liczyć na to, że <code>unia.a</code> będzie zachowywać dotychczasową wartość. Ten sam obszar pamięci służy aktualnie do przechowywania liczby zmiennoprzecinkowej.</p>
            <h3 id="pola-bitowe">Pola Bitowe</h3>
            <p><strong>Pola bitowe</strong> (ang. <em>bit fields</em>) to cecha języka C i C++, umożliwiająca zdefiniowanie w strukturze lub klasie pól zajmujących ściśle określoną liczbę bitów. Umożliwia to wydajniejsze wykorzystanie pamięci w sytuacjach, gdy pola mogą przyjmować jedynie ograniczony zakres wartości.</p>
            <p><strong>Przykład pól bitowych</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;

struct Data {
  unsigned int Rok : 13;    // Zakres: 0–8191
  unsigned int Miesiac : 4; // Zakres: 0–15
  unsigned int Dzien : 5;   // Zakres: 0–31

};

void wypiszDate(const Data&amp; d) {
  std::cout &lt;&lt; "Mamy dziś: " 

            &lt;&lt; d.Dzien &lt;&lt; "-" 

            &lt;&lt; d.Miesiac &lt;&lt; "-" 

            &lt;&lt; d.Rok &lt;&lt; std::endl;

}

int main() {

  Data d;
  d.Rok = 2023;
  d.Miesiac = 8;
  d.Dzien = 17;

  wypiszDate(d); // Wyświetli: Mamy dziś: 17-8-2023
  return 0;

}</code></pre>
            </div>
            </p>
            <p>Tutaj <code>Rok</code> zajmuje tylko 13 bitów, <code>Miesiac</code> – 4, a <code>Dzien</code> – 5, co w zupełności wystarcza, aby przechowywać rok z pewnego przedziału, miesiąc (1–12) i dzień (1–31). To rozwiązanie jest szczególnie przydatne w systemach wbudowanych lub w sytuacjach, w których liczy się każda jednostka pamięci.</p>
        </section>
        <div id="table-of-contents">
            <h2>Spis Treści</h2>
            <ol><a href="#programowanie-obiektowe">Programowanie Obiektowe</a>
                <ol>
                    <li><a href="#klasy-i-obiekty">Klasy i Obiekty</a></li>
                    <li><a href="#dlaczego-programowanie-obiektowe-">Dlaczego Programowanie Obiektowe?</a></li>
                    <li><a href="#konstruktory">Konstruktory</a></li>
                    <li><a href="#destruktor">Destruktor</a></li>
                    <li><a href="#poziomy-dostępu-w-klasie">Poziomy Dostępu w Klasie</a></li>
                    <li><a href="#wskaźnik-na-obiekt">Wskaźnik na Obiekt</a></li>
                    <li><a href="#przeciążanie-operatorów">Przeciążanie Operatorów</a></li>
                    <li><a href="#pola-i-metody-statyczne">Pola i Metody Statyczne</a></li>
                    <li><a href="#funkcje-zaprzyjaźnione">Funkcje Zaprzyjaźnione</a></li>
                    <li><a href="#struktury">Struktury</a>
                        <ol>
                            <li><a href="#struktury-w-stylu-c">Struktury w stylu C</a></li>
                            <li><a href="#struktury-w-c-">Struktury w C++</a></li>
                        </ol>
                    </li>
                    <li><a href="#unie">Unie</a></li>
                    <li><a href="#pola-bitowe">Pola Bitowe</a></li>
                </ol>
            </ol>
            <div id="related-articles">
                <h2>Related Articles</h2>
                <ol>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/01_proces_kompilacji.html">Proces Kompilacji</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/02_preprocesor.html">Preprocesor</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/03_zmienne_i_typy_danych.html">Zmienne i Typy Danych</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/04_interakcja_z_konsola.html">Interakcja z Konsola</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/05_instrukcja_warunkowa.html">Instrukcja Warunkowa</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/06_petle.html">Petle</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/07_liczby_losowe.html">Liczby Losowe</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/08_typ_wyliczeniowy.html">Typ Wyliczeniowy</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/09_funkcje.html">Funkcje</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/10_l_wartosci_r_wartosci.html">L Wartosci R Wartosci</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/11_wskazniki.html">Wskazniki</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/12_tablice.html">Tablice</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/13_napisy.html">Napisy</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/14_operacje_bitowe.html">Operacje Bitowe</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/15_programowanie_obietkowe.html">Programowanie Obietkowe</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/16_dziedziczenie.html">Dziedziczenie</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/17_zaawansowane_wskazniki.html">Zaawansowane Wskazniki</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/18_przeciazanie.html">Przeciazanie</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/19_konwersje.html">Konwersje</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/20_lambdy.html">Lambdy</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/21_szablony.html">Szablony</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/22_wyjatki.html">Wyjatki</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/23_stl.html">Stl</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/24_praca_z_plikami.html">Praca z Plikami</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/25_c_vs_cpp.html">C vs Cpp</a></li>
                </ol>
            </div>
        </div>
    </div>
    <footer>
        <div class="footer-columns">
            <div class="footer-column">
                <img alt="Adam Djellouli Symbol" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/symbol.png" />
            </div>
            <div class="footer-column">
                <h2><a href="https://adamdjellouli.com/core/privacy_policy.html" title="Privacy Policy">Our Privacy Policy</a></h2>
                <p>Thank you for visiting my personal website. All content here is free to use, but please remember to be respectful and avoid any misuse of the site. If you’d like to get in touch, feel free to reach out via my <a href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" title="LinkedIn Profile">LinkedIn profile</a> or connect with me on <a href="https://github.com/djeada" title="GitHub Profile">GitHub</a> if you have technical questions or ideas to share. Wishing you all the best and a fantastic life ahead!</p>
            </div>
            <div class="footer-column">
                <h2>Follow me</h2>
                <ul class="social-media">
                    <li>
                        <a class="fa fa-youtube" href="https://www.youtube.com/channel/UCGPoHTVjMN77wcGknXPHl1Q" target="_blank" title="YouTube">
                        </a>YouTube
                    </li>
                    <li>
                        <a class="fa fa-linkedin" href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" target="_blank" title="LinkedIn">
                        </a>LinkedIn
                    </li>
                    <li>
                        <a class="fa fa-instagram" href="https://www.instagram.com/linuxchallenges/" target="_blank" title="Instagram">
                        </a>Instagram
                    </li>
                    <li>
                        <a class="fa fa-github" href="https://github.com/djeada" title="GitHub">
                        </a>Github
                    </li>
                </ul>
            </div>
        </div>
        <div>
            <p id="copyright">
                © Adam Djellouli. All rights reserved.
            </p>
        </div>
        <script>
            document.getElementById("copyright").innerHTML = "&copy; " + new Date().getFullYear() + " Adam Djellouli. All rights reserved.";
        </script>
        <script src="../../app.js"></script>
    </footer>
    <div id="pdf-spinner-overlay">
        <div class="spinner"></div>
    </div>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-bash.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-cpp.min.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
jax: ["input/TeX", "output/HTML-CSS"],
extensions: ["tex2jax.js"],
"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] },
tex2jax: { inlineMath: [ ["$", "$"] ], displayMath: [ ["$$","$$"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
TeX: { noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } } },
messageStyle: "none"
});
</script>
<script async="" id="MathJax-script" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>

</html>