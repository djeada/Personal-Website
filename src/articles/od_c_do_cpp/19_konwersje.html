<!DOCTYPE html>

<html lang="pl">

<head>
    <script async="" crossorigin="anonymous" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5593122079896089"></script>
    <meta charset="utf-8" />
    <title>Konwersje</title>
    <meta content="Konwersje typów danych są kluczowym elementem programowania zarówno w języku C, jak i C++." name="description" />
    <meta content="Adam Djellouli" name="author" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <meta content="IE=edge" http-equiv="X-UA-Compatible" />
    <link crossorigin="" href="https://fonts.googleapis.com" rel="preconnect" />
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/icon.ico" rel="icon" />
    <link href="../../resources/style.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
</head>

<body>
    <nav aria-label="Main navigation">
        <a class="logo" href="https://adamdjellouli.com">
            <img alt="Adam Djellouli - Home Page Logo" id="logo-image" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/logo.PNG" />
        </a>
        <input aria-label="Toggle navigation menu" id="navbar-toggle" type="checkbox" />
        <ul aria-labelledby="navbar-toggle" role="menu">
            <li role="menuitem">
                <a href="../../index.html" title="Go to Home Page"> Home </a>
            </li>
            <li role="menuitem">
                <a class="active" href="../../core/blog.html" title="Read Adam Djellouli Blog on Programming and Technology"> Blog </a>
            </li>
            <li role="menuitem">
                <a href="../../core/tools.html" title="Discover Tools Created by Adam Djellouli"> Tools </a>
            </li>
            <li role="menuitem">
                <a href="../../core/projects.html" title="Explore Projects Developed by Adam Djellouli"> Projects </a>
            </li>
            <li role="menuitem">
                <a href="../../core/resume.html" title="View Adam Djellouli Professional Resume"> Resume </a>
            </li>
            <li>
                <script async="" src="https://cse.google.com/cse.js?cx=8160ef9bb935f4f68"></script>
                <div class="gcse-search"></div>
            </li>
            <li>
                <button aria-label="Toggle dark mode" id="dark-mode-button"></button>
            </li>
        </ul>
    </nav>
    <div id="article-wrapper">
        <section id="article-body">
            <div class="article-action-buttons"><button class="btn-suggest-edit" title="Suggest Edit">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <path d="M4 21h4l11-11-4-4L4 17v4z" stroke="currentColor" stroke-width="2"></path>
                    </svg>
                </button><button class="btn-create-issue" title="Create Issue">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2"></circle>
                        <line stroke="currentColor" stroke-width="2" x1="12" x2="12" y1="8" y2="12"></line>
                        <circle cx="12" cy="16" fill="currentColor" r="1"></circle>
                    </svg>
                </button><button class="btn-download" title="Download">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <path d="M12 5v14m0 0l-6-6m6 6l6-6" stroke="currentColor" stroke-width="2"></path>
                    </svg>
                </button></div>
            <p style="text-align: right;"><i>Last modified: June 02, 2020</i></p>
            <p style="text-align: right;"><i>This article is written in: 🇵🇱</i></p>
            <h2 id="konwersje">Konwersje</h2>
            <p>Konwersje typów danych są kluczowym elementem programowania zarówno w języku C, jak i C++. Pozwalają na przekształcanie wartości jednego typu na inny, co jest niezbędne w wielu sytuacjach, takich jak operacje arytmetyczne między różnymi typami, interakcja z funkcjami bibliotecznymi czy manipulacja danymi na niskim poziomie. Chociaż podstawowe mechanizmy konwersji są dostępne w obu językach, C++ wprowadza bardziej zaawansowane i bezpieczne narzędzia. Zrozumienie różnic między konwersjami w C i C++ oraz umiejętne ich stosowanie jest kluczowe dla pisania efektywnego i bezpiecznego kodu.</p>
            <h3 id="rzutowanie-w-c">Rzutowanie w C</h3>
            <p>Rzutowanie w języku C jest mechanizmem pozwalającym na jawne przekształcenie jednej wartości na inny typ danych. Jest to szczególnie przydatne, gdy chcemy wymusić określone zachowanie kompilatora lub gdy pracujemy z interfejsami wymagającymi konkretnych typów danych. Jednak niewłaściwe użycie rzutowania może prowadzić do nieoczekiwanych rezultatów, trudnych do wykrycia błędów oraz niezdefiniowanego zachowania programu. Dlatego ważne jest zrozumienie zasad i ograniczeń rzutowania w C.</p>
            <h4 id="podstawowe-rzutowanie">Podstawowe rzutowanie</h4>
            <p>Podstawowe rzutowanie w C pozwala na konwersję między typami arytmetycznymi, takimi jak <code>int</code>, <code>float</code>, <code>double</code>, <code>char</code> itp. Rzutowanie może być wykorzystywane do:</p>
            <ul>
                <li>Konwersji między typami całkowitymi i zmiennoprzecinkowymi, np. z <code>int</code> na <code>double</code>.</li>
                <li>Zmiany rozmiaru typu, np. z <code>int</code> na <code>short</code>.</li>
                <li>Wymuszenia określonego typu w operacjach arytmetycznych, aby uniknąć automatycznej promocji typów.</li>
            </ul>
            <p>Ogólny schemat rzutowania:</p>
            <p>
            <div>
                <pre><code class="language-clike">(typ_docelowy)wartość;</code></pre>
            </div>
            </p>
            <p><strong>Przykład rzutowania zmiennej typu <code>int</code> na <code>double</code>:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">int a = 10;
double b = (double)a;</code></pre>
            </div>
            </p>
            <p>W tym przypadku wartość zmiennej <code>a</code> jest konwertowana na typ <code>double</code> i przypisywana do zmiennej <code>b</code>. Ponieważ konwersja z <code>int</code> na <code>double</code> jest poszerzająca (ang. <em>widening conversion</em>), nie występuje utrata danych.</p>
            <p><strong>Przykład rzutowania z utratą danych:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">double x = 3.14159;
int y = (int)x;  // y będzie równe 3</code></pre>
            </div>
            </p>
            <p>Tutaj część ułamkowa liczby <code>x</code> zostaje odrzucona, co może prowadzić do błędów, jeśli nie jest to zamierzone działanie.</p>
            <h5>Zasady konwersji arytmetycznych</h5>
            <ul>
                <li>Typy takie jak <code>char</code> i <code>short</code> są automatycznie promowane do <code>int</code> podczas operacji arytmetycznych.</li>
                <li>W operacjach mieszanych typ całkowity jest konwertowany na zmiennoprzecinkowy.</li>
                <li>W operacjach z udziałem różnych typów zmiennoprzecinkowych (<code>float</code>, <code>double</code>, <code>long double</code>), niższy typ jest konwertowany na wyższy.</li>
            </ul>
            <h5>Potencjalne problemy</h5>
            <ul>
                <li>Rzutowanie z typu o większym zakresie do typu o mniejszym zakresie może prowadzić do utraty danych.</li>
                <li>Przy konwersjach między typami o różnych zakresach wartości może dojść do przepełnienia lub niedomiaru, co skutkuje niezdefiniowanym zachowaniem.</li>
                <li>Rzutowanie między typami ze znakiem i bez znaku (<code>signed</code> i <code>unsigned</code>) może prowadzić do nieoczekiwanych wyników.</li>
            </ul>
            <p><strong>Zalecenia:</strong></p>
            <ul>
                <li>Zawsze analizuj, czy rzutowanie jest bezpieczne i nie prowadzi do utraty istotnych informacji.</li>
                <li>Unikaj niejawnych konwersji między typami o różnych zakresach i precyzji.</li>
                <li>W razie wątpliwości korzystaj z jawnego rzutowania, aby zaznaczyć intencje.</li>
            </ul>
            <h4 id="rzutowanie-wskaźników">Rzutowanie wskaźników</h4>
            <p>Rzutowanie wskaźników w C jest bardziej złożone i niesie ze sobą większe ryzyko błędów. Wskaźniki reprezentują adresy w pamięci, a nieprawidłowe ich użycie może prowadzić do naruszenia pamięci (ang. <em>segmentation fault</em>) lub innych poważnych błędów.</p>
            <p>W języku C istnieje wskaźnik typu <code>void *</code>, który jest ogólnym wskaźnikiem mogącym przechowywać adres dowolnego typu danych. Jest on często używany w funkcjach biblioteki standardowej, takich jak <code>malloc()</code>, <code>qsort()</code>, <code>bsearch()</code>, gdzie typ danych jest nieznany lub może się różnić.</p>
            <h5>Przykład użycia wskaźnika <code>void *</code>:</h5>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
    void *ptr = malloc(sizeof(int));  // Alokacja pamięci dla typu int
    if (ptr == NULL) {
        perror("malloc");
        exit(EXIT_FAILURE);
    }

    int *int_ptr = (int *)ptr;  // Rzutowanie wskaźnika void* na int*
    *int_ptr = 42;
    printf("Wartość: %d\n", *int_ptr);

    free(ptr);  // Zwolnienie pamięci
    return 0;
}</code></pre>
            </div>
            </p>
            <p>W powyższym przykładzie:</p>
            <ul>
                <li>Funkcja <code>malloc()</code> zwraca wskaźnik typu <code>void *</code>.</li>
                <li>Rzutujemy go na <code>int *</code>, aby móc pracować z nim jako ze wskaźnikiem na <code>int</code>.</li>
                <li>Przypisujemy wartość do zaalokowanej pamięci i wyświetlamy ją.</li>
            </ul>
            <h5>Niebezpieczeństwa związane z rzutowaniem wskaźników</h5>
            <ul>
                <li>Rzutowanie wskaźnika na nieodpowiedni typ może prowadzić do odczytywania lub zapisywania nieprawidłowych danych.</li>
                <li>Niektóre architektury wymagają, aby dane były wyrównane do określonych granic pamięci. Rzutowanie wskaźnika na typ o innym wymaganym wyrównaniu może prowadzić do błędów.</li>
                <li>Kompilatory zakładają, że wskaźniki różnego typu nie wskazują na ten sam obszar pamięci. Naruszenie tej zasady może prowadzić do niezdefiniowanego zachowania.</li>
            </ul>
            <p><strong>Przykład błędnego rzutowania wskaźników:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">float f = 3.14f;
int *int_ptr = (int *)&amp;f
printf("Wartość int: %d\n", *int_ptr);</code></pre>
            </div>
            </p>
            <p>Tutaj interpretujemy bajty reprezentujące liczbę zmiennoprzecinkową jako liczbę całkowitą, co zazwyczaj nie ma sensu i może prowadzić do nieprzewidywalnych wyników.</p>
            <h5>Bezpieczne praktyki</h5>
            <ul>
                <li>Jeśli to możliwe, trzymaj się oryginalnych typów.</li>
                <li>Upewnij się, że rzutowane wskaźniki spełniają wymagania wyrównania dla docelowego typu.</li>
                <li>Korzystaj z <code>void *</code> ostrożnie**, używaj go tylko wtedy, gdy jest to konieczne i zawsze rzutuj z powrotem na właściwy typ przed użyciem.</li>
            </ul>
            <h3 id="konwersja-w-c-">Konwersja w C++</h3>
            <p>Język C++ wprowadza bardziej zaawansowane mechanizmy konwersji, które mają na celu zwiększenie bezpieczeństwa i czytelności kodu. W przeciwieństwie do C, gdzie rzutowanie jest proste, ale potencjalnie niebezpieczne, C++ oferuje zestaw operatorów rzutowania, które są bardziej restrykcyjne i precyzyjne w swoim działaniu. Pozwalają one na wyraźne określenie intencji programisty i redukują ryzyko błędów wynikających z niejawnych lub niezamierzonych konwersji.</p>
            <h4 id="static_cast">static_cast</h4>
            <p><code>static_cast</code> jest jednym z operatorów konwersji w C++, służącym do przeprowadzania konwersji między typami, których konwersja jest znana i sprawdzana w czasie kompilacji. Jest to najbardziej ogólny i najczęściej używany operator rzutowania w C++. Pozwala na:</p>
            <ul>
                <li>Konwersje między typami arytmetycznymi, np. z <code>int</code> na <code>double</code> i odwrotnie.</li>
                <li>Rzutowanie wskaźników w hierarchii dziedziczenia klas, upcasting i downcasting bez kontroli bezpieczeństwa w czasie wykonania.</li>
                <li>Konwersje między typami wskaźników i referencji, pod warunkiem, że istnieje odpowiednia ścieżka konwersji.</li>
            </ul>
            <p><strong>Przykłady:</strong></p>
            <p>I. <strong>Konwersja między typami arytmetycznymi:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">int i = 42;
double d = static_cast&lt;double&gt;(i);  // d = 42.0</code></pre>
            </div>
            </p>
            <p>II. <strong>Upcasting w hierarchii klas:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">class Base {};
class Derived : public Base {};

Derived *d = new Derived();
Base *b = static_cast&lt;base *=""/&gt;(d);  // Bezpieczne - upcasting</code></pre>
            </div>
            </p>
            <p>III. <strong>Downcasting (niezalecane z <code>static_cast</code>):</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">Base *b = new Derived();
Derived *d = static_cast&lt;derived *=""&gt;(b);  // Niebezpieczne - brak kontroli w czasie wykonania</code></pre>
            </div>
            </p>
            <p>W powyższym przykładzie, jeśli <code>b</code> nie wskazuje na obiekt typu <code>Derived</code>, wynik może być niezdefiniowany. Dlatego do downcastingu zaleca się używanie <code>dynamic_cast</code>.</p>
            <h5>Ograniczenia <code>static_cast</code></h5>
            <ul>
                <li>Nie sprawdza poprawności rzutowania podczas działania programu.</li>
                <li>Nie pozwala na usuwanie kwalifikatora <code>const</code> lub <code>volatile</code>; do tego służy <code>const_cast</code>.</li>
                <li>Nie można go użyć do rzutowania między wskaźnikami na niepowiązane typy.</li>
            </ul>
            <h5>Zalety <code>static_cast</code></h5>
            <ul>
                <li>Jest bardziej bezpieczny niż tradycyjne rzutowanie w stylu C, ponieważ jest bardziej restrykcyjny.</li>
                <li>Poprawia czytelność kodu, jasno wskazując intencje programisty.</li>
                <li>Łatwiejszy do zlokalizowania podczas przeglądania kodu lub analiz statycznych.</li>
            </ul>
            <h4 id="dynamic_cast">dynamic_cast</h4>
            <p><code>dynamic_cast</code> to operator konwersji, który służy do bezpiecznego rzutowania wskaźników i referencji w hierarchii dziedziczenia klas polimorficznych (tj. takich, które zawierają co najmniej jedną wirtualną funkcję). Poprawność tej konwersji jest sprawdzana w czasie działania programu, co oznacza, że program sprawdzi podczas wykonania, czy rzutowanie jest właściwe.</p>
            <h5>Zastosowanie <code>dynamic_cast</code></h5>
            <p>Najczęstszym zastosowaniem <code>dynamic_cast</code> jest <strong>downcasting</strong>, czyli rzutowanie wskaźnika lub referencji z klasy bazowej na klasę pochodną, gdy nie mamy pewności co do rzeczywistego typu obiektu.</p>
            <p><strong>Przykład:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;
#include &lt;typeinfo&gt;

class Base {
public:
    virtual ~Base() = default;
};

class Derived : public Base {
public:
    void specificFunction() {
        std::cout &lt;&lt; "Funkcja specyficzna dla klasy Derived\n";
    }
};

int main() {
    Base *b = new Derived();

    Derived *d = dynamic_cast&lt;derived *=""&gt;(b);
    if (d != nullptr) {
        d-&gt;specificFunction();
    } else {
        std::cout &lt;&lt; "Rzutowanie nie powiodło się.\n";
    }

    delete b;
    return 0;
}</code></pre>
            </div>
            </p>
            <ul>
                <li>Tworzymy obiekt klasy <code>Derived</code>, ale przechowujemy go we wskaźniku typu <code>Base *</code>.</li>
                <li>Używamy <code>dynamic_cast</code> do sprawdzenia, czy <code>b</code> rzeczywiście wskazuje na obiekt typu <code>Derived</code>.</li>
                <li>Jeśli rzutowanie się powiedzie, możemy bezpiecznie wywołać funkcje specyficzne dla <code>Derived</code>.</li>
            </ul>
            <h5>Rzutowanie referencji</h5>
            <p>Przy rzutowaniu referencji, jeśli rzutowanie się nie powiedzie, zostanie rzucony wyjątek <code>std::bad_cast</code>:</p>
            <p>
            <div>
                <pre><code class="language-clike">try {
    Base &amp;refBase = *b;
    Derived &amp;refDerived = dynamic_cast&lt;derived &amp;=""&gt;(refBase);
    refDerived.specificFunction();
} catch (const std::bad_cast &amp;e) {
    std::cout &lt;&lt; "Rzutowanie nie powiodło się: " &lt;&lt; e.what() &lt;&lt; '\n';
}</code></pre>
            </div>
            </p>
            <h5>Wymagania dla <code>dynamic_cast</code></h5>
            <ul>
                <li>Klasa bazowa musi zawierać przynajmniej jedną wirtualną funkcję (najczęściej jest to wirtualny destruktor).</li>
                <li>Mechanizm RTTI (Run-Time Type Information) musi być włączony w kompilatorze (domyślnie jest włączony).</li>
            </ul>
            <h5>Zalety i wady</h5>
            <p><strong>Zalety</strong>:</p>
            <ul>
                <li>Zapewnia poprawność rzutowania w czasie wykonania.</li>
                <li>Ułatwia pracę z hierarchiami klas polimorficznych.</li>
            </ul>
            <p><strong>Wady</strong>:</p>
            <ul>
                <li>Sprawdzanie typu w czasie wykonania może być kosztowne.</li>
                <li>Nadużywanie może prowadzić do trudnego w utrzymaniu kodu.</li>
            </ul>
            <h4 id="const_cast">const_cast</h4>
            <p><code>const_cast</code> to operator rzutowania używany do dodawania lub usuwania kwalifikatorów <code>const</code> lub <code>volatile</code> z typu danych. Jest to jedyny operator rzutowania, który może zmieniać kwalifikatory typu.</p>
            <h5>Przykłady użycia</h5>
            <ol>
                <li><strong>Usunięcie kwalifikatora <code>const</code>:</strong></li>
            </ol>
            <p>
            <div>
                <pre><code class="language-clike">const int a = 10;
int *p = const_cast&lt;int *=""&gt;(&amp;a);
*p = 20;  // Niezdefiniowane zachowanie!</code></pre>
            </div>
            </p>
            <p>Modyfikacja obiektu pierwotnie zadeklarowanego jako <code>const</code> prowadzi do niezdefiniowanego zachowania. Nawet jeśli kompilator nie zgłosi błędu, wynik może być nieprzewidywalny.</p>
            <ol>
                <li><strong>Bezpieczne użycie <code>const_cast</code>:</strong></li>
            </ol>
            <p>
            <div>
                <pre><code class="language-clike">void printMessage(char *msg) {
   // ... przetwarzanie wiadomości
}

int main() {
   const char *text = "Witaj świecie!";
   printMessage(const_cast&lt;char *=""&gt;(text));
   return 0;
}</code></pre>
            </div>
            </p>
            <p>Jeśli jesteśmy pewni, że funkcja <code>printMessage</code> nie modyfikuje przekazanego tekstu, możemy bezpiecznie usunąć kwalifikator <code>const</code>. Lepszym rozwiązaniem byłoby jednak poprawienie sygnatury funkcji, aby przyjmowała <code>const char *</code>.</p>
            <h5>Zastosowania <code>const_cast</code></h5>
            <ul>
                <li>Gdy funkcje nie używają kwalifikatorów <code>const</code>, a my chcemy przekazać im stałe dane.</li>
                <li>Możemy również użyć <code>const_cast</code> do dodania kwalifikatora <code>const</code>, chociaż rzadko jest to potrzebne.</li>
            </ul>
            <h5>Ostrzeżenia</h5>
            <ul>
                <li>Modyfikacja obiektu pierwotnie zadeklarowanego jako <code>const</code> jest zabroniona.</li>
                <li>Używaj <code>const_cast</code> tylko wtedy, gdy masz pewność, że nie naruszasz zasad bezpieczeństwa i integralności danych.</li>
                <li>Zamiast usuwać <code>const</code>, lepiej dostosować funkcje, aby akceptowały stałe argumenty.</li>
            </ul>
            <h4 id="reinterpret_cast">reinterpret_cast</h4>
            <p><code>reinterpret_cast</code> to najbardziej "brutalny" sposób konwersji w C++. Pozwala na reinterpretację bitów obiektu jako innego typu bez jakiejkolwiek konwersji danych. Jest to przydatne w sytuacjach niskopoziomowych, ale niesie ze sobą duże ryzyko błędów.</p>
            <h5>Przykłady użycia</h5>
            <ol>
                <li><strong>Konwersja wskaźnika na typ całkowity:</strong></li>
            </ol>
            <p>
            <div>
                <pre><code class="language-clike">void *ptr = malloc(10);
std::uintptr_t addr = reinterpret_cast&lt;std::uintptr_t&gt;(ptr);
std::cout &lt;&lt; "Adres: " &lt;&lt; addr &lt;&lt; '\n';</code></pre>
            </div>
            </p>
            <ol>
                <li><strong>Rzutowanie między niepowiązanymi typami wskaźników:</strong></li>
            </ol>
            <p>
            <div>
                <pre><code class="language-clike">class A { /* ... */ };
class B { /* ... */ };

A *a = new A();
B *b = reinterpret_cast&lt;b *=""&gt;(a);  // Niebezpieczne!</code></pre>
            </div>
            </p>
            <p>Taki kod jest potencjalnie niebezpieczny i może prowadzić do niezdefiniowanego zachowania.</p>
            <h5>Zastosowania <code>reinterpret_cast</code></h5>
            <ul>
                <li>Konwersja obiektu do ciągu bajtów i odwrotnie.</li>
                <li>Dostęp do rejestrów sprzętowych lub specjalnych obszarów pamięci.</li>
                <li>Manipulacja pamięcią na niskim poziomie, np. w implementacji własnego alokatora pamięci.</li>
            </ul>
            <h5>Ostrzeżenia i dobre praktyki</h5>
            <ul>
                <li>Rzutowanie wskaźników na niepowiązane typy i ich używanie może prowadzić do niezdefiniowanego zachowania.</li>
                <li>Wynik działania <code>reinterpret_cast</code> może różnić się w zależności od platformy, kompilatora i architektury.</li>
                <li>Stosuj <code>reinterpret_cast</code> tylko wtedy, gdy nie ma innej możliwości i jesteś świadomy ryzyka.</li>
                <li>Jeśli potrzebujesz konwersji między typami wskaźników w hierarchii klas, użyj <code>static_cast</code> lub <code>dynamic_cast</code>. Do konwersji typów arytmetycznych stosuj <code>static_cast</code>.</li>
            </ul>
            <h4 id="własne-konwersje">Własne konwersje</h4>
            <p>C++ pozwala na definiowanie własnych konwersji typów poprzez przeciążanie operatorów konwersji oraz konstruktorów konwersji. Pozwala to na elastyczne i intuicyjne przekształcanie obiektów jednego typu na inny.</p>
            <h5>Operatory konwersji</h5>
            <p>Operator konwersji to specjalna funkcja składowa klasy, która umożliwia przekształcenie obiektu klasy na inny typ.</p>
            <p><strong>Składnia:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">operator typ_docelowy() const;</code></pre>
            </div>
            </p>
            <p><strong>Przykład:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;cmath&gt;

class Complex {
public:
    double real, imag;
    Complex(double r, double i) : real(r), imag(i) {}

    // Konwersja na double - zwracamy moduł liczby zespolonej
    operator double() const {
        return sqrt(real * real + imag * imag);
    }
};

int main() {
    Complex c(3.0, 4.0);
    double magnitude = c;  // używa operatora konwersji
    std::cout &lt;&lt; "Moduł: " &lt;&lt; magnitude &lt;&lt; '\n';  // wyświetli 5.0
    return 0;
}</code></pre>
            </div>
            </p>
            <h5>Konstruktor konwersji</h5>
            <p>Konstruktor, który przyjmuje jeden argument, może służyć jako konstruktor konwersji, umożliwiający tworzenie obiektu danej klasy z innego typu.</p>
            <p><strong>Przykład:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">class Fraction {
private:
    int numerator;
    int denominator;
public:
    Fraction(int n, int d) : numerator(n), denominator(d) {}

    // Konstruktor konwersji z int
    Fraction(int wholeNumber) : numerator(wholeNumber), denominator(1) {}
};

int main() {
    Fraction f = 5;  // Używa konstruktora konwersji
    return 0;
}</code></pre>
            </div>
            </p>
            <h5>Słowo kluczowe <code>explicit</code></h5>
            <p>Aby uniknąć niejawnych konwersji, które mogą prowadzić do nieoczekiwanych wyników, można użyć słowa kluczowego <code>explicit</code>:</p>
            <p>
            <div>
                <pre><code class="language-clike">class Fraction {
public:
    explicit Fraction(int wholeNumber) : numerator(wholeNumber), denominator(1) {}
    // ...
};

int main() {
    Fraction f1 = 5;            // Błąd kompilacji
    Fraction f2(5);             // Poprawne
    Fraction f3 = Fraction(5);  // Poprawne
    return 0;
}</code></pre>
            </div>
            </p>
            <h5>Dobre praktyki</h5>
            <ul>
                <li>Definiuj tylko te konwersje, które mają sens w kontekście Twojej klasy i nie wprowadzają dwuznaczności.</li>
                <li>Stosuj <code>explicit</code>, aby zapobiec niezamierzonym konwersjom, które mogą prowadzić do błędów.</li>
                <li>Upewnij się, że konwersje są intuicyjne dla innych programistów i poprawiają czytelność kodu.</li>
            </ul>
            <h5>Potencjalne problemy</h5>
            <ul>
                <li>Zbyt wiele możliwych konwersji może prowadzić do konfliktów i utrudniać kompilację.</li>
                <li>Niejawne konwersje mogą prowadzić do wywoływania niewłaściwych funkcji przeciążonych lub operatorów.</li>
                <li>Używaj operatorów konwersji z rozwagą i tylko wtedy, gdy jest to uzasadnione.</li>
                <li>Preferuj jawne konwersje za pomocą konstruktorów i słowa kluczowego <code>explicit</code>.</li>
                <li>Zawsze rozważ wpływ na czytelność i utrzymanie kodu.</li>
            </ul>
        </section>
        <div id="table-of-contents">
            <h2>Spis Treści</h2>
            <ol><a href="#konwersje">Konwersje</a>
                <ol>
                    <li><a href="#rzutowanie-w-c">Rzutowanie w C</a>
                        <ol>
                            <li><a href="#podstawowe-rzutowanie">Podstawowe rzutowanie</a></li>
                            <li><a href="#rzutowanie-wskaźników">Rzutowanie wskaźników</a></li>
                        </ol>
                    </li>
                    <li><a href="#konwersja-w-c-">Konwersja w C++</a>
                        <ol>
                            <li><a href="#static_cast">static_cast</a></li>
                            <li><a href="#dynamic_cast">dynamic_cast</a></li>
                            <li><a href="#const_cast">const_cast</a></li>
                            <li><a href="#reinterpret_cast">reinterpret_cast</a></li>
                            <li><a href="#własne-konwersje">Własne konwersje</a></li>
                        </ol>
                    </li>
                </ol>
            </ol>
            <div id="related-articles">
                <h2>Related Articles</h2>
                <ol>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/01_proces_kompilacji.html">Proces Kompilacji</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/02_preprocesor.html">Preprocesor</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/03_zmienne_i_typy_danych.html">Zmienne i Typy Danych</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/04_interakcja_z_konsola.html">Interakcja z Konsola</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/05_instrukcja_warunkowa.html">Instrukcja Warunkowa</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/06_petle.html">Petle</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/07_liczby_losowe.html">Liczby Losowe</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/08_typ_wyliczeniowy.html">Typ Wyliczeniowy</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/09_funkcje.html">Funkcje</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/10_l_wartosci_r_wartosci.html">L Wartosci R Wartosci</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/11_wskazniki.html">Wskazniki</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/12_tablice.html">Tablice</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/13_napisy.html">Napisy</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/14_operacje_bitowe.html">Operacje Bitowe</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/15_programowanie_obietkowe.html">Programowanie Obietkowe</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/16_dziedziczenie.html">Dziedziczenie</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/17_zaawansowane_wskazniki.html">Zaawansowane Wskazniki</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/18_przeciazanie.html">Przeciazanie</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/19_konwersje.html">Konwersje</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/20_lambdy.html">Lambdy</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/21_szablony.html">Szablony</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/22_wyjatki.html">Wyjatki</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/23_stl.html">Stl</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/24_praca_z_plikami.html">Praca z Plikami</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/25_c_vs_cpp.html">C vs Cpp</a></li>
                </ol>
            </div>
        </div>
    </div>
    <footer>
        <div class="footer-columns">
            <div class="footer-column">
                <img alt="Adam Djellouli Symbol" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/symbol.png" />
            </div>
            <div class="footer-column">
                <h2><a href="https://adamdjellouli.com/core/privacy_policy.html" title="Privacy Policy">Our Privacy Policy</a></h2>
                <p>
                    Thank you for visiting my personal website. All of the <br />
                    content on this site is free to use, but please remember <br />
                    to be a good human being and refrain from any abuse<br />
                    of the site. If you would like to contact me, please use <br />
                    my <a href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" title="LinkedIn Profile">LinkedIn profile</a> or my <a href="https://github.com/djeada" title="GitHub Profile">GitHub</a> if you have any technical <br />
                    issues or ideas to share. I wish you the best and hope you <br />
                    have a fantastic life. <br />
                </p>
            </div>
            <div class="footer-column">
                <h2>Follow me</h2>
                <ul class="social-media">
                    <li>
                        <a class="fa fa-youtube" href="https://www.youtube.com/channel/UCGPoHTVjMN77wcGknXPHl1Q" target="_blank" title="YouTube">
                        </a>YouTube
                    </li>
                    <li>
                        <a class="fa fa-linkedin" href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" target="_blank" title="LinkedIn">
                        </a>LinkedIn
                    </li>
                    <li>
                        <a class="fa fa-instagram" href="https://www.instagram.com/linuxchallenges/" target="_blank" title="Instagram">
                        </a>Instagram
                    </li>
                    <li>
                        <a class="fa fa-github" href="https://github.com/djeada" title="GitHub">
                        </a>Github
                    </li>
                </ul>
            </div>
        </div>
        <div>
            <p id="copyright">
                © Adam Djellouli. All rights reserved.
            </p>
        </div>
        <script>
            document.getElementById("copyright").innerHTML = "&copy; " + new Date().getFullYear() + " Adam Djellouli. All rights reserved.";
        </script>
        <script src="../../app.js"></script>
    </footer>
    <div id="pdf-spinner-overlay">
        <div class="spinner"></div>
    </div>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-bash.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-cpp.min.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
jax: ["input/TeX", "output/HTML-CSS"],
extensions: ["tex2jax.js"],
"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] },
tex2jax: { inlineMath: [ ["$", "$"] ], displayMath: [ ["$$","$$"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
TeX: { noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } } },
messageStyle: "none"
});
</script>
<script async="" id="MathJax-script" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>

</html>