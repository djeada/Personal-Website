<!DOCTYPE html>

<html lang="pl">

<head>
    <script async="" crossorigin="anonymous" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5593122079896089"></script>
    <meta charset="utf-8" />
    <title>Tablice</title>
    <meta content="Tablice to kontenery przechowujÄ…ce wiele elementÃ³w tego samego typu, uporzÄ…dkowane w okreÅ›lonej kolejnoÅ›ci." name="description" />
    <meta content="Adam Djellouli" name="author" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <meta content="IE=edge" http-equiv="X-UA-Compatible" />
    <link crossorigin="" href="https://fonts.googleapis.com" rel="preconnect" />
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/icon.ico" rel="icon" />
    <link href="../../resources/style.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />
</head>

<body>
    <nav aria-label="Main navigation">
        <a class="logo" href="https://adamdjellouli.com">
            <img alt="Adam Djellouli - Home Page Logo" id="logo-image" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/logo.PNG" />
        </a>
        <input aria-label="Toggle navigation menu" id="navbar-toggle" type="checkbox" />
        <ul aria-labelledby="navbar-toggle" role="menu">
            <li role="menuitem">
                <a href="../../index.html" title="Go to Home Page"> Home </a>
            </li>
            <li role="menuitem">
                <a class="active" href="../../core/blog.html" title="Read Adam Djellouli Blog on Programming and Technology"> Blog </a>
            </li>
            <li role="menuitem">
                <a href="../../core/tools.html" title="Discover Tools Created by Adam Djellouli"> Tools </a>
            </li>
            <li role="menuitem">
                <a href="../../core/projects.html" title="Explore Projects Developed by Adam Djellouli"> Projects </a>
            </li>
            <li role="menuitem">
                <a href="../../core/resume.html" title="View Adam Djellouli Professional Resume"> Resume </a>
            </li>
            <li>
                <script async="" src="https://cse.google.com/cse.js?cx=8160ef9bb935f4f68"></script>
                <div class="gcse-search"></div>
            </li>
            <li>
                <button aria-label="Toggle dark mode" id="dark-mode-button"></button>
            </li>
        </ul>
    </nav>
    <div id="article-wrapper">
        <section id="article-body">
            <p style="text-align: right;"><i>Last modified: December 31, 2024</i></p>
            <p style="text-align: right;"><i>This article is written in: ğŸ‡µğŸ‡±</i></p>
            <h2 id="tablice">Tablice</h2>
            <p>Tablice to kontenery przechowujÄ…ce wiele elementÃ³w tego samego typu, uporzÄ…dkowane w okreÅ›lonej kolejnoÅ›ci. KaÅ¼dy element w tablicy moÅ¼na identyfikowaÄ‡ za pomocÄ… jego indeksu, przy czym indeksy zaczynajÄ… siÄ™ od zera. Tablice sÄ… fundamentalnym elementem jÄ™zyka C++, umoÅ¼liwiajÄ…cym przechowywanie i zarzÄ…dzanie zestawami danych w sposÃ³b zorganizowany. Ich wykorzystanie pozwala na zdefiniowanie konkretnego obszaru pamiÄ™ci, w ktÃ³rym zostanÄ… przechowane wszystkie elementy danej kolekcji.</p>
            <p>Tablice w C++ sÄ… niezwykle waÅ¼ne dla poczÄ…tkujÄ…cych programistÃ³w, poniewaÅ¼ wprowadzajÄ… doÅ›Ä‡ podstawowe, a jednoczeÅ›nie bardzo przydatne pojÄ™cia zwiÄ…zane ze strukturÄ… danych. Zanim jednak zaczniemy intensywnie korzystaÄ‡ z tablic, warto zapoznaÄ‡ siÄ™ z ich najwaÅ¼niejszymi cechami: rozmiarem okreÅ›lanym w czasie kompilacji (w przypadku tablic statycznych), koniecznoÅ›ciÄ… podawania typu przechowywanych elementÃ³w oraz mechanizmami dostÄ™pu do zawartoÅ›ci tablicy. DziÄ™ki tym elementom programista moÅ¼e lepiej zrozumieÄ‡, jak zarzÄ…dzaÄ‡ pamiÄ™ciÄ… w swoim programie.</p>
            <h3 id="deklaracja-tablicy">Deklaracja tablicy</h3>
            <p>Aby zadeklarowaÄ‡ tablicÄ™ w C++, umieszczamy liczbÄ™ elementÃ³w w nawiasach kwadratowych po typie danych i nazwie tablicy. Deklaracja tablicy rezerwuje blok pamiÄ™ci dla okreÅ›lonej liczby elementÃ³w.</p>
            <p>
            <div>
                <pre><code class="language-clike">int numbers[5]; // Tablica skÅ‚adajÄ…ca siÄ™ z 5 elementÃ³w typu int.</code></pre>
            </div>
            </p>
            <p>Warto pamiÄ™taÄ‡, Å¼e niezainicjalizowane tablice, zwÅ‚aszcza tablice lokalne (wewnÄ…trz funkcji), mogÄ… zawieraÄ‡ losowe wartoÅ›ci. Dlatego zaleca siÄ™ inicjalizowaÄ‡ tablicÄ™ podczas jej deklaracji.</p>
            <p>
            <div>
                <pre><code class="language-clike">int arrayA[3] = {1, 2, 3}; // Inicjalizacja tablicy wartoÅ›ciami 1, 2, 3.</code></pre>
            </div>
            </p>
            <p>MoÅ¼emy rÃ³wnieÅ¼ pominÄ…Ä‡ rozmiar tablicy podczas jej inicjalizacji, a kompilator sam obliczy odpowiedni rozmiar na podstawie liczby podanych elementÃ³w.</p>
            <p>
            <div>
                <pre><code class="language-clike">int arrayB[] = {4, 5, 6, 7}; // Rozmiar to 4, poniewaÅ¼ tablica zawiera 4 elementy.</code></pre>
            </div>
            </p>
            <p>W sytuacjach, w ktÃ³rych znamy dokÅ‚adnÄ… liczbÄ™ elementÃ³w, ktÃ³re musimy przechowaÄ‡, tablice statyczne sÄ… dobrym wyborem ze wzglÄ™du na wydajnoÅ›Ä‡ i prostotÄ™. JeÅ¼eli jednak nie jesteÅ›my pewni co do rozmiaru kolekcji, moÅ¼emy rozwaÅ¼yÄ‡ alternatywy, takie jak tablice dynamiczne bÄ…dÅº kontenery z biblioteki standardowej (std::vector, std::array). KaÅ¼de z tych rozwiÄ…zaÅ„ ma swoje zalety i ograniczenia, ale sama idea tablic pozostaje przydatnym fundamentem dla zrozumienia dziaÅ‚ania struktur danych w C++.</p>
            <h3 id="przeszukiwanie-i-wyÅ›wietlanie-tablicy">Przeszukiwanie i wyÅ›wietlanie tablicy</h3>
            <p>Do przeszukiwania i wyÅ›wietlania tablicy czÄ™sto uÅ¼ywa siÄ™ pÄ™tli. PoniÅ¼ej znajduje siÄ™ przykÅ‚ad wczytywania i wyÅ›wietlania tablicy za pomocÄ… pÄ™tli for. Ten proces ilustruje, jak moÅ¼na iterowaÄ‡ przez wszystkie elementy tablicy, aby wykonaÄ‡ operacje na jej zawartoÅ›ci.</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;

const int SIZE = 5;

int main() {
    int arr[SIZE];

    std::cout &lt;&lt; "WprowadÅº " &lt;&lt; SIZE &lt;&lt; " liczb: " &lt;&lt; std::endl;

    // Wczytywanie danych do tablicy
    for (int i = 0; i &lt; SIZE; i++) {
        std::cin &gt;&gt; arr[i];
    }

    std::cout &lt;&lt; "Elementy tablicy to:" &lt;&lt; std::endl;

    // WyÅ›wietlanie zawartoÅ›ci tablicy
    for (int i = 0; i &lt; SIZE; i++) {
        std::cout &lt;&lt; arr[i] &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;

    return 0;
}</code></pre>
            </div>
            </p>
            <p>PÄ™tle for (lub inne konstrukcje iteracyjne) sÄ… podstawowym narzÄ™dziem sÅ‚uÅ¼Ä…cym do przechodzenia przez kolejne elementy tablicy i wykonywania na nich operacji, takich jak sumowanie, szukanie najwiÄ™kszego elementu czy wyÅ›wietlanie zawartoÅ›ci. DziÄ™ki nim moÅ¼na Å‚atwo kontrolowaÄ‡ indeksy i unikaÄ‡ ewentualnych bÅ‚Ä™dÃ³w zwiÄ…zanych z wychodzeniem poza zakres tablicy. W praktyce, przy bardziej zÅ‚oÅ¼onych zadaniach, warto Å‚Ä…czyÄ‡ tÄ™ technikÄ™ z innymi, np. z warunkami if, aby uzyskiwaÄ‡ bardziej skomplikowane efekty przetwarzania danych.</p>
            <h3 id="dostÄ™p-do-elementÃ³w-tablicy-i-bezpieczeÅ„stwo">DostÄ™p do elementÃ³w tablicy i bezpieczeÅ„stwo</h3>
            <p>DostÄ™p do elementÃ³w tablicy odbywa siÄ™ za pomocÄ… operatora indeksowania <code>[]</code>. PoniÅ¼szy przykÅ‚ad pokazuje, jak przypisywaÄ‡ wartoÅ›ci do elementÃ³w tablicy i je odczytywaÄ‡.</p>
            <p>
            <div>
                <pre><code class="language-clike">int main() {
    int arr[3];
    arr[0] = 10; // Przypisanie wartoÅ›ci 10 do pierwszego elementu tablicy
    arr[1] = 20; // Przypisanie wartoÅ›ci 20 do drugiego elementu tablicy
    arr[2] = 30; // Przypisanie wartoÅ›ci 30 do trzeciego elementu tablicy

    std::cout &lt;&lt; "Pierwszy element: " &lt;&lt; arr[0] &lt;&lt; std::endl;
    std::cout &lt;&lt; "Drugi element: " &lt;&lt; arr[1] &lt;&lt; std::endl;
    std::cout &lt;&lt; "Trzeci element: " &lt;&lt; arr[2] &lt;&lt; std::endl;

    return 0;
}</code></pre>
            </div>
            </p>
            <p>Kiedy prÃ³bujemy uzyskaÄ‡ dostÄ™p do indeksu tablicy poza jej zakresem, moÅ¼e to prowadziÄ‡ do niezdefiniowanego zachowania programu. To zachowanie moÅ¼e byÄ‡ rÃ³Å¼ne w zaleÅ¼noÅ›ci od sytuacji: od czytania nieprawidÅ‚owych danych, przez nadpisywanie pamiÄ™ci poza tablicÄ…, aÅ¼ po awariÄ™ programu. Dlatego zawsze naleÅ¼y zachowaÄ‡ ostroÅ¼noÅ›Ä‡ przy manipulacji indeksami tablicy.</p>
            <p>
            <div>
                <pre><code class="language-clike">int main() {
    int arr[3] = {1, 2, 3};

    // PrÃ³ba dostÄ™pu do elementu poza zakresem
    std::cout &lt;&lt; arr[3] &lt;&lt; std::endl; // Niezdefiniowane zachowanie

    return 0;
}</code></pre>
            </div>
            </p>
            <p>BezpieczeÅ„stwo podczas korzystania z tablic jest kluczowe w kontekÅ›cie programÃ³w komercyjnych oraz systemÃ³w, w ktÃ³rych stabilnoÅ›Ä‡ i brak bÅ‚Ä™dÃ³w sÄ… absolutnym priorytetem. ChociaÅ¼ w maÅ‚ych, testowych projektach konsekwencje wyjÅ›cia poza zakres tablicy mogÄ… wydawaÄ‡ siÄ™ maÅ‚o dotkliwe, w wiÄ™kszych aplikacjach moÅ¼e to prowadziÄ‡ do trudnych do wykrycia awarii czy nawet luk bezpieczeÅ„stwa. Z tego wzglÄ™du, przed przetworzeniem kolejnego elementu zawsze upewniaj siÄ™, Å¼e nie wykraczasz poza rozmiar zdefiniowanej tablicy.</p>
            <h3 id="tablica-jako-wskaÅºnik">Tablica jako wskaÅºnik</h3>
            <p>W C++, tablica to kontener przechowujÄ…cy elementy tego samego typu. Jednak tablica sama w sobie moÅ¼e byÄ‡ traktowana jako wskaÅºnik do jej pierwszego elementu. Oznacza to, Å¼e odwoÅ‚anie siÄ™ do <code>tab[0]</code> jest rÃ³wnowaÅ¼ne z <code>*tab</code>. Kiedy przekazujemy tablicÄ™ do funkcji, faktycznie przekazujemy wskaÅºnik do jej pierwszego elementu. DziÄ™ki temu moÅ¼liwe jest operowanie na elementach tablicy w funkcjach, jak pokazano w poniÅ¼szym przykÅ‚adzie.</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;

int suma(int *tablica, int dlugosc) {
    int suma = 0;

    for (int i = 0; i &lt; dlugosc; i++)
        suma += tablica[i];

    return suma;
}

int main() {
    int tab[] = {2, 4, 8, 16, 32};
    std::cout &lt;&lt; suma(tab, 5) &lt;&lt; std::endl;

    return 0;
}</code></pre>
            </div>
            </p>
            <p>Warto zwrÃ³ciÄ‡ uwagÄ™, Å¼e mimo iÅ¼ tablica moÅ¼e byÄ‡ rozpoznana przez kompilator jako wskaÅºnik, nadal obiekty tych typÃ³w rÃ³Å¼niÄ… siÄ™ pod pewnymi wzglÄ™dami. Tablica statyczna (np. <code>int arr[5]</code>) ma zarezerwowanÄ… okreÅ›lonÄ… iloÅ›Ä‡ miejsca na stosie w momencie kompilacji, natomiast wskaÅºnik jest tylko zmiennÄ… przechowujÄ…cÄ… adres pamiÄ™ci. Mechanizm automatycznej konwersji do wskaÅºnika ogranicza siÄ™ gÅ‚Ã³wnie do kontekstu przekazywania tablic jako argumentÃ³w do funkcji, co bywa bardzo wygodne, ale jednoczeÅ›nie wymaga dbaÅ‚oÅ›ci o informacje dotyczÄ…ce rozmiaru tablicy.</p>
            <h3 id="przekazywanie-tablic-do-funkcji">Przekazywanie tablic do funkcji</h3>
            <p>Warto zauwaÅ¼yÄ‡, Å¼e przekazujÄ…c tablicÄ™ jako wskaÅºnik do funkcji, kompilator nie zna jej rzeczywistego rozmiaru. Dlatego musimy jawnie przekazaÄ‡ dÅ‚ugoÅ›Ä‡ tablicy jako drugi argument funkcji. Operator <code>sizeof</code> w tym kontekÅ›cie zwrÃ³ci jedynie rozmiar wskaÅºnika, a nie caÅ‚ej tablicy.</p>
            <p>
            <div>
                <pre><code class="language-clike">void printArray(int *array, int size) {
    for (int i = 0; i &lt; size; i++) {
        std::cout &lt;&lt; array[i] &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
}

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    int size = sizeof(arr) / sizeof(arr[0]);
    printArray(arr, size);
    return 0;
}</code></pre>
            </div>
            </p>
            <p>Z praktycznego punktu widzenia, przekazywanie wskaÅºnika do funkcji zapewnia pewnÄ… elastycznoÅ›Ä‡ w dziaÅ‚aniu programu, jednak wymaga odpowiedzialnego obchodzenia siÄ™ z pamiÄ™ciÄ… i dokÅ‚adnego pilnowania zakresu. W wiÄ™kszych projektach czÄ™sto korzysta siÄ™ ze zdefiniowanych struktur lub klas, a takÅ¼e z kontenerÃ³w biblioteki standardowej (m.in. <code>std::vector</code>), ktÃ³re automatycznie przechowujÄ… informacje o swoim rozmiarze i zapewniajÄ… metody kontroli dostÄ™pu do elementÃ³w.</p>
            <h3 id="arytmetyka-wskaÅºnikÃ³w">Arytmetyka wskaÅºnikÃ³w</h3>
            <p>WskaÅºniki w C++ umoÅ¼liwiajÄ… wykonanie operacji arytmetycznych, co pozwala na przesuwanie siÄ™ po tablicy w sposÃ³b dynamiczny. Operacje te sÄ… bardzo uÅ¼yteczne podczas manipulacji tablicami i strukturami danych.</p>
            <h4 id="podstawowe-operacje-arytmetyczne-na-wskaÅºnikach-">Podstawowe operacje arytmetyczne na wskaÅºnikach:</h4>
            <p>
            <table>
                <tr>
                    <td>Operator</td>
                    <td>Opis</td>
                </tr>
                <tr>
                    <td><code>++</code></td>
                    <td>Przesuwa wskaÅºnik do nastÄ™pnego elementu.</td>
                </tr>
                <tr>
                    <td><code>--</code></td>
                    <td>Przesuwa wskaÅºnik do poprzedniego elementu.</td>
                </tr>
                <tr>
                    <td><code>+=</code></td>
                    <td>Przesuwa wskaÅºnik o okreÅ›lonÄ… liczbÄ™ elementÃ³w do przodu.</td>
                </tr>
                <tr>
                    <td><code>-=</code></td>
                    <td>Przesuwa wskaÅºnik o okreÅ›lonÄ… liczbÄ™ elementÃ³w do tyÅ‚u.</td>
                </tr>
                <tr>
                    <td><code>+</code></td>
                    <td>Zwraca nowy wskaÅºnik przesuniÄ™ty o okreÅ›lonÄ… liczbÄ™ elementÃ³w od obecnego miejsca.</td>
                </tr>
                <tr>
                    <td><code>-</code></td>
                    <td>JeÅ›li uÅ¼yte miÄ™dzy dwoma wskaÅºnikami, zwraca rÃ³Å¼nicÄ™ (liczbÄ™ elementÃ³w) pomiÄ™dzy nimi.</td>
                </tr>
            </table>
            </p>
            <h4 id="przykÅ‚ady-zastosowania-arytmetyki-wskaÅºnikÃ³w">PrzykÅ‚ady zastosowania arytmetyki wskaÅºnikÃ³w</h4>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;

int main() {
    int arr[] = {10, 20, 30, 40, 50};
    int *ptr = arr;

    std::cout &lt;&lt; "Pierwszy element: " &lt;&lt; *ptr &lt;&lt; std::endl;

    ptr++; // PrzesuniÄ™cie wskaÅºnika do nastÄ™pnego elementu
    std::cout &lt;&lt; "Drugi element: " &lt;&lt; *ptr &lt;&lt; std::endl;

    ptr += 2; // PrzesuniÄ™cie wskaÅºnika o dwa elementy do przodu
    std::cout &lt;&lt; "Czwarty element: " &lt;&lt; *ptr &lt;&lt; std::endl;

    ptr--; // PrzesuniÄ™cie wskaÅºnika do poprzedniego elementu
    std::cout &lt;&lt; "Trzeci element: " &lt;&lt; *ptr &lt;&lt; std::endl;

    int *start = arr;
    int *end = arr + 4;
    std::cout &lt;&lt; "RÃ³Å¼nica miÄ™dzy wskaÅºnikami start i end: " &lt;&lt; end - start &lt;&lt; std::endl;

    return 0;
}</code></pre>
            </div>
            </p>
            <p>Arytmetyka wskaÅºnikÃ³w moÅ¼e wydawaÄ‡ siÄ™ nieco abstrakcyjna osobom, ktÃ³re nie miaÅ‚y dotÄ…d stycznoÅ›ci z niskopoziomowymi zagadnieniami pamiÄ™ci. Jednak w jÄ™zykach z rodziny C/C++ stanowi ona potÄ™Å¼ne narzÄ™dzie, pozwalajÄ…ce na dostÄ™p do poszczegÃ³lnych komÃ³rek pamiÄ™ci i poruszanie siÄ™ miÄ™dzy nimi z duÅ¼Ä… swobodÄ…. Warto jednak pamiÄ™taÄ‡, Å¼e wiÄ™ksze moÅ¼liwoÅ›ci zawsze pociÄ…gajÄ… za sobÄ… wiÄ™kszÄ… odpowiedzialnoÅ›Ä‡. KaÅ¼dy bÅ‚Ä…d wynikajÄ…cy z niepoprawnej arytmetyki wskaÅºnikÃ³w moÅ¼e powodowaÄ‡ trudne do wykrycia bÅ‚Ä™dy w programie.</p>
            <h3 id="bezpieczeÅ„stwo-arytmetyki-wskaÅºnikÃ³w">BezpieczeÅ„stwo arytmetyki wskaÅºnikÃ³w</h3>
            <p>ChociaÅ¼ arytmetyka wskaÅºnikÃ³w jest potÄ™Å¼nym narzÄ™dziem, wymaga ostroÅ¼noÅ›ci. Operacje na wskaÅºnikach poza zakresem tablicy mogÄ… prowadziÄ‡ do niezdefiniowanego zachowania programu, ktÃ³re moÅ¼e objawiaÄ‡ siÄ™ w rÃ³Å¼ny sposÃ³b: od czytania nieprawidÅ‚owych danych, przez nadpisywanie pamiÄ™ci, aÅ¼ po awarie programu. PrzykÅ‚adem takiego niebezpiecznego zachowania jest:</p>
            <p>
            <div>
                <pre><code class="language-clike">int main() {
    int arr[3] = {1, 2, 3};
    int *ptr = arr;

    ptr += 5; // PrzesuniÄ™cie wskaÅºnika poza zakres tablicy
    std::cout &lt;&lt; *ptr &lt;&lt; std::endl; // Niezdefiniowane zachowanie

    return 0;
}</code></pre>
            </div>
            </p>
            <p>W celu unikniÄ™cia bÅ‚Ä™dÃ³w zwiÄ…zanych z tego typu niepoÅ¼Ä…danymi operacjami, warto zawsze kontrolowaÄ‡, w jakim obszarze pamiÄ™ci siÄ™ poruszamy. NajczÄ™Å›ciej wiÄ…Å¼e siÄ™ to z pilnowaniem limitÃ³w pÄ™tli iterujÄ…cych po tablicy lub stosowaniem wyÅ¼szych abstrakcji (np. wspomniany juÅ¼ wczeÅ›niej <code>std::vector</code>). Zasada ograniczonego zaufania do wskaÅºnikÃ³w i sprawdzanie, czy dany indeks mieÅ›ci siÄ™ w granicach tablicy, w znacznym stopniu redukuje ryzyko nieoczekiwanych awarii.</p>
            <h3 id="dynamiczna-alokacja-pamiÄ™ci">Dynamiczna alokacja pamiÄ™ci</h3>
            <p>Dynamiczna alokacja pamiÄ™ci w C++ pozwala na rezerwacjÄ™ przestrzeni w pamiÄ™ci w czasie dziaÅ‚ania programu, zamiast podczas jego kompilacji. Aby zaalokowaÄ‡ pamiÄ™Ä‡ na stercie, korzystamy z operatora <code>new</code>. Do alokacji pojedynczej zmiennej uÅ¼ywamy <code>new</code>, natomiast dla tablicy <code>new [liczba]</code>, gdzie "liczba" reprezentuje iloÅ›Ä‡ elementÃ³w w tablicy.</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;

int main() {
  std::cout &lt;&lt; "Podaj liczbÄ™ elementÃ³w tablicy: ";
  int n;
  std::cin &gt;&gt; n;

  int *tab = new int[n];
  // PozostaÅ‚a czÄ™Å›Ä‡ kodu...</code></pre>
            </div>
            </p>
            <p>Gdy dynamicznie zaalokowana pamiÄ™Ä‡ nie jest juÅ¼ potrzebna, musimy jÄ… zwolniÄ‡. Do tego sÅ‚uÅ¼y operator <code>delete</code>. Dla pojedynczej zmiennej uÅ¼ywamy <code>delete</code>, natomiast dla tablicy <code>delete[]</code> - bez podawania liczby elementÃ³w.</p>
            <p>
            <div>
                <pre><code class="language-clike">// ... Koniec pracy z tablicÄ…
  delete[] tab;
  return 0;
}</code></pre>
            </div>
            </p>
            <p>ZarzÄ…dzanie dynamicznie alokowanÄ… pamiÄ™ciÄ… jest kluczowe. Niezwalnianie pamiÄ™ci moÅ¼e prowadziÄ‡ do wyciekÃ³w pamiÄ™ci, ktÃ³re w skumulowaniu mogÄ… obciÄ…Å¼yÄ‡ zasoby systemu. Wyciek pamiÄ™ci wystÄ™puje, gdy program zaalokuje pamiÄ™Ä‡, lecz nigdy jej nie zwolni, co moÅ¼e prowadziÄ‡ do zuÅ¼ycia wszystkich dostÄ™pnych zasobÃ³w.</p>
            <p>Dodatkowo warto podkreÅ›liÄ‡, Å¼e dynamiczna alokacja pamiÄ™ci ma pewne koszty - nie tylko w postaci zuÅ¼ywanej pamiÄ™ci, ale teÅ¼ czasu potrzebnego na jej alokacjÄ™ i dealokacjÄ™. Z tego powodu warto rozwaÅ¼yÄ‡, czy dynamiczna alokacja jest rzeczywiÅ›cie konieczna w danym przypadku. W wielu sytuacjach moÅ¼e byÄ‡ bardziej opÅ‚acalne korzystanie z gotowych kontenerÃ³w, takich jak <code>std::vector</code>, ktÃ³re automatycznie zarzÄ…dzajÄ… pamiÄ™ciÄ….</p>
            <p>Co wiÄ™cej, dynamiczna alokacja daje duÅ¼Ä… elastycznoÅ›Ä‡ w sytuacjach, gdy nie znamy dokÅ‚adnego rozmiaru tablicy w czasie kompilacji, lub gdy rozmiar ten moÅ¼e siÄ™ zmieniaÄ‡ w trakcie dziaÅ‚ania programu. Jednak przy tej swobodzie zawsze naleÅ¼y pamiÄ™taÄ‡ o ryzyku bÅ‚Ä™dÃ³w i obowiÄ…zku samodzielnego zarzÄ…dzania pamiÄ™ciÄ…. Niepoprawne lub zbyt pÃ³Åºne zwolnienie zasobÃ³w moÅ¼e prowadziÄ‡ do destabilizacji dziaÅ‚ania programu i licznych problemÃ³w z wydajnoÅ›ciÄ….</p>
            <h3 id="zwracanie-tablic-z-funkcji">Zwracanie tablic z funkcji</h3>
            <p>W C++ istnieje kilka sposobÃ³w na zwracanie tablic z funkcji. MoÅ¼emy uÅ¼ywaÄ‡ wskaÅºnikÃ³w, dynamicznie alokowanej pamiÄ™ci, struktur lub nowoczesnych kontenerÃ³w, takich jak <code>std::vector</code>. KaÅ¼de podejÅ›cie ma swoje zalety i wady, ktÃ³re zostanÄ… omÃ³wione poniÅ¼ej. WybÃ³r konkretnej metody zaleÅ¼y w duÅ¼ej mierze od charakteru problemu, z ktÃ³rym siÄ™ mierzymy â€” od tego, czy nasza tablica ma mieÄ‡ staÅ‚y rozmiar, byÄ‡ zmienna w trakcie dziaÅ‚ania programu, czy teÅ¼ czy chcemy z niej korzystaÄ‡ tylko lokalnie, czy rÃ³wnieÅ¼ poza funkcjÄ…. Przed podjÄ™ciem decyzji warto przemyÅ›leÄ‡ dÅ‚ugoterminowe konsekwencje dotyczÄ…ce wydajnoÅ›ci i zarzÄ…dzania pamiÄ™ciÄ….</p>
            <h4 id="i-zwracanie-wskaÅºnika-do-tablicy">I. Zwracanie wskaÅºnika do tablicy</h4>
            <p>Jednym z najprostszych sposobÃ³w jest zwracanie wskaÅºnika do pierwszego elementu tablicy. NaleÅ¼y jednak pamiÄ™taÄ‡, Å¼e tablica musi byÄ‡ dynamicznie alokowana, aby jej zawartoÅ›Ä‡ byÅ‚a dostÄ™pna poza funkcjÄ…. PodejÅ›cie to jest szczegÃ³lnie przydatne, jeÅ›li nie znamy dokÅ‚adnie rozmiaru tablicy w czasie kompilacji i chcemy zaalokowaÄ‡ jÄ… w trakcie dziaÅ‚ania programu. Trzeba jednak zwrÃ³ciÄ‡ uwagÄ™ na koniecznoÅ›Ä‡ rÄ™cznego zwalniania pamiÄ™ci po zakoÅ„czeniu korzystania z tablicy.</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;

int* createArray(int size) {
    int* array = new int[size];
    for (int i = 0; i &lt; size; ++i) {
        array[i] = i + 1;
    }
    return array;
}

int main() {
    int size = 5;
    int* myArray = createArray(size);

    for (int i = 0; i &lt; size; ++i) {
        std::cout &lt;&lt; myArray[i] &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;

    // PamiÄ™taj, aby zwolniÄ‡ zaalokowanÄ… pamiÄ™Ä‡
    delete[] myArray;

    return 0;
}</code></pre>
            </div>
            </p>
            <p><strong>Zalety:</strong></p>
            <ul>
                <li>Proste i bezpoÅ›rednie podejÅ›cie.</li>
                <li>MoÅ¼liwe do zastosowania, gdy rozmiar tablicy nie jest znany w czasie kompilacji.</li>
            </ul>
            <p><strong>Wady:</strong></p>
            <ul>
                <li>OdpowiedzialnoÅ›Ä‡ za zarzÄ…dzanie pamiÄ™ciÄ… spoczywa na uÅ¼ytkowniku funkcji.</li>
                <li>Potencjalne wycieki pamiÄ™ci, jeÅ›li zapomni siÄ™ zwolniÄ‡ zaalokowanÄ… pamiÄ™Ä‡.</li>
                <li>KoniecznoÅ›Ä‡ pamiÄ™tania, gdzie w kodzie zaalokowano pamiÄ™Ä‡, aby mÃ³c jÄ… poprawnie zwolniÄ‡.</li>
            </ul>
            <h4 id="ii-zwracanie-tablicy-przez-strukturÄ™">II. Zwracanie tablicy przez strukturÄ™</h4>
            <p>Innym podejÅ›ciem jest opakowanie tablicy w strukturÄ™ i zwracanie tej struktury. Pozwala to na ominiÄ™cie problemÃ³w zwiÄ…zanych z dynamicznÄ… alokacjÄ… pamiÄ™ci, gdyÅ¼ zwracany obiekt (struktura) istnieje w obszarze stosu i jest automatycznie zarzÄ…dzany przez kompilator. RozwiÄ…zanie to sprawdza siÄ™ w sytuacjach, w ktÃ³rych rozmiar tablicy jest z gÃ³ry znany i nie zamierzamy go zmieniaÄ‡ w trakcie dziaÅ‚ania programu.</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;

struct ArrayWrapper {
    int array[5];
};

ArrayWrapper createArray() {
    ArrayWrapper wrapper;
    for (int i = 0; i &lt; 5; ++i) {
        wrapper.array[i] = i + 1;
    }
    return wrapper;
}

int main() {
    ArrayWrapper myArray = createArray();

    for (int i = 0; i &lt; 5; ++i) {
        std::cout &lt;&lt; myArray.array[i] &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;

    return 0;
}</code></pre>
            </div>
            </p>
            <p><strong>Zalety:</strong></p>
            <ul>
                <li>Unikamy dynamicznej alokacji pamiÄ™ci i zwiÄ…zanych z niÄ… problemÃ³w.</li>
                <li>Åatwiejsze zarzÄ…dzanie cyklem Å¼ycia obiektu (struktury), ktÃ³ry jest automatycznie niszczony poza swoim zasiÄ™giem.</li>
            </ul>
            <p><strong>Wady:</strong></p>
            <ul>
                <li>Rozmiar tablicy musi byÄ‡ znany w czasie kompilacji.</li>
                <li>Nieelastyczne, jeÅ›li rozmiar tablicy ma byÄ‡ zmienny.</li>
                <li>W przypadku wiÄ™kszych tablic moÅ¼e pojawiÄ‡ siÄ™ koszt kopiowania podczas zwracania struktury, chociaÅ¼ w praktyce nowoczesne kompilatory C++ optymalizujÄ… takie sytuacje (Return Value Optimization).</li>
            </ul>
            <h4 id="iii-zwracanie-wskaÅºnika-do-dynamicznie-alokowanej-tablicy-z-zarzÄ…dzaniem-pamiÄ™ciÄ…-w-funkcji-wywoÅ‚ujÄ…cej">III. Zwracanie wskaÅºnika do dynamicznie alokowanej tablicy z zarzÄ…dzaniem pamiÄ™ciÄ… w funkcji wywoÅ‚ujÄ…cej</h4>
            <p>Zamiast zwracaÄ‡ wskaÅºnik do dynamicznie alokowanej pamiÄ™ci, moÅ¼emy przekazaÄ‡ wskaÅºnik do funkcji, ktÃ³ra wypeÅ‚ni tablicÄ™ danymi. DziÄ™ki temu kontrola nad tym, jak i gdzie pamiÄ™Ä‡ jest alokowana, pozostaje w caÅ‚oÅ›ci po stronie funkcji wywoÅ‚ujÄ…cej. Jest to wygodne w sytuacjach, w ktÃ³rych juÅ¼ dysponujemy pewnym obszarem pamiÄ™ci (np. statycznie zdefiniowanÄ… tablicÄ…) i chcemy jedynie, aby funkcja jÄ… zainicjalizowaÅ‚a.</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;

void createArray(int* array, int size) {
    for (int i = 0; i &lt; size; ++i) {
        array[i] = i + 1;
    }
}

int main() {
    int size = 5;
    int myArray[5];

    createArray(myArray, size);

    for (int i = 0; i &lt; size; ++i) {
        std::cout &lt;&lt; myArray[i] &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;

    return 0;
}</code></pre>
            </div>
            </p>
            <p><strong>Zalety:</strong></p>
            <ul>
                <li>ZarzÄ…dzanie pamiÄ™ciÄ… jest prostsze, brak potrzeby rÄ™cznego zwalniania pamiÄ™ci w funkcji wywoÅ‚ujÄ…cej, jeÅ›li tablica jest statyczna.</li>
                <li>Tablica moÅ¼e byÄ‡ zaalokowana przez wywoÅ‚ujÄ…cego w dowolny sposÃ³b (na stosie lub dynamicznie), a funkcja jedynie jÄ… wypeÅ‚nia.</li>
            </ul>
            <p><strong>Wady:</strong></p>
            <ul>
                <li>Tablica musi byÄ‡ zadeklarowana i zaalokowana przed wywoÅ‚aniem funkcji, co oznacza mniejszÄ… elastycznoÅ›Ä‡, jeÅ›li dopiero w funkcji chcemy okreÅ›liÄ‡ rozmiar.</li>
                <li>Funkcja musi polegaÄ‡ na poprawnym rozmiarze tablicy przekazanej przez wywoÅ‚ujÄ…cego, co wymaga dodatkowej ostroÅ¼noÅ›ci i sprawdzania ewentualnych bÅ‚Ä™dÃ³w.</li>
            </ul>
            <h3 id="tablica-2d">Tablica 2D</h3>
            <p>Tablica dwuwymiarowa, inaczej znana jako â€2D arrayâ€ w jÄ™zyku angielskim, moÅ¼na sobie wyobraziÄ‡ jako tablicÄ™ tablic. SkÅ‚ada siÄ™ ona z pewnej liczby rzÄ™dÃ³w, gdzie kaÅ¼dy rzÄ…d to jednowymiarowa tablica. Tablice dwuwymiarowe sÄ… powszechnie uÅ¼ywane w programowaniu do reprezentowania macierzy, siatek czy tabel danych. DziÄ™ki nim moÅ¼emy w przejrzysty sposÃ³b zarzÄ…dzaÄ‡ danymi, ktÃ³re posiadajÄ… dwa wymiary (np. wspÃ³Å‚rzÄ™dne w przestrzeni 2D, piksele obrazu, czy tabele w bazach danych).</p>
            <h4 id="deklaracja-i-inicjalizacja-tablicy-2d">Deklaracja i Inicjalizacja Tablicy 2D</h4>
            <p>Deklaracja tablicy dwuwymiarowej wymaga podania zarÃ³wno liczby rzÄ™dÃ³w, jak i liczby kolumn. Oto przykÅ‚ad deklaracji i inicjalizacji tablicy 2D:</p>
            <p>
            <div>
                <pre><code class="language-clike">int a[3][4] = { 
    {1, 2, 3, 4}, 
    {5, 6, 7, 8}, 
    {9, 10, 11, 12} 
};</code></pre>
            </div>
            </p>
            <p>W tym przypadku mamy do czynienia z tablicÄ… o trzech rzÄ™dach i czterech kolumnach. KaÅ¼dy element w tablicy 2D moÅ¼e byÄ‡ dostÄ™pny za pomocÄ… dwÃ³ch indeksÃ³w: pierwszego dla rzÄ™du i drugiego dla kolumny. Takie rozwiÄ…zanie doskonale sprawdza siÄ™ w sytuacjach, w ktÃ³rych z gÃ³ry znamy rozmiar siatki (np. macierze matematyczne staÅ‚ej wielkoÅ›ci).</p>
            <h4 id="wczytywanie-i-wyÅ›wietlanie-tablicy-2d">Wczytywanie i WyÅ›wietlanie Tablicy 2D</h4>
            <p>PoniÅ¼ej przedstawiono kod, ktÃ³ry pozwala na wczytanie danych do tablicy 2D od uÅ¼ytkownika i wyÅ›wietlenie jej zawartoÅ›ci. Takie operacje sÄ… czÄ™sto stosowane w zadaniach z przetwarzania danych, na przykÅ‚ad przy analizie arkuszy kalkulacyjnych lub w wypadku symulacji fizycznych, gdzie dane wejÅ›ciowe okreÅ›lajÄ… warunki poczÄ…tkowe.</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;

const unsigned int n = 3;
const unsigned int m = 4;

int main() {
    int a[n][m];

    std::cout &lt;&lt; "Podaj " &lt;&lt; n * m &lt;&lt; " elementÃ³w: " &lt;&lt; std::endl;

    for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; m; j++) {
            std::cin &gt;&gt; a[i][j];
        }
    }

    std::cout &lt;&lt; "Twoja tablica: " &lt;&lt; std::endl;

    for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; m; j++) {
            std::cout &lt;&lt; a[i][j] &lt;&lt; " ";
        }
        std::cout &lt;&lt; std::endl;
    }

    return 0;
}</code></pre>
            </div>
            </p>
            <p>DziÄ™ki wykorzystaniu zagnieÅ¼dÅ¼onej pÄ™tli <code>for</code>, iterujemy po wszystkich wierszach i kolumnach tablicy, co pozwala w przystÄ™pny sposÃ³b zarÃ³wno wczytywaÄ‡, jak i wyÅ›wietlaÄ‡ zawartoÅ›Ä‡ tablicy. StrukturÄ™ takiej tablicy moÅ¼na Å‚atwo przenieÅ›Ä‡ na bardziej zÅ‚oÅ¼one zastosowania, jak systemy bazodanowe czy oprogramowanie do analizy zdjÄ™Ä‡.</p>
            <h4 id="dynamiczna-alokacja-tablicy-2d">Dynamiczna Alokacja Tablicy 2D</h4>
            <p>W niektÃ³rych przypadkach chcemy alokowaÄ‡ pamiÄ™Ä‡ dla tablicy dwuwymiarowej dynamicznie. Jest to szczegÃ³lnie przydatne, gdy wymiary tablicy sÄ… nieznane w czasie kompilacji i muszÄ… byÄ‡ okreÅ›lone w czasie wykonywania programu. DynamicznÄ… alokacjÄ™ pamiÄ™ci moÅ¼na osiÄ…gnÄ…Ä‡ za pomocÄ… operatora <code>new</code>. Takie podejÅ›cie jest typowe w bardziej zÅ‚oÅ¼onych aplikacjach, gdzie iloÅ›Ä‡ danych wejÅ›ciowych moÅ¼e zaleÅ¼eÄ‡ od pliku konfiguracyjnego, danych z sieci czy innych zmiennych czynnikÃ³w.</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;

int main() {
    int wysokoÅ›Ä‡, szerokoÅ›Ä‡;

    std::cout &lt;&lt; "Podaj wysokoÅ›Ä‡ i szerokoÅ›Ä‡ macierzy: ";
    std::cin &gt;&gt; wysokoÅ›Ä‡ &gt;&gt; szerokoÅ›Ä‡;

    // Alokacja dynamiczna
    double **macierz = new double*[wysokoÅ›Ä‡];
    for (int i = 0; i &lt; wysokoÅ›Ä‡; i++) {
        macierz[i] = new double[szerokoÅ›Ä‡];
    }

    // WypeÅ‚nianie tablicy wartoÅ›ciami
    std::cout &lt;&lt; "Podaj wartoÅ›ci dla macierzy:" &lt;&lt; std::endl;
    for (int i = 0; i &lt; wysokoÅ›Ä‡; i++) {
        for (int j = 0; j &lt; szerokoÅ›Ä‡; j++) {
            std::cin &gt;&gt; macierz[i][j];
        }
    }

    // WyÅ›wietlanie zawartoÅ›ci tablicy
    std::cout &lt;&lt; "Macierz:" &lt;&lt; std::endl;
    for (int i = 0; i &lt; wysokoÅ›Ä‡; i++) {
        for (int j = 0; j &lt; szerokoÅ›Ä‡; j++) {
            std::cout &lt;&lt; macierz[i][j] &lt;&lt; " ";
        }
        std::cout &lt;&lt; std::endl;
    }

    // Dealokacja pamiÄ™ci
    for (int i = 0; i &lt; wysokoÅ›Ä‡; i++) {
        delete[] macierz[i];
    }
    delete[] macierz;

    return 0;
}</code></pre>
            </div>
            </p>
            <p>W powyÅ¼szym kodzie uÅ¼ytkownik okreÅ›la wymiary macierzy (wysokoÅ›Ä‡ i szerokoÅ›Ä‡), po czym nastÄ™puje dynamiczna alokacja pamiÄ™ci dla niej. WaÅ¼ne jest, aby po skoÅ„czonej pracy z tablicÄ… dynamicznÄ… odpowiednio zwolniÄ‡ zajmowanÄ… przez niÄ… pamiÄ™Ä‡, korzystajÄ…c z operatora <code>delete[]</code>. PamiÄ™tajmy, Å¼e w bardziej rozbudowanych programach zapominanie o dealokacji pamiÄ™ci moÅ¼e prowadziÄ‡ do wyciekÃ³w pamiÄ™ci, powodujÄ…cych stopniowe spowalnianie programu, a w skrajnych przypadkach nawet jego awariÄ™.</p>
            <h4 id="przykÅ‚ad-dodawanie-danych-do-tablicy-2d">PrzykÅ‚ad: Dodawanie Danych do Tablicy 2D</h4>
            <p>PoniÅ¼ej przedstawiono przykÅ‚ad programu, ktÃ³ry dynamicznie tworzy tablicÄ™ 2D, wypeÅ‚nia jÄ… danymi wprowadzonymi przez uÅ¼ytkownika i wyÅ›wietla jej zawartoÅ›Ä‡. Jest to jeden z czÄ™stszych scenariuszy, spotykanych w praktycznych zastosowaniach, np. podczas tworzenia prostych arkuszy kalkulacyjnych, systemÃ³w do edycji obrazÃ³w czy nawet gier 2D, w ktÃ³rych mapa jest reprezentowana jako dwuwymiarowa tablica.</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;

int main() {
    int rows, cols;

    std::cout &lt;&lt; "Podaj liczbÄ™ rzÄ™dÃ³w i kolumn: ";
    std::cin &gt;&gt; rows &gt;&gt; cols;

    // Dynamiczna alokacja pamiÄ™ci dla tablicy 2D
    int** array = new int*[rows];
    for (int i = 0; i &lt; rows; i++) {
        array[i] = new int[cols];
    }

    // Wczytywanie danych do tablicy
    std::cout &lt;&lt; "Podaj " &lt;&lt; rows * cols &lt;&lt; " elementÃ³w:" &lt;&lt; std::endl;
    for (int i = 0; i &lt; rows; i++) {
        for (int j = 0; j &lt; cols; j++) {
            std::cin &gt;&gt; array[i][j];
        }
    }

    // WyÅ›wietlanie zawartoÅ›ci tablicy
    std::cout &lt;&lt; "ZawartoÅ›Ä‡ tablicy:" &lt;&lt; std::endl;
    for (int i = 0; i &lt; rows; i++) {
        for (int j = 0; j &lt; cols; j++) {
            std::cout &lt;&lt; array[i][j] &lt;&lt; " ";
        }
        std::cout &lt;&lt; std::endl;
    }

    // Zwolnienie pamiÄ™ci
    for (int i = 0; i &lt; rows; i++) {
        delete[] array[i];
    }
    delete[] array;

    return 0;
}</code></pre>
            </div>
            </p>
            <p>W programie tym w prosty sposÃ³b pokazano, jak alokowaÄ‡ i dealokowaÄ‡ pamiÄ™Ä‡ dla tablicy 2D oraz jak odczytywaÄ‡ i wyÅ›wietlaÄ‡ dane. Przy rozbudowie takiego kodu w kierunku wiÄ™kszych projektÃ³w naleÅ¼y pamiÄ™taÄ‡ o zabezpieczeniach, np. sprawdzaniu poprawnoÅ›ci wprowadzonych danych czy wyÅ‚apywaniu wyjÄ…tkÃ³w, ktÃ³re mogÄ… wystÄ…piÄ‡ przy niepoprawnej alokacji pamiÄ™ci.</p>
            <h4 id="zastosowania-tablic-2d">Zastosowania Tablic 2D</h4>
            <p>Tablice 2D sÄ… powszechnie stosowane w rÃ³Å¼nych dziedzinach informatyki, takich jak:</p>
            <ul>
                <li>W <strong>przetwarzaniu obrazÃ³w</strong> macierze sÄ… uÅ¼ywane do reprezentowania pikseli obrazu, co umoÅ¼liwia manipulowanie i analizowanie danych obrazowych. KaÅ¼dy element macierzy moÅ¼e wtedy odpowiadaÄ‡ jednemu pikselowi.</li>
                <li><strong>Symulacje fizyczne</strong> czÄ™sto wykorzystujÄ… macierze do reprezentowania siatek i modeli symulacji, co pozwala na dokÅ‚adne odwzorowanie zjawisk fizycznych, np. przepÅ‚ywu ciepÅ‚a czy symulacji ruchu cieczy.</li>
                <li>W kontekÅ›cie <strong>przechowywania danych</strong>, macierze sÄ… uÅ¼ywane do tworzenia tabel danych i macierzy matematycznych, co uÅ‚atwia organizacjÄ™ i obliczenia. Takie podejÅ›cie bywa niezbÄ™dne w analizie duÅ¼ych zbiorÃ³w danych.</li>
                <li>W <strong>grach komputerowych</strong> macierze mogÄ… reprezentowaÄ‡ plansze gier oraz mapy poziomÃ³w, co umoÅ¼liwia efektywne zarzÄ…dzanie strukturÄ… i logikÄ… gry. Dodatkowo uÅ‚atwia to okreÅ›lenie pozycji obiektÃ³w oraz kolizji.</li>
            </ul>
            <h3 id="zalecenia-dotyczÄ…ce-uÅ¼ycia-tablic">Zalecenia dotyczÄ…ce uÅ¼ycia tablic</h3>
            <ul>
                <li><strong>Zawsze inicjalizuj tablice</strong>, aby uniknÄ…Ä‡ problemÃ³w z losowymi wartoÅ›ciami, ktÃ³re mogÄ… prowadziÄ‡ do nieprzewidywalnych bÅ‚Ä™dÃ³w w programie. W przypadku tablic lokalnych warto wypeÅ‚niÄ‡ je odpowiedniÄ… domyÅ›lnÄ… wartoÅ›ciÄ… jeszcze przed pierwszym uÅ¼yciem.</li>
                <li><strong>Sprawdzaj granice tablicy</strong>, aby zapewniÄ‡ bezpieczeÅ„stwo i zapobiec dostÄ™powi do elementÃ³w poza zakresem, co moÅ¼e prowadziÄ‡ do awarii programu. Jest to szczegÃ³lnie waÅ¼ne w jÄ™zyku C++, ktÃ³ry nie ma wbudowanych mechanizmÃ³w automatycznej ochrony przed wyjÅ›ciem poza zakres.</li>
                <li>W wielu przypadkach warto rozwaÅ¼yÄ‡ <strong>uÅ¼ycie kontenerÃ³w standardowych</strong>, takich jak <code>std::vector</code>, ktÃ³re oferujÄ… wiÄ™ksze bezpieczeÅ„stwo i elastycznoÅ›Ä‡ niÅ¼ tradycyjne tablice, eliminujÄ…c ryzyko bÅ‚Ä™dÃ³w zwiÄ…zanych z zarzÄ…dzaniem pamiÄ™ciÄ…. DziÄ™ki temu moÅ¼emy zminimalizowaÄ‡ liczbÄ™ bÅ‚Ä™dÃ³w zwiÄ…zanych z niewÅ‚aÅ›ciwÄ… alokacjÄ… i dealokacjÄ….</li>
                <li>JeÅ›li jednak korzystasz z tablic surowych (ang. raw arrays), <strong>pamiÄ™taj o odpowiedzialnoÅ›ci za zarzÄ…dzanie pamiÄ™ciÄ…</strong>. Dotyczy to zarÃ³wno alokacji (z operatorem <code>new</code>), jak i dealokacji (z operatorem <code>delete[]</code>). NiewÅ‚aÅ›ciwe korzystanie z pamiÄ™ci moÅ¼e skutkowaÄ‡ wyciekami, a w konsekwencji niestabilnoÅ›ciÄ… i awariami oprogramowania.</li>
            </ul>
        </section>
        <div id="table-of-contents">
            <h2>Spis TreÅ›ci</h2>
            <ol><a href="#tablice">Tablice</a>
                <ol>
                    <li><a href="#deklaracja-tablicy">Deklaracja tablicy</a></li>
                    <li><a href="#przeszukiwanie-i-wyÅ›wietlanie-tablicy">Przeszukiwanie i wyÅ›wietlanie tablicy</a></li>
                    <li><a href="#dostÄ™p-do-elementÃ³w-tablicy-i-bezpieczeÅ„stwo">DostÄ™p do elementÃ³w tablicy i bezpieczeÅ„stwo</a></li>
                    <li><a href="#tablica-jako-wskaÅºnik">Tablica jako wskaÅºnik</a></li>
                    <li><a href="#przekazywanie-tablic-do-funkcji">Przekazywanie tablic do funkcji</a></li>
                    <li><a href="#arytmetyka-wskaÅºnikÃ³w">Arytmetyka wskaÅºnikÃ³w</a>
                        <ol>
                            <li><a href="#podstawowe-operacje-arytmetyczne-na-wskaÅºnikach-">Podstawowe operacje arytmetyczne na wskaÅºnikach:</a></li>
                            <li><a href="#przykÅ‚ady-zastosowania-arytmetyki-wskaÅºnikÃ³w">PrzykÅ‚ady zastosowania arytmetyki wskaÅºnikÃ³w</a></li>
                        </ol>
                    </li>
                    <li><a href="#bezpieczeÅ„stwo-arytmetyki-wskaÅºnikÃ³w">BezpieczeÅ„stwo arytmetyki wskaÅºnikÃ³w</a></li>
                    <li><a href="#dynamiczna-alokacja-pamiÄ™ci">Dynamiczna alokacja pamiÄ™ci</a></li>
                    <li><a href="#zwracanie-tablic-z-funkcji">Zwracanie tablic z funkcji</a>
                        <ol>
                            <li><a href="#i-zwracanie-wskaÅºnika-do-tablicy">I. Zwracanie wskaÅºnika do tablicy</a></li>
                            <li><a href="#ii-zwracanie-tablicy-przez-strukturÄ™">II. Zwracanie tablicy przez strukturÄ™</a></li>
                            <li><a href="#iii-zwracanie-wskaÅºnika-do-dynamicznie-alokowanej-tablicy-z-zarzÄ…dzaniem-pamiÄ™ciÄ…-w-funkcji-wywoÅ‚ujÄ…cej">III. Zwracanie wskaÅºnika do dynamicznie alokowanej tablicy z zarzÄ…dzaniem pamiÄ™ciÄ… w funkcji wywoÅ‚ujÄ…cej</a></li>
                        </ol>
                    </li>
                    <li><a href="#tablica-2d">Tablica 2D</a>
                        <ol>
                            <li><a href="#deklaracja-i-inicjalizacja-tablicy-2d">Deklaracja i Inicjalizacja Tablicy 2D</a></li>
                            <li><a href="#wczytywanie-i-wyÅ›wietlanie-tablicy-2d">Wczytywanie i WyÅ›wietlanie Tablicy 2D</a></li>
                            <li><a href="#dynamiczna-alokacja-tablicy-2d">Dynamiczna Alokacja Tablicy 2D</a></li>
                            <li><a href="#przykÅ‚ad-dodawanie-danych-do-tablicy-2d">PrzykÅ‚ad: Dodawanie Danych do Tablicy 2D</a></li>
                            <li><a href="#zastosowania-tablic-2d">Zastosowania Tablic 2D</a></li>
                        </ol>
                    </li>
                    <li><a href="#zalecenia-dotyczÄ…ce-uÅ¼ycia-tablic">Zalecenia dotyczÄ…ce uÅ¼ycia tablic</a></li>
                </ol>
            </ol>
            <div id="related-articles">
                <h2>Related Articles</h2>
                <ol>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/01_proces_kompilacji.html">Proces Kompilacji</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/02_preprocesor.html">Preprocesor</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/03_zmienne_i_typy_danych.html">Zmienne i Typy Danych</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/04_interakcja_z_konsola.html">Interakcja z Konsola</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/05_instrukcja_warunkowa.html">Instrukcja Warunkowa</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/06_petle.html">Petle</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/07_liczby_losowe.html">Liczby Losowe</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/08_typ_wyliczeniowy.html">Typ Wyliczeniowy</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/09_funkcje.html">Funkcje</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/10_l_wartosci_r_wartosci.html">L Wartosci R Wartosci</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/11_wskazniki.html">Wskazniki</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/12_tablice.html">Tablice</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/13_napisy.html">Napisy</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/14_operacje_bitowe.html">Operacje Bitowe</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/15_programowanie_obietkowe.html">Programowanie Obietkowe</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/16_dziedziczenie.html">Dziedziczenie</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/17_zaawansowane_wskazniki.html">Zaawansowane Wskazniki</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/18_przeciazanie.html">Przeciazanie</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/19_konwersje.html">Konwersje</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/20_lambdy.html">Lambdy</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/21_szablony.html">Szablony</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/22_wyjatki.html">Wyjatki</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/23_stl.html">Stl</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/24_praca_z_plikami.html">Praca z Plikami</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/25_c_vs_cpp.html">C vs Cpp</a></li>
                </ol>
            </div>
        </div>
    </div>
    <footer>
        <div class="footer-columns">
            <div class="footer-column">
                <img alt="Adam Djellouli Symbol" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/symbol.png" />
            </div>
            <div class="footer-column">
                <h2><a href="https://adamdjellouli.com/core/privacy_policy.html" title="Privacy Policy">Our Privacy Policy</a></h2>
                <p>
                    Thank you for visiting my personal website. All of the <br />
                    content on this site is free to use, but please remember <br />
                    to be a good human being and refrain from any abuse<br />
                    of the site. If you would like to contact me, please use <br />
                    my <a href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" title="LinkedIn Profile">LinkedIn profile</a> or my <a href="https://github.com/djeada" title="GitHub Profile">GitHub</a> if you have any technical <br />
                    issues or ideas to share. I wish you the best and hope you <br />
                    have a fantastic life. <br />
                </p>
            </div>
            <div class="footer-column">
                <h2>Follow me</h2>
                <ul class="social-media">
                    <li>
                        <a class="fa fa-youtube" href="https://www.youtube.com/channel/UCGPoHTVjMN77wcGknXPHl1Q" target="_blank" title="YouTube">
                        </a>YouTube
                    </li>
                    <li>
                        <a class="fa fa-linkedin" href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" target="_blank" title="LinkedIn">
                        </a>LinkedIn
                    </li>
                    <li>
                        <a class="fa fa-instagram" href="https://www.instagram.com/linuxchallenges/" target="_blank" title="Instagram">
                        </a>Instagram
                    </li>
                    <li>
                        <a class="fa fa-github" href="https://github.com/djeada" title="GitHub">
                        </a>Github
                    </li>
                </ul>
            </div>
        </div>
        <div>
            <p id="copyright">
                Â© Adam Djellouli. All rights reserved.
            </p>
        </div>
        <script>
            document.getElementById("copyright").innerHTML = "&copy; " + new Date().getFullYear() + " Adam Djellouli. All rights reserved.";
        </script>
        <script src="../../app.js"></script>
    </footer>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-bash.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-cpp.min.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
jax: ["input/TeX", "output/HTML-CSS"],
extensions: ["tex2jax.js"],
"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] },
tex2jax: { inlineMath: [ ["$", "$"] ], displayMath: [ ["$$","$$"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
TeX: { noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } } },
messageStyle: "none"
});
</script>
<script async="" id="MathJax-script" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>

</html>