<!DOCTYPE html>

<html lang="pl">

<head>
    <script async="" crossorigin="anonymous" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5593122079896089"></script>
    <meta charset="utf-8" />
    <title>Szablony</title>
    <meta content="Szablony (ang." name="description" />
    <meta content="Adam Djellouli" name="author" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <meta content="IE=edge" http-equiv="X-UA-Compatible" />
    <link crossorigin="" href="https://fonts.googleapis.com" rel="preconnect" />
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/icon.ico" rel="icon" />
    <link href="../../resources/style.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
</head>

<body>
    <nav aria-label="Main navigation">
        <a class="logo" href="https://adamdjellouli.com">
            <img alt="Adam Djellouli - Home Page Logo" id="logo-image" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/logo.PNG" />
        </a>
        <input aria-label="Toggle navigation menu" id="navbar-toggle" type="checkbox" />
        <ul aria-labelledby="navbar-toggle" role="menu">
            <li role="menuitem">
                <a href="../../index.html" title="Go to Home Page"> Home </a>
            </li>
            <li role="menuitem">
                <a class="active" href="../../core/blog.html" title="Read Adam Djellouli Blog on Programming and Technology"> Blog </a>
            </li>
            <li role="menuitem">
                <a href="../../core/tools.html" title="Discover Tools Created by Adam Djellouli"> Tools </a>
            </li>
            <li role="menuitem">
                <a href="../../core/projects.html" title="Explore Projects Developed by Adam Djellouli"> Projects </a>
            </li>
            <li role="menuitem">
                <a href="../../core/resume.html" title="View Adam Djellouli Professional Resume"> Resume </a>
            </li>
            <li>
                <script async="" src="https://cse.google.com/cse.js?cx=8160ef9bb935f4f68"></script>
                <div class="gcse-search"></div>
            </li>
            <li>
                <button aria-label="Toggle dark mode" id="dark-mode-button"></button>
            </li>
        </ul>
    </nav>
    <div id="article-wrapper">
        <section id="article-body">
            <div class="article-action-buttons"><button class="btn-suggest-edit" title="Suggest Edit">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <path d="M4 21h4l11-11-4-4L4 17v4z" stroke="currentColor" stroke-width="2"></path>
                    </svg>
                </button><button class="btn-create-issue" title="Create Issue">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2"></circle>
                        <line stroke="currentColor" stroke-width="2" x1="12" x2="12" y1="8" y2="12"></line>
                        <circle cx="12" cy="16" fill="currentColor" r="1"></circle>
                    </svg>
                </button><button class="btn-download" title="Download">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <path d="M12 5v14m0 0l-6-6m6 6l6-6" stroke="currentColor" stroke-width="2"></path>
                    </svg>
                </button></div>
            <p style="text-align: right;"><i>Last modified: January 31, 2019</i></p>
            <p style="text-align: right;"><i>This article is written in: 叼</i></p>
            <h2 id="szablony">Szablony</h2>
            <p>Szablony (ang. <em>templates</em>) stanowi fundament nowoczesnego programowania w jzyku C++. S jednym z najbardziej pot偶nych narzdzi oferowanych przez ten jzyk, umo偶liwiajc programistom pisanie bardziej elastycznego i wielokrotnego u偶ytku kodu. Dziki szablonom, mo偶na tworzy funkcje i klasy, kt贸re dziaaj z r贸偶nymi typami danych, co znaczco redukuje potrzeb duplikacji kodu oraz zwiksza jego czytelno i utrzymanie. Szablony odgrywaj kluczow rol w metaprogramowaniu w C++, pozwalajc na wykonywanie oblicze na etapie kompilacji oraz optymalizacj kodu wynikowego. Poni偶ej przedstawiono szczeg贸owe om贸wienie r贸偶nych aspekt贸w szablon贸w w C++, wraz z przykadami i wyjanieniami.</p>
            <h3 id="szablony-funkcji">Szablony Funkcji</h3>
            <p>Szablony funkcji pozwalaj na definiowanie funkcji, kt贸re dziaaj na r贸偶nych typach danych. Umo偶liwiaj one tworzenie generycznego kodu, kt贸ry jest bardziej uniwersalny i mo偶e by stosowany w szerokim zakresie zastosowa bez koniecznoci pisania osobnych wersji funkcji dla ka偶dego typu danych. Og贸lna skadnia definicji szablonu funkcji jest nastpujca:</p>
            <p>
            <div>
                <pre><code class="language-clike">template &lt;parametry_szablonu&gt;
typ_zwracany nazwa_funkcji(argumenty) {

    // ciao funkcji

}</code></pre>
            </div>
            </p>
            <p><strong>Przykad:</strong> </p>
            <p>Definicja generycznej funkcji <code>max2</code>, kt贸ra zwraca wiksz z dw贸ch wartoci:</p>
            <p>
            <div>
                <pre><code class="language-clike">template &lt;typename t=""&gt;
T max2(T arg1, T arg2) {
    return arg1 &gt; arg2 ? arg1 : arg2;
}</code></pre>
            </div>
            </p>
            <ul>
                <li><code>template &lt;typename T&gt;</code> deklaruje szablon z parametrem typu <code>T</code>, kt贸ry mo偶e by dowolnym typem danych (np. <code>int</code>, <code>double</code>, <code>std::string</code>).</li>
                <li>Funkcja <code>max2</code> przyjmuje dwa argumenty typu <code>T</code> i zwraca warto typu <code>T</code>.</li>
                <li>Operator <code>?:</code> zwraca <code>arg1</code> lub <code>arg2</code> w zale偶noci od wyniku por贸wnania <code>arg1 &gt; arg2</code>, co pozwala na elastyczne por贸wnywanie r贸偶nych typ贸w danych.</li>
            </ul>
            <p><strong>U偶ycie funkcji szablonowej:</strong></p>
            <p>Szablony funkcji s wykorzystywane poprzez ich instancjowanie z konkretnymi typami danych, co pozwala na ich wielokrotne u偶ycie bez koniecznoci definiowania nowych funkcji dla ka偶dego typu.</p>
            <p>
            <div>
                <pre><code class="language-clike">int a = max2&lt;int&gt;(10, 20);            // Wynik: 20
double b = max2&lt;double&gt;(16.2, 3.14);  // Wynik: 16.2
char c = max2&lt;char&gt;('a', 'b');        // Wynik: 'b'</code></pre>
            </div>
            </p>
            <h4 id="mechanizm-instancjacji">Mechanizm Instancjacji</h4>
            <p>Podczas kompilacji, gdy funkcja szablonowa jest wywoywana z konkretnym typem, kompilator tworzy jej <strong>instancj</strong> dla tego typu. Proces ten nazywany jest <strong>instancjacj szablonu</strong>. Dziki temu generowany kod jest zoptymalizowany pod ktem u偶ytych typ贸w, eliminujc narzut wydajnociowy zwizany z polimorfizmem dynamicznym. Instancjacja szablon贸w pozwala na tworzenie specjalizowanych wersji funkcji lub klas, kt贸re s dostosowane do specyficznych potrzeb aplikacji, co zwiksza efektywno i wydajno kodu.</p>
            <h3 id="szablony-klas">Szablony Klas</h3>
            <p>Szablony klas umo偶liwiaj definiowanie klas generycznych, kt贸re mog operowa na r贸偶nych typach danych. Dziki temu mo偶na tworzy bardziej elastyczne i wielokrotnego u偶ytku struktury danych oraz obiekt贸w. Skadnia szablonu klasy jest podobna do szablonu funkcji, co uatwia zrozumienie i implementacj.</p>
            <p><strong>Przykad:</strong> </p>
            <p>Definicja szablonu klasy <code>Box</code>:</p>
            <p>
            <div>
                <pre><code class="language-clike">template &lt;typename t=""&gt;
class Box {
private:
    T content;

public:
    Box(T content) : content(content) {}
    T getContent() const { return content; }
};</code></pre>
            </div>
            </p>
            <ul>
                <li><code>template &lt;typename T&gt;</code>: Deklaruje szablon klasy z parametrem typu <code>T</code>, co pozwala na przechowywanie r贸偶nych typ贸w danych w jednej klasie.</li>
                <li><code>T content;</code>: Zmienna czonkowska przechowujca zawarto typu <code>T</code>, co umo偶liwia elastyczne przechowywanie dowolnego typu danych.</li>
                <li>Konstruktor i metoda <code>getContent()</code> operuj na typie <code>T</code>, co zapewnia, 偶e klasa <code>Box</code> jest w peni generyczna i mo偶e by u偶ywana z dowolnym typem danych.</li>
            </ul>
            <p><strong>Tworzenie instancji szablonu klasy:</strong></p>
            <p>Szablony klas s wykorzystywane poprzez okrelenie konkretnego typu danych podczas tworzenia obiektu.</p>
            <p>
            <div>
                <pre><code class="language-clike">Box&lt;int&gt; intBox(42);

Box&lt;std::string&gt; stringBox("Witaj");</code></pre>
            </div>
            </p>
            <h4 id="wielokrotne-parametry-szablonu">Wielokrotne Parametry Szablonu</h4>
            <p>Szablony mog przyjmowa wiele parametr贸w, zar贸wno typ贸w, jak i wartoci staych. Pozwala to na bardziej precyzyjne parametryzowanie kodu, co zwiksza jego elastyczno i umo偶liwia tworzenie bardziej zaawansowanych struktur danych oraz algorytm贸w.</p>
            <p><strong>Przykad:</strong> </p>
            <p>Szablon klasy <code>Array</code> z dwoma parametrami:</p>
            <p>
            <div>
                <pre><code class="language-clike">template &lt;typename size="" std::size_t="" t,=""&gt;
class Array {
private:
    T elements[Size];

public:
    // Metody dostpu i modyfikacji element贸w
};</code></pre>
            </div>
            </p>
            <p><strong>U偶ycie:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">Array&lt;int, 5=""&gt; myArray;</code></pre>
            </div>
            </p>
            <p>W tym przykadzie, szablon klasy <code>Array</code> przyjmuje zar贸wno typ danych <code>T</code>, jak i sta <code>Size</code>, co pozwala na tworzenie tablic o dynamicznie okrelonym rozmiarze i typie danych.</p>
            <h4 id="specjalizacja-szablonu">Specjalizacja Szablonu</h4>
            <p>Czasami istnieje potrzeba dostosowania zachowania szablonu dla konkretnego typu. W takich przypadkach u偶ywamy <strong>specjalizacji szablonu</strong>, co pozwala na definiowanie unikalnych implementacji dla wybranych typ贸w danych, zachowujc jednoczenie og贸lno szablonu dla innych typ贸w.</p>
            <p><strong>Przykad:</strong> </p>
            <p>Specjalizacja szablonu klasy <code>Box</code> dla typu <code>std::string</code>:</p>
            <p>
            <div>
                <pre><code class="language-clike">template &lt;&gt;
class Box&lt;std::string&gt; {
private:
    std::string content;

public:
    Box(std::string content) : content(content) {}
    std::string getContent() const { return "Zawarto: " + content; }
};</code></pre>
            </div>
            </p>
            <ul>
                <li><code>template &lt;&gt;</code>: Wskazuje pen specjalizacj szablonu, co oznacza, 偶e ta definicja jest unikalna dla okrelonego typu.</li>
                <li><code>class Box&lt;std::string&gt;</code>: Specjalizacja szablonu <code>Box</code> dla typu <code>std::string</code> umo偶liwia dostosowanie zachowania klasy do specyfiki tego typu danych.</li>
                <li>Metoda <code>getContent()</code> zostaa zmodyfikowana, aby zwraca prefiksowany cig znak贸w, co jest specyficzne dla typu <code>std::string</code> i nie byoby konieczne dla innych typ贸w.</li>
            </ul>
            <h3 id="typy-domylne-w-szablonach">Typy Domylne w Szablonach</h3>
            <p>Mo偶emy definiowa wartoci domylne dla parametr贸w szablonu, co zwiksza elastyczno ich u偶ycia. Dziki wartociom domylnym, programista mo偶e tworzy instancje szablon贸w bez koniecznoci podawania wszystkich parametr贸w, co upraszcza kod i poprawia jego czytelno.</p>
            <p><strong>Przykad:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">template &lt;typename size="10" std::size_t="" t="int,"&gt;
class Array {
private:

    T elements[Size];

public:

    // Implementacja metod

};</code></pre>
            </div>
            </p>
            <p><strong>U偶ycie:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">Array&lt;&gt; defaultArray;             // Typ T=int, Size=10
Array&lt;double, 5=""&gt; customArray;     // Typ T=double, Size=5</code></pre>
            </div>
            </p>
            <p>W tym przykadzie, szablon klasy <code>Array</code> ma zdefiniowane wartoci domylne dla parametr贸w <code>T</code> i <code>Size</code>, co pozwala na tworzenie instancji z domylnymi ustawieniami lub z niestandardowymi parametrami w zale偶noci od potrzeb.</p>
            <h3 id="szablony-zmiennych">Szablony Zmiennych</h3>
            <p>Od C++14 mo偶liwe jest definiowanie szablon贸w zmiennych, co pozwala na tworzenie zmiennych parametryzowanych typem. Szablony zmiennych s szczeg贸lnie przydatne w przypadku staych wartoci, kt贸re mog by r贸偶ne w zale偶noci od typu danych.</p>
            <p><strong>Przykad:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">template&lt;typename t=""&gt;
constexpr T pi = T(3.1415926535897932385);

auto floatPi = pi&lt;float&gt;;
auto doublePi = pi&lt;double&gt;;</code></pre>
            </div>
            </p>
            <p><strong>Wyjanienie:</strong></p>
            <ul>
                <li><code>constexpr</code> oznacza, 偶e warto jest staa w czasie kompilacji, co pozwala na optymalizacj i redukcj koszt贸w czasowych w czasie wykonywania programu.</li>
                <li><code>pi&lt;T&gt;</code> jest zmienn szablonow parametryzowan typem <code>T</code>, co umo偶liwia tworzenie precyzyjnych wersji staej <code>pi</code> dla r贸偶nych typ贸w danych, takich jak <code>float</code> czy <code>double</code>.</li>
            </ul>
            <h3 id="aliasowanie-szablon贸w">Aliasowanie Szablon贸w</h3>
            <p>C++11 wprowadzi mo偶liwo tworzenia alias贸w szablon贸w za pomoc sowa kluczowego <code>using</code>. Aliasowanie szablon贸w uatwia prac z zo偶onymi typami szablonowymi, poprawiajc czytelno kodu oraz zmniejszajc jego zo偶ono.</p>
            <p><strong>Przykad:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">template &lt;typename t=""&gt;
using Vec = std::vector&lt;t&gt;;

Vec&lt;int&gt; intVector;
Vec&lt;double&gt; doubleVector;</code></pre>
            </div>
            </p>
            <p>W tym przykadzie, alias <code>Vec</code> jest u偶ywany do reprezentowania <code>std::vector&lt;T&gt;</code>, co upraszcza deklaracj wektor贸w r贸偶nych typ贸w i poprawia czytelno kodu.</p>
            <h3 id="szablony-lambda">Szablony Lambda</h3>
            <p>Od C++20 mo偶na tworzy szablony funkcji lambda, co dodatkowo zwiksza mo偶liwoci programistyczne. Szablony lambda pozwalaj na definiowanie anonimowych funkcji generycznych, kt贸re mog by wykorzystywane w r贸偶nych kontekstach bez potrzeby definiowania osobnych funkcji.</p>
            <p><strong>Przykad:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">auto lambda = []&lt;typename t=""&gt;(T a, T b) {
    return a + b;
};

auto sumInt = lambda(5, 3);           // Wynik: 8
auto sumDouble = lambda(2.5, 1.5);    // Wynik: 4.0</code></pre>
            </div>
            </p>
            <p>W tym przykadzie, lambda jest szablonem funkcji, kt贸ry mo偶e przyjmowa r贸偶ne typy danych <code>T</code> i wykonywa na nich operacj dodawania, co czyni j niezwykle elastyczn i wielokrotnego u偶ytku.</p>
            <h3 id="metaprogramowanie-szablonowe">Metaprogramowanie Szablonowe</h3>
            <p>Metaprogramowanie szablonowe to technika, kt贸ra wykorzystuje szablony do wykonywania oblicze na etapie kompilacji. Pozwala to na optymalizacj kodu oraz wykonywanie skomplikowanych oblicze bez narzutu w czasie wykonywania programu. Metaprogramowanie szablonowe jest szczeg贸lnie przydatne w przypadkach, gdzie wydajno jest kluczowa, a obliczenia mog by przeprowadzone wczeniej, podczas kompilacji.</p>
            <h3 id="przykad-obliczanie-liczby-fibonacciego">Przykad: Obliczanie Liczby Fibonacciego</h3>
            <p>Obliczanie wartoci cigu Fibonacciego za pomoc szablon贸w:</p>
            <p>
            <div>
                <pre><code class="language-clike">template&lt;int n=""&gt;
struct Fibonacci {
    static_assert(N &gt;= 0, "N musi by nieujemne");
    static constexpr int value = Fibonacci&lt;n -="" 1=""&gt;::value + Fibonacci&lt;n -="" 2=""&gt;::value;
};

template&lt;&gt;
struct Fibonacci&lt;0&gt; {
    static constexpr int value = 0;
};

template&lt;&gt;
struct Fibonacci&lt;1&gt; {
    static constexpr int value = 1;
};

constexpr int fib10 = Fibonacci&lt;10&gt;::value; // Wynik: 55</code></pre>
            </div>
            </p>
            <ul>
                <li><strong>Rekurencja w czasie kompilacji</strong> polega na tym, 偶e struktura <code>Fibonacci</code> jest rekurencyjnie instancjonowana dla wartoci <code>N</code>, a偶 do osignicia przypadk贸w bazowych, takich jak <code>N=0</code> i <code>N=1</code>, co pozwala na obliczenia w trakcie kompilacji.</li>
                <li><strong><code>static_assert</code></strong> jest u偶ywany do sprawdzania warunk贸w w czasie kompilacji, co pozwala na weryfikacj poprawnoci kodu przed jego wykonaniem. W tym przypadku, zapewnia, 偶e <code>N</code> jest nieujemne.</li>
                <li><strong><code>constexpr</code></strong> zapewnia, 偶e dana warto zostanie obliczona w czasie kompilacji, co zwiksza efektywno i pozwala na lepsz optymalizacj kodu.</li>
            </ul>
            <h4 id="analiza-matematyczna">Analiza Matematyczna</h4>
            <p>Cig Fibonacciego jest zdefiniowany rekurencyjnie:</p>
            <p>$$
                F(0) = 0, \quad F(1) = 1, \quad F(N) = F(N-1) + F(N-2) \text{ dla } N \geq 2
                $$</p>
            <p>Implementacja za pomoc szablon贸w odwzorowuje t definicj, pozwalajc kompilatorowi na obliczenie wartoci <code>F(N)</code> podczas kompilacji. Dziki temu, wartoci cigu Fibonacciego s dostpne w czasie kompilacji, co mo偶e by u偶yteczne w r贸偶nych optymalizacjach i zastosowaniach.</p>
            <h5>Zastosowania Metaprogramowania Szablonowego</h5>
            <ul>
                <li><strong>Optymalizacja</strong> polega na usuniciu narzutu czasowego poprzez przeniesienie oblicze z etapu wykonania programu na etap kompilacji, co przyspiesza dziaanie aplikacji. Dziki temu, program mo偶e dziaa szybciej, poniewa偶 wiele oblicze zostao ju偶 wykonanych przed jego uruchomieniem.</li>
                <li><strong>Generowanie kod贸w specjalizowanych</strong> umo偶liwia tworzenie kodu dostosowanego do konkretnych typ贸w lub wartoci, co poprawia wydajno i elastyczno aplikacji. Szablony mog automatycznie generowa r贸偶ne wersje funkcji lub klas, zoptymalizowane pod ktem specyficznych potrzeb.</li>
                <li><strong>Sprawdzanie warunk贸w w czasie kompilacji</strong> odbywa si za pomoc <code>static_assert</code>, kt贸ry pozwala na weryfikacj zao偶e programu przed jego uruchomieniem, eliminujc potencjalne bdy ju偶 na etapie kompilacji. Dziki temu, programista mo偶e szybko zidentyfikowa i naprawi bdy, zanim program zostanie uruchomiony.</li>
            </ul>
            <h3 id="zastosowanie-szablon贸w-w-praktyce">Zastosowanie Szablon贸w w Praktyce</h3>
            <p>Szablony s integraln czci jzyka C++ i stanowi podstaw wielu bibliotek oraz aplikacji komercyjnych. Ich zdolno do tworzenia kodu generycznego, kt贸ry mo偶e dziaa z r贸偶nymi typami danych, sprawia, 偶e s one niezbdne w nowoczesnym programowaniu. W tej sekcji przyjrzymy si, jak szablony s wykorzystywane w praktyce, skupiajc si na standardowej bibliotece C++ (STL) oraz na innych popularnych bibliotekach, takich jak Boost czy Eigen.</p>
            <h4 id="standardowa-biblioteka-szablon贸w-stl-">Standardowa Biblioteka Szablon贸w (STL)</h4>
            <p>STL (Standard Template Library) jest zestawem klas i funkcji szablonowych dostarczanych przez standardow bibliotek C++. Zostaa ona zaprojektowana w celu zapewnienia programistom gotowych do u偶ycia struktur danych oraz algorytm贸w, kt贸re s zar贸wno wydajne, jak i atwe w u偶yciu. STL jest szeroko stosowana w r贸偶nych aplikacjach, od prostych program贸w konsolowych po zaawansowane systemy o du偶ej skali.</p>
            <h5>Kontenery</h5>
            <p>Kontenery s klasami szablonowymi, kt贸re przechowuj kolekcje obiekt贸w. Dziki szablonom mog one przechowywa elementy dowolnego typu, co czyni je niezwykle elastycznymi i wielokrotnego u偶ytku. Kontenery w STL s zoptymalizowane pod ktem r贸偶nych operacji, takich jak dodawanie, usuwanie czy wyszukiwanie element贸w, co pozwala na efektywne zarzdzanie danymi.</p>
            <p>Oto niekt贸re z najwa偶niejszych kontener贸w w STL:</p>
            <p>
            <table>
                <tr>
                    <td>Kontener</td>
                    <td>Opis</td>
                </tr>
                <tr>
                    <td><strong><code>std::vector</code></strong></td>
                    <td>Dynamiczna tablica o zmiennym rozmiarze.</td>
                </tr>
                <tr>
                    <td><strong><code>std::list</code></strong></td>
                    <td>Lista dwukierunkowa.</td>
                </tr>
                <tr>
                    <td><strong><code>std::deque</code></strong></td>
                    <td>Dwustronna kolejka.</td>
                </tr>
                <tr>
                    <td><strong><code>std::set</code></strong></td>
                    <td>Zbi贸r unikalnych element贸w, uporzdkowanych.</td>
                </tr>
                <tr>
                    <td><strong><code>std::map</code></strong></td>
                    <td>Asocjacyjny kontener przechowujcy pary klucz-warto.</td>
                </tr>
                <tr>
                    <td><strong><code>std::unordered_set</code></strong></td>
                    <td>Nieuporzdkowany zbi贸r wykorzystujcy tablice haszujce.</td>
                </tr>
                <tr>
                    <td><strong><code>std::unordered_map</code></strong></td>
                    <td>Nieuporzdkowana mapa wykorzystujca tablice haszujce do par klucz-warto.</td>
                </tr>
            </table>
            </p>
            <p>Ka偶dy z tych kontener贸w ma swoje specyficzne zastosowania i jest zoptymalizowany pod ktem r贸偶nych operacji, co pozwala programistom na wyb贸r najbardziej odpowiedniego kontenera dla ich potrzeb.</p>
            <h5>Algorytmy</h5>
            <p>Algorytmy w STL s funkcjami szablonowymi, kt贸re wykonuj operacje na danych przechowywanych w kontenerach. S one niezale偶ne od konkretnych typ贸w danych i kontener贸w, o ile dostarczone s odpowiednie iteratory. Algorytmy w STL obejmuj szeroki zakres operacji, takich jak sortowanie, wyszukiwanie, modyfikowanie czy transformowanie danych, co pozwala na efektywne i elastyczne manipulowanie kolekcjami danych.</p>
            <p>
            <table>
                <tr>
                    <td>Funkcja</td>
                    <td>Opis</td>
                </tr>
                <tr>
                    <td><strong><code>std::sort</code></strong></td>
                    <td>Sortowanie element贸w w zakresie.</td>
                </tr>
                <tr>
                    <td><strong><code>std::find</code></strong></td>
                    <td>Wyszukiwanie elementu w zakresie.</td>
                </tr>
                <tr>
                    <td><strong><code>std::accumulate</code></strong></td>
                    <td>Sumowanie wartoci w zakresie.</td>
                </tr>
                <tr>
                    <td><strong><code>std::copy</code></strong></td>
                    <td>Kopiowanie element贸w z jednego zakresu do drugiego.</td>
                </tr>
            </table>
            </p>
            <p>Algorytmy te s zoptymalizowane pod ktem wydajnoci i mog by stosowane do r贸偶nych typ贸w danych, co czyni je niezwykle wszechstronnymi narzdziami w arsenale programisty C++.</p>
            <h5>Iteratory</h5>
            <p>Iteratory s abstrakcj wska藕nik贸w, kt贸re pozwalaj na jednolite interfejsy do przegldania element贸w w kontenerach. S one zaimplementowane jako szablony, dziki czemu mog dziaa z r贸偶nymi typami kontener贸w. Iteratory umo偶liwiaj programistom pisanie bardziej generycznego i elastycznego kodu, kt贸ry mo偶e dziaa z dowolnym kontenerem, kt贸ry wspiera dany typ iteratora.</p>
            <h4 id="przykad-kontener-std-vector">Przykad: Kontener <code>std::vector</code></h4>
            <p><code>std::vector</code> jest jednym z najczciej u偶ywanych kontener贸w w STL. Reprezentuje dynamiczn tablic, kt贸ra mo偶e zmienia sw贸j rozmiar w czasie wykonywania programu. Dziki wykorzystaniu szablon贸w, <code>std::vector</code> mo偶e przechowywa elementy dowolnego typu, co czyni go niezwykle elastycznym narzdziem do zarzdzania dynamicznymi kolekcjami danych.</p>
            <p><strong>Definicja szablonu <code>std::vector</code>:</strong></p>
            <p>W uproszczeniu, <code>std::vector</code> jest zdefiniowany nastpujco:</p>
            <p>
            <div>
                <pre><code class="language-clike">template &lt;typename allocator="std::allocator&lt;T" t,="" typename=""&gt;&gt;
class vector {

    // Implementacja wewntrzna

};</code></pre>
            </div>
            </p>
            <p><strong>Parametry szablonu:</strong></p>
            <ul>
                <li><strong><code>typename T</code></strong> okrela typ przechowywanych element贸w, co pozwala na tworzenie szablon贸w, kt贸re mog dziaa z r贸偶nymi typami danych.</li>
                <li><strong><code>typename Allocator</code></strong> definiuje typ alokatora u偶ywanego do zarzdzania pamici, z domyln wartoci <code>std::allocator&lt;T&gt;</code>, co umo偶liwia elastyczne zarzdzanie pamici dla element贸w.</li>
            </ul>
            <p><strong>Przykady u偶ycia:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">std::vector&lt;int&gt; vecInt;            // Wektor liczb cakowitych
std::vector&lt;double&gt; vecDouble;      // Wektor liczb zmiennoprzecinkowych
std::vector&lt;std::string&gt; vecString; // Wektor acuch贸w znak贸w</code></pre>
            </div>
            </p>
            <p>W tym przykadzie, <code>std::vector</code> jest u偶ywany do przechowywania r贸偶nych typ贸w danych, co pokazuje jego elastyczno i wszechstronno. Dziki szablonom, mo偶na atwo tworzy wektory dla dowolnego typu danych, co znacznie uatwia zarzdzanie dynamicznymi kolekcjami.</p>
            <h4 id="biblioteka-boost">Biblioteka Boost</h4>
            <p>Boost to zestaw bibliotek C++ rozszerzajcych funkcjonalno standardowej biblioteki. Wiele z nich jest proponowanych do wczenia do standardu C++. Szablony s intensywnie wykorzystywane w celu zapewnienia elastycznoci i wydajnoci.</p>
            <p><strong>Przykad: <code>boost::shared_ptr</code></strong></p>
            <p>Przed wprowadzeniem <code>std::shared_ptr</code> w C++11, <code>boost::shared_ptr</code> by szeroko stosowanym inteligentnym wska藕nikiem zarzdzajcym 偶yciem obiektu.</p>
            <p><strong>Definicja:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">template&lt;typename t=""&gt;
class shared_ptr {
    // Implementacja wewntrzna
};</code></pre>
            </div>
            </p>
            <p><strong>U偶ycie:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">boost::shared_ptr&lt;myclass&gt; ptr(new MyClass());</code></pre>
            </div>
            </p>
            <p><strong>Zalety:</strong></p>
            <ul>
                <li>Automatyczne zarzdzanie pamici poprzez licznik referencji.</li>
                <li>Bezpieczestwo w rodowiskach wielowtkowych (z odpowiedni synchronizacj).</li>
            </ul>
            <h4 id="biblioteka-eigen">Biblioteka Eigen</h4>
            <p>Eigen to szablonowa biblioteka C++ do algebry liniowej, zoptymalizowana pod ktem wysokiej wydajnoci.</p>
            <p><strong>Definicja szablonu macierzy:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">template&lt;typename colsatcompiletime="" int="" rowsatcompiletime,="" scalar,=""&gt;
class Matrix {
    // Implementacja wewntrzna
};</code></pre>
            </div>
            </p>
            <p><strong>Przykad u偶ycia:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">Eigen::Matrix&lt;float, 3="" 3,=""&gt; matA;
Eigen::Matrix&lt;float, 1="" 3,=""&gt; vecB;

matA &lt;&lt; 1, 2, 3,
         4, 5, 6,
         7, 8, 9;

vecB &lt;&lt; 1,
         2,
         3;

Eigen::Matrix&lt;float, 1="" 3,=""&gt; result = matA * vecB;</code></pre>
            </div>
            </p>
            <p>Waciwoci:</p>
            <ul>
                <li><strong>Statyczne rozmiary</strong> macierzy, gdy s znane w czasie kompilacji, pozwalaj bibliotece Eigen na generowanie wysoce wydajnego kodu, co zwiksza efektywno oblicze.</li>
                <li><strong>Szablony wyra偶eniowe</strong> (<em>Expression Templates</em>) umo偶liwiaj optymalizacj oblicze, minimalizujc tworzenie niepotrzebnych kopii danych, co poprawia wydajno dziaania programu.</li>
            </ul>
            <p>Analiza wydajnoci:</p>
            <ul>
                <li><strong>Unikanie alokacji pamici</strong> jest mo偶liwe dziki zastosowaniu szablon贸w i mechanizmu inlining, co pozwala bibliotece Eigen na wykonywanie operacji bez potrzeby dodatkowych alokacji pamici, co zwiksza wydajno.</li>
                <li><strong>Wektorowe instrukcje procesora</strong> s automatycznie wykorzystywane przez Eigen, dziki wsparciu dla instrukcji SIMD (Single Instruction, Multiple Data), jeli s one dostpne na danej platformie, co przyspiesza operacje matematyczne.</li>
            </ul>
            <h4 id="koncepty-c-20-">Koncepty (C++20)</h4>
            <p>Koncepty wprowadzaj mo偶liwo definiowania wymaga dla parametr贸w szablonu, co uatwia tworzenie bardziej czytelnego i bezpiecznego kodu.</p>
            <p><strong>Przykad:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">template&lt;typename t=""&gt;
concept Number = std::is_arithmetic_v&lt;t&gt;;

template&lt;number t=""&gt;
T multiply(T a, T b) {
    return a * b;
}</code></pre>
            </div>
            </p>
            <p><strong>Zalety:</strong></p>
            <ul>
                <li><strong>Poprawa czytelnoci bd贸w kompilacji</strong> wynika z zastosowania koncept贸w, kt贸re umo偶liwiaj kompilatorowi dostarczenie bardziej precyzyjnych i zrozumiaych komunikat贸w o bdach, co uatwia debugowanie.</li>
                <li><strong>Dokumentacja wymaga</strong> jest naturalnym efektem u偶ycia koncept贸w, poniewa偶 jasno okrelaj one, jakie wymagania musi spenia typ parametr贸w szablonu, co poprawia zrozumiao i u偶yteczno kodu.</li>
            </ul>
            <h3 id="zaawansowane-techniki-z-szablonami">Zaawansowane Techniki z Szablonami</h3>
            <p>W miar rozwoju jzyka C++, szablony stay si nie tylko narzdziem do tworzenia generycznego kodu, ale tak偶e platform do implementacji zaawansowanych technik programistycznych. W tej sekcji om贸wimy kilka z tych zaawansowanych technik, kt贸re pozwalaj na jeszcze wiksz elastyczno i moc w tworzeniu aplikacji. Skoncentrujemy si na szablonach o zmiennej liczbie argument贸w, wyra偶eniach <code>constexpr</code> w szablonach, szablonach wewntrznych (CRTP), a tak偶e na om贸wieniu ogranicze i wyzwa zwizanych z ich u偶ywaniem. Dodatkowo, przedstawimy praktyczne wskaz贸wki, kt贸re pomog w efektywnym wykorzystaniu tych technik w codziennym programowaniu.</p>
            <h4 id="szablony-o-zmiennej-liczbie-argument贸w">Szablony o Zmiennej Liczbie Argument贸w</h4>
            <p>Szablony o zmiennej liczbie argument贸w, znane r贸wnie偶 jako <em>variadic templates</em>, zostay wprowadzone w standardzie C++11 i stanowi pot偶ne rozszerzenie tradycyjnych szablon贸w. Umo偶liwiaj one definiowanie funkcji i klas, kt贸re mog przyjmowa dowoln liczb parametr贸w, co jest niezwykle przydatne w sytuacjach, gdy liczba argument贸w nie jest znana z g贸ry lub mo偶e si dynamicznie zmienia.</p>
            <p><strong>Przykad:</strong> Funkcja <code>print</code> wywietlajca dowoln liczb argument贸w:</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;

template&lt;typename... args=""&gt;
void print(Args... args) {
    (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; std::endl;
}

int main() {
    print(1, 2, 3);                 // Wywietla: 123
    print("Witaj, ", "wiecie!");   // Wywietla: Witaj, wiecie!
    return 0;
}</code></pre>
            </div>
            </p>
            <ul>
                <li><code>template&lt;typename... Args&gt;</code>: Deklaruje szablon z pakietem typ贸w <code>Args</code>. Operator <code>...</code> oznacza, 偶e <code>Args</code> mo偶e reprezentowa dowoln liczb typ贸w.</li>
                <li><code>Args... args</code>: Pakiet argument贸w funkcji. Podobnie jak powy偶ej, <code>...</code> wskazuje na zmienn liczb argument贸w.</li>
                <li><code>(std::cout &lt;&lt; ... &lt;&lt; args)</code>: Fold expression, dostpne od C++17, kt贸re umo偶liwia skadanie wyra偶e binarnych. W tym przypadku, czy wszystkie argumenty za pomoc operatora <code>&lt;&lt;</code> i wypisuje je na standardowe wyjcie.</li>
            </ul>
            <p><strong>Zastosowanie:</strong></p>
            <p>Szablony o zmiennej liczbie argument贸w s niezwykle przydatne w tworzeniu funkcji, kt贸re musz obsugiwa dynamiczn liczb parametr贸w, takich jak funkcje logujce, formatowania czy tworzenia kontener贸w o zmiennym rozmiarze.</p>
            <h4 id="wyra偶enia-constexpr-w-szablonach">Wyra偶enia <code>constexpr</code> w Szablonach</h4>
            <p>Sowo kluczowe <code>constexpr</code> zostao wprowadzone w C++11 i pozwala na wykonywanie oblicze w czasie kompilacji. W poczeniu z szablonami, <code>constexpr</code> umo偶liwia tworzenie funkcji, kt贸re zwracaj stae wartoci zale偶ne od parametr贸w szablonu, co mo偶e prowadzi do znacznych optymalizacji kodu.</p>
            <p><strong>Przykad:</strong> Funkcja <code>square</code> obliczajca kwadrat liczby:</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;

template&lt;typename t=""&gt;
constexpr T square(T x) {
    return x * x;
}

int main() {
    constexpr int squareOfFive = square(5); // Wynik: 25
    std::cout &lt;&lt; "Kwadrat 5 to: " &lt;&lt; squareOfFive &lt;&lt; std::endl;
    return 0;
}</code></pre>
            </div>
            </p>
            <ul>
                <li><code>template&lt;typename T&gt;</code>: Deklaruje szablon funkcji z parametrem typu <code>T</code>.</li>
                <li><code>constexpr T square(T x)</code>: Funkcja oznaczona jako <code>constexpr</code>, co oznacza, 偶e mo偶e by oceniona w czasie kompilacji, jeli argumenty s znane w tym czasie.</li>
                <li><code>constexpr int squareOfFive = square(5);</code>: Inicjalizuje sta <code>squareOfFive</code> wynikiem funkcji <code>square(5)</code>, kt贸ry jest obliczany w czasie kompilacji.</li>
            </ul>
            <p><strong>Zastosowanie:</strong></p>
            <p>Funkcje <code>constexpr</code> s u偶yteczne w przypadkach, gdzie potrzebne s stae wartoci obliczane na podstawie parametr贸w szablonu, co mo偶e prowadzi do bardziej wydajnego kodu dziki wstpnej ocenie wyra偶e.</p>
            <h5>Szablony Wewntrzne (Curiously Recurring Template Pattern - CRTP)</h5>
            <p>Curiously Recurring Template Pattern (CRTP) to idiom programistyczny, w kt贸rym klasa dziedziczy po szablonie swojej wasnej klasy. Technika ta pozwala na osignicie statycznego polimorfizmu oraz umo偶liwia implementacj funkcji, kt贸re s specyficzne dla klasy pochodnej, bez u偶ycia wirtualnych metod.</p>
            <p><strong>Przykad:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;

// Szablon bazowej klasy wykorzystujcy CRTP
template&lt;typename derived=""&gt;
class Base {
public:
    void interface() {
        // Wywouje implementacj specyficzn dla klasy pochodnej
        static_cast&lt;derived*&gt;(this)-&gt;implementation();
    }

    void commonFunction() {
        std::cout &lt;&lt; "Funkcja wsp贸lna w klasie Base." &lt;&lt; std::endl;
    }
};

// Klasa pochodna dziedziczca po Base za pomoc CRTP
class DerivedClass : public Base&lt;derivedclass&gt; {
public:
    void implementation() {
        std::cout &lt;&lt; "Implementacja specyficzna dla DerivedClass." &lt;&lt; std::endl;
    }
};

int main() {
    DerivedClass obj;
    obj.interface();         // Wywouje DerivedClass::implementation()
    obj.commonFunction();    // Wywouje Base::commonFunction()
    return 0;
}</code></pre>
            </div>
            </p>
            <ul>
                <li><code>template&lt;typename Derived&gt;</code>: Szablon bazowej klasy przyjmujcy typ klasy pochodnej.</li>
                <li><code>static_cast&lt;Derived*&gt;(this)-&gt;implementation()</code>: Rzutowanie wska藕nika <code>this</code> na typ klasy pochodnej i wywoanie jej metody <code>implementation()</code>.</li>
                <li><code>DerivedClass : public Base&lt;DerivedClass&gt;</code>: Klasa pochodna dziedziczy po bazowej klasie szablonowej, przekazujc siebie jako parametr szablonu.</li>
            </ul>
            <p><strong>Zastosowania:</strong></p>
            <ul>
                <li><strong>Statyczny polimorfizm</strong> umo偶liwia polimorfizm bez koszt贸w zwizanych z dynamicznym wizaniem, co zwiksza wydajno.</li>
                <li><strong>Klasy mixin</strong> pozwalaj na dodawanie funkcjonalnoci do klas pochodnych w spos贸b moduowy i wielokrotnego u偶ytku.</li>
            </ul>
            <h4 id="ograniczenia-i-wyzwania">Ograniczenia i Wyzwania</h4>
            <p>Mimo 偶e szablony oferuj ogromne mo偶liwoci, ich u偶ycie wi偶e si r贸wnie偶 z pewnymi ograniczeniami i wyzwaniami, kt贸re programici powinni mie na uwadze:</p>
            <ul>
                <li>Bdy w kodzie szablonowym czsto generuj dugie i trudne do zrozumienia komunikaty kompilatora, co utrudnia diagnozowanie problem贸w.</li>
                <li>Intensywne u偶ycie szablon贸w mo偶e znacznie wydu偶y czas kompilacji, szczeg贸lnie w du偶ych projektach.</li>
                <li>Szablony mog wprowadza zale偶noci, kt贸re nie s od razu widoczne, co mo偶e prowadzi do trudnych do zidentyfikowania bd贸w lub problem贸w z kompatybilnoci.</li>
                <li>Nadmierne korzystanie ze szablon贸w mo偶e uczyni kod mniej czytelnym i trudniejszym do utrzymania, zwaszcza dla programist贸w nieznajcych zaawansowanych technik szablonowych.</li>
            </ul>
            <h4 id="praktyczne-wskaz贸wki">Praktyczne Wskaz贸wki</h4>
            <p>Aby skutecznie wykorzysta zaawansowane techniki szablonowe i unikn typowych puapek, warto przestrzega kilku praktycznych zasad:</p>
            <ul>
                <li>Jeli to mo偶liwe, u偶ywaj koncept贸w do jasno okrelenia wymaga dla parametr贸w szablonu. Pozwala to na lepsz czytelno kodu oraz wczeniejsze wykrywanie bd贸w.</li>
            </ul>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;concepts&gt;

template&lt;std::integral t=""&gt;
T add(T a, T b) {
  return a + b;
}</code></pre>
            </div>
            </p>
            <ul>
                <li>Dokumentuj, jakie cechy lub interfejsy musz posiada typy u偶ywane jako parametry szablonu. Uatwia to zrozumienie kodu oraz jego prawidowe u偶ycie.</li>
                <li>Staraj si nie komplikowa kodu szablonowego bardziej ni偶 to konieczne. Zo偶one szablony mog by trudne do zrozumienia i utrzymania, co zwiksza ryzyko bd贸w.</li>
                <li>Projektuj szablony w spos贸b modularny, aby mogy by atwo reu偶ywane w r贸偶nych kontekstach. To zwiksza ich warto i uatwia integracj z innymi komponentami systemu.</li>
                <li>Monitoruj czas kompilacji i optymalizuj u偶ycie szablon贸w, aby unikn znacznego wydu偶enia procesu kompilacji. Mo偶na to osign poprzez stosowanie technik takich jak prekompilowane nag贸wki lub ograniczenie gbokoci rekurencji szablon贸w.</li>
            </ul>
        </section>
        <div id="table-of-contents">
            <h2>Spis Treci</h2>
            <ol><a href="#szablony">Szablony</a>
                <ol>
                    <li><a href="#szablony-funkcji">Szablony Funkcji</a>
                        <ol>
                            <li><a href="#mechanizm-instancjacji">Mechanizm Instancjacji</a></li>
                        </ol>
                    </li>
                    <li><a href="#szablony-klas">Szablony Klas</a>
                        <ol>
                            <li><a href="#wielokrotne-parametry-szablonu">Wielokrotne Parametry Szablonu</a></li>
                            <li><a href="#specjalizacja-szablonu">Specjalizacja Szablonu</a></li>
                        </ol>
                    </li>
                    <li><a href="#typy-domylne-w-szablonach">Typy Domylne w Szablonach</a></li>
                    <li><a href="#szablony-zmiennych">Szablony Zmiennych</a></li>
                    <li><a href="#aliasowanie-szablon贸w">Aliasowanie Szablon贸w</a></li>
                    <li><a href="#szablony-lambda">Szablony Lambda</a></li>
                    <li><a href="#metaprogramowanie-szablonowe">Metaprogramowanie Szablonowe</a></li>
                    <li><a href="#przykad-obliczanie-liczby-fibonacciego">Przykad: Obliczanie Liczby Fibonacciego</a>
                        <ol>
                            <li><a href="#analiza-matematyczna">Analiza Matematyczna</a></li>
                        </ol>
                    </li>
                    <li><a href="#zastosowanie-szablon贸w-w-praktyce">Zastosowanie Szablon贸w w Praktyce</a>
                        <ol>
                            <li><a href="#standardowa-biblioteka-szablon贸w-stl-">Standardowa Biblioteka Szablon贸w (STL)</a></li>
                            <li><a href="#przykad-kontener-std-vector">Przykad: Kontener std::vector</a></li>
                            <li><a href="#biblioteka-boost">Biblioteka Boost</a></li>
                            <li><a href="#biblioteka-eigen">Biblioteka Eigen</a></li>
                            <li><a href="#koncepty-c-20-">Koncepty (C++20)</a></li>
                        </ol>
                    </li>
                    <li><a href="#zaawansowane-techniki-z-szablonami">Zaawansowane Techniki z Szablonami</a>
                        <ol>
                            <li><a href="#szablony-o-zmiennej-liczbie-argument贸w">Szablony o Zmiennej Liczbie Argument贸w</a></li>
                            <li><a href="#wyra偶enia-constexpr-w-szablonach">Wyra偶enia constexpr w Szablonach</a></li>
                            <li><a href="#ograniczenia-i-wyzwania">Ograniczenia i Wyzwania</a></li>
                            <li><a href="#praktyczne-wskaz贸wki">Praktyczne Wskaz贸wki</a></li>
                        </ol>
                    </li>
                </ol>
            </ol>
            <div id="related-articles">
                <h2>Related Articles</h2>
                <ol>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/01_proces_kompilacji.html">Proces Kompilacji</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/02_preprocesor.html">Preprocesor</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/03_zmienne_i_typy_danych.html">Zmienne i Typy Danych</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/04_interakcja_z_konsola.html">Interakcja z Konsola</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/05_instrukcja_warunkowa.html">Instrukcja Warunkowa</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/06_petle.html">Petle</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/07_liczby_losowe.html">Liczby Losowe</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/08_typ_wyliczeniowy.html">Typ Wyliczeniowy</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/09_funkcje.html">Funkcje</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/10_l_wartosci_r_wartosci.html">L Wartosci R Wartosci</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/11_wskazniki.html">Wskazniki</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/12_tablice.html">Tablice</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/13_napisy.html">Napisy</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/14_operacje_bitowe.html">Operacje Bitowe</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/15_programowanie_obietkowe.html">Programowanie Obietkowe</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/16_dziedziczenie.html">Dziedziczenie</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/17_zaawansowane_wskazniki.html">Zaawansowane Wskazniki</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/18_przeciazanie.html">Przeciazanie</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/19_konwersje.html">Konwersje</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/20_lambdy.html">Lambdy</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/21_szablony.html">Szablony</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/22_wyjatki.html">Wyjatki</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/23_stl.html">Stl</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/24_praca_z_plikami.html">Praca z Plikami</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/25_c_vs_cpp.html">C vs Cpp</a></li>
                </ol>
            </div>
        </div>
    </div>
    <footer>
        <div class="footer-columns">
            <div class="footer-column">
                <img alt="Adam Djellouli Symbol" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/symbol.png" />
            </div>
            <div class="footer-column">
                <h2><a href="https://adamdjellouli.com/core/privacy_policy.html" title="Privacy Policy">Our Privacy Policy</a></h2>
                <p>
                    Thank you for visiting my personal website. All of the <br />
                    content on this site is free to use, but please remember <br />
                    to be a good human being and refrain from any abuse<br />
                    of the site. If you would like to contact me, please use <br />
                    my <a href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" title="LinkedIn Profile">LinkedIn profile</a> or my <a href="https://github.com/djeada" title="GitHub Profile">GitHub</a> if you have any technical <br />
                    issues or ideas to share. I wish you the best and hope you <br />
                    have a fantastic life. <br />
                </p>
            </div>
            <div class="footer-column">
                <h2>Follow me</h2>
                <ul class="social-media">
                    <li>
                        <a class="fa fa-youtube" href="https://www.youtube.com/channel/UCGPoHTVjMN77wcGknXPHl1Q" target="_blank" title="YouTube">
                        </a>YouTube
                    </li>
                    <li>
                        <a class="fa fa-linkedin" href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" target="_blank" title="LinkedIn">
                        </a>LinkedIn
                    </li>
                    <li>
                        <a class="fa fa-instagram" href="https://www.instagram.com/linuxchallenges/" target="_blank" title="Instagram">
                        </a>Instagram
                    </li>
                    <li>
                        <a class="fa fa-github" href="https://github.com/djeada" title="GitHub">
                        </a>Github
                    </li>
                </ul>
            </div>
        </div>
        <div>
            <p id="copyright">
                漏 Adam Djellouli. All rights reserved.
            </p>
        </div>
        <script>
            document.getElementById("copyright").innerHTML = "&copy; " + new Date().getFullYear() + " Adam Djellouli. All rights reserved.";
        </script>
        <script src="../../app.js"></script>
    </footer>
    <div id="pdf-spinner-overlay">
        <div class="spinner"></div>
    </div>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-bash.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-cpp.min.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
jax: ["input/TeX", "output/HTML-CSS"],
extensions: ["tex2jax.js"],
"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] },
tex2jax: { inlineMath: [ ["$", "$"] ], displayMath: [ ["$$","$$"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
TeX: { noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } } },
messageStyle: "none"
});
</script>
<script async="" id="MathJax-script" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>

</html>