<!DOCTYPE html>

<html lang="pl">

<head>
    <script async="" crossorigin="anonymous" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5593122079896089"></script>
    <meta charset="utf-8" />
    <title>Szablony</title>
    <meta content="Szablony (ang." name="description" />
    <meta content="Adam Djellouli" name="author" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <meta content="IE=edge" http-equiv="X-UA-Compatible" />
    <link crossorigin="" href="https://fonts.googleapis.com" rel="preconnect" />
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/icon.ico" rel="icon" />
    <link href="../../resources/style.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
</head>

<body>
    <nav aria-label="Main navigation">
        <a class="logo" href="https://adamdjellouli.com">
            <img alt="Adam Djellouli - Home Page Logo" id="logo-image" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/logo.PNG" />
        </a>
        <input aria-label="Toggle navigation menu" id="navbar-toggle" type="checkbox" />
        <ul aria-labelledby="navbar-toggle" role="menu">
            <li role="menuitem">
                <a href="../../index.html" title="Go to Home Page"> Home </a>
            </li>
            <li role="menuitem">
                <a class="active" href="../../core/blog.html" title="Read Adam Djellouli Blog on Programming and Technology"> Blog </a>
            </li>
            <li role="menuitem">
                <a href="../../core/tools.html" title="Discover Tools Created by Adam Djellouli"> Tools </a>
            </li>
            <li role="menuitem">
                <a href="../../core/projects.html" title="Explore Projects Developed by Adam Djellouli"> Projects </a>
            </li>
            <li role="menuitem">
                <a href="../../core/resume.html" title="View Adam Djellouli Professional Resume"> Resume </a>
            </li>
            <li>
                <script async="" src="https://cse.google.com/cse.js?cx=8160ef9bb935f4f68"></script>
                <div class="gcse-search"></div>
            </li>
            <li>
                <button aria-label="Toggle dark mode" id="dark-mode-button"></button>
            </li>
        </ul>
    </nav>
    <div id="article-wrapper">
        <section id="article-body">
            <div class="article-action-buttons"><button class="btn-suggest-edit" title="Suggest Edit">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <path d="M4 21h4l11-11-4-4L4 17v4z" stroke="currentColor" stroke-width="2"></path>
                    </svg>
                </button><button class="btn-create-issue" title="Create Issue">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2"></circle>
                        <line stroke="currentColor" stroke-width="2" x1="12" x2="12" y1="8" y2="12"></line>
                        <circle cx="12" cy="16" fill="currentColor" r="1"></circle>
                    </svg>
                </button><button class="btn-download" title="Download">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <path d="M12 5v14m0 0l-6-6m6 6l6-6" stroke="currentColor" stroke-width="2"></path>
                    </svg>
                </button></div>
            <p style="text-align: right;"><i>Last modified: January 31, 2019</i></p>
            <p style="text-align: right;"><i>This article is written in: 🇵🇱</i></p>
            <h2 id="szablony">Szablony</h2>
            <p>Szablony (ang. <em>templates</em>) stanowią fundament nowoczesnego programowania w języku C++. Są jednym z najbardziej potężnych narzędzi oferowanych przez ten język, umożliwiając programistom pisanie bardziej elastycznego i wielokrotnego użytku kodu. Dzięki szablonom, można tworzyć funkcje i klasy, które działają z różnymi typami danych, co znacząco redukuje potrzebę duplikacji kodu oraz zwiększa jego czytelność i utrzymanie. Szablony odgrywają kluczową rolę w metaprogramowaniu w C++, pozwalając na wykonywanie obliczeń na etapie kompilacji oraz optymalizację kodu wynikowego. Poniżej przedstawiono szczegółowe omówienie różnych aspektów szablonów w C++, wraz z przykładami i wyjaśnieniami.</p>
            <h3 id="szablony-funkcji">Szablony Funkcji</h3>
            <p>Szablony funkcji pozwalają na definiowanie funkcji, które działają na różnych typach danych. Umożliwiają one tworzenie generycznego kodu, który jest bardziej uniwersalny i może być stosowany w szerokim zakresie zastosowań bez konieczności pisania osobnych wersji funkcji dla każdego typu danych. Ogólna składnia definicji szablonu funkcji jest następująca:</p>
            <p>
            <div>
                <pre><code class="language-clike">template &lt;parametry_szablonu&gt;
typ_zwracany nazwa_funkcji(argumenty) {

    // ciało funkcji

}</code></pre>
            </div>
            </p>
            <p><strong>Przykład:</strong> </p>
            <p>Definicja generycznej funkcji <code>max2</code>, która zwraca większą z dwóch wartości:</p>
            <p>
            <div>
                <pre><code class="language-clike">template &lt;typename t=""&gt;
T max2(T arg1, T arg2) {
    return arg1 &gt; arg2 ? arg1 : arg2;
}</code></pre>
            </div>
            </p>
            <ul>
                <li><code>template &lt;typename T&gt;</code> deklaruje szablon z parametrem typu <code>T</code>, który może być dowolnym typem danych (np. <code>int</code>, <code>double</code>, <code>std::string</code>).</li>
                <li>Funkcja <code>max2</code> przyjmuje dwa argumenty typu <code>T</code> i zwraca wartość typu <code>T</code>.</li>
                <li>Operator <code>?:</code> zwraca <code>arg1</code> lub <code>arg2</code> w zależności od wyniku porównania <code>arg1 &gt; arg2</code>, co pozwala na elastyczne porównywanie różnych typów danych.</li>
            </ul>
            <p><strong>Użycie funkcji szablonowej:</strong></p>
            <p>Szablony funkcji są wykorzystywane poprzez ich instancjowanie z konkretnymi typami danych, co pozwala na ich wielokrotne użycie bez konieczności definiowania nowych funkcji dla każdego typu.</p>
            <p>
            <div>
                <pre><code class="language-clike">int a = max2&lt;int&gt;(10, 20);            // Wynik: 20
double b = max2&lt;double&gt;(16.2, 3.14);  // Wynik: 16.2
char c = max2&lt;char&gt;('a', 'b');        // Wynik: 'b'</code></pre>
            </div>
            </p>
            <h4 id="mechanizm-instancjacji">Mechanizm Instancjacji</h4>
            <p>Podczas kompilacji, gdy funkcja szablonowa jest wywoływana z konkretnym typem, kompilator tworzy jej <strong>instancję</strong> dla tego typu. Proces ten nazywany jest <strong>instancjacją szablonu</strong>. Dzięki temu generowany kod jest zoptymalizowany pod kątem użytych typów, eliminując narzut wydajnościowy związany z polimorfizmem dynamicznym. Instancjacja szablonów pozwala na tworzenie specjalizowanych wersji funkcji lub klas, które są dostosowane do specyficznych potrzeb aplikacji, co zwiększa efektywność i wydajność kodu.</p>
            <h3 id="szablony-klas">Szablony Klas</h3>
            <p>Szablony klas umożliwiają definiowanie klas generycznych, które mogą operować na różnych typach danych. Dzięki temu można tworzyć bardziej elastyczne i wielokrotnego użytku struktury danych oraz obiektów. Składnia szablonu klasy jest podobna do szablonu funkcji, co ułatwia zrozumienie i implementację.</p>
            <p><strong>Przykład:</strong> </p>
            <p>Definicja szablonu klasy <code>Box</code>:</p>
            <p>
            <div>
                <pre><code class="language-clike">template &lt;typename t=""&gt;
class Box {
private:
    T content;

public:
    Box(T content) : content(content) {}
    T getContent() const { return content; }
};</code></pre>
            </div>
            </p>
            <ul>
                <li><code>template &lt;typename T&gt;</code>: Deklaruje szablon klasy z parametrem typu <code>T</code>, co pozwala na przechowywanie różnych typów danych w jednej klasie.</li>
                <li><code>T content;</code>: Zmienna członkowska przechowująca zawartość typu <code>T</code>, co umożliwia elastyczne przechowywanie dowolnego typu danych.</li>
                <li>Konstruktor i metoda <code>getContent()</code> operują na typie <code>T</code>, co zapewnia, że klasa <code>Box</code> jest w pełni generyczna i może być używana z dowolnym typem danych.</li>
            </ul>
            <p><strong>Tworzenie instancji szablonu klasy:</strong></p>
            <p>Szablony klas są wykorzystywane poprzez określenie konkretnego typu danych podczas tworzenia obiektu.</p>
            <p>
            <div>
                <pre><code class="language-clike">Box&lt;int&gt; intBox(42);

Box&lt;std::string&gt; stringBox("Witaj");</code></pre>
            </div>
            </p>
            <h4 id="wielokrotne-parametry-szablonu">Wielokrotne Parametry Szablonu</h4>
            <p>Szablony mogą przyjmować wiele parametrów, zarówno typów, jak i wartości stałych. Pozwala to na bardziej precyzyjne parametryzowanie kodu, co zwiększa jego elastyczność i umożliwia tworzenie bardziej zaawansowanych struktur danych oraz algorytmów.</p>
            <p><strong>Przykład:</strong> </p>
            <p>Szablon klasy <code>Array</code> z dwoma parametrami:</p>
            <p>
            <div>
                <pre><code class="language-clike">template &lt;typename size="" std::size_t="" t,=""&gt;
class Array {
private:
    T elements[Size];

public:
    // Metody dostępu i modyfikacji elementów
};</code></pre>
            </div>
            </p>
            <p><strong>Użycie:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">Array&lt;int, 5=""&gt; myArray;</code></pre>
            </div>
            </p>
            <p>W tym przykładzie, szablon klasy <code>Array</code> przyjmuje zarówno typ danych <code>T</code>, jak i stałą <code>Size</code>, co pozwala na tworzenie tablic o dynamicznie określonym rozmiarze i typie danych.</p>
            <h4 id="specjalizacja-szablonu">Specjalizacja Szablonu</h4>
            <p>Czasami istnieje potrzeba dostosowania zachowania szablonu dla konkretnego typu. W takich przypadkach używamy <strong>specjalizacji szablonu</strong>, co pozwala na definiowanie unikalnych implementacji dla wybranych typów danych, zachowując jednocześnie ogólność szablonu dla innych typów.</p>
            <p><strong>Przykład:</strong> </p>
            <p>Specjalizacja szablonu klasy <code>Box</code> dla typu <code>std::string</code>:</p>
            <p>
            <div>
                <pre><code class="language-clike">template &lt;&gt;
class Box&lt;std::string&gt; {
private:
    std::string content;

public:
    Box(std::string content) : content(content) {}
    std::string getContent() const { return "Zawartość: " + content; }
};</code></pre>
            </div>
            </p>
            <ul>
                <li><code>template &lt;&gt;</code>: Wskazuje pełną specjalizację szablonu, co oznacza, że ta definicja jest unikalna dla określonego typu.</li>
                <li><code>class Box&lt;std::string&gt;</code>: Specjalizacja szablonu <code>Box</code> dla typu <code>std::string</code> umożliwia dostosowanie zachowania klasy do specyfiki tego typu danych.</li>
                <li>Metoda <code>getContent()</code> została zmodyfikowana, aby zwracać prefiksowany ciąg znaków, co jest specyficzne dla typu <code>std::string</code> i nie byłoby konieczne dla innych typów.</li>
            </ul>
            <h3 id="typy-domyślne-w-szablonach">Typy Domyślne w Szablonach</h3>
            <p>Możemy definiować wartości domyślne dla parametrów szablonu, co zwiększa elastyczność ich użycia. Dzięki wartościom domyślnym, programista może tworzyć instancje szablonów bez konieczności podawania wszystkich parametrów, co upraszcza kod i poprawia jego czytelność.</p>
            <p><strong>Przykład:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">template &lt;typename size="10" std::size_t="" t="int,"&gt;
class Array {
private:

    T elements[Size];

public:

    // Implementacja metod

};</code></pre>
            </div>
            </p>
            <p><strong>Użycie:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">Array&lt;&gt; defaultArray;             // Typ T=int, Size=10
Array&lt;double, 5=""&gt; customArray;     // Typ T=double, Size=5</code></pre>
            </div>
            </p>
            <p>W tym przykładzie, szablon klasy <code>Array</code> ma zdefiniowane wartości domyślne dla parametrów <code>T</code> i <code>Size</code>, co pozwala na tworzenie instancji z domyślnymi ustawieniami lub z niestandardowymi parametrami w zależności od potrzeb.</p>
            <h3 id="szablony-zmiennych">Szablony Zmiennych</h3>
            <p>Od C++14 możliwe jest definiowanie szablonów zmiennych, co pozwala na tworzenie zmiennych parametryzowanych typem. Szablony zmiennych są szczególnie przydatne w przypadku stałych wartości, które mogą być różne w zależności od typu danych.</p>
            <p><strong>Przykład:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">template&lt;typename t=""&gt;
constexpr T pi = T(3.1415926535897932385);

auto floatPi = pi&lt;float&gt;;
auto doublePi = pi&lt;double&gt;;</code></pre>
            </div>
            </p>
            <p><strong>Wyjaśnienie:</strong></p>
            <ul>
                <li><code>constexpr</code> oznacza, że wartość jest stała w czasie kompilacji, co pozwala na optymalizację i redukcję kosztów czasowych w czasie wykonywania programu.</li>
                <li><code>pi&lt;T&gt;</code> jest zmienną szablonową parametryzowaną typem <code>T</code>, co umożliwia tworzenie precyzyjnych wersji stałej <code>pi</code> dla różnych typów danych, takich jak <code>float</code> czy <code>double</code>.</li>
            </ul>
            <h3 id="aliasowanie-szablonów">Aliasowanie Szablonów</h3>
            <p>C++11 wprowadził możliwość tworzenia aliasów szablonów za pomocą słowa kluczowego <code>using</code>. Aliasowanie szablonów ułatwia pracę z złożonymi typami szablonowymi, poprawiając czytelność kodu oraz zmniejszając jego złożoność.</p>
            <p><strong>Przykład:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">template &lt;typename t=""&gt;
using Vec = std::vector&lt;t&gt;;

Vec&lt;int&gt; intVector;
Vec&lt;double&gt; doubleVector;</code></pre>
            </div>
            </p>
            <p>W tym przykładzie, alias <code>Vec</code> jest używany do reprezentowania <code>std::vector&lt;T&gt;</code>, co upraszcza deklarację wektorów różnych typów i poprawia czytelność kodu.</p>
            <h3 id="szablony-lambda">Szablony Lambda</h3>
            <p>Od C++20 można tworzyć szablony funkcji lambda, co dodatkowo zwiększa możliwości programistyczne. Szablony lambda pozwalają na definiowanie anonimowych funkcji generycznych, które mogą być wykorzystywane w różnych kontekstach bez potrzeby definiowania osobnych funkcji.</p>
            <p><strong>Przykład:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">auto lambda = []&lt;typename t=""&gt;(T a, T b) {
    return a + b;
};

auto sumInt = lambda(5, 3);           // Wynik: 8
auto sumDouble = lambda(2.5, 1.5);    // Wynik: 4.0</code></pre>
            </div>
            </p>
            <p>W tym przykładzie, lambda jest szablonem funkcji, który może przyjmować różne typy danych <code>T</code> i wykonywać na nich operację dodawania, co czyni ją niezwykle elastyczną i wielokrotnego użytku.</p>
            <h3 id="metaprogramowanie-szablonowe">Metaprogramowanie Szablonowe</h3>
            <p>Metaprogramowanie szablonowe to technika, która wykorzystuje szablony do wykonywania obliczeń na etapie kompilacji. Pozwala to na optymalizację kodu oraz wykonywanie skomplikowanych obliczeń bez narzutu w czasie wykonywania programu. Metaprogramowanie szablonowe jest szczególnie przydatne w przypadkach, gdzie wydajność jest kluczowa, a obliczenia mogą być przeprowadzone wcześniej, podczas kompilacji.</p>
            <h3 id="przykład-obliczanie-liczby-fibonacciego">Przykład: Obliczanie Liczby Fibonacciego</h3>
            <p>Obliczanie wartości ciągu Fibonacciego za pomocą szablonów:</p>
            <p>
            <div>
                <pre><code class="language-clike">template&lt;int n=""&gt;
struct Fibonacci {
    static_assert(N &gt;= 0, "N musi być nieujemne");
    static constexpr int value = Fibonacci&lt;n -="" 1=""&gt;::value + Fibonacci&lt;n -="" 2=""&gt;::value;
};

template&lt;&gt;
struct Fibonacci&lt;0&gt; {
    static constexpr int value = 0;
};

template&lt;&gt;
struct Fibonacci&lt;1&gt; {
    static constexpr int value = 1;
};

constexpr int fib10 = Fibonacci&lt;10&gt;::value; // Wynik: 55</code></pre>
            </div>
            </p>
            <ul>
                <li><strong>Rekurencja w czasie kompilacji</strong> polega na tym, że struktura <code>Fibonacci</code> jest rekurencyjnie instancjonowana dla wartości <code>N</code>, aż do osiągnięcia przypadków bazowych, takich jak <code>N=0</code> i <code>N=1</code>, co pozwala na obliczenia w trakcie kompilacji.</li>
                <li><strong><code>static_assert</code></strong> jest używany do sprawdzania warunków w czasie kompilacji, co pozwala na weryfikację poprawności kodu przed jego wykonaniem. W tym przypadku, zapewnia, że <code>N</code> jest nieujemne.</li>
                <li><strong><code>constexpr</code></strong> zapewnia, że dana wartość zostanie obliczona w czasie kompilacji, co zwiększa efektywność i pozwala na lepszą optymalizację kodu.</li>
            </ul>
            <h4 id="analiza-matematyczna">Analiza Matematyczna</h4>
            <p>Ciąg Fibonacciego jest zdefiniowany rekurencyjnie:</p>
            <p>$$
                F(0) = 0, \quad F(1) = 1, \quad F(N) = F(N-1) + F(N-2) \text{ dla } N \geq 2
                $$</p>
            <p>Implementacja za pomocą szablonów odwzorowuje tę definicję, pozwalając kompilatorowi na obliczenie wartości <code>F(N)</code> podczas kompilacji. Dzięki temu, wartości ciągu Fibonacciego są dostępne w czasie kompilacji, co może być użyteczne w różnych optymalizacjach i zastosowaniach.</p>
            <h5>Zastosowania Metaprogramowania Szablonowego</h5>
            <ul>
                <li><strong>Optymalizacja</strong> polega na usunięciu narzutu czasowego poprzez przeniesienie obliczeń z etapu wykonania programu na etap kompilacji, co przyspiesza działanie aplikacji. Dzięki temu, program może działać szybciej, ponieważ wiele obliczeń zostało już wykonanych przed jego uruchomieniem.</li>
                <li><strong>Generowanie kodów specjalizowanych</strong> umożliwia tworzenie kodu dostosowanego do konkretnych typów lub wartości, co poprawia wydajność i elastyczność aplikacji. Szablony mogą automatycznie generować różne wersje funkcji lub klas, zoptymalizowane pod kątem specyficznych potrzeb.</li>
                <li><strong>Sprawdzanie warunków w czasie kompilacji</strong> odbywa się za pomocą <code>static_assert</code>, który pozwala na weryfikację założeń programu przed jego uruchomieniem, eliminując potencjalne błędy już na etapie kompilacji. Dzięki temu, programista może szybko zidentyfikować i naprawić błędy, zanim program zostanie uruchomiony.</li>
            </ul>
            <h3 id="zastosowanie-szablonów-w-praktyce">Zastosowanie Szablonów w Praktyce</h3>
            <p>Szablony są integralną częścią języka C++ i stanowią podstawę wielu bibliotek oraz aplikacji komercyjnych. Ich zdolność do tworzenia kodu generycznego, który może działać z różnymi typami danych, sprawia, że są one niezbędne w nowoczesnym programowaniu. W tej sekcji przyjrzymy się, jak szablony są wykorzystywane w praktyce, skupiając się na standardowej bibliotece C++ (STL) oraz na innych popularnych bibliotekach, takich jak Boost czy Eigen.</p>
            <h4 id="standardowa-biblioteka-szablonów-stl-">Standardowa Biblioteka Szablonów (STL)</h4>
            <p>STL (Standard Template Library) jest zestawem klas i funkcji szablonowych dostarczanych przez standardową bibliotekę C++. Została ona zaprojektowana w celu zapewnienia programistom gotowych do użycia struktur danych oraz algorytmów, które są zarówno wydajne, jak i łatwe w użyciu. STL jest szeroko stosowana w różnych aplikacjach, od prostych programów konsolowych po zaawansowane systemy o dużej skali.</p>
            <h5>Kontenery</h5>
            <p>Kontenery są klasami szablonowymi, które przechowują kolekcje obiektów. Dzięki szablonom mogą one przechowywać elementy dowolnego typu, co czyni je niezwykle elastycznymi i wielokrotnego użytku. Kontenery w STL są zoptymalizowane pod kątem różnych operacji, takich jak dodawanie, usuwanie czy wyszukiwanie elementów, co pozwala na efektywne zarządzanie danymi.</p>
            <p>Oto niektóre z najważniejszych kontenerów w STL:</p>
            <p>
            <table>
                <tr>
                    <td>Kontener</td>
                    <td>Opis</td>
                </tr>
                <tr>
                    <td><strong><code>std::vector</code></strong></td>
                    <td>Dynamiczna tablica o zmiennym rozmiarze.</td>
                </tr>
                <tr>
                    <td><strong><code>std::list</code></strong></td>
                    <td>Lista dwukierunkowa.</td>
                </tr>
                <tr>
                    <td><strong><code>std::deque</code></strong></td>
                    <td>Dwustronna kolejka.</td>
                </tr>
                <tr>
                    <td><strong><code>std::set</code></strong></td>
                    <td>Zbiór unikalnych elementów, uporządkowanych.</td>
                </tr>
                <tr>
                    <td><strong><code>std::map</code></strong></td>
                    <td>Asocjacyjny kontener przechowujący pary klucz-wartość.</td>
                </tr>
                <tr>
                    <td><strong><code>std::unordered_set</code></strong></td>
                    <td>Nieuporządkowany zbiór wykorzystujący tablice haszujące.</td>
                </tr>
                <tr>
                    <td><strong><code>std::unordered_map</code></strong></td>
                    <td>Nieuporządkowana mapa wykorzystująca tablice haszujące do par klucz-wartość.</td>
                </tr>
            </table>
            </p>
            <p>Każdy z tych kontenerów ma swoje specyficzne zastosowania i jest zoptymalizowany pod kątem różnych operacji, co pozwala programistom na wybór najbardziej odpowiedniego kontenera dla ich potrzeb.</p>
            <h5>Algorytmy</h5>
            <p>Algorytmy w STL są funkcjami szablonowymi, które wykonują operacje na danych przechowywanych w kontenerach. Są one niezależne od konkretnych typów danych i kontenerów, o ile dostarczone są odpowiednie iteratory. Algorytmy w STL obejmują szeroki zakres operacji, takich jak sortowanie, wyszukiwanie, modyfikowanie czy transformowanie danych, co pozwala na efektywne i elastyczne manipulowanie kolekcjami danych.</p>
            <p>
            <table>
                <tr>
                    <td>Funkcja</td>
                    <td>Opis</td>
                </tr>
                <tr>
                    <td><strong><code>std::sort</code></strong></td>
                    <td>Sortowanie elementów w zakresie.</td>
                </tr>
                <tr>
                    <td><strong><code>std::find</code></strong></td>
                    <td>Wyszukiwanie elementu w zakresie.</td>
                </tr>
                <tr>
                    <td><strong><code>std::accumulate</code></strong></td>
                    <td>Sumowanie wartości w zakresie.</td>
                </tr>
                <tr>
                    <td><strong><code>std::copy</code></strong></td>
                    <td>Kopiowanie elementów z jednego zakresu do drugiego.</td>
                </tr>
            </table>
            </p>
            <p>Algorytmy te są zoptymalizowane pod kątem wydajności i mogą być stosowane do różnych typów danych, co czyni je niezwykle wszechstronnymi narzędziami w arsenale programisty C++.</p>
            <h5>Iteratory</h5>
            <p>Iteratory są abstrakcją wskaźników, które pozwalają na jednolite interfejsy do przeglądania elementów w kontenerach. Są one zaimplementowane jako szablony, dzięki czemu mogą działać z różnymi typami kontenerów. Iteratory umożliwiają programistom pisanie bardziej generycznego i elastycznego kodu, który może działać z dowolnym kontenerem, który wspiera dany typ iteratora.</p>
            <h4 id="przykład-kontener-std-vector">Przykład: Kontener <code>std::vector</code></h4>
            <p><code>std::vector</code> jest jednym z najczęściej używanych kontenerów w STL. Reprezentuje dynamiczną tablicę, która może zmieniać swój rozmiar w czasie wykonywania programu. Dzięki wykorzystaniu szablonów, <code>std::vector</code> może przechowywać elementy dowolnego typu, co czyni go niezwykle elastycznym narzędziem do zarządzania dynamicznymi kolekcjami danych.</p>
            <p><strong>Definicja szablonu <code>std::vector</code>:</strong></p>
            <p>W uproszczeniu, <code>std::vector</code> jest zdefiniowany następująco:</p>
            <p>
            <div>
                <pre><code class="language-clike">template &lt;typename allocator="std::allocator&lt;T" t,="" typename=""&gt;&gt;
class vector {

    // Implementacja wewnętrzna

};</code></pre>
            </div>
            </p>
            <p><strong>Parametry szablonu:</strong></p>
            <ul>
                <li><strong><code>typename T</code></strong> określa typ przechowywanych elementów, co pozwala na tworzenie szablonów, które mogą działać z różnymi typami danych.</li>
                <li><strong><code>typename Allocator</code></strong> definiuje typ alokatora używanego do zarządzania pamięcią, z domyślną wartością <code>std::allocator&lt;T&gt;</code>, co umożliwia elastyczne zarządzanie pamięcią dla elementów.</li>
            </ul>
            <p><strong>Przykłady użycia:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">std::vector&lt;int&gt; vecInt;            // Wektor liczb całkowitych
std::vector&lt;double&gt; vecDouble;      // Wektor liczb zmiennoprzecinkowych
std::vector&lt;std::string&gt; vecString; // Wektor łańcuchów znaków</code></pre>
            </div>
            </p>
            <p>W tym przykładzie, <code>std::vector</code> jest używany do przechowywania różnych typów danych, co pokazuje jego elastyczność i wszechstronność. Dzięki szablonom, można łatwo tworzyć wektory dla dowolnego typu danych, co znacznie ułatwia zarządzanie dynamicznymi kolekcjami.</p>
            <h4 id="biblioteka-boost">Biblioteka Boost</h4>
            <p>Boost to zestaw bibliotek C++ rozszerzających funkcjonalność standardowej biblioteki. Wiele z nich jest proponowanych do włączenia do standardu C++. Szablony są intensywnie wykorzystywane w celu zapewnienia elastyczności i wydajności.</p>
            <p><strong>Przykład: <code>boost::shared_ptr</code></strong></p>
            <p>Przed wprowadzeniem <code>std::shared_ptr</code> w C++11, <code>boost::shared_ptr</code> był szeroko stosowanym inteligentnym wskaźnikiem zarządzającym życiem obiektu.</p>
            <p><strong>Definicja:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">template&lt;typename t=""&gt;
class shared_ptr {
    // Implementacja wewnętrzna
};</code></pre>
            </div>
            </p>
            <p><strong>Użycie:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">boost::shared_ptr&lt;myclass&gt; ptr(new MyClass());</code></pre>
            </div>
            </p>
            <p><strong>Zalety:</strong></p>
            <ul>
                <li>Automatyczne zarządzanie pamięcią poprzez licznik referencji.</li>
                <li>Bezpieczeństwo w środowiskach wielowątkowych (z odpowiednią synchronizacją).</li>
            </ul>
            <h4 id="biblioteka-eigen">Biblioteka Eigen</h4>
            <p>Eigen to szablonowa biblioteka C++ do algebry liniowej, zoptymalizowana pod kątem wysokiej wydajności.</p>
            <p><strong>Definicja szablonu macierzy:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">template&lt;typename colsatcompiletime="" int="" rowsatcompiletime,="" scalar,=""&gt;
class Matrix {
    // Implementacja wewnętrzna
};</code></pre>
            </div>
            </p>
            <p><strong>Przykład użycia:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">Eigen::Matrix&lt;float, 3="" 3,=""&gt; matA;
Eigen::Matrix&lt;float, 1="" 3,=""&gt; vecB;

matA &lt;&lt; 1, 2, 3,
         4, 5, 6,
         7, 8, 9;

vecB &lt;&lt; 1,
         2,
         3;

Eigen::Matrix&lt;float, 1="" 3,=""&gt; result = matA * vecB;</code></pre>
            </div>
            </p>
            <p>Właściwości:</p>
            <ul>
                <li><strong>Statyczne rozmiary</strong> macierzy, gdy są znane w czasie kompilacji, pozwalają bibliotece Eigen na generowanie wysoce wydajnego kodu, co zwiększa efektywność obliczeń.</li>
                <li><strong>Szablony wyrażeniowe</strong> (<em>Expression Templates</em>) umożliwiają optymalizację obliczeń, minimalizując tworzenie niepotrzebnych kopii danych, co poprawia wydajność działania programu.</li>
            </ul>
            <p>Analiza wydajności:</p>
            <ul>
                <li><strong>Unikanie alokacji pamięci</strong> jest możliwe dzięki zastosowaniu szablonów i mechanizmu inlining, co pozwala bibliotece Eigen na wykonywanie operacji bez potrzeby dodatkowych alokacji pamięci, co zwiększa wydajność.</li>
                <li><strong>Wektorowe instrukcje procesora</strong> są automatycznie wykorzystywane przez Eigen, dzięki wsparciu dla instrukcji SIMD (Single Instruction, Multiple Data), jeśli są one dostępne na danej platformie, co przyspiesza operacje matematyczne.</li>
            </ul>
            <h4 id="koncepty-c-20-">Koncepty (C++20)</h4>
            <p>Koncepty wprowadzają możliwość definiowania wymagań dla parametrów szablonu, co ułatwia tworzenie bardziej czytelnego i bezpiecznego kodu.</p>
            <p><strong>Przykład:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">template&lt;typename t=""&gt;
concept Number = std::is_arithmetic_v&lt;t&gt;;

template&lt;number t=""&gt;
T multiply(T a, T b) {
    return a * b;
}</code></pre>
            </div>
            </p>
            <p><strong>Zalety:</strong></p>
            <ul>
                <li><strong>Poprawa czytelności błędów kompilacji</strong> wynika z zastosowania konceptów, które umożliwiają kompilatorowi dostarczenie bardziej precyzyjnych i zrozumiałych komunikatów o błędach, co ułatwia debugowanie.</li>
                <li><strong>Dokumentacja wymagań</strong> jest naturalnym efektem użycia konceptów, ponieważ jasno określają one, jakie wymagania musi spełniać typ parametrów szablonu, co poprawia zrozumiałość i użyteczność kodu.</li>
            </ul>
            <h3 id="zaawansowane-techniki-z-szablonami">Zaawansowane Techniki z Szablonami</h3>
            <p>W miarę rozwoju języka C++, szablony stały się nie tylko narzędziem do tworzenia generycznego kodu, ale także platformą do implementacji zaawansowanych technik programistycznych. W tej sekcji omówimy kilka z tych zaawansowanych technik, które pozwalają na jeszcze większą elastyczność i moc w tworzeniu aplikacji. Skoncentrujemy się na szablonach o zmiennej liczbie argumentów, wyrażeniach <code>constexpr</code> w szablonach, szablonach wewnętrznych (CRTP), a także na omówieniu ograniczeń i wyzwań związanych z ich używaniem. Dodatkowo, przedstawimy praktyczne wskazówki, które pomogą w efektywnym wykorzystaniu tych technik w codziennym programowaniu.</p>
            <h4 id="szablony-o-zmiennej-liczbie-argumentów">Szablony o Zmiennej Liczbie Argumentów</h4>
            <p>Szablony o zmiennej liczbie argumentów, znane również jako <em>variadic templates</em>, zostały wprowadzone w standardzie C++11 i stanowią potężne rozszerzenie tradycyjnych szablonów. Umożliwiają one definiowanie funkcji i klas, które mogą przyjmować dowolną liczbę parametrów, co jest niezwykle przydatne w sytuacjach, gdy liczba argumentów nie jest znana z góry lub może się dynamicznie zmieniać.</p>
            <p><strong>Przykład:</strong> Funkcja <code>print</code> wyświetlająca dowolną liczbę argumentów:</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;

template&lt;typename... args=""&gt;
void print(Args... args) {
    (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; std::endl;
}

int main() {
    print(1, 2, 3);                 // Wyświetla: 123
    print("Witaj, ", "świecie!");   // Wyświetla: Witaj, świecie!
    return 0;
}</code></pre>
            </div>
            </p>
            <ul>
                <li><code>template&lt;typename... Args&gt;</code>: Deklaruje szablon z pakietem typów <code>Args</code>. Operator <code>...</code> oznacza, że <code>Args</code> może reprezentować dowolną liczbę typów.</li>
                <li><code>Args... args</code>: Pakiet argumentów funkcji. Podobnie jak powyżej, <code>...</code> wskazuje na zmienną liczbę argumentów.</li>
                <li><code>(std::cout &lt;&lt; ... &lt;&lt; args)</code>: Fold expression, dostępne od C++17, które umożliwia składanie wyrażeń binarnych. W tym przypadku, łączy wszystkie argumenty za pomocą operatora <code>&lt;&lt;</code> i wypisuje je na standardowe wyjście.</li>
            </ul>
            <p><strong>Zastosowanie:</strong></p>
            <p>Szablony o zmiennej liczbie argumentów są niezwykle przydatne w tworzeniu funkcji, które muszą obsługiwać dynamiczną liczbę parametrów, takich jak funkcje logujące, formatowania czy tworzenia kontenerów o zmiennym rozmiarze.</p>
            <h4 id="wyrażenia-constexpr-w-szablonach">Wyrażenia <code>constexpr</code> w Szablonach</h4>
            <p>Słowo kluczowe <code>constexpr</code> zostało wprowadzone w C++11 i pozwala na wykonywanie obliczeń w czasie kompilacji. W połączeniu z szablonami, <code>constexpr</code> umożliwia tworzenie funkcji, które zwracają stałe wartości zależne od parametrów szablonu, co może prowadzić do znacznych optymalizacji kodu.</p>
            <p><strong>Przykład:</strong> Funkcja <code>square</code> obliczająca kwadrat liczby:</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;

template&lt;typename t=""&gt;
constexpr T square(T x) {
    return x * x;
}

int main() {
    constexpr int squareOfFive = square(5); // Wynik: 25
    std::cout &lt;&lt; "Kwadrat 5 to: " &lt;&lt; squareOfFive &lt;&lt; std::endl;
    return 0;
}</code></pre>
            </div>
            </p>
            <ul>
                <li><code>template&lt;typename T&gt;</code>: Deklaruje szablon funkcji z parametrem typu <code>T</code>.</li>
                <li><code>constexpr T square(T x)</code>: Funkcja oznaczona jako <code>constexpr</code>, co oznacza, że może być oceniona w czasie kompilacji, jeśli argumenty są znane w tym czasie.</li>
                <li><code>constexpr int squareOfFive = square(5);</code>: Inicjalizuje stałą <code>squareOfFive</code> wynikiem funkcji <code>square(5)</code>, który jest obliczany w czasie kompilacji.</li>
            </ul>
            <p><strong>Zastosowanie:</strong></p>
            <p>Funkcje <code>constexpr</code> są użyteczne w przypadkach, gdzie potrzebne są stałe wartości obliczane na podstawie parametrów szablonu, co może prowadzić do bardziej wydajnego kodu dzięki wstępnej ocenie wyrażeń.</p>
            <h5>Szablony Wewnętrzne (Curiously Recurring Template Pattern - CRTP)</h5>
            <p>Curiously Recurring Template Pattern (CRTP) to idiom programistyczny, w którym klasa dziedziczy po szablonie swojej własnej klasy. Technika ta pozwala na osiągnięcie statycznego polimorfizmu oraz umożliwia implementację funkcji, które są specyficzne dla klasy pochodnej, bez użycia wirtualnych metod.</p>
            <p><strong>Przykład:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;iostream&gt;

// Szablon bazowej klasy wykorzystujący CRTP
template&lt;typename derived=""&gt;
class Base {
public:
    void interface() {
        // Wywołuje implementację specyficzną dla klasy pochodnej
        static_cast&lt;derived*&gt;(this)-&gt;implementation();
    }

    void commonFunction() {
        std::cout &lt;&lt; "Funkcja wspólna w klasie Base." &lt;&lt; std::endl;
    }
};

// Klasa pochodna dziedzicząca po Base za pomocą CRTP
class DerivedClass : public Base&lt;derivedclass&gt; {
public:
    void implementation() {
        std::cout &lt;&lt; "Implementacja specyficzna dla DerivedClass." &lt;&lt; std::endl;
    }
};

int main() {
    DerivedClass obj;
    obj.interface();         // Wywołuje DerivedClass::implementation()
    obj.commonFunction();    // Wywołuje Base::commonFunction()
    return 0;
}</code></pre>
            </div>
            </p>
            <ul>
                <li><code>template&lt;typename Derived&gt;</code>: Szablon bazowej klasy przyjmujący typ klasy pochodnej.</li>
                <li><code>static_cast&lt;Derived*&gt;(this)-&gt;implementation()</code>: Rzutowanie wskaźnika <code>this</code> na typ klasy pochodnej i wywołanie jej metody <code>implementation()</code>.</li>
                <li><code>DerivedClass : public Base&lt;DerivedClass&gt;</code>: Klasa pochodna dziedziczy po bazowej klasie szablonowej, przekazując siebie jako parametr szablonu.</li>
            </ul>
            <p><strong>Zastosowania:</strong></p>
            <ul>
                <li><strong>Statyczny polimorfizm</strong> umożliwia polimorfizm bez kosztów związanych z dynamicznym wiązaniem, co zwiększa wydajność.</li>
                <li><strong>Klasy mixin</strong> pozwalają na dodawanie funkcjonalności do klas pochodnych w sposób modułowy i wielokrotnego użytku.</li>
            </ul>
            <h4 id="ograniczenia-i-wyzwania">Ograniczenia i Wyzwania</h4>
            <p>Mimo że szablony oferują ogromne możliwości, ich użycie wiąże się również z pewnymi ograniczeniami i wyzwaniami, które programiści powinni mieć na uwadze:</p>
            <ul>
                <li>Błędy w kodzie szablonowym często generują długie i trudne do zrozumienia komunikaty kompilatora, co utrudnia diagnozowanie problemów.</li>
                <li>Intensywne użycie szablonów może znacznie wydłużyć czas kompilacji, szczególnie w dużych projektach.</li>
                <li>Szablony mogą wprowadzać zależności, które nie są od razu widoczne, co może prowadzić do trudnych do zidentyfikowania błędów lub problemów z kompatybilnością.</li>
                <li>Nadmierne korzystanie ze szablonów może uczynić kod mniej czytelnym i trudniejszym do utrzymania, zwłaszcza dla programistów nieznających zaawansowanych technik szablonowych.</li>
            </ul>
            <h4 id="praktyczne-wskazówki">Praktyczne Wskazówki</h4>
            <p>Aby skutecznie wykorzystać zaawansowane techniki szablonowe i uniknąć typowych pułapek, warto przestrzegać kilku praktycznych zasad:</p>
            <ul>
                <li>Jeśli to możliwe, używaj konceptów do jasno określenia wymagań dla parametrów szablonu. Pozwala to na lepszą czytelność kodu oraz wcześniejsze wykrywanie błędów.</li>
            </ul>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;concepts&gt;

template&lt;std::integral t=""&gt;
T add(T a, T b) {
  return a + b;
}</code></pre>
            </div>
            </p>
            <ul>
                <li>Dokumentuj, jakie cechy lub interfejsy muszą posiadać typy używane jako parametry szablonu. Ułatwia to zrozumienie kodu oraz jego prawidłowe użycie.</li>
                <li>Staraj się nie komplikować kodu szablonowego bardziej niż to konieczne. Złożone szablony mogą być trudne do zrozumienia i utrzymania, co zwiększa ryzyko błędów.</li>
                <li>Projektuj szablony w sposób modularny, aby mogły być łatwo reużywane w różnych kontekstach. To zwiększa ich wartość i ułatwia integrację z innymi komponentami systemu.</li>
                <li>Monitoruj czas kompilacji i optymalizuj użycie szablonów, aby uniknąć znacznego wydłużenia procesu kompilacji. Można to osiągnąć poprzez stosowanie technik takich jak prekompilowane nagłówki lub ograniczenie głębokości rekurencji szablonów.</li>
            </ul>
        </section>
        <div id="table-of-contents">
            <h2>Spis Treści</h2>
            <ol><a href="#szablony">Szablony</a>
                <ol>
                    <li><a href="#szablony-funkcji">Szablony Funkcji</a>
                        <ol>
                            <li><a href="#mechanizm-instancjacji">Mechanizm Instancjacji</a></li>
                        </ol>
                    </li>
                    <li><a href="#szablony-klas">Szablony Klas</a>
                        <ol>
                            <li><a href="#wielokrotne-parametry-szablonu">Wielokrotne Parametry Szablonu</a></li>
                            <li><a href="#specjalizacja-szablonu">Specjalizacja Szablonu</a></li>
                        </ol>
                    </li>
                    <li><a href="#typy-domyślne-w-szablonach">Typy Domyślne w Szablonach</a></li>
                    <li><a href="#szablony-zmiennych">Szablony Zmiennych</a></li>
                    <li><a href="#aliasowanie-szablonów">Aliasowanie Szablonów</a></li>
                    <li><a href="#szablony-lambda">Szablony Lambda</a></li>
                    <li><a href="#metaprogramowanie-szablonowe">Metaprogramowanie Szablonowe</a></li>
                    <li><a href="#przykład-obliczanie-liczby-fibonacciego">Przykład: Obliczanie Liczby Fibonacciego</a>
                        <ol>
                            <li><a href="#analiza-matematyczna">Analiza Matematyczna</a></li>
                        </ol>
                    </li>
                    <li><a href="#zastosowanie-szablonów-w-praktyce">Zastosowanie Szablonów w Praktyce</a>
                        <ol>
                            <li><a href="#standardowa-biblioteka-szablonów-stl-">Standardowa Biblioteka Szablonów (STL)</a></li>
                            <li><a href="#przykład-kontener-std-vector">Przykład: Kontener std::vector</a></li>
                            <li><a href="#biblioteka-boost">Biblioteka Boost</a></li>
                            <li><a href="#biblioteka-eigen">Biblioteka Eigen</a></li>
                            <li><a href="#koncepty-c-20-">Koncepty (C++20)</a></li>
                        </ol>
                    </li>
                    <li><a href="#zaawansowane-techniki-z-szablonami">Zaawansowane Techniki z Szablonami</a>
                        <ol>
                            <li><a href="#szablony-o-zmiennej-liczbie-argumentów">Szablony o Zmiennej Liczbie Argumentów</a></li>
                            <li><a href="#wyrażenia-constexpr-w-szablonach">Wyrażenia constexpr w Szablonach</a></li>
                            <li><a href="#ograniczenia-i-wyzwania">Ograniczenia i Wyzwania</a></li>
                            <li><a href="#praktyczne-wskazówki">Praktyczne Wskazówki</a></li>
                        </ol>
                    </li>
                </ol>
            </ol>
            <div id="related-articles">
                <h2>Related Articles</h2>
                <ol>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/01_proces_kompilacji.html">Proces Kompilacji</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/02_preprocesor.html">Preprocesor</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/03_zmienne_i_typy_danych.html">Zmienne i Typy Danych</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/04_interakcja_z_konsola.html">Interakcja z Konsola</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/05_instrukcja_warunkowa.html">Instrukcja Warunkowa</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/06_petle.html">Petle</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/07_liczby_losowe.html">Liczby Losowe</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/08_typ_wyliczeniowy.html">Typ Wyliczeniowy</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/09_funkcje.html">Funkcje</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/10_l_wartosci_r_wartosci.html">L Wartosci R Wartosci</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/11_wskazniki.html">Wskazniki</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/12_tablice.html">Tablice</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/13_napisy.html">Napisy</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/14_operacje_bitowe.html">Operacje Bitowe</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/15_programowanie_obietkowe.html">Programowanie Obietkowe</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/16_dziedziczenie.html">Dziedziczenie</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/17_zaawansowane_wskazniki.html">Zaawansowane Wskazniki</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/18_przeciazanie.html">Przeciazanie</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/19_konwersje.html">Konwersje</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/20_lambdy.html">Lambdy</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/21_szablony.html">Szablony</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/22_wyjatki.html">Wyjatki</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/23_stl.html">Stl</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/24_praca_z_plikami.html">Praca z Plikami</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/25_c_vs_cpp.html">C vs Cpp</a></li>
                </ol>
            </div>
        </div>
    </div>
    <footer>
        <div class="footer-columns">
            <div class="footer-column">
                <img alt="Adam Djellouli Symbol" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/symbol.png" />
            </div>
            <div class="footer-column">
                <h2><a href="https://adamdjellouli.com/core/privacy_policy.html" title="Privacy Policy">Our Privacy Policy</a></h2>
                <p>
                    Thank you for visiting my personal website. All of the <br />
                    content on this site is free to use, but please remember <br />
                    to be a good human being and refrain from any abuse<br />
                    of the site. If you would like to contact me, please use <br />
                    my <a href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" title="LinkedIn Profile">LinkedIn profile</a> or my <a href="https://github.com/djeada" title="GitHub Profile">GitHub</a> if you have any technical <br />
                    issues or ideas to share. I wish you the best and hope you <br />
                    have a fantastic life. <br />
                </p>
            </div>
            <div class="footer-column">
                <h2>Follow me</h2>
                <ul class="social-media">
                    <li>
                        <a class="fa fa-youtube" href="https://www.youtube.com/channel/UCGPoHTVjMN77wcGknXPHl1Q" target="_blank" title="YouTube">
                        </a>YouTube
                    </li>
                    <li>
                        <a class="fa fa-linkedin" href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" target="_blank" title="LinkedIn">
                        </a>LinkedIn
                    </li>
                    <li>
                        <a class="fa fa-instagram" href="https://www.instagram.com/linuxchallenges/" target="_blank" title="Instagram">
                        </a>Instagram
                    </li>
                    <li>
                        <a class="fa fa-github" href="https://github.com/djeada" title="GitHub">
                        </a>Github
                    </li>
                </ul>
            </div>
        </div>
        <div>
            <p id="copyright">
                © Adam Djellouli. All rights reserved.
            </p>
        </div>
        <script>
            document.getElementById("copyright").innerHTML = "&copy; " + new Date().getFullYear() + " Adam Djellouli. All rights reserved.";
        </script>
        <script src="../../app.js"></script>
    </footer>
    <div id="pdf-spinner-overlay">
        <div class="spinner"></div>
    </div>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-bash.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-cpp.min.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
jax: ["input/TeX", "output/HTML-CSS"],
extensions: ["tex2jax.js"],
"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] },
tex2jax: { inlineMath: [ ["$", "$"] ], displayMath: [ ["$$","$$"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
TeX: { noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } } },
messageStyle: "none"
});
</script>
<script async="" id="MathJax-script" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>

</html>