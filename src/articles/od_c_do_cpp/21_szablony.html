<!DOCTYPE html>

<html lang="pl">

<head>
    <script async="" crossorigin="anonymous" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5593122079896089"></script>
    <meta charset="utf-8" />
    <title>Szablony</title>
    <meta content="Szablony (ang." name="description" />
    <meta content="Adam Djellouli" name="author" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <meta content="IE=edge" http-equiv="X-UA-Compatible" />
    <link crossorigin="" href="https://fonts.googleapis.com" rel="preconnect" />
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/icon.ico" rel="icon" />
    <link href="../../resources/style.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />
</head>

<body>
    <nav aria-label="Main navigation">
        <a class="logo" href="https://adamdjellouli.com">
            <img alt="Adam Djellouli - Home Page Logo" id="logo-image" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/logo.PNG" />
        </a>
        <input aria-label="Toggle navigation menu" id="navbar-toggle" type="checkbox" />
        <ul aria-labelledby="navbar-toggle" role="menu">
            <li role="menuitem">
                <a href="../../index.html" title="Go to Home Page"> Home </a>
            </li>
            <li role="menuitem">
                <a class="active" href="../../core/blog.html" title="Read Adam Djellouli Blog on Programming and Technology"> Blog </a>
            </li>
            <li role="menuitem">
                <a href="../../core/tools.html" title="Discover Tools Created by Adam Djellouli"> Tools </a>
            </li>
            <li role="menuitem">
                <a href="../../core/projects.html" title="Explore Projects Developed by Adam Djellouli"> Projects </a>
            </li>
            <li role="menuitem">
                <a href="../../core/resume.html" title="View Adam Djellouli Professional Resume"> Resume </a>
            </li>
            <li>
                <script async="" src="https://cse.google.com/cse.js?cx=8160ef9bb935f4f68"></script>
                <div class="gcse-search"></div>
            </li>
            <li>
                <button aria-label="Toggle dark mode" id="dark-mode-button"></button>
            </li>
        </ul>
    </nav>
    <div id="article-wrapper">
        <section id="article-body">
            <p style="text-align: right;"><i>Last modified: September 25, 2024</i></p>
            <p style="text-align: right;"><i>This article is written in: 叼</i></p>
            <header>Szablony</header>
            <p>Szablony (ang. <em>templates</em>) stanowi fundament nowoczesnego programowania w jzyku C++. Umo偶liwiaj one tworzenie kodu generycznego, kt贸ry mo偶e dziaa z r贸偶nymi typami danych bez koniecznoci jego duplikacji. Szablony s kluczowym elementem metaprogramowania w C++, pozwalajc na wykonywanie oblicze na etapie kompilacji i optymalizacj kodu wynikowego.</p>
            <h2 id="wprowadzenie-do-szablon贸w">Wprowadzenie do Szablon贸w</h2>
            <p>Szablony w C++ s mechanizmem pozwalajcym na tworzenie funkcji, klas, a nawet zmiennych, kt贸re s parametryzowane typami lub wartociami staymi. Dziki temu mo偶emy pisa kod, kt贸ry jest niezale偶ny od konkretnego typu danych, co zwiksza jego reu偶ywalno i elastyczno.</p>
            <h3 id="szablony-funkcji">Szablony Funkcji</h3>
            <p>Szablony funkcji pozwalaj na definiowanie funkcji, kt贸re dziaaj na r贸偶nych typach danych. Og贸lna skadnia definicji szablonu funkcji jest nastpujca:</p>
            <p>
            <div>
                <pre><code class="language-clike">template &lt;parametry_szablonu&gt;
typ_zwracany nazwa_funkcji(argumenty) {
    // ciao funkcji
}</code></pre>
            </div>
            </p>
            <p><strong>Przykad:</strong> Definicja generycznej funkcji <code>max2</code>, kt贸ra zwraca wiksz z dw贸ch wartoci:</p>
            <p>
            <div>
                <pre><code class="language-clike">template &lt;typename t=""&gt;
T max2(T arg1, T arg2) {
    return arg1 &gt; arg2 ? arg1 : arg2;
}</code></pre>
            </div>
            </p>
            <p><strong>Wyjanienie:</strong></p>
            <ul>
                <li><code>template &lt;typename T&gt;</code> deklaruje szablon z parametrem typu <code>T</code>.</li>
                <li>Funkcja <code>max2</code> przyjmuje dwa argumenty typu <code>T</code> i zwraca warto typu <code>T</code>.</li>
                <li>Operator <code>?:</code> zwraca <code>arg1</code> lub <code>arg2</code> w zale偶noci od wyniku por贸wnania <code>arg1 &gt; arg2</code>.</li>
            </ul>
            <p><strong>U偶ycie funkcji szablonowej:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">int a = max2&lt;int&gt;(10, 20);            // Wynik: 20
double b = max2&lt;double&gt;(16.2, 3.14);  // Wynik: 16.2
char c = max2&lt;char&gt;('a', 'b');        // Wynik: 'b'</code></pre>
            </div>
            </p>
            <h3 id="mechanizm-instancjacji">Mechanizm Instancjacji</h3>
            <p>Podczas kompilacji, gdy funkcja szablonowa jest wywoywana z konkretnym typem, kompilator tworzy jej <strong>instancj</strong> dla tego typu. Proces ten nazywany jest <strong>instancjacj szablonu</strong>. Dziki temu generowany kod jest zoptymalizowany pod ktem u偶ytych typ贸w, eliminujc narzut wydajnociowy zwizany z polimorfizmem dynamicznym.</p>
            <h2 id="szablony-klas">Szablony Klas</h2>
            <p>Szablony klas umo偶liwiaj definiowanie klas generycznych, kt贸re mog operowa na r贸偶nych typach danych. Skadnia szablonu klasy jest podobna do szablonu funkcji.</p>
            <p><strong>Przykad:</strong> Definicja szablonu klasy <code>Box</code>:</p>
            <p>
            <div>
                <pre><code class="language-clike">template &lt;typename t=""&gt;
class Box {
private:
    T content;

public:
    Box(T content) : content(content) {}
    T getContent() const { return content; }
};</code></pre>
            </div>
            </p>
            <p><strong>Wyjanienie:</strong></p>
            <ul>
                <li><code>template &lt;typename T&gt;</code>: Deklaruje szablon klasy z parametrem typu <code>T</code>.</li>
                <li><code>T content;</code>: Zmienna czonkowska przechowujca zawarto typu <code>T</code>.</li>
                <li>Konstruktor i metoda <code>getContent()</code> operuj na typie <code>T</code>.</li>
            </ul>
            <p><strong>Tworzenie instancji szablonu klasy:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">Box&lt;int&gt; intBox(42);
Box&lt;std::string&gt; stringBox("Witaj");</code></pre>
            </div>
            </p>
            <h2 id="wielokrotne-parametry-szablonu">Wielokrotne Parametry Szablonu</h2>
            <p>Szablony mog przyjmowa wiele parametr贸w, zar贸wno typ贸w, jak i wartoci staych. Pozwala to na bardziej precyzyjne parametryzowanie kodu.</p>
            <p><strong>Przykad:</strong> Szablon klasy <code>Array</code> z dwoma parametrami:</p>
            <p>
            <div>
                <pre><code class="language-clike">template &lt;typename size="" std::size_t="" t,=""&gt;
class Array {
private:
    T elements[Size];

public:
    // Metody dostpu i modyfikacji element贸w
};</code></pre>
            </div>
            </p>
            <p><strong>U偶ycie:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">Array&lt;int, 5=""&gt; myArray;</code></pre>
            </div>
            </p>
            <h2 id="specjalizacja-szablonu">Specjalizacja Szablonu</h2>
            <p>Czasami istnieje potrzeba dostosowania zachowania szablonu dla konkretnego typu. W takich przypadkach u偶ywamy <strong>specjalizacji szablonu</strong>.</p>
            <p><strong>Przykad:</strong> Specjalizacja szablonu klasy <code>Box</code> dla typu <code>std::string</code>:</p>
            <p>
            <div>
                <pre><code class="language-clike">template &lt;&gt;
class Box&lt;std::string&gt; {
private:
    std::string content;

public:
    Box(std::string content) : content(content) {}
    std::string getContent() const { return "Zawarto: " + content; }
};</code></pre>
            </div>
            </p>
            <p><strong>Wyjanienie:</strong></p>
            <ul>
                <li><code>template &lt;&gt;</code>: Wskazuje pen specjalizacj szablonu.</li>
                <li><code>class Box&lt;std::string&gt;</code>: Specjalizacja szablonu <code>Box</code> dla typu <code>std::string</code>.</li>
                <li>Metoda <code>getContent()</code> zostaa zmodyfikowana, aby zwraca prefiksowany cig znak贸w.</li>
            </ul>
            <h2 id="typy-domylne-w-szablonach">Typy Domylne w Szablonach</h2>
            <p>Mo偶emy definiowa wartoci domylne dla parametr贸w szablonu, co zwiksza elastyczno ich u偶ycia.</p>
            <p><strong>Przykad:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">template &lt;typename size="10" std::size_t="" t="int,"&gt;
class Array {
private:
    T elements[Size];

public:
    // Implementacja metod
};</code></pre>
            </div>
            </p>
            <p><strong>U偶ycie:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">Array&lt;&gt; defaultArray;             // Typ T=int, Size=10
Array&lt;double, 5=""&gt; customArray;     // Typ T=double, Size=5</code></pre>
            </div>
            </p>
            <h2 id="szablony-zmiennych">Szablony Zmiennych</h2>
            <p>Od C++14 mo偶liwe jest definiowanie szablon贸w zmiennych, co pozwala na tworzenie zmiennych parametryzowanych typem.</p>
            <p><strong>Przykad:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">template&lt;typename t=""&gt;
constexpr T pi = T(3.1415926535897932385);

auto floatPi = pi&lt;float&gt;;
auto doublePi = pi&lt;double&gt;;</code></pre>
            </div>
            </p>
            <p><strong>Wyjanienie:</strong></p>
            <ul>
                <li><code>constexpr</code> oznacza, 偶e warto jest staa w czasie kompilacji.</li>
                <li><code>pi&lt;T&gt;</code> jest zmienn szablonow parametryzowan typem <code>T</code>.</li>
            </ul>
            <h2 id="aliasowanie-szablon贸w">Aliasowanie Szablon贸w</h2>
            <p>C++11 wprowadzi mo偶liwo tworzenia alias贸w szablon贸w za pomoc sowa kluczowego <code>using</code>. Uatwia to prac z zo偶onymi typami szablonowymi.</p>
            <p><strong>Przykad:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">template &lt;typename t=""&gt;
using Vec = std::vector&lt;t&gt;;

Vec&lt;int&gt; intVector;
Vec&lt;double&gt; doubleVector;</code></pre>
            </div>
            </p>
            <h2 id="szablony-lambda">Szablony Lambda</h2>
            <p>Od C++20 mo偶na tworzy szablony funkcji lambda, co dodatkowo zwiksza mo偶liwoci programistyczne.</p>
            <p><strong>Przykad:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">auto lambda = []&lt;typename t=""&gt;(T a, T b) {
    return a + b;
};

auto sumInt = lambda(5, 3);           // Wynik: 8
auto sumDouble = lambda(2.5, 1.5);    // Wynik: 4.0</code></pre>
            </div>
            </p>
            <h2 id="zaawansowane-techniki-z-szablonami">Zaawansowane Techniki z Szablonami</h2>
            <h3 id="szablony-o-zmiennej-liczbie-argument贸w">Szablony o Zmiennej Liczbie Argument贸w</h3>
            <p>C++11 wprowadzi <strong>szablony o zmiennej liczbie argument贸w</strong> (ang. <em>variadic templates</em>), kt贸re pozwalaj na definiowanie funkcji i klas przyjmujcych dowoln liczb parametr贸w.</p>
            <p><strong>Przykad:</strong> Funkcja <code>print</code> wywietlajca dowoln liczb argument贸w:</p>
            <p>
            <div>
                <pre><code class="language-clike">template&lt;typename... args=""&gt;
void print(Args... args) {
    (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; std::endl;
}

print(1, 2, 3);                 // Wywietla: 123
print("Witaj, ", "wiecie!");   // Wywietla: Witaj, wiecie!</code></pre>
            </div>
            </p>
            <p><strong>Wyjanienie:</strong></p>
            <ul>
                <li><code>template&lt;typename... Args&gt;</code>: Deklaruje szablon z pakietem typ贸w <code>Args</code>.</li>
                <li><code>Args... args</code>: Pakiet argument贸w funkcji.</li>
                <li><code>(std::cout &lt;&lt; ... &lt;&lt; args)</code>: Fold expression, dostpne od C++17, kt贸re skada wyra偶enia binarne.</li>
            </ul>
            <h3 id="wyra偶enia-constexpr-w-szablonach">Wyra偶enia <code>constexpr</code> w Szablonach</h3>
            <p><code>constexpr</code> pozwala na wykonywanie oblicze w czasie kompilacji. Gdy u偶ywamy go w szablonach, mo偶emy tworzy funkcje, kt贸re zwracaj stae wartoci zale偶ne od parametr贸w szablonu.</p>
            <p><strong>Przykad:</strong> Funkcja <code>square</code> obliczajca kwadrat liczby:</p>
            <p>
            <div>
                <pre><code class="language-clike">template&lt;typename t=""&gt;
constexpr T square(T x) {
    return x * x;
}

constexpr int squareOfFive = square(5); // Wynik: 25</code></pre>
            </div>
            </p>
            <h2 id="metaprogramowanie-szablonowe">Metaprogramowanie Szablonowe</h2>
            <p>Metaprogramowanie szablonowe to technika, kt贸ra wykorzystuje szablony do wykonywania oblicze na etapie kompilacji. Pozwala to na optymalizacj kodu i wykonywanie skomplikowanych oblicze bez narzutu w czasie wykonywania programu.</p>
            <h3 id="przykad-obliczanie-liczby-fibonacciego">Przykad: Obliczanie Liczby Fibonacciego</h3>
            <p>Obliczanie wartoci cigu Fibonacciego za pomoc szablon贸w:</p>
            <p>
            <div>
                <pre><code class="language-clike">template&lt;int n=""&gt;
struct Fibonacci {
    static_assert(N &gt;= 0, "N musi by nieujemne");
    static constexpr int value = Fibonacci&lt;n -="" 1=""&gt;::value + Fibonacci&lt;n -="" 2=""&gt;::value;
};

template&lt;&gt;
struct Fibonacci&lt;0&gt; {
    static constexpr int value = 0;
};

template&lt;&gt;
struct Fibonacci&lt;1&gt; {
    static constexpr int value = 1;
};

constexpr int fib10 = Fibonacci&lt;10&gt;::value; // Wynik: 55</code></pre>
            </div>
            </p>
            <p><strong>Wyjanienie:</strong></p>
            <ul>
                <li><strong>Rekurencja w czasie kompilacji</strong> polega na tym, 偶e struktura <code>Fibonacci</code> jest rekurencyjnie instancjonowana dla wartoci <code>N</code>, a偶 do osignicia przypadk贸w bazowych, takich jak <code>N=0</code> i <code>N=1</code>, co pozwala na obliczenia w trakcie kompilacji.</li>
                <li><strong><code>static_assert</code></strong> jest u偶ywany do sprawdzania warunk贸w w czasie kompilacji, co pozwala na weryfikacj poprawnoci kodu przed jego wykonaniem.</li>
                <li><strong><code>constexpr</code></strong> zapewnia, 偶e dana warto zostanie obliczona w czasie kompilacji, co zwiksza efektywno i pozwala na lepsz optymalizacj kodu.</li>
            </ul>
            <h3 id="analiza-matematyczna">Analiza Matematyczna</h3>
            <p>Cig Fibonacciego jest zdefiniowany rekurencyjnie:</p>
            <p>$$
                F(0) = 0, \quad F(1) = 1, \quad F(N) = F(N-1) + F(N-2) \text{ dla } N \geq 2
                $$</p>
            <p>Implementacja za pomoc szablon贸w odwzorowuje t definicj, pozwalajc kompilatorowi na obliczenie wartoci <code>F(N)</code> podczas kompilacji.</p>
            <h3 id="zastosowania-metaprogramowania-szablonowego">Zastosowania Metaprogramowania Szablonowego</h3>
            <ul>
                <li><strong>Optymalizacja</strong> polega na usuniciu narzutu czasowego poprzez przeniesienie oblicze z etapu wykonania programu na etap kompilacji, co przyspiesza dziaanie aplikacji.</li>
                <li><strong>Generowanie kod贸w specjalizowanych</strong> umo偶liwia tworzenie kodu dostosowanego do konkretnych typ贸w lub wartoci, co poprawia wydajno i elastyczno aplikacji.</li>
                <li><strong>Sprawdzanie warunk贸w w czasie kompilacji</strong> odbywa si za pomoc <code>static_assert</code>, kt贸ry pozwala na weryfikacj zao偶e programu przed jego uruchomieniem, eliminujc potencjalne bdy ju偶 na etapie kompilacji.</li>
            </ul>
            <h2 id="zastosowanie-szablon贸w-w-praktyce">Zastosowanie Szablon贸w w Praktyce</h2>
            <p>Szablony s integraln czci jzyka C++ i stanowi podstaw wielu bibliotek oraz aplikacji komercyjnych. Ich zdolno do tworzenia kodu generycznego, kt贸ry mo偶e dziaa z r贸偶nymi typami danych, sprawia, 偶e s one niezbdne w nowoczesnym programowaniu. W tej sekcji przyjrzymy si, jak szablony s wykorzystywane w praktyce, skupiajc si na standardowej bibliotece C++ (STL) oraz na innych popularnych bibliotekach, takich jak Boost czy Eigen.</p>
            <h3 id="standardowa-biblioteka-szablon贸w-stl-">Standardowa Biblioteka Szablon贸w (STL)</h3>
            <p>STL (Standard Template Library) jest zestawem klas i funkcji szablonowych dostarczanych przez standardow bibliotek C++. Zawiera ona kontenery, algorytmy oraz iteratory, kt贸re umo偶liwiaj efektywne i elastyczne manipulowanie danymi.</p>
            <h4 id="kontenery">Kontenery</h4>
            <p>Kontenery s klasami szablonowymi, kt贸re przechowuj kolekcje obiekt贸w. Dziki szablonom mog one przechowywa elementy dowolnego typu. Oto niekt贸re z najwa偶niejszych kontener贸w w STL:</p>
            <p>
            <table>
                <tr>
                    <td>Kontener</td>
                    <td>Opis</td>
                </tr>
                <tr>
                    <td><strong><code>std::vector</code></strong></td>
                    <td>Dynamiczna tablica o zmiennym rozmiarze.</td>
                </tr>
                <tr>
                    <td><strong><code>std::list</code></strong></td>
                    <td>Lista dwukierunkowa.</td>
                </tr>
                <tr>
                    <td><strong><code>std::deque</code></strong></td>
                    <td>Dwustronna kolejka.</td>
                </tr>
                <tr>
                    <td><strong><code>std::set</code></strong></td>
                    <td>Zbi贸r unikalnych element贸w, uporzdkowanych.</td>
                </tr>
                <tr>
                    <td><strong><code>std::map</code></strong></td>
                    <td>Asocjacyjny kontener przechowujcy pary klucz-warto.</td>
                </tr>
                <tr>
                    <td><strong><code>std::unordered_set</code></strong></td>
                    <td>Nieuporzdkowany zbi贸r wykorzystujcy tablice haszujce.</td>
                </tr>
                <tr>
                    <td><strong><code>std::unordered_map</code></strong></td>
                    <td>Nieuporzdkowana mapa wykorzystujca tablice haszujce do par klucz-warto.</td>
                </tr>
            </table>
            </p>
            <h4 id="algorytmy">Algorytmy</h4>
            <p>Algorytmy w STL s funkcjami szablonowymi, kt贸re wykonuj operacje na danych przechowywanych w kontenerach. S one niezale偶ne od konkretnych typ贸w danych i kontener贸w, o ile dostarczone s odpowiednie iteratory.</p>
            <p>
            <table>
                <tr>
                    <td>Funkcja</td>
                    <td>Opis</td>
                </tr>
                <tr>
                    <td><strong><code>std::sort</code></strong></td>
                    <td>Sortowanie element贸w w zakresie.</td>
                </tr>
                <tr>
                    <td><strong><code>std::find</code></strong></td>
                    <td>Wyszukiwanie elementu w zakresie.</td>
                </tr>
                <tr>
                    <td><strong><code>std::accumulate</code></strong></td>
                    <td>Sumowanie wartoci w zakresie.</td>
                </tr>
                <tr>
                    <td><strong><code>std::copy</code></strong></td>
                    <td>Kopiowanie element贸w z jednego zakresu do drugiego.</td>
                </tr>
            </table>
            </p>
            <h4 id="iteratory">Iteratory</h4>
            <p>Iteratory s abstrakcj wska藕nik贸w, kt贸re pozwalaj na jednolite interfejsy do przegldania element贸w w kontenerach. S one zaimplementowane jako szablony, dziki czemu mog dziaa z r贸偶nymi typami kontener贸w.</p>
            <h3 id="przykad-kontener-std-vector">Przykad: Kontener <code>std::vector</code></h3>
            <p><code>std::vector</code> jest jednym z najczciej u偶ywanych kontener贸w w STL. Reprezentuje dynamiczn tablic, kt贸ra mo偶e zmienia sw贸j rozmiar w czasie wykonywania programu. Dziki wykorzystaniu szablon贸w, <code>std::vector</code> mo偶e przechowywa elementy dowolnego typu.</p>
            <p><strong>Definicja szablonu <code>std::vector</code>:</strong></p>
            <p>W uproszczeniu, <code>std::vector</code> jest zdefiniowany nastpujco:</p>
            <p>
            <div>
                <pre><code class="language-clike">template &lt;typename allocator="std::allocator&lt;T" t,="" typename=""&gt;&gt;
class vector {
    // Implementacja wewntrzna
};</code></pre>
            </div>
            </p>
            <p><strong>Parametry szablonu:</strong></p>
            <ul>
                <li><strong><code>typename T</code></strong> okrela typ przechowywanych element贸w, co pozwala na tworzenie szablon贸w, kt贸re mog dziaa z r贸偶nymi typami danych.</li>
                <li><strong><code>typename Allocator</code></strong> definiuje typ alokatora u偶ywanego do zarzdzania pamici, z domyln wartoci <code>std::allocator&lt;T&gt;</code>, co umo偶liwia elastyczne zarzdzanie pamici dla element贸w.</li>
            </ul>
            <p><strong>Przykady u偶ycia:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">std::vector&lt;int&gt; vecInt;            // Wektor liczb cakowitych
std::vector&lt;double&gt; vecDouble;      // Wektor liczb zmiennoprzecinkowych
std::vector&lt;std::string&gt; vecString; // Wektor acuch贸w znak贸w</code></pre>
            </div>
            </p>
            <p><strong>Operacje na <code>std::vector</code>:</strong></p>
            <p>I. <strong>Dodawanie element贸w:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">vecInt.push_back(10);
vecInt.push_back(20);
vecInt.push_back(30);</code></pre>
            </div>
            </p>
            <p>II. <strong>Dostp do element贸w:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">int firstElement = vecInt[0];          // Dostp za pomoc operatora []
int secondElement = vecInt.at(1);      // Dostp z kontrol zakresu</code></pre>
            </div>
            </p>
            <p>III. <strong>Iterowanie po elementach:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">for (size_t i = 0; i &lt; vecInt.size(); ++i) {
  std::cout &lt;&lt; vecInt[i] &lt;&lt; " ";
}

for (auto it = vecInt.begin(); it != vecInt.end(); ++it) {
  std::cout &lt;&lt; *it &lt;&lt; " ";
}

for (const auto&amp; value : vecInt) {
  std::cout &lt;&lt; value &lt;&lt; " ";
}</code></pre>
            </div>
            </p>
            <p>IV. <strong>Modyfikacja element贸w:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">vecInt[0] = 100;</code></pre>
            </div>
            </p>
            <p><strong>Implementacja generyczna:</strong></p>
            <p>Dziki temu, 偶e <code>std::vector</code> jest szablonem, mo偶emy u偶ywa go z dowolnym typem, kt贸ry jest kopiowalny lub przenony. Oznacza to, 偶e mo偶emy przechowywa zar贸wno typy podstawowe, jak i zo偶one obiekty u偶ytkownika.</p>
            <p><strong>Przykad z typem u偶ytkownika:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">class Point {
public:
    int x, y;
    Point(int x, int y) : x(x), y(y) {}
};

std::vector&lt;point&gt; points;
points.emplace_back(1, 2);
points.emplace_back(3, 4);</code></pre>
            </div>
            </p>
            <p><strong>Analiza matematyczna wydajnoci:</strong></p>
            <p>Operacje na <code>std::vector</code> maj okrelone zo偶onoci czasowe:</p>
            <p>
            <table>
                <tr>
                    <td>Operacja</td>
                    <td>Zo偶ono</td>
                    <td>Wyjanienie</td>
                </tr>
                <tr>
                    <td><strong>Dostp do element贸w</strong></td>
                    <td>$O(1)$</td>
                    <td>Dziki cigemu ukadowi pamici, dostp do dowolnego elementu jest bezporedni.</td>
                </tr>
                <tr>
                    <td><strong>Dodawanie elementu na kocu</strong></td>
                    <td>Amortyzowane $O(1)$</td>
                    <td>Dodanie elementu jest szybkie, chyba 偶e konieczna jest realokacja pamici.</td>
                </tr>
                <tr>
                    <td><strong>Wstawianie/usuwanie element贸w w rodku</strong></td>
                    <td>$O(n)$</td>
                    <td>Wymaga przesunicia pozostaych element贸w, co zwiksza czas operacji.</td>
                </tr>
            </table>
            </p>
            <p><strong>Zarzdzanie pamici:</strong></p>
            <p><code>std::vector</code> zarzdza pamici dynamicznie. Gdy wektor osiga swoj maksymaln pojemno, automatycznie alokuje wikszy blok pamici i kopiuje istniejce elementy. Domylnie pojemno jest podwajana, co zapewnia amortyzowan zo偶ono O(1) dla operacji dodawania na kocu.</p>
            <h3 id="przykad-algorytm-std-sort">Przykad: Algorytm <code>std::sort</code></h3>
            <p>Algorytm <code>std::sort</code> jest funkcj szablonow, kt贸ra sortuje elementy w zakresie okrelonym przez dwa iteratory.</p>
            <p><strong>Definicja:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">template &lt;class randomit=""&gt;
void sort(RandomIt first, RandomIt last);</code></pre>
            </div>
            </p>
            <p><strong>Wymagania:</strong></p>
            <ul>
                <li>Typ element贸w musi by por贸wnywalny za pomoc operatora <code>&lt;</code>.</li>
                <li>Iteratory musz by iteratorami losowego dostpu (np. z <code>std::vector</code> lub tablicy).</li>
            </ul>
            <p><strong>Przykad u偶ycia:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">std::vector&lt;int&gt; data = {5, 2, 9, 1, 5, 6};
std::sort(data.begin(), data.end());</code></pre>
            </div>
            </p>
            <p><strong>Dostosowywanie kryterium sortowania:</strong></p>
            <p>Mo偶emy dostarczy wasn funkcj por贸wnujc:</p>
            <p>
            <div>
                <pre><code class="language-clike">std::sort(data.begin(), data.end(), [](int a, int b) {
    return a &gt; b; // Sortowanie malejce
});</code></pre>
            </div>
            </p>
            <p><strong>Zo偶ono czasowa:</strong></p>
            <ul>
                <li>rednia: $O(nlogn)$</li>
                <li>Najgorszy przypadek: $O(nlogn)$ - w implementacji wykorzystujcej zabezpieczenia przed zym rozkadem danych.</li>
            </ul>
            <h3 id="przykad-kontener-std-map">Przykad: Kontener <code>std::map</code></h3>
            <p><code>std::map</code> jest kontenerem asocjacyjnym, kt贸ry przechowuje pary klucz-warto w uporzdkowany spos贸b.</p>
            <p><strong>Definicja:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">template &lt;
    class Key,
    class T,
    class Compare = std::less&lt;key&gt;,
    class Allocator = std::allocator&lt;std::pair&lt;const key,="" t=""&gt;&gt;
&gt;
class map {
    // Implementacja wewntrzna
};</code></pre>
            </div>
            </p>
            <p><strong>Parametry szablonu:</strong></p>
            <p>
            <table>
                <tr>
                    <td>Parametr</td>
                    <td>Opis</td>
                    <td>Wyjanienie</td>
                </tr>
                <tr>
                    <td><code>class Key</code></td>
                    <td>Typ klucza</td>
                    <td>Okrela typ danych, kt贸ry bdzie u偶ywany jako klucz w kontenerze.</td>
                </tr>
                <tr>
                    <td><code>class T</code></td>
                    <td>Typ wartoci</td>
                    <td>Reprezentuje typ danych przechowywanych jako wartoci w kontenerze.</td>
                </tr>
                <tr>
                    <td><code>class Compare</code></td>
                    <td>Funkcja por贸wnujca</td>
                    <td>Funktor lub funkcja, kt贸ra decyduje o sposobie por贸wnywania kluczy.</td>
                </tr>
                <tr>
                    <td><code>class Allocator</code></td>
                    <td>Alokator pamici</td>
                    <td>Definiuje spos贸b alokacji i zarzdzania pamici dla element贸w kontenera.</td>
                </tr>
            </table>
            </p>
            <p><strong>Przykad u偶ycia:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">std::map&lt;std::string, int=""&gt; wordCounts;
wordCounts["apple"] = 3;
wordCounts["banana"] = 5;
wordCounts["orange"] = 2;</code></pre>
            </div>
            </p>
            <p><strong>Operacje:</strong></p>
            <p>I. <strong>Wstawianie element贸w:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">wordCounts.insert({"grape", 4});</code></pre>
            </div>
            </p>
            <p>II. <strong>Dostp do wartoci:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">int count = wordCounts["banana"]; // count == 5</code></pre>
            </div>
            </p>
            <p>III. <strong>Iterowanie:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">for (const auto&amp; pair : wordCounts) {
  std::cout &lt;&lt; pair.first &lt;&lt; ": " &lt;&lt; pair.second &lt;&lt; "\n";
}</code></pre>
            </div>
            </p>
            <p><strong>Waciwoci:</strong></p>
            <ul>
                <li>Elementy s przechowywane w uporzdkowany spos贸b wedug klucza.</li>
                <li>Wyszukiwanie, wstawianie i usuwanie maj zo偶ono O(log n) dziki wewntrznej implementacji drzewa czerwono-czarnego.</li>
            </ul>
            <h3 id="biblioteka-boost">Biblioteka Boost</h3>
            <p>Boost to zestaw bibliotek C++ rozszerzajcych funkcjonalno standardowej biblioteki. Wiele z nich jest proponowanych do wczenia do standardu C++. Szablony s intensywnie wykorzystywane w celu zapewnienia elastycznoci i wydajnoci.</p>
            <p><strong>Przykad: <code>boost::shared_ptr</code></strong></p>
            <p>Przed wprowadzeniem <code>std::shared_ptr</code> w C++11, <code>boost::shared_ptr</code> by szeroko stosowanym inteligentnym wska藕nikiem zarzdzajcym 偶yciem obiektu.</p>
            <p><strong>Definicja:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">template&lt;typename t=""&gt;
class shared_ptr {
    // Implementacja wewntrzna
};</code></pre>
            </div>
            </p>
            <p><strong>U偶ycie:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">boost::shared_ptr&lt;myclass&gt; ptr(new MyClass());</code></pre>
            </div>
            </p>
            <p><strong>Zalety:</strong></p>
            <ul>
                <li>Automatyczne zarzdzanie pamici poprzez licznik referencji.</li>
                <li>Bezpieczestwo w rodowiskach wielowtkowych (z odpowiedni synchronizacj).</li>
            </ul>
            <h3 id="biblioteka-eigen">Biblioteka Eigen</h3>
            <p>Eigen to szablonowa biblioteka C++ do algebry liniowej, zoptymalizowana pod ktem wysokiej wydajnoci.</p>
            <p><strong>Definicja szablonu macierzy:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">template&lt;typename colsatcompiletime="" int="" rowsatcompiletime,="" scalar,=""&gt;
class Matrix {
    // Implementacja wewntrzna
};</code></pre>
            </div>
            </p>
            <p><strong>Przykad u偶ycia:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">Eigen::Matrix&lt;float, 3="" 3,=""&gt; matA;
Eigen::Matrix&lt;float, 1="" 3,=""&gt; vecB;

matA &lt;&lt; 1, 2, 3,
         4, 5, 6,
         7, 8, 9;

vecB &lt;&lt; 1,
         2,
         3;

Eigen::Matrix&lt;float, 1="" 3,=""&gt; result = matA * vecB;</code></pre>
            </div>
            </p>
            <p><strong>Waciwoci:</strong></p>
            <ul>
                <li><strong>Statyczne rozmiary</strong> macierzy, gdy s znane w czasie kompilacji, pozwalaj bibliotece Eigen na generowanie wysoce wydajnego kodu, co zwiksza efektywno oblicze.</li>
                <li><strong>Szablony wyra偶eniowe</strong> (<em>Expression Templates</em>) umo偶liwiaj optymalizacj oblicze, minimalizujc tworzenie niepotrzebnych kopii danych, co poprawia wydajno dziaania programu.</li>
            </ul>
            <p><strong>Analiza wydajnoci:</strong></p>
            <ul>
                <li><strong>Unikanie alokacji pamici</strong> jest mo偶liwe dziki zastosowaniu szablon贸w i mechanizmu inlining, co pozwala bibliotece Eigen na wykonywanie operacji bez potrzeby dodatkowych alokacji pamici, co zwiksza wydajno.</li>
                <li><strong>Wektorowe instrukcje procesora</strong> s automatycznie wykorzystywane przez Eigen, dziki wsparciu dla instrukcji SIMD (Single Instruction, Multiple Data), jeli s one dostpne na danej platformie, co przyspiesza operacje matematyczne.</li>
            </ul>
            <h3 id="wpyw-szablon贸w-na-projektowanie-bibliotek">Wpyw Szablon贸w na Projektowanie Bibliotek</h3>
            <p>Szablony umo偶liwiaj tworzenie bibliotek, kt贸re s zar贸wno elastyczne, jak i wydajne. Oto kilka kluczowych aspekt贸w:</p>
            <ul>
                <li><strong>Polimorfizm statyczny</strong> w szablonach odbywa si w czasie kompilacji, w przeciwiestwie do polimorfizmu dynamicznego (realizowanego przez klasy bazowe i wska藕niki), co eliminuje narzut zwizany z wykonywaniem w czasie dziaania programu.</li>
                <li><strong>Silne typowanie</strong> sprawia, 偶e bdy typ贸w s wykrywane w czasie kompilacji, co zwiksza bezpieczestwo kodu i minimalizuje ryzyko bd贸w w czasie dziaania.</li>
                <li><strong>Optymalizacje kompilatora</strong> s mo偶liwe dziki generowaniu specjalizowanego kodu dla konkretnych typ贸w, co umo偶liwia kompilatorowi stosowanie agresywnych optymalizacji w celu poprawy wydajnoci.</li>
            </ul>
            <h3 id="koncepty-c-20-">Koncepty (C++20)</h3>
            <p>Koncepty wprowadzaj mo偶liwo definiowania wymaga dla parametr贸w szablonu, co uatwia tworzenie bardziej czytelnego i bezpiecznego kodu.</p>
            <p><strong>Przykad:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">template&lt;typename t=""&gt;
concept Number = std::is_arithmetic_v&lt;t&gt;;

template&lt;number t=""&gt;
T multiply(T a, T b) {
    return a * b;
}</code></pre>
            </div>
            </p>
            <p><strong>Zalety:</strong></p>
            <ul>
                <li><strong>Poprawa czytelnoci bd贸w kompilacji</strong> wynika z zastosowania koncept贸w, kt贸re umo偶liwiaj kompilatorowi dostarczenie bardziej precyzyjnych i zrozumiaych komunikat贸w o bdach, co uatwia debugowanie.</li>
                <li><strong>Dokumentacja wymaga</strong> jest naturalnym efektem u偶ycia koncept贸w, poniewa偶 jasno okrelaj one, jakie wymagania musi spenia typ parametr贸w szablonu, co poprawia zrozumiao i u偶yteczno kodu.</li>
            </ul>
            <h3 id="zaawansowane-techniki-z-u偶yciem-szablon贸w">Zaawansowane Techniki z U偶yciem Szablon贸w</h3>
            <h4 id="metaprogramowanie-szablonowe">Metaprogramowanie Szablonowe</h4>
            <p>Metaprogramowanie szablonowe pozwala na wykonywanie oblicze w czasie kompilacji.</p>
            <p><strong>Przykad: Generowanie listy typ贸w</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">template&lt;typename... types=""&gt;
struct TypeList {};

using MyTypes = TypeList&lt;int, double,="" std::string=""&gt;;</code></pre>
            </div>
            </p>
            <h4 id="szablony-wewntrzne-curiously-recurring-template-pattern-crtp-">Szablony Wewntrzne (Curiously Recurring Template Pattern - CRTP)</h4>
            <p>CRTP to idiom programistyczny, w kt贸rym klasa dziedziczy po szablonie swojej wasnej klasy.</p>
            <p><strong>Przykad:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">template&lt;typename derived=""&gt;
class Base {
public:
    void interface() {
        static_cast&lt;derived*&gt;(this)-&gt;implementation();
    }
};

class DerivedClass : public Base&lt;derivedclass&gt; {
public:
    void implementation() {
        // Implementacja specyficzna dla klasy pochodnej
    }
};</code></pre>
            </div>
            </p>
            <p><strong>Zastosowania:</strong></p>
            <ul>
                <li><strong>Statyczny polimorfizm</strong> pozwala na osignicie polimorfizmu w czasie kompilacji, eliminujc narzut zwizany z dynamicznym wizaniem, co zwiksza wydajno.</li>
                <li><strong>Klasy mixin</strong> umo偶liwiaj wstrzykiwanie dodatkowej funkcjonalnoci do klasy pochodnej, co uatwia tworzenie modularnych i wielokrotnego u偶ytku komponent贸w.</li>
            </ul>
            <h3 id="ograniczenia-i-wyzwania">Ograniczenia i Wyzwania</h3>
            <ul>
                <li>Bdy w kodzie szablonowym mog generowa dugie i trudne do zrozumienia komunikaty.</li>
                <li>Intensywne u偶ycie szablon贸w mo偶e znaczco wydu偶y czas kompilacji.</li>
                <li>Szablony mog wprowadza zale偶noci, kt贸re nie s oczywiste na pierwszy rzut oka.</li>
            </ul>
            <h3 id="praktyczne-wskaz贸wki">Praktyczne Wskaz贸wki</h3>
            <ul>
                <li>W miar mo偶liwoci korzystaj z koncept贸w, aby jasno okreli wymagania dla parametr贸w szablonu.</li>
                <li>Wyjaniaj zao偶enia i oczekiwania wobec typ贸w parametr贸w.</li>
                <li>Staraj si nie komplikowa kodu szablonowego bardziej ni偶 to konieczne.</li>
            </ul>
        </section>
        <div id="table-of-contents">
            <h2>Spis Treci</h2>
            <ol>
                <li><a href="#wprowadzenie-do-szablon贸w">Wprowadzenie do Szablon贸w</a>
                    <ol>
                        <li><a href="#szablony-funkcji">Szablony Funkcji</a></li>
                        <li><a href="#mechanizm-instancjacji">Mechanizm Instancjacji</a></li>
                    </ol>
                </li>
                <li><a href="#szablony-klas">Szablony Klas</a></li>
                <li><a href="#wielokrotne-parametry-szablonu">Wielokrotne Parametry Szablonu</a></li>
                <li><a href="#specjalizacja-szablonu">Specjalizacja Szablonu</a></li>
                <li><a href="#typy-domylne-w-szablonach">Typy Domylne w Szablonach</a></li>
                <li><a href="#szablony-zmiennych">Szablony Zmiennych</a></li>
                <li><a href="#aliasowanie-szablon贸w">Aliasowanie Szablon贸w</a></li>
                <li><a href="#szablony-lambda">Szablony Lambda</a></li>
                <li><a href="#zaawansowane-techniki-z-szablonami">Zaawansowane Techniki z Szablonami</a>
                    <ol>
                        <li><a href="#szablony-o-zmiennej-liczbie-argument贸w">Szablony o Zmiennej Liczbie Argument贸w</a></li>
                        <li><a href="#wyra偶enia-constexpr-w-szablonach">Wyra偶enia constexpr w Szablonach</a></li>
                    </ol>
                </li>
                <li><a href="#metaprogramowanie-szablonowe">Metaprogramowanie Szablonowe</a>
                    <ol>
                        <li><a href="#przykad-obliczanie-liczby-fibonacciego">Przykad: Obliczanie Liczby Fibonacciego</a></li>
                        <li><a href="#analiza-matematyczna">Analiza Matematyczna</a></li>
                        <li><a href="#zastosowania-metaprogramowania-szablonowego">Zastosowania Metaprogramowania Szablonowego</a></li>
                    </ol>
                </li>
                <li><a href="#zastosowanie-szablon贸w-w-praktyce">Zastosowanie Szablon贸w w Praktyce</a>
                    <ol>
                        <li><a href="#standardowa-biblioteka-szablon贸w-stl-">Standardowa Biblioteka Szablon贸w (STL)</a>
                            <ol>
                                <li><a href="#kontenery">Kontenery</a></li>
                                <li><a href="#algorytmy">Algorytmy</a></li>
                                <li><a href="#iteratory">Iteratory</a></li>
                            </ol>
                        </li>
                        <li><a href="#przykad-kontener-std-vector">Przykad: Kontener std::vector</a></li>
                        <li><a href="#przykad-algorytm-std-sort">Przykad: Algorytm std::sort</a></li>
                        <li><a href="#przykad-kontener-std-map">Przykad: Kontener std::map</a></li>
                        <li><a href="#biblioteka-boost">Biblioteka Boost</a></li>
                        <li><a href="#biblioteka-eigen">Biblioteka Eigen</a></li>
                        <li><a href="#wpyw-szablon贸w-na-projektowanie-bibliotek">Wpyw Szablon贸w na Projektowanie Bibliotek</a></li>
                        <li><a href="#koncepty-c-20-">Koncepty (C++20)</a></li>
                        <li><a href="#zaawansowane-techniki-z-u偶yciem-szablon贸w">Zaawansowane Techniki z U偶yciem Szablon贸w</a>
                            <ol>
                                <li><a href="#metaprogramowanie-szablonowe">Metaprogramowanie Szablonowe</a></li>
                                <li><a href="#szablony-wewntrzne-curiously-recurring-template-pattern-crtp-">Szablony Wewntrzne (Curiously Recurring Template Pattern - CRTP)</a></li>
                            </ol>
                        </li>
                        <li><a href="#ograniczenia-i-wyzwania">Ograniczenia i Wyzwania</a></li>
                        <li><a href="#praktyczne-wskaz贸wki">Praktyczne Wskaz贸wki</a></li>
                    </ol>
                </li>
            </ol>
            <div id="related-articles">
                <h2>Related Articles</h2>
                <ol>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/01_proces_kompilacji.html">Proces Kompilacji</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/02_preprocesor.html">Preprocesor</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/03_zmienne_i_typy_danych.html">Zmienne i Typy Danych</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/04_interakcja_z_konsola.html">Interakcja z Konsola</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/05_instrukcja_warunkowa.html">Instrukcja Warunkowa</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/06_petle.html">Petle</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/07_liczby_losowe.html">Liczby Losowe</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/08_typ_wyliczeniowy.html">Typ Wyliczeniowy</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/09_funkcje.html">Funkcje</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/10_l_wartosci_r_wartosci.html">L Wartosci R Wartosci</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/11_wskazniki.html">Wskazniki</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/12_tablice.html">Tablice</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/13_napisy.html">Napisy</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/14_operacje_bitowe.html">Operacje Bitowe</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/15_programowanie_obietkowe.html">Programowanie Obietkowe</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/16_dziedziczenie.html">Dziedziczenie</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/17_zaawansowane_wskazniki.html">Zaawansowane Wskazniki</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/18_przeciazanie.html">Przeciazanie</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/19_konwersje.html">Konwersje</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/20_lambdy.html">Lambdy</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/21_szablony.html">Szablony</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/22_wyjatki.html">Wyjatki</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/23_stl.html">Stl</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/24_praca_z_plikami.html">Praca z Plikami</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/25_c_vs_cpp.html">C vs Cpp</a></li>
                </ol>
            </div>
        </div>
    </div>
    <footer>
        <div class="footer-columns">
            <div class="footer-column">
                <img alt="Adam Djellouli Symbol" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/symbol.png" />
            </div>
            <div class="footer-column">
                <h2><a href="https://adamdjellouli.com/core/privacy_policy.html" title="Privacy Policy">Our Privacy Policy</a></h2>
                <p>
                    Thank you for visiting my personal website. All of the <br />
                    content on this site is free to use, but please remember <br />
                    to be a good human being and refrain from any abuse<br />
                    of the site. If you would like to contact me, please use <br />
                    my <a href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" title="LinkedIn Profile">LinkedIn profile</a> or my <a href="https://github.com/djeada" title="GitHub Profile">GitHub</a> if you have any technical <br />
                    issues or ideas to share. I wish you the best and hope you <br />
                    have a fantastic life. <br />
                </p>
            </div>
            <div class="footer-column">
                <h2>Follow me</h2>
                <ul class="social-media">
                    <li>
                        <a class="fa fa-youtube" href="https://www.youtube.com/channel/UCGPoHTVjMN77wcGknXPHl1Q" target="_blank" title="YouTube">
                        </a>YouTube
                    </li>
                    <li>
                        <a class="fa fa-linkedin" href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" target="_blank" title="LinkedIn">
                        </a>LinkedIn
                    </li>
                    <li>
                        <a class="fa fa-instagram" href="https://www.instagram.com/linuxchallenges/" target="_blank" title="Instagram">
                        </a>Instagram
                    </li>
                    <li>
                        <a class="fa fa-github" href="https://github.com/djeada" title="GitHub">
                        </a>Github
                    </li>
                </ul>
            </div>
        </div>
        <div>
            <p id="copyright">
                漏 Adam Djellouli. All rights reserved.
            </p>
        </div>
        <script>
            document.getElementById("copyright").innerHTML = "&copy; " + new Date().getFullYear() + " Adam Djellouli. All rights reserved.";
        </script>
        <script src="../../app.js"></script>
    </footer>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-bash.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-cpp.min.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
jax: ["input/TeX", "output/HTML-CSS"],
extensions: ["tex2jax.js"],
"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] },
tex2jax: { inlineMath: [ ["$", "$"] ], displayMath: [ ["$$","$$"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
TeX: { noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } } },
messageStyle: "none"
});
</script>
<script async="" id="MathJax-script" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>

</html>