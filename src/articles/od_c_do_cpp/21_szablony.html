<!DOCTYPE html>

<html lang="pl">

<head>
    <script async="" crossorigin="anonymous" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5593122079896089"></script>
    <meta charset="utf-8" />
    <title>Szablony</title>
    <meta content="Szablony (ang." name="description" />
    <meta content="Adam Djellouli" name="author" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <meta content="IE=edge" http-equiv="X-UA-Compatible" />
    <link crossorigin="" href="https://fonts.googleapis.com" rel="preconnect" />
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/icon.ico" rel="icon" />
    <link href="../../resources/style.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />
</head>

<body>
    <nav aria-label="Main navigation">
        <a class="logo" href="https://adamdjellouli.com">
            <img alt="Adam Djellouli - Home Page Logo" id="logo-image" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/logo.PNG" />
        </a>
        <input aria-label="Toggle navigation menu" id="navbar-toggle" type="checkbox" />
        <ul aria-labelledby="navbar-toggle" role="menu">
            <li role="menuitem">
                <a href="../../index.html" title="Go to Home Page"> Home </a>
            </li>
            <li role="menuitem">
                <a class="active" href="../../core/blog.html" title="Read Adam Djellouli Blog on Programming and Technology"> Blog </a>
            </li>
            <li role="menuitem">
                <a href="../../core/tools.html" title="Discover Tools Created by Adam Djellouli"> Tools </a>
            </li>
            <li role="menuitem">
                <a href="../../core/projects.html" title="Explore Projects Developed by Adam Djellouli"> Projects </a>
            </li>
            <li role="menuitem">
                <a href="../../core/resume.html" title="View Adam Djellouli Professional Resume"> Resume </a>
            </li>
            <li>
                <script async="" src="https://cse.google.com/cse.js?cx=8160ef9bb935f4f68"></script>
                <div class="gcse-search"></div>
            </li>
            <li>
                <button aria-label="Toggle dark mode" id="dark-mode-button"></button>
            </li>
        </ul>
    </nav>
    <div id="article-wrapper">
        <section id="article-body">
            <p style="text-align: right;"><i>Last modified: September 25, 2024</i></p>
            <p style="text-align: right;"><i>This article is written in: 🇵🇱</i></p>
            <header>Szablony</header>
            <p>Szablony (ang. <em>templates</em>) stanowią fundament nowoczesnego programowania w języku C++. Umożliwiają one tworzenie kodu generycznego, który może działać z różnymi typami danych bez konieczności jego duplikacji. Szablony są kluczowym elementem metaprogramowania w C++, pozwalając na wykonywanie obliczeń na etapie kompilacji i optymalizację kodu wynikowego.</p>
            <h2 id="wprowadzenie-do-szablonów">Wprowadzenie do Szablonów</h2>
            <p>Szablony w C++ są mechanizmem pozwalającym na tworzenie funkcji, klas, a nawet zmiennych, które są parametryzowane typami lub wartościami stałymi. Dzięki temu możemy pisać kod, który jest niezależny od konkretnego typu danych, co zwiększa jego reużywalność i elastyczność.</p>
            <h3 id="szablony-funkcji">Szablony Funkcji</h3>
            <p>Szablony funkcji pozwalają na definiowanie funkcji, które działają na różnych typach danych. Ogólna składnia definicji szablonu funkcji jest następująca:</p>
            <p>
            <div>
                <pre><code class="language-clike">template &lt;parametry_szablonu&gt;
typ_zwracany nazwa_funkcji(argumenty) {
    // ciało funkcji
}</code></pre>
            </div>
            </p>
            <p><strong>Przykład:</strong> Definicja generycznej funkcji <code>max2</code>, która zwraca większą z dwóch wartości:</p>
            <p>
            <div>
                <pre><code class="language-clike">template &lt;typename t=""&gt;
T max2(T arg1, T arg2) {
    return arg1 &gt; arg2 ? arg1 : arg2;
}</code></pre>
            </div>
            </p>
            <p><strong>Wyjaśnienie:</strong></p>
            <ul>
                <li><code>template &lt;typename T&gt;</code> deklaruje szablon z parametrem typu <code>T</code>.</li>
                <li>Funkcja <code>max2</code> przyjmuje dwa argumenty typu <code>T</code> i zwraca wartość typu <code>T</code>.</li>
                <li>Operator <code>?:</code> zwraca <code>arg1</code> lub <code>arg2</code> w zależności od wyniku porównania <code>arg1 &gt; arg2</code>.</li>
            </ul>
            <p><strong>Użycie funkcji szablonowej:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">int a = max2&lt;int&gt;(10, 20);            // Wynik: 20
double b = max2&lt;double&gt;(16.2, 3.14);  // Wynik: 16.2
char c = max2&lt;char&gt;('a', 'b');        // Wynik: 'b'</code></pre>
            </div>
            </p>
            <h3 id="mechanizm-instancjacji">Mechanizm Instancjacji</h3>
            <p>Podczas kompilacji, gdy funkcja szablonowa jest wywoływana z konkretnym typem, kompilator tworzy jej <strong>instancję</strong> dla tego typu. Proces ten nazywany jest <strong>instancjacją szablonu</strong>. Dzięki temu generowany kod jest zoptymalizowany pod kątem użytych typów, eliminując narzut wydajnościowy związany z polimorfizmem dynamicznym.</p>
            <h2 id="szablony-klas">Szablony Klas</h2>
            <p>Szablony klas umożliwiają definiowanie klas generycznych, które mogą operować na różnych typach danych. Składnia szablonu klasy jest podobna do szablonu funkcji.</p>
            <p><strong>Przykład:</strong> Definicja szablonu klasy <code>Box</code>:</p>
            <p>
            <div>
                <pre><code class="language-clike">template &lt;typename t=""&gt;
class Box {
private:
    T content;

public:
    Box(T content) : content(content) {}
    T getContent() const { return content; }
};</code></pre>
            </div>
            </p>
            <p><strong>Wyjaśnienie:</strong></p>
            <ul>
                <li><code>template &lt;typename T&gt;</code>: Deklaruje szablon klasy z parametrem typu <code>T</code>.</li>
                <li><code>T content;</code>: Zmienna członkowska przechowująca zawartość typu <code>T</code>.</li>
                <li>Konstruktor i metoda <code>getContent()</code> operują na typie <code>T</code>.</li>
            </ul>
            <p><strong>Tworzenie instancji szablonu klasy:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">Box&lt;int&gt; intBox(42);
Box&lt;std::string&gt; stringBox("Witaj");</code></pre>
            </div>
            </p>
            <h2 id="wielokrotne-parametry-szablonu">Wielokrotne Parametry Szablonu</h2>
            <p>Szablony mogą przyjmować wiele parametrów, zarówno typów, jak i wartości stałych. Pozwala to na bardziej precyzyjne parametryzowanie kodu.</p>
            <p><strong>Przykład:</strong> Szablon klasy <code>Array</code> z dwoma parametrami:</p>
            <p>
            <div>
                <pre><code class="language-clike">template &lt;typename size="" std::size_t="" t,=""&gt;
class Array {
private:
    T elements[Size];

public:
    // Metody dostępu i modyfikacji elementów
};</code></pre>
            </div>
            </p>
            <p><strong>Użycie:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">Array&lt;int, 5=""&gt; myArray;</code></pre>
            </div>
            </p>
            <h2 id="specjalizacja-szablonu">Specjalizacja Szablonu</h2>
            <p>Czasami istnieje potrzeba dostosowania zachowania szablonu dla konkretnego typu. W takich przypadkach używamy <strong>specjalizacji szablonu</strong>.</p>
            <p><strong>Przykład:</strong> Specjalizacja szablonu klasy <code>Box</code> dla typu <code>std::string</code>:</p>
            <p>
            <div>
                <pre><code class="language-clike">template &lt;&gt;
class Box&lt;std::string&gt; {
private:
    std::string content;

public:
    Box(std::string content) : content(content) {}
    std::string getContent() const { return "Zawartość: " + content; }
};</code></pre>
            </div>
            </p>
            <p><strong>Wyjaśnienie:</strong></p>
            <ul>
                <li><code>template &lt;&gt;</code>: Wskazuje pełną specjalizację szablonu.</li>
                <li><code>class Box&lt;std::string&gt;</code>: Specjalizacja szablonu <code>Box</code> dla typu <code>std::string</code>.</li>
                <li>Metoda <code>getContent()</code> została zmodyfikowana, aby zwracać prefiksowany ciąg znaków.</li>
            </ul>
            <h2 id="typy-domyślne-w-szablonach">Typy Domyślne w Szablonach</h2>
            <p>Możemy definiować wartości domyślne dla parametrów szablonu, co zwiększa elastyczność ich użycia.</p>
            <p><strong>Przykład:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">template &lt;typename size="10" std::size_t="" t="int,"&gt;
class Array {
private:
    T elements[Size];

public:
    // Implementacja metod
};</code></pre>
            </div>
            </p>
            <p><strong>Użycie:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">Array&lt;&gt; defaultArray;             // Typ T=int, Size=10
Array&lt;double, 5=""&gt; customArray;     // Typ T=double, Size=5</code></pre>
            </div>
            </p>
            <h2 id="szablony-zmiennych">Szablony Zmiennych</h2>
            <p>Od C++14 możliwe jest definiowanie szablonów zmiennych, co pozwala na tworzenie zmiennych parametryzowanych typem.</p>
            <p><strong>Przykład:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">template&lt;typename t=""&gt;
constexpr T pi = T(3.1415926535897932385);

auto floatPi = pi&lt;float&gt;;
auto doublePi = pi&lt;double&gt;;</code></pre>
            </div>
            </p>
            <p><strong>Wyjaśnienie:</strong></p>
            <ul>
                <li><code>constexpr</code> oznacza, że wartość jest stała w czasie kompilacji.</li>
                <li><code>pi&lt;T&gt;</code> jest zmienną szablonową parametryzowaną typem <code>T</code>.</li>
            </ul>
            <h2 id="aliasowanie-szablonów">Aliasowanie Szablonów</h2>
            <p>C++11 wprowadził możliwość tworzenia aliasów szablonów za pomocą słowa kluczowego <code>using</code>. Ułatwia to pracę z złożonymi typami szablonowymi.</p>
            <p><strong>Przykład:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">template &lt;typename t=""&gt;
using Vec = std::vector&lt;t&gt;;

Vec&lt;int&gt; intVector;
Vec&lt;double&gt; doubleVector;</code></pre>
            </div>
            </p>
            <h2 id="szablony-lambda">Szablony Lambda</h2>
            <p>Od C++20 można tworzyć szablony funkcji lambda, co dodatkowo zwiększa możliwości programistyczne.</p>
            <p><strong>Przykład:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">auto lambda = []&lt;typename t=""&gt;(T a, T b) {
    return a + b;
};

auto sumInt = lambda(5, 3);           // Wynik: 8
auto sumDouble = lambda(2.5, 1.5);    // Wynik: 4.0</code></pre>
            </div>
            </p>
            <h2 id="zaawansowane-techniki-z-szablonami">Zaawansowane Techniki z Szablonami</h2>
            <h3 id="szablony-o-zmiennej-liczbie-argumentów">Szablony o Zmiennej Liczbie Argumentów</h3>
            <p>C++11 wprowadził <strong>szablony o zmiennej liczbie argumentów</strong> (ang. <em>variadic templates</em>), które pozwalają na definiowanie funkcji i klas przyjmujących dowolną liczbę parametrów.</p>
            <p><strong>Przykład:</strong> Funkcja <code>print</code> wyświetlająca dowolną liczbę argumentów:</p>
            <p>
            <div>
                <pre><code class="language-clike">template&lt;typename... args=""&gt;
void print(Args... args) {
    (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; std::endl;
}

print(1, 2, 3);                 // Wyświetla: 123
print("Witaj, ", "świecie!");   // Wyświetla: Witaj, świecie!</code></pre>
            </div>
            </p>
            <p><strong>Wyjaśnienie:</strong></p>
            <ul>
                <li><code>template&lt;typename... Args&gt;</code>: Deklaruje szablon z pakietem typów <code>Args</code>.</li>
                <li><code>Args... args</code>: Pakiet argumentów funkcji.</li>
                <li><code>(std::cout &lt;&lt; ... &lt;&lt; args)</code>: Fold expression, dostępne od C++17, które składa wyrażenia binarne.</li>
            </ul>
            <h3 id="wyrażenia-constexpr-w-szablonach">Wyrażenia <code>constexpr</code> w Szablonach</h3>
            <p><code>constexpr</code> pozwala na wykonywanie obliczeń w czasie kompilacji. Gdy używamy go w szablonach, możemy tworzyć funkcje, które zwracają stałe wartości zależne od parametrów szablonu.</p>
            <p><strong>Przykład:</strong> Funkcja <code>square</code> obliczająca kwadrat liczby:</p>
            <p>
            <div>
                <pre><code class="language-clike">template&lt;typename t=""&gt;
constexpr T square(T x) {
    return x * x;
}

constexpr int squareOfFive = square(5); // Wynik: 25</code></pre>
            </div>
            </p>
            <h2 id="metaprogramowanie-szablonowe">Metaprogramowanie Szablonowe</h2>
            <p>Metaprogramowanie szablonowe to technika, która wykorzystuje szablony do wykonywania obliczeń na etapie kompilacji. Pozwala to na optymalizację kodu i wykonywanie skomplikowanych obliczeń bez narzutu w czasie wykonywania programu.</p>
            <h3 id="przykład-obliczanie-liczby-fibonacciego">Przykład: Obliczanie Liczby Fibonacciego</h3>
            <p>Obliczanie wartości ciągu Fibonacciego za pomocą szablonów:</p>
            <p>
            <div>
                <pre><code class="language-clike">template&lt;int n=""&gt;
struct Fibonacci {
    static_assert(N &gt;= 0, "N musi być nieujemne");
    static constexpr int value = Fibonacci&lt;n -="" 1=""&gt;::value + Fibonacci&lt;n -="" 2=""&gt;::value;
};

template&lt;&gt;
struct Fibonacci&lt;0&gt; {
    static constexpr int value = 0;
};

template&lt;&gt;
struct Fibonacci&lt;1&gt; {
    static constexpr int value = 1;
};

constexpr int fib10 = Fibonacci&lt;10&gt;::value; // Wynik: 55</code></pre>
            </div>
            </p>
            <p><strong>Wyjaśnienie:</strong></p>
            <ul>
                <li><strong>Rekurencja w czasie kompilacji</strong> polega na tym, że struktura <code>Fibonacci</code> jest rekurencyjnie instancjonowana dla wartości <code>N</code>, aż do osiągnięcia przypadków bazowych, takich jak <code>N=0</code> i <code>N=1</code>, co pozwala na obliczenia w trakcie kompilacji.</li>
                <li><strong><code>static_assert</code></strong> jest używany do sprawdzania warunków w czasie kompilacji, co pozwala na weryfikację poprawności kodu przed jego wykonaniem.</li>
                <li><strong><code>constexpr</code></strong> zapewnia, że dana wartość zostanie obliczona w czasie kompilacji, co zwiększa efektywność i pozwala na lepszą optymalizację kodu.</li>
            </ul>
            <h3 id="analiza-matematyczna">Analiza Matematyczna</h3>
            <p>Ciąg Fibonacciego jest zdefiniowany rekurencyjnie:</p>
            <p>$$
                F(0) = 0, \quad F(1) = 1, \quad F(N) = F(N-1) + F(N-2) \text{ dla } N \geq 2
                $$</p>
            <p>Implementacja za pomocą szablonów odwzorowuje tę definicję, pozwalając kompilatorowi na obliczenie wartości <code>F(N)</code> podczas kompilacji.</p>
            <h3 id="zastosowania-metaprogramowania-szablonowego">Zastosowania Metaprogramowania Szablonowego</h3>
            <ul>
                <li><strong>Optymalizacja</strong> polega na usunięciu narzutu czasowego poprzez przeniesienie obliczeń z etapu wykonania programu na etap kompilacji, co przyspiesza działanie aplikacji.</li>
                <li><strong>Generowanie kodów specjalizowanych</strong> umożliwia tworzenie kodu dostosowanego do konkretnych typów lub wartości, co poprawia wydajność i elastyczność aplikacji.</li>
                <li><strong>Sprawdzanie warunków w czasie kompilacji</strong> odbywa się za pomocą <code>static_assert</code>, który pozwala na weryfikację założeń programu przed jego uruchomieniem, eliminując potencjalne błędy już na etapie kompilacji.</li>
            </ul>
            <h2 id="zastosowanie-szablonów-w-praktyce">Zastosowanie Szablonów w Praktyce</h2>
            <p>Szablony są integralną częścią języka C++ i stanowią podstawę wielu bibliotek oraz aplikacji komercyjnych. Ich zdolność do tworzenia kodu generycznego, który może działać z różnymi typami danych, sprawia, że są one niezbędne w nowoczesnym programowaniu. W tej sekcji przyjrzymy się, jak szablony są wykorzystywane w praktyce, skupiając się na standardowej bibliotece C++ (STL) oraz na innych popularnych bibliotekach, takich jak Boost czy Eigen.</p>
            <h3 id="standardowa-biblioteka-szablonów-stl-">Standardowa Biblioteka Szablonów (STL)</h3>
            <p>STL (Standard Template Library) jest zestawem klas i funkcji szablonowych dostarczanych przez standardową bibliotekę C++. Zawiera ona kontenery, algorytmy oraz iteratory, które umożliwiają efektywne i elastyczne manipulowanie danymi.</p>
            <h4 id="kontenery">Kontenery</h4>
            <p>Kontenery są klasami szablonowymi, które przechowują kolekcje obiektów. Dzięki szablonom mogą one przechowywać elementy dowolnego typu. Oto niektóre z najważniejszych kontenerów w STL:</p>
            <p>
            <table>
                <tr>
                    <td>Kontener</td>
                    <td>Opis</td>
                </tr>
                <tr>
                    <td><strong><code>std::vector</code></strong></td>
                    <td>Dynamiczna tablica o zmiennym rozmiarze.</td>
                </tr>
                <tr>
                    <td><strong><code>std::list</code></strong></td>
                    <td>Lista dwukierunkowa.</td>
                </tr>
                <tr>
                    <td><strong><code>std::deque</code></strong></td>
                    <td>Dwustronna kolejka.</td>
                </tr>
                <tr>
                    <td><strong><code>std::set</code></strong></td>
                    <td>Zbiór unikalnych elementów, uporządkowanych.</td>
                </tr>
                <tr>
                    <td><strong><code>std::map</code></strong></td>
                    <td>Asocjacyjny kontener przechowujący pary klucz-wartość.</td>
                </tr>
                <tr>
                    <td><strong><code>std::unordered_set</code></strong></td>
                    <td>Nieuporządkowany zbiór wykorzystujący tablice haszujące.</td>
                </tr>
                <tr>
                    <td><strong><code>std::unordered_map</code></strong></td>
                    <td>Nieuporządkowana mapa wykorzystująca tablice haszujące do par klucz-wartość.</td>
                </tr>
            </table>
            </p>
            <h4 id="algorytmy">Algorytmy</h4>
            <p>Algorytmy w STL są funkcjami szablonowymi, które wykonują operacje na danych przechowywanych w kontenerach. Są one niezależne od konkretnych typów danych i kontenerów, o ile dostarczone są odpowiednie iteratory.</p>
            <p>
            <table>
                <tr>
                    <td>Funkcja</td>
                    <td>Opis</td>
                </tr>
                <tr>
                    <td><strong><code>std::sort</code></strong></td>
                    <td>Sortowanie elementów w zakresie.</td>
                </tr>
                <tr>
                    <td><strong><code>std::find</code></strong></td>
                    <td>Wyszukiwanie elementu w zakresie.</td>
                </tr>
                <tr>
                    <td><strong><code>std::accumulate</code></strong></td>
                    <td>Sumowanie wartości w zakresie.</td>
                </tr>
                <tr>
                    <td><strong><code>std::copy</code></strong></td>
                    <td>Kopiowanie elementów z jednego zakresu do drugiego.</td>
                </tr>
            </table>
            </p>
            <h4 id="iteratory">Iteratory</h4>
            <p>Iteratory są abstrakcją wskaźników, które pozwalają na jednolite interfejsy do przeglądania elementów w kontenerach. Są one zaimplementowane jako szablony, dzięki czemu mogą działać z różnymi typami kontenerów.</p>
            <h3 id="przykład-kontener-std-vector">Przykład: Kontener <code>std::vector</code></h3>
            <p><code>std::vector</code> jest jednym z najczęściej używanych kontenerów w STL. Reprezentuje dynamiczną tablicę, która może zmieniać swój rozmiar w czasie wykonywania programu. Dzięki wykorzystaniu szablonów, <code>std::vector</code> może przechowywać elementy dowolnego typu.</p>
            <p><strong>Definicja szablonu <code>std::vector</code>:</strong></p>
            <p>W uproszczeniu, <code>std::vector</code> jest zdefiniowany następująco:</p>
            <p>
            <div>
                <pre><code class="language-clike">template &lt;typename allocator="std::allocator&lt;T" t,="" typename=""&gt;&gt;
class vector {
    // Implementacja wewnętrzna
};</code></pre>
            </div>
            </p>
            <p><strong>Parametry szablonu:</strong></p>
            <ul>
                <li><strong><code>typename T</code></strong> określa typ przechowywanych elementów, co pozwala na tworzenie szablonów, które mogą działać z różnymi typami danych.</li>
                <li><strong><code>typename Allocator</code></strong> definiuje typ alokatora używanego do zarządzania pamięcią, z domyślną wartością <code>std::allocator&lt;T&gt;</code>, co umożliwia elastyczne zarządzanie pamięcią dla elementów.</li>
            </ul>
            <p><strong>Przykłady użycia:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">std::vector&lt;int&gt; vecInt;            // Wektor liczb całkowitych
std::vector&lt;double&gt; vecDouble;      // Wektor liczb zmiennoprzecinkowych
std::vector&lt;std::string&gt; vecString; // Wektor łańcuchów znaków</code></pre>
            </div>
            </p>
            <p><strong>Operacje na <code>std::vector</code>:</strong></p>
            <p>I. <strong>Dodawanie elementów:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">vecInt.push_back(10);
vecInt.push_back(20);
vecInt.push_back(30);</code></pre>
            </div>
            </p>
            <p>II. <strong>Dostęp do elementów:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">int firstElement = vecInt[0];          // Dostęp za pomocą operatora []
int secondElement = vecInt.at(1);      // Dostęp z kontrolą zakresu</code></pre>
            </div>
            </p>
            <p>III. <strong>Iterowanie po elementach:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">for (size_t i = 0; i &lt; vecInt.size(); ++i) {
  std::cout &lt;&lt; vecInt[i] &lt;&lt; " ";
}

for (auto it = vecInt.begin(); it != vecInt.end(); ++it) {
  std::cout &lt;&lt; *it &lt;&lt; " ";
}

for (const auto&amp; value : vecInt) {
  std::cout &lt;&lt; value &lt;&lt; " ";
}</code></pre>
            </div>
            </p>
            <p>IV. <strong>Modyfikacja elementów:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">vecInt[0] = 100;</code></pre>
            </div>
            </p>
            <p><strong>Implementacja generyczna:</strong></p>
            <p>Dzięki temu, że <code>std::vector</code> jest szablonem, możemy używać go z dowolnym typem, który jest kopiowalny lub przenośny. Oznacza to, że możemy przechowywać zarówno typy podstawowe, jak i złożone obiekty użytkownika.</p>
            <p><strong>Przykład z typem użytkownika:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">class Point {
public:
    int x, y;
    Point(int x, int y) : x(x), y(y) {}
};

std::vector&lt;point&gt; points;
points.emplace_back(1, 2);
points.emplace_back(3, 4);</code></pre>
            </div>
            </p>
            <p><strong>Analiza matematyczna wydajności:</strong></p>
            <p>Operacje na <code>std::vector</code> mają określone złożoności czasowe:</p>
            <p>
            <table>
                <tr>
                    <td>Operacja</td>
                    <td>Złożoność</td>
                    <td>Wyjaśnienie</td>
                </tr>
                <tr>
                    <td><strong>Dostęp do elementów</strong></td>
                    <td>$O(1)$</td>
                    <td>Dzięki ciągłemu układowi pamięci, dostęp do dowolnego elementu jest bezpośredni.</td>
                </tr>
                <tr>
                    <td><strong>Dodawanie elementu na końcu</strong></td>
                    <td>Amortyzowane $O(1)$</td>
                    <td>Dodanie elementu jest szybkie, chyba że konieczna jest realokacja pamięci.</td>
                </tr>
                <tr>
                    <td><strong>Wstawianie/usuwanie elementów w środku</strong></td>
                    <td>$O(n)$</td>
                    <td>Wymaga przesunięcia pozostałych elementów, co zwiększa czas operacji.</td>
                </tr>
            </table>
            </p>
            <p><strong>Zarządzanie pamięcią:</strong></p>
            <p><code>std::vector</code> zarządza pamięcią dynamicznie. Gdy wektor osiąga swoją maksymalną pojemność, automatycznie alokuje większy blok pamięci i kopiuje istniejące elementy. Domyślnie pojemność jest podwajana, co zapewnia amortyzowaną złożoność O(1) dla operacji dodawania na końcu.</p>
            <h3 id="przykład-algorytm-std-sort">Przykład: Algorytm <code>std::sort</code></h3>
            <p>Algorytm <code>std::sort</code> jest funkcją szablonową, która sortuje elementy w zakresie określonym przez dwa iteratory.</p>
            <p><strong>Definicja:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">template &lt;class randomit=""&gt;
void sort(RandomIt first, RandomIt last);</code></pre>
            </div>
            </p>
            <p><strong>Wymagania:</strong></p>
            <ul>
                <li>Typ elementów musi być porównywalny za pomocą operatora <code>&lt;</code>.</li>
                <li>Iteratory muszą być iteratorami losowego dostępu (np. z <code>std::vector</code> lub tablicy).</li>
            </ul>
            <p><strong>Przykład użycia:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">std::vector&lt;int&gt; data = {5, 2, 9, 1, 5, 6};
std::sort(data.begin(), data.end());</code></pre>
            </div>
            </p>
            <p><strong>Dostosowywanie kryterium sortowania:</strong></p>
            <p>Możemy dostarczyć własną funkcję porównującą:</p>
            <p>
            <div>
                <pre><code class="language-clike">std::sort(data.begin(), data.end(), [](int a, int b) {
    return a &gt; b; // Sortowanie malejące
});</code></pre>
            </div>
            </p>
            <p><strong>Złożoność czasowa:</strong></p>
            <ul>
                <li>Średnia: $O(nlogn)$</li>
                <li>Najgorszy przypadek: $O(nlogn)$ - w implementacji wykorzystującej zabezpieczenia przed złym rozkładem danych.</li>
            </ul>
            <h3 id="przykład-kontener-std-map">Przykład: Kontener <code>std::map</code></h3>
            <p><code>std::map</code> jest kontenerem asocjacyjnym, który przechowuje pary klucz-wartość w uporządkowany sposób.</p>
            <p><strong>Definicja:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">template &lt;
    class Key,
    class T,
    class Compare = std::less&lt;key&gt;,
    class Allocator = std::allocator&lt;std::pair&lt;const key,="" t=""&gt;&gt;
&gt;
class map {
    // Implementacja wewnętrzna
};</code></pre>
            </div>
            </p>
            <p><strong>Parametry szablonu:</strong></p>
            <p>
            <table>
                <tr>
                    <td>Parametr</td>
                    <td>Opis</td>
                    <td>Wyjaśnienie</td>
                </tr>
                <tr>
                    <td><code>class Key</code></td>
                    <td>Typ klucza</td>
                    <td>Określa typ danych, który będzie używany jako klucz w kontenerze.</td>
                </tr>
                <tr>
                    <td><code>class T</code></td>
                    <td>Typ wartości</td>
                    <td>Reprezentuje typ danych przechowywanych jako wartości w kontenerze.</td>
                </tr>
                <tr>
                    <td><code>class Compare</code></td>
                    <td>Funkcja porównująca</td>
                    <td>Funktor lub funkcja, która decyduje o sposobie porównywania kluczy.</td>
                </tr>
                <tr>
                    <td><code>class Allocator</code></td>
                    <td>Alokator pamięci</td>
                    <td>Definiuje sposób alokacji i zarządzania pamięcią dla elementów kontenera.</td>
                </tr>
            </table>
            </p>
            <p><strong>Przykład użycia:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">std::map&lt;std::string, int=""&gt; wordCounts;
wordCounts["apple"] = 3;
wordCounts["banana"] = 5;
wordCounts["orange"] = 2;</code></pre>
            </div>
            </p>
            <p><strong>Operacje:</strong></p>
            <p>I. <strong>Wstawianie elementów:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">wordCounts.insert({"grape", 4});</code></pre>
            </div>
            </p>
            <p>II. <strong>Dostęp do wartości:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">int count = wordCounts["banana"]; // count == 5</code></pre>
            </div>
            </p>
            <p>III. <strong>Iterowanie:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">for (const auto&amp; pair : wordCounts) {
  std::cout &lt;&lt; pair.first &lt;&lt; ": " &lt;&lt; pair.second &lt;&lt; "\n";
}</code></pre>
            </div>
            </p>
            <p><strong>Właściwości:</strong></p>
            <ul>
                <li>Elementy są przechowywane w uporządkowany sposób według klucza.</li>
                <li>Wyszukiwanie, wstawianie i usuwanie mają złożoność O(log n) dzięki wewnętrznej implementacji drzewa czerwono-czarnego.</li>
            </ul>
            <h3 id="biblioteka-boost">Biblioteka Boost</h3>
            <p>Boost to zestaw bibliotek C++ rozszerzających funkcjonalność standardowej biblioteki. Wiele z nich jest proponowanych do włączenia do standardu C++. Szablony są intensywnie wykorzystywane w celu zapewnienia elastyczności i wydajności.</p>
            <p><strong>Przykład: <code>boost::shared_ptr</code></strong></p>
            <p>Przed wprowadzeniem <code>std::shared_ptr</code> w C++11, <code>boost::shared_ptr</code> był szeroko stosowanym inteligentnym wskaźnikiem zarządzającym życiem obiektu.</p>
            <p><strong>Definicja:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">template&lt;typename t=""&gt;
class shared_ptr {
    // Implementacja wewnętrzna
};</code></pre>
            </div>
            </p>
            <p><strong>Użycie:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">boost::shared_ptr&lt;myclass&gt; ptr(new MyClass());</code></pre>
            </div>
            </p>
            <p><strong>Zalety:</strong></p>
            <ul>
                <li>Automatyczne zarządzanie pamięcią poprzez licznik referencji.</li>
                <li>Bezpieczeństwo w środowiskach wielowątkowych (z odpowiednią synchronizacją).</li>
            </ul>
            <h3 id="biblioteka-eigen">Biblioteka Eigen</h3>
            <p>Eigen to szablonowa biblioteka C++ do algebry liniowej, zoptymalizowana pod kątem wysokiej wydajności.</p>
            <p><strong>Definicja szablonu macierzy:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">template&lt;typename colsatcompiletime="" int="" rowsatcompiletime,="" scalar,=""&gt;
class Matrix {
    // Implementacja wewnętrzna
};</code></pre>
            </div>
            </p>
            <p><strong>Przykład użycia:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">Eigen::Matrix&lt;float, 3="" 3,=""&gt; matA;
Eigen::Matrix&lt;float, 1="" 3,=""&gt; vecB;

matA &lt;&lt; 1, 2, 3,
         4, 5, 6,
         7, 8, 9;

vecB &lt;&lt; 1,
         2,
         3;

Eigen::Matrix&lt;float, 1="" 3,=""&gt; result = matA * vecB;</code></pre>
            </div>
            </p>
            <p><strong>Właściwości:</strong></p>
            <ul>
                <li><strong>Statyczne rozmiary</strong> macierzy, gdy są znane w czasie kompilacji, pozwalają bibliotece Eigen na generowanie wysoce wydajnego kodu, co zwiększa efektywność obliczeń.</li>
                <li><strong>Szablony wyrażeniowe</strong> (<em>Expression Templates</em>) umożliwiają optymalizację obliczeń, minimalizując tworzenie niepotrzebnych kopii danych, co poprawia wydajność działania programu.</li>
            </ul>
            <p><strong>Analiza wydajności:</strong></p>
            <ul>
                <li><strong>Unikanie alokacji pamięci</strong> jest możliwe dzięki zastosowaniu szablonów i mechanizmu inlining, co pozwala bibliotece Eigen na wykonywanie operacji bez potrzeby dodatkowych alokacji pamięci, co zwiększa wydajność.</li>
                <li><strong>Wektorowe instrukcje procesora</strong> są automatycznie wykorzystywane przez Eigen, dzięki wsparciu dla instrukcji SIMD (Single Instruction, Multiple Data), jeśli są one dostępne na danej platformie, co przyspiesza operacje matematyczne.</li>
            </ul>
            <h3 id="wpływ-szablonów-na-projektowanie-bibliotek">Wpływ Szablonów na Projektowanie Bibliotek</h3>
            <p>Szablony umożliwiają tworzenie bibliotek, które są zarówno elastyczne, jak i wydajne. Oto kilka kluczowych aspektów:</p>
            <ul>
                <li><strong>Polimorfizm statyczny</strong> w szablonach odbywa się w czasie kompilacji, w przeciwieństwie do polimorfizmu dynamicznego (realizowanego przez klasy bazowe i wskaźniki), co eliminuje narzut związany z wykonywaniem w czasie działania programu.</li>
                <li><strong>Silne typowanie</strong> sprawia, że błędy typów są wykrywane w czasie kompilacji, co zwiększa bezpieczeństwo kodu i minimalizuje ryzyko błędów w czasie działania.</li>
                <li><strong>Optymalizacje kompilatora</strong> są możliwe dzięki generowaniu specjalizowanego kodu dla konkretnych typów, co umożliwia kompilatorowi stosowanie agresywnych optymalizacji w celu poprawy wydajności.</li>
            </ul>
            <h3 id="koncepty-c-20-">Koncepty (C++20)</h3>
            <p>Koncepty wprowadzają możliwość definiowania wymagań dla parametrów szablonu, co ułatwia tworzenie bardziej czytelnego i bezpiecznego kodu.</p>
            <p><strong>Przykład:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">template&lt;typename t=""&gt;
concept Number = std::is_arithmetic_v&lt;t&gt;;

template&lt;number t=""&gt;
T multiply(T a, T b) {
    return a * b;
}</code></pre>
            </div>
            </p>
            <p><strong>Zalety:</strong></p>
            <ul>
                <li><strong>Poprawa czytelności błędów kompilacji</strong> wynika z zastosowania konceptów, które umożliwiają kompilatorowi dostarczenie bardziej precyzyjnych i zrozumiałych komunikatów o błędach, co ułatwia debugowanie.</li>
                <li><strong>Dokumentacja wymagań</strong> jest naturalnym efektem użycia konceptów, ponieważ jasno określają one, jakie wymagania musi spełniać typ parametrów szablonu, co poprawia zrozumiałość i użyteczność kodu.</li>
            </ul>
            <h3 id="zaawansowane-techniki-z-użyciem-szablonów">Zaawansowane Techniki z Użyciem Szablonów</h3>
            <h4 id="metaprogramowanie-szablonowe">Metaprogramowanie Szablonowe</h4>
            <p>Metaprogramowanie szablonowe pozwala na wykonywanie obliczeń w czasie kompilacji.</p>
            <p><strong>Przykład: Generowanie listy typów</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">template&lt;typename... types=""&gt;
struct TypeList {};

using MyTypes = TypeList&lt;int, double,="" std::string=""&gt;;</code></pre>
            </div>
            </p>
            <h4 id="szablony-wewnętrzne-curiously-recurring-template-pattern-crtp-">Szablony Wewnętrzne (Curiously Recurring Template Pattern - CRTP)</h4>
            <p>CRTP to idiom programistyczny, w którym klasa dziedziczy po szablonie swojej własnej klasy.</p>
            <p><strong>Przykład:</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">template&lt;typename derived=""&gt;
class Base {
public:
    void interface() {
        static_cast&lt;derived*&gt;(this)-&gt;implementation();
    }
};

class DerivedClass : public Base&lt;derivedclass&gt; {
public:
    void implementation() {
        // Implementacja specyficzna dla klasy pochodnej
    }
};</code></pre>
            </div>
            </p>
            <p><strong>Zastosowania:</strong></p>
            <ul>
                <li><strong>Statyczny polimorfizm</strong> pozwala na osiągnięcie polimorfizmu w czasie kompilacji, eliminując narzut związany z dynamicznym wiązaniem, co zwiększa wydajność.</li>
                <li><strong>Klasy mixin</strong> umożliwiają wstrzykiwanie dodatkowej funkcjonalności do klasy pochodnej, co ułatwia tworzenie modularnych i wielokrotnego użytku komponentów.</li>
            </ul>
            <h3 id="ograniczenia-i-wyzwania">Ograniczenia i Wyzwania</h3>
            <ul>
                <li>Błędy w kodzie szablonowym mogą generować długie i trudne do zrozumienia komunikaty.</li>
                <li>Intensywne użycie szablonów może znacząco wydłużyć czas kompilacji.</li>
                <li>Szablony mogą wprowadzać zależności, które nie są oczywiste na pierwszy rzut oka.</li>
            </ul>
            <h3 id="praktyczne-wskazówki">Praktyczne Wskazówki</h3>
            <ul>
                <li>W miarę możliwości korzystaj z konceptów, aby jasno określić wymagania dla parametrów szablonu.</li>
                <li>Wyjaśniaj założenia i oczekiwania wobec typów parametrów.</li>
                <li>Staraj się nie komplikować kodu szablonowego bardziej niż to konieczne.</li>
            </ul>
        </section>
        <div id="table-of-contents">
            <h2>Spis Treści</h2>
            <ol>
                <li><a href="#wprowadzenie-do-szablonów">Wprowadzenie do Szablonów</a>
                    <ol>
                        <li><a href="#szablony-funkcji">Szablony Funkcji</a></li>
                        <li><a href="#mechanizm-instancjacji">Mechanizm Instancjacji</a></li>
                    </ol>
                </li>
                <li><a href="#szablony-klas">Szablony Klas</a></li>
                <li><a href="#wielokrotne-parametry-szablonu">Wielokrotne Parametry Szablonu</a></li>
                <li><a href="#specjalizacja-szablonu">Specjalizacja Szablonu</a></li>
                <li><a href="#typy-domyślne-w-szablonach">Typy Domyślne w Szablonach</a></li>
                <li><a href="#szablony-zmiennych">Szablony Zmiennych</a></li>
                <li><a href="#aliasowanie-szablonów">Aliasowanie Szablonów</a></li>
                <li><a href="#szablony-lambda">Szablony Lambda</a></li>
                <li><a href="#zaawansowane-techniki-z-szablonami">Zaawansowane Techniki z Szablonami</a>
                    <ol>
                        <li><a href="#szablony-o-zmiennej-liczbie-argumentów">Szablony o Zmiennej Liczbie Argumentów</a></li>
                        <li><a href="#wyrażenia-constexpr-w-szablonach">Wyrażenia constexpr w Szablonach</a></li>
                    </ol>
                </li>
                <li><a href="#metaprogramowanie-szablonowe">Metaprogramowanie Szablonowe</a>
                    <ol>
                        <li><a href="#przykład-obliczanie-liczby-fibonacciego">Przykład: Obliczanie Liczby Fibonacciego</a></li>
                        <li><a href="#analiza-matematyczna">Analiza Matematyczna</a></li>
                        <li><a href="#zastosowania-metaprogramowania-szablonowego">Zastosowania Metaprogramowania Szablonowego</a></li>
                    </ol>
                </li>
                <li><a href="#zastosowanie-szablonów-w-praktyce">Zastosowanie Szablonów w Praktyce</a>
                    <ol>
                        <li><a href="#standardowa-biblioteka-szablonów-stl-">Standardowa Biblioteka Szablonów (STL)</a>
                            <ol>
                                <li><a href="#kontenery">Kontenery</a></li>
                                <li><a href="#algorytmy">Algorytmy</a></li>
                                <li><a href="#iteratory">Iteratory</a></li>
                            </ol>
                        </li>
                        <li><a href="#przykład-kontener-std-vector">Przykład: Kontener std::vector</a></li>
                        <li><a href="#przykład-algorytm-std-sort">Przykład: Algorytm std::sort</a></li>
                        <li><a href="#przykład-kontener-std-map">Przykład: Kontener std::map</a></li>
                        <li><a href="#biblioteka-boost">Biblioteka Boost</a></li>
                        <li><a href="#biblioteka-eigen">Biblioteka Eigen</a></li>
                        <li><a href="#wpływ-szablonów-na-projektowanie-bibliotek">Wpływ Szablonów na Projektowanie Bibliotek</a></li>
                        <li><a href="#koncepty-c-20-">Koncepty (C++20)</a></li>
                        <li><a href="#zaawansowane-techniki-z-użyciem-szablonów">Zaawansowane Techniki z Użyciem Szablonów</a>
                            <ol>
                                <li><a href="#metaprogramowanie-szablonowe">Metaprogramowanie Szablonowe</a></li>
                                <li><a href="#szablony-wewnętrzne-curiously-recurring-template-pattern-crtp-">Szablony Wewnętrzne (Curiously Recurring Template Pattern - CRTP)</a></li>
                            </ol>
                        </li>
                        <li><a href="#ograniczenia-i-wyzwania">Ograniczenia i Wyzwania</a></li>
                        <li><a href="#praktyczne-wskazówki">Praktyczne Wskazówki</a></li>
                    </ol>
                </li>
            </ol>
            <div id="related-articles">
                <h2>Related Articles</h2>
                <ol>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/01_proces_kompilacji.html">Proces Kompilacji</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/02_preprocesor.html">Preprocesor</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/03_zmienne_i_typy_danych.html">Zmienne i Typy Danych</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/04_interakcja_z_konsola.html">Interakcja z Konsola</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/05_instrukcja_warunkowa.html">Instrukcja Warunkowa</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/06_petle.html">Petle</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/07_liczby_losowe.html">Liczby Losowe</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/08_typ_wyliczeniowy.html">Typ Wyliczeniowy</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/09_funkcje.html">Funkcje</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/10_l_wartosci_r_wartosci.html">L Wartosci R Wartosci</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/11_wskazniki.html">Wskazniki</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/12_tablice.html">Tablice</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/13_napisy.html">Napisy</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/14_operacje_bitowe.html">Operacje Bitowe</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/15_programowanie_obietkowe.html">Programowanie Obietkowe</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/16_dziedziczenie.html">Dziedziczenie</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/17_zaawansowane_wskazniki.html">Zaawansowane Wskazniki</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/18_przeciazanie.html">Przeciazanie</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/19_konwersje.html">Konwersje</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/20_lambdy.html">Lambdy</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/21_szablony.html">Szablony</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/22_wyjatki.html">Wyjatki</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/23_stl.html">Stl</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/24_praca_z_plikami.html">Praca z Plikami</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/25_c_vs_cpp.html">C vs Cpp</a></li>
                </ol>
            </div>
        </div>
    </div>
    <footer>
        <div class="footer-columns">
            <div class="footer-column">
                <img alt="Adam Djellouli Symbol" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/symbol.png" />
            </div>
            <div class="footer-column">
                <h2><a href="https://adamdjellouli.com/core/privacy_policy.html" title="Privacy Policy">Our Privacy Policy</a></h2>
                <p>
                    Thank you for visiting my personal website. All of the <br />
                    content on this site is free to use, but please remember <br />
                    to be a good human being and refrain from any abuse<br />
                    of the site. If you would like to contact me, please use <br />
                    my <a href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" title="LinkedIn Profile">LinkedIn profile</a> or my <a href="https://github.com/djeada" title="GitHub Profile">GitHub</a> if you have any technical <br />
                    issues or ideas to share. I wish you the best and hope you <br />
                    have a fantastic life. <br />
                </p>
            </div>
            <div class="footer-column">
                <h2>Follow me</h2>
                <ul class="social-media">
                    <li>
                        <a class="fa fa-youtube" href="https://www.youtube.com/channel/UCGPoHTVjMN77wcGknXPHl1Q" target="_blank" title="YouTube">
                        </a>YouTube
                    </li>
                    <li>
                        <a class="fa fa-linkedin" href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" target="_blank" title="LinkedIn">
                        </a>LinkedIn
                    </li>
                    <li>
                        <a class="fa fa-instagram" href="https://www.instagram.com/linuxchallenges/" target="_blank" title="Instagram">
                        </a>Instagram
                    </li>
                    <li>
                        <a class="fa fa-github" href="https://github.com/djeada" title="GitHub">
                        </a>Github
                    </li>
                </ul>
            </div>
        </div>
        <div>
            <p id="copyright">
                © Adam Djellouli. All rights reserved.
            </p>
        </div>
        <script>
            document.getElementById("copyright").innerHTML = "&copy; " + new Date().getFullYear() + " Adam Djellouli. All rights reserved.";
        </script>
        <script src="../../app.js"></script>
    </footer>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-bash.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-cpp.min.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
jax: ["input/TeX", "output/HTML-CSS"],
extensions: ["tex2jax.js"],
"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] },
tex2jax: { inlineMath: [ ["$", "$"] ], displayMath: [ ["$$","$$"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
TeX: { noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } } },
messageStyle: "none"
});
</script>
<script async="" id="MathJax-script" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>

</html>