<!DOCTYPE html>

<html lang="pl">

<head>
    <script async="" crossorigin="anonymous" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5593122079896089"></script>
    <meta charset="utf-8" />
    <title>Liczby losowe i generatory liczb losowych</title>
    <meta content="W języku C++ liczby losowe generuje się za pomocą standardowej biblioteki ." name="description" />
    <meta content="Adam Djellouli" name="author" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <meta content="IE=edge" http-equiv="X-UA-Compatible" />
    <link crossorigin="" href="https://fonts.googleapis.com" rel="preconnect" />
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/icon.ico" rel="icon" />
    <link href="../../resources/style.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
</head>

<body>
    <nav aria-label="Main navigation">
        <a class="logo" href="https://adamdjellouli.com">
            <img alt="Adam Djellouli - Home Page Logo" id="logo-image" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/logo.PNG" />
        </a>
        <input aria-label="Toggle navigation menu" id="navbar-toggle" type="checkbox" />
        <ul aria-labelledby="navbar-toggle" role="menu">
            <li role="menuitem">
                <a href="../../index.html" title="Go to Home Page"> Home </a>
            </li>
            <li role="menuitem">
                <a class="active" href="../../core/blog.html" title="Read Adam Djellouli Blog on Programming and Technology"> Blog </a>
            </li>
            <li role="menuitem">
                <a href="../../core/tools.html" title="Discover Tools Created by Adam Djellouli"> Tools </a>
            </li>
            <li role="menuitem">
                <a href="../../core/projects.html" title="Explore Projects Developed by Adam Djellouli"> Projects </a>
            </li>
            <li role="menuitem">
                <a href="../../core/resume.html" title="View Adam Djellouli Professional Resume"> Resume </a>
            </li>
            <li>
                <script async="" src="https://cse.google.com/cse.js?cx=8160ef9bb935f4f68"></script>
                <div class="gcse-search"></div>
            </li>
            <li>
                <button aria-label="Toggle dark mode" id="dark-mode-button"></button>
            </li>
        </ul>
    </nav>
    <div id="article-wrapper">
        <section id="article-body">
            <div class="article-action-buttons"><button class="btn-suggest-edit" title="Suggest Edit">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <path d="M4 21h4l11-11-4-4L4 17v4z" stroke="currentColor" stroke-width="2"></path>
                    </svg>
                </button><button class="btn-create-issue" title="Create Issue">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2"></circle>
                        <line stroke="currentColor" stroke-width="2" x1="12" x2="12" y1="8" y2="12"></line>
                        <circle cx="12" cy="16" fill="currentColor" r="1"></circle>
                    </svg>
                </button><button class="btn-download" title="Download">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <path d="M12 5v14m0 0l-6-6m6 6l6-6" stroke="currentColor" stroke-width="2"></path>
                    </svg>
                </button></div>
            <p style="text-align: right;"><i>Last modified: May 24, 2025</i></p>
            <p style="text-align: right;"><i>This article is written in: 🇵🇱</i></p>
            <h2 id="liczby-losowe-i-generatory-liczb-losowych">Liczby losowe i generatory liczb losowych</h2>
            <p>W języku C++ liczby losowe generuje się za pomocą standardowej biblioteki <code>&lt;random&gt;</code>. Proces losowania zaczyna się od utworzenia generatora liczb pseudolosowych, np. <code>std::mt19937</code>, który bazuje na algorytmie Mersenne Twister. Aby uzyskać bardziej losowe wyniki, generator inicjalizuje się za pomocą unikalnej wartości, zwaną "ziarnem" (ang. <em>seed</em>), co można zrobić np. poprzez <code>std::random_device</code>. Następnie używa się odpowiednich dystrybucji, takich jak <code>std::uniform_int_distribution</code> (dla liczb całkowitych z równomiernym rozkładem) lub <code>std::uniform_real_distribution</code> (dla liczb zmiennoprzecinkowych), aby wygenerować liczby z określonego zakresu. Dzięki tej bibliotece losowanie w C++ jest bardziej elastyczne i daje kontrolę nad różnymi aspektami generowania liczb losowych, w tym nad zakresem i typem wartości.</p>
            <p>
            <div>
                <pre><code class="language-shell">┌──────────────────────────────────────────┐
│          Generator liczb losowych        │
│  (std::random_device, std::mt19937 itp.) │
└──────────────────────────────────────────┘
                │           ▲
                │ surowe    │ ziarno
                │ bity      │ (opcjonalnie)
                ▼           │
╔═════════════════════════════════════════╗
║   Sekwencja losowych bitów / liczb      ║
╚═════════════════════════════════════════╝
                │
                │ źródło entropii
                ▼
┌─────────────────────────────────────────┐
│             Dystrybucja                 │
│ (std::uniform_int_distribution,         │
│  std::normal_distribution itp.)         │
└─────────────────────────────────────────┘
                │
                │ przekształcenie na
                │ określony rozkład
                ▼
╔═══════════════════════════════════════════════╗
║   Gotowe liczby losowe w zadanym rozkładzie   ║
╚═══════════════════════════════════════════════╝</code></pre>
            </div>
            </p>
            <h3 id="liczby-losowe">Liczby losowe</h3>
            <p>Teraz zapoznamy się z matematycznymi podstawami pojęcia liczby losowej, definiując zmienne losowe oraz ich rozkłady.</p>
            <p>W klasycznej teorii prawdopodobieństwa liczbę losową modeluje <strong>zmienna losowa</strong></p>
            <p>$$
                X:(\Omega,\mathcal F,\mathbb P)\longrightarrow (\mathbb R,\mathcal B)
                $$</p>
            <p>gdzie $(\Omega,\mathcal F,\mathbb P)$ to przestrzeń probabilistyczna, a $\mathcal B$ – σ–algebra borelowska.</p>
            <p>Dla każdego przedziału $A\subseteq\mathbb R$ prawdopodobieństwo $\mathbb P!\bigl(X\in A\bigr)$ jest ustalone przez rozkład $F_X(x)=\mathbb P(X\le x)$.</p>
            <h4 id="własności-oczekiwane">Własności oczekiwane</h4>
            <p>W tej części opisujemy podstawowe miary statystyczne zmiennej losowej, takie jak wartość oczekiwana i wariancja.</p>
            <p>Jeśli $X$ ma gęstość $f_X$, to</p>
            <p>$$
                E[X]=\int_{-\infty}^{\infty}xf_X(x)dx
                $$</p>
            <p>$$
                Var[X]=\int_{-\infty}^{\infty}(x- E[X])^{2}f_X(x)dx
                $$</p>
            <p>Prawo wielkich liczb (LLN) gwarantuje zbieżność średniej $\bar X_n$ do $E[X]$ przy $n\to\infty$, a centralne tw. graniczne (CLT) – normalne odchylenie $O(n^{-1/2})$.</p>
            <h4 id="prawdziwa-losowość-vs-pseudolosowość">Prawdziwa losowość vs. pseudolosowość</h4>
            <p>Teraz omówimy różnice pomiędzy rzeczywistymi źródłami losowości a deterministycznymi generatorami pseudolosowymi.</p>
            <p>Źródła entropii</p>
            <ul>
                <li><strong>Prawdziwe RNG (TRNG).</strong> Oparte na zjawiskach fizycznych: szum termiczny, promieniotwórczość, odchylenia czasu taktowania CPU.</li>
                <li><strong>Generator pseudolosowy (PRNG).</strong> Deterministyczny algorytm</li>
            </ul>
            <p>$$
                s_{k+1}=F(s_k)\pmod m,\qquad X_k=g(s_k)
                $$</p>
            <p>który przy zadanym ziarnie $s_0$ tworzy powtarzalną sekwencję. Parametry:</p>
            <ul>
                <li><strong>Okres</strong> $p$ – najmniejsze $k&gt;0$ z $s_{n+k}=s_n$.</li>
                <li><strong>Wymiar równomierności</strong> – równomierne pokrycie hipersześcianu $[0,1)^d$.</li>
                <li><strong>Test next-bit</strong> (dla RNG kryptograficznych) – nieprzewidywalność kolejnego bitu z prawdopodobieństwem istotnie $&gt;\tfrac12$.</li>
            </ul>
            <p>Statystyczne testy jakości</p>
            <p>Poniższa tabela przedstawia główne klasy testów statystycznych używanych do oceny generatorów pseudolosowych:</p>
            <p>
            <table>
                <tr>
                    <td>Klasa testu</td>
                    <td>Weryfikowana własność</td>
                    <td>Metryka</td>
                </tr>
                <tr>
                    <td><strong>Chi-kwadrat</strong></td>
                    <td>jednorodność histogramu</td>
                    <td>$\chi^2=\sum \frac{(O_i-E_i)^2}{E_i}$</td>
                </tr>
                <tr>
                    <td><strong>Serial/correlation</strong></td>
                    <td>niezależność kolejnych wartości</td>
                    <td>współczynnik $r=\frac{Cov(X_i,X_{i+k})}{\sigma^2}$</td>
                </tr>
                <tr>
                    <td><strong>K–S (Kolmogorov–Smirnov)</strong></td>
                    <td>zgodność z dystrybuantą $F$</td>
                    <td>statystyka sup-normy $D_n$</td>
                </tr>
                <tr>
                    <td><strong>DieHard / TestU01</strong></td>
                    <td>złożone właściwości</td>
                    <td>zbiór 20–100 testów</td>
                </tr>
            </table>
            </p>
            <p>Sekwencja testów nie dowodzi losowości, lecz obala ją, gdy statystyki wyjdą poza akceptowalny przedział ufności.</p>
            <h3 id="generowanie-liczb-losowych">Generowanie liczb losowych</h3>
            <p>Teraz przedstawimy dostępne w C++ generatory liczb losowych oraz ich główne właściwości i zastosowania.</p>
            <p>Przegląd generatorów</p>
            <p>
            <table>
                <tr>
                    <td>Generator</td>
                    <td>Algorytm</td>
                    <td>Okres</td>
                    <td>Zastosowania</td>
                </tr>
                <tr>
                    <td><code>std::mt19937</code></td>
                    <td>Mersenne Twister (19937-bit)</td>
                    <td>$2^{19937}-1$</td>
                    <td>ogólne symulacje</td>
                </tr>
                <tr>
                    <td><code>std::ranlux24_base</code></td>
                    <td>Tausworthe + przekładanie</td>
                    <td>$ \approx 10^{171}$</td>
                    <td>obliczeniowa fizyka jądrowa</td>
                </tr>
                <tr>
                    <td><code>std::knuth_b</code></td>
                    <td>LCG + shuffling</td>
                    <td>$2^{64}$</td>
                    <td>proste gry, testy</td>
                </tr>
                <tr>
                    <td><code>std::random_device</code></td>
                    <td>TRNG – entropia OS</td>
                    <td>n/d</td>
                    <td>seeding, kryptografia</td>
                </tr>
            </table>
            </p>
            <p><strong>Mersenne Twister.</strong> Rekurencja:</p>
            <p>$$
                x_{k+n}=x_{k+m}\oplus\bigl((x_k^{\text{upper}}\|\;x_{k+1}^{\text{lower}})\cdot A\bigr),
                $$</p>
            <p>gdzie $n=624,m=397$. Duży okres i 623-wymiarowa równomierność zapewniają dobry rozkład w praktyce nie-krypto.</p>
            <h4 id="dystrybucje">Dystrybucje</h4>
            <p>W tej części omówione zostaną najważniejsze dystrybucje dostępne w bibliotece <code>&lt;random&gt;</code> oraz ich własności.</p>
            <p>
            <table>
                <tr>
                    <td>Dystrybucja</td>
                    <td>Parametry</td>
                    <td>Gęstość/PMF $f(x)$</td>
                </tr>
                <tr>
                    <td><code>std::uniform_int_distribution</code></td>
                    <td>$a,b\in\mathbb Z$</td>
                    <td>$f(k)=\tfrac1{b-a+1}$</td>
                </tr>
                <tr>
                    <td><code>std::uniform_real_distribution</code></td>
                    <td>$a,b\in\mathbb R$</td>
                    <td>$f(x)=\tfrac1{b-a}$</td>
                </tr>
                <tr>
                    <td><code>std::normal_distribution</code></td>
                    <td>$\mu,\sigma$</td>
                    <td>$f(x)=\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x-\mu)^2}{2\sigma^2}}$</td>
                </tr>
                <tr>
                    <td><code>std::bernoulli_distribution</code></td>
                    <td>$p$</td>
                    <td>$f(1)=p,;f(0)=1-p$</td>
                </tr>
                <tr>
                    <td><code>std::poisson_distribution</code></td>
                    <td>$\lambda$</td>
                    <td>$f(k)=e^{-\lambda}\frac{\lambda^k}{k!}$</td>
                </tr>
            </table>
            </p>
            <p>Dystrybucje ciągłe implementują <strong>metodę inwersji</strong></p>
            <p>$$
                X=F^{-1}(U)\text{ z }U\sim\mathcal U(0,1)
                $$</p>
            <p>lub transformacje specjalne (np. Box-Muller).</p>
            <h4 id="inicjalizacja-właściwości-ziarna">Inicjalizacja – właściwości ziarna</h4>
            <p>Omówimy, jak dobór ziarna wpływa na powtarzalność oraz jakość generowanych sekwencji.</p>
            <p>Jeśli dwa generatory otrzymają to samo <strong>seed</strong>, ich sekwencje będą identyczne:</p>
            <p>$$
                \forall n\;\;x^{(1)}_n = x^{(2)}_n.
                $$</p>
            <p>W symulacjach replikowalnych podajemy jawnie wartość seeda; w sytuacjach wymagających nieprzewidywalności (kryptografia) używamy <code>std::random_device</code>.</p>
            <h3 id="przykłady-użycia-c-17-">Przykłady użycia (C++ 17)</h3>
            <p>Poniżej znajdują się przykłady wykorzystania biblioteki <code>&lt;random&gt;</code> w praktycznych scenariuszach, ilustrujące różne zastosowania dystrybucji.</p>
            <h4 id="liczba-z-przedziału-a-b-subset-mathbb-z-">Liczba z przedziału $[a,b]\subset\mathbb Z$</h4>
            <p>Wygenerujemy liczbę całkowitą z zadanego przedziału.</p>
            <p>
            <div>
                <pre><code class="language-clike">std::mt19937 gen(std::random_device{}());
std::uniform_int_distribution&lt;int&gt; dist(a,b);
int x = dist(gen);</code></pre>
            </div>
            </p>
            <p><em>Własności.</em> $\Pr{X=k}=1/(b-a+1)$. Oczekiwana wartość $E[X]=\tfrac{a+b}{2}$, wariancja $\sigma^2=\tfrac{(b-a+1)^2-1}{12}$.</p>
            <h4 id="rzut-monetą-dystrybucja-bernoulliego">Rzut monetą – dystrybucja Bernoulliego</h4>
            <p>Przykład rzutu uczciwą monetą.</p>
            <p>
            <div>
                <pre><code class="language-clike">std::bernoulli_distribution coin(0.5);
bool isHeads = coin(gen);</code></pre>
            </div>
            </p>
            <p><em>Analiza.</em> $X\sim\mathrm{Bern}(p)$: $E[X]=p$, Var[X]=p(1-p).
                Dla $n$ rzutów błąd względny częstości maleje jak $O!\bigl(n^{-1/2}\bigr)$.</p>
            <h4 id="rzut-sześciościenną-kostką">Rzut sześciościenną kostką</h4>
            <p>Generowanie wyrzutu kostki o sześciu ściankach.</p>
            <p>
            <div>
                <pre><code class="language-clike">std::uniform_int_distribution&lt;int&gt; d6(1,6);
int result = d6(gen);</code></pre>
            </div>
            </p>
            <p>Rozkład dyskretny równomierny na ${1,\dots,6}$.
                $E[X]=3.5,; \sigma^2=\tfrac{35}{12}$.</p>
            <h4 id="generator-silnych-haseł">Generator silnych haseł</h4>
            <p>Przykład tworzenia losowego hasła o zadanej długości.</p>
            <p>
            <div>
                <pre><code class="language-clike">std::string alphabet =
    "abcdefghijklmnopqrstuvwxyz"
    "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    "0123456789!@#$%^&amp;*()-_=+";
std::uniform_int_distribution&lt;size_t&gt; pick(0, alphabet.size()-1);

auto password = [&amp;] (size_t n) {
    std::string s;
    for(size_t i=0;i&lt;n;++i) s+=alphabet[pick(gen)];
    return s;
};</code></pre>
            </div>
            </p>
            <p>Entropia hasła $H = n\log_2 |\text{alphabet}|$.
                Dla $n=12$ i $|alphabet| = 74$: $H\approx 71$ bitów.</p>
            <h4 id="metody-monte-carlo">Metody Monte Carlo</h4>
            <p>Demonstracja estymacji całki przy pomocy losowania.</p>
            <p>
            <div>
                <pre><code class="language-clike">std::uniform_real_distribution&lt;double&gt; U(a,b);
double sum = 0;
for(size_t k=0;k&lt;N;++k) sum += g(U(gen));
double I = (b-a)*sum/N;</code></pre>
            </div>
            </p>
            <p>Symulacyjna estymata całki:</p>
            <p>$$
                I=\int_{a}^{b}g(x)dx,
                \qquad<br />
                \hat I_N = (b-a)\frac1N\sum_{k=1}^N g(U_k),\quad U_k\sim\mathcal U(a,b).
                $$</p>
            <p><em>Błąd przeciętny</em> $RMSE=\sigma/\sqrt N$ z $\sigma^2=Var[g(U)]$.
                <strong>Uwaga.</strong> Dla funkcji silnie oscylujących warto stosować <em>ważoną próbę</em> (importance sampling) lub <em>stratyfikację</em>.
            </p>
            <h4 id="rng-kryptograficzne-csprng-">RNG kryptograficzne (CSPRNG)</h4>
            <p>Wymagania formalne (Goldwasser–Micali):</p>
            <ol>
                <li><strong>Jednokierunkowość</strong> – brak efektywnego algorytmu do odtworzenia seeda.</li>
                <li><strong>Test next-bit</strong> –</li>
            </ol>
            <p>$$
                \Pr[G(x)<em>i = 1 \mid G(x)_1, G(x)_2, \dots, G(x)</em>{i-1}]
                = \frac{1}{2} \pm \varepsilon(\lambda).
                $$</p>
            <p>gdzie $\varepsilon$ jest zaniedbywalne względem parametru bezpieczeństwa $\lambda$.</p>
            <p>W C++20 brak oficjalnego CSPRNG, ale popularne biblioteki (libsodium, Botan) udostępniają <code>randombytes_buf</code>, <code>crypto_rng</code>. Dla systemowego źródła entropii można użyć:</p>
            <p>
            <div>
                <pre><code class="language-clike">#include &lt;openssl rand.h=""&gt;
unsigned char buf[32];
RAND_bytes(buf, sizeof(buf)); // 256-bit</code></pre>
            </div>
            </p>
            <h3 id="zastosowanie-różnych-dystrybucji">Zastosowanie różnych dystrybucji</h3>
            <p>Teraz omówimy zastosowania kilku dystrybucji losowych dostępnych w bibliotece <code>&lt;random&gt;</code>, prezentując ich definicje, własności, implementację w C++ oraz przykłady użycia.</p>
            <h4 id="dystrybucja-równomierna">Dystrybucja równomierna</h4>
            <p>Dystrybucja równomierna generuje wartości o jednakowym prawdopodobieństwie w całym zakresie, co jest przydatne, gdy potrzebujemy równomiernie rozłożyć próbki.</p>
            <p>Dyskretna wersja na zbiorze kolejnych liczb całkowitych ${a,\dots,b}$:</p>
            <p>$$
                \mathbb P(X=k)=\frac1{b-a+1},\qquad k=a,\dots,b
                $$</p>
            <p>Wersja ciągła na przedziale $[a,b]$:</p>
            <p>$$
                f(x)=\frac1{b-a}\mathbf 1_{[a,b]}(x)
                $$</p>
            <p>$$
                F(x)=\frac{x-a}{b-a}
                $$</p>
            <p>W poniższych wzorach przedstawiono momenty i funkcję generującą momenty (MGF), które charakteryzują tę dystrybucję:</p>
            <p>$$
                E[X]=\frac{a+b}{2}
                $$</p>
            <p>$$
                Var[X]=\frac{(b-a)^2}{12}
                $$</p>
            <p>$$
                M_X(t)=\frac{e^{tb}-e^{ta}}{t(b-a)}\;(t\ne 0)
                $$</p>
            <p><strong>Implementacja</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">std::mt19937 gen(std::random_device{}());
std::uniform_int_distribution&lt;int&gt; U(a,b);
int k = U(gen);</code></pre>
            </div>
            </p>
            <blockquote>
                <p><strong>Rada.</strong> Generator wywołuj <strong>raz</strong> i przekazuj referencję; kosztowna inicjalizacja <code>std::random_device{}</code> nie powinna znajdować się w pętli.</p>
            </blockquote>
            <h5>Przykład: 10 liczb w zakresie $[1,100]$</h5>
            <p>Poniżej przykład wylosowania dziesięciu liczb z przedziału [1,100]:</p>
            <p>
            <div>
                <pre><code class="language-clike">std::cout &lt;&lt; "Uniform[1,100]: ";
for(int i=0;i&lt;10;++i) std::cout &lt;&lt; U(gen) &lt;&lt; ' ';</code></pre>
            </div>
            </p>
            <h4 id="dystrybucja-normalna-gaussa-">Dystrybucja normalna (Gaussa)</h4>
            <p>Rozkład normalny, zwany też Gaussa, opisuje zmienną losową o gęstości dzwonowej i jest uzywany w statystyce ze względu na centralne twierdzenie graniczne.</p>
            <p>$$
                f(x)=\frac1{\sqrt{2\pi}\sigma}\exp!\Bigl[-\frac{(x-\mu)^2}{2\sigma^2}\Bigr],
                \quad x\in\mathbb R
                $$</p>
            <h5>Parametry</h5>
            <p>Podstawowe parametry wpływające na położenie i rozrzut rozkładu przedstawiono poniżej:</p>
            <p>$$
                E[X]=\mu
                $$</p>
            <p>$$
                Var[X]=\sigma^{2}
                $$</p>
            <p>$$
                M_X(t)=\exp!\left(\mu t+\tfrac12\sigma^{2}t^{2}\right)
                $$</p>
            <p>Suma niezależnych $X_i\sim\mathcal N(\mu_i,\sigma_i^2)$ jest również normalna:</p>
            <p>$$
                \sum_i X_i \sim \mathcal N!\Bigl(\sum \mu_i,\;\sum\sigma_i^2\Bigr)
                $$</p>
            <p><strong>Implementacja</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">std::normal_distribution&lt;double&gt; N(mu, sigma);
double x = N(gen);</code></pre>
            </div>
            </p>
            <p>Przykład generowania próbek z rozkładu normalnego o zadanych parametrach:</p>
            <p>
            <div>
                <pre><code class="language-clike">std::cout &lt;&lt; "Normal(50,10): ";
for(int i=0;i&lt;10;++i) std::cout &lt;&lt; N(gen) &lt;&lt; ' ';</code></pre>
            </div>
            </p>
            <blockquote>
                <p><strong>Weryfikacja.</strong> Aby sprawdzić poprawność generatora, warto przeprowadzić prostą weryfikację statystyczną:</p>
                <ol>
                    <li>zbuduj histogram,</li>
                    <li>oblicz statystykę K–S $D_n=\sup_x|F_n(x)-\Phi_{\mu,\sigma}(x)|$,</li>
                    <li>odrzucaj generator jeśli $D_n&gt;D_{\alpha,n}$ dla wybranego poziomu $\alpha$.</li>
                </ol>
            </blockquote>
            <h4 id="dystrybucja-bernoulliego">Dystrybucja Bernoulliego</h4>
            <p>Dystrybucja Bernoulliego modeluje zdarzenie dychotomiczne, zwracając 1 z prawdopodobieństwem $p$ lub 0 z prawdopodobieństwem $1-p$.</p>
            <p>$$
                \mathbb P(X=1)=p,\qquad \mathbb P(X=0)=1-p,\quad 0&lt;p&lt;1.
                $$</p>
            <h5>Parametry</h5>
            <p>$$
                E[X]=p
                $$</p>
            <p>$$
                Var[X]=p(1-p)
                $$</p>
            <p>$$
                M_X(t)=1-p+pe^{t}
                $$</p>
            <p><strong>Związek z rozkladem dwumianowym.</strong> Suma prób Bernoulliego prowadzi do rozkładu dwumianowego, co ilustruje związek pomiędzy tymi rozkładami:</p>
            <p>$$
                \sum_{i=1}^{n}X_i \sim \mathrm{Bin}(n,p).
                $$</p>
            <p><strong>Implementacja</strong></p>
            <p>
            <div>
                <pre><code class="language-clike">double p = 0.3;
std::bernoulli_distribution B(p);
bool success = B(gen);</code></pre>
            </div>
            </p>
            <p><strong>Przykład: 10 losowań, $p=0,3$</strong></p>
            <p>Przykład wykonania dziesięciu niezależnych prób Bernoulliego:</p>
            <p>
            <div>
                <pre><code class="language-clike">for(int i=0;i&lt;10;++i) std::cout &lt;&lt; B(gen) &lt;&lt; ' ';</code></pre>
            </div>
            </p>
            <blockquote>
                <p><strong>Analiza częstości.</strong> Analiza częstościowa pozwala na ocenę zbieżności częstości względnej do $p$ oraz wyznaczenie przedziału ufności 95 %:</p>
                <p>$\hat p \pm 1.96\sqrt{p(1-p)/n}$</p>
            </blockquote>
            <p>Tabela poniżej zestawia informacje o omawianych dystrybucjach, umożliwiając szybkie porównanie:</p>
            <p>
            <table>
                <tr>
                    <td>Rozkład</td>
                    <td>Kod dystr. <code>&lt;random&gt;</code></td>
                    <td>Parametry</td>
                    <td>$E[X]$</td>
                    <td>$Var[X]$</td>
                    <td>Typ danych</td>
                </tr>
                <tr>
                    <td>Równomierny (dyskr.)</td>
                    <td><code>std::uniform_int_distribution</code></td>
                    <td>$a,b$</td>
                    <td>$\tfrac{a+b}{2}$</td>
                    <td>$\tfrac{(b-a+1)^2-1}{12}$</td>
                    <td>całkowite</td>
                </tr>
                <tr>
                    <td>Normalny</td>
                    <td><code>std::normal_distribution</code></td>
                    <td>$\mu,\sigma$</td>
                    <td>$\mu$</td>
                    <td>$\sigma^2$</td>
                    <td>zmiennoprzec.</td>
                </tr>
                <tr>
                    <td>Bernoulli</td>
                    <td><code>std::bernoulli_distribution</code></td>
                    <td>$p$</td>
                    <td>$p$</td>
                    <td>$p(1-p)$</td>
                    <td>bool/int</td>
                </tr>
            </table>
            </p>
            <h3 id="zalety-i-wady-różnych-metod">Zalety i wady różnych metod</h3>
            <p>Teraz porównamy najpopularniejsze metody generowania liczb losowych w C++, omawiając ich zalety oraz ograniczenia w różnych zastosowaniach.</p>
            <h4 id="std-random-c-11-"><code>std::random</code> (C++11)</h4>
            <p>Biblioteka <code>&lt;random&gt;</code> w C++11 dostarcza elastyczny interfejs „generator + dystrybucja” bazujący domyślnie na <code>std::mt19937</code>. Poniżej przyjrzymy się matematycznemu modelowi Mersenne Twistera wraz z jego mocnymi i słabymi stronami.</p>
            <p><strong>Model matematyczny</strong></p>
            <p>Domyślny wybór – <code>std::mt19937</code> – jest implementacją algorytmu Mersenne Twistera:</p>
            <p>$$
                \begin{aligned}
                x_{k+n} &amp;= x_{k+m}\oplus\Bigl((x_k^{u}\parallel x_{k+1}^{\ell})A\Bigr),\\
                n&amp;=624,\;m=397,\\
                \text{okres}&amp;=2^{19937}-1\approx 10^{6001},\\
                d_{\max}&amp;=623\quad\text{(wymiar równomierności).}
                \end{aligned}
                $$</p>
            <p><em>Spektralny test równoległości</em> daje wynik rzędu $2^{-2018}$ – przy wielu zastosowaniach symulacyjnych uznaje się to za „praktycznie idealne”.</p>
            <p><strong>Zalety</strong></p>
            <p>
            <table>
                <tr>
                    <td>Aspekt</td>
                    <td>Wartość dodana</td>
                    <td>Komentarz matematyczny</td>
                </tr>
                <tr>
                    <td><strong>Okres</strong></td>
                    <td>$2^{19937}-1$</td>
                    <td>eliminuje cykliczność w trwałych symulacjach</td>
                </tr>
                <tr>
                    <td><strong>Równomierność</strong></td>
                    <td>623-wymiarowa</td>
                    <td>równy rozkład punktów w hipersześcianie $[0,1)^{623}$</td>
                </tr>
                <tr>
                    <td><strong>Bogactwo dystrybucji</strong></td>
                    <td>normalna, Poissona, gamma…</td>
                    <td>każda dystrybucja to transformacja $X=F^{-1}(U)$ lub specjalny algorytm</td>
                </tr>
                <tr>
                    <td><strong>Konfigurowalne ziarno</strong></td>
                    <td>deterministyczne lub <code>random_device</code></td>
                    <td>replikowalność lub entropia systemowa</td>
                </tr>
                <tr>
                    <td><strong>Przenośność</strong></td>
                    <td>zdefiniowane przez ISO/IEC 14882</td>
                    <td>identyczna sekwencja dla tego samego seeda na wszystkich kompilatorach</td>
                </tr>
            </table>
            </p>
            <p><strong>Wady</strong></p>
            <ol>
                <li>Trzeba rozumieć dwustopniowy model: <em>generator + dystrybucja</em>.</li>
                <li><strong>Brak odporności kryptograficznej</strong> – Mersenne Twister jest liniowy nad \$\mathbb F_2\$; stan generatora (19937 bitów) można odtworzyć na podstawie 19937 kolejnych wyjść.</li>
                <li><strong>Koszt inicjalizacji</strong> – <code>std::random_device</code> może być wolny (blokuje podczas odczytu z <code>/dev/urandom</code>).</li>
                <li><strong>Rozmiar stanu</strong> – 2,5 KB dla <code>mt19937</code>; przy wielu wątkach oznacza to znaczną ilość pamięci.</li>
            </ol>
            <h4 id="rand-klasyczny-lcg"><code>rand()</code> – klasyczny LCG</h4>
            <p>Funkcja <code>rand()</code> to prosty liniowy kongruentny generator (LCG) o minimalnym API, często używany dla szybkiego startu, ale z istotnymi ograniczeniami.</p>
            <p><strong>Model matematyczny</strong></p>
            <p>Większość implementacji to <strong>liniowy generator</strong>:</p>
            <p>$$
                x_{n+1} = (ax_n + c)\;\bmod m,
                $$</p>
            <p>typowe stałe (glibc, MSVC):</p>
            <p>$$
                a=1103515245,\;c=12345,\;m=2^{31}.
                $$</p>
            <p>Okres ≤ $m=2^{31};(\approx2.1\cdot10^9)$. Najmłodszy bit ma okres 2, co czyni go bezużytecznym w symulacjach binarnych.</p>
            <p><strong>Zalety</strong></p>
            <p>
            <table>
                <tr>
                    <td>Aspekt</td>
                    <td>Argument</td>
                    <td>Uwaga</td>
                </tr>
                <tr>
                    <td><strong>Minimalne API</strong></td>
                    <td><code>int r = rand();</code></td>
                    <td>brak szablonów ↔ szybki start</td>
                </tr>
                <tr>
                    <td><strong>Dostępność</strong></td>
                    <td>C89 / C++98</td>
                    <td>działanie na wbudowanych systemach, bibliotece <code>libc</code></td>
                </tr>
                <tr>
                    <td><strong>Przepustowość</strong></td>
                    <td>jedna operacja mnożenia + dodawania</td>
                    <td>przeciętnie 2–3× szybciej od <code>mt19937</code> (zależnie od CPU)</td>
                </tr>
            </table>
            </p>
            <p><strong>Wady</strong></p>
            <ol>
                <li><strong>Krótki okres generacji</strong> – przy prędkości 10⁸ liczb/s pełny cykl wyczerpuje się w ok. 21 s.</li>
                <li><strong>Słabe własności spektralne</strong> – pojawiają się korelacje w przestrzeni 3D w symulacjach Monte Carlo.</li>
                <li><strong>Niejednorodność implementacji</strong> – różne kompilatory używają odmiennych stałych.</li>
                <li><strong>Brak wbudowanych rozkładów</strong> – konieczne ręczne przekształcenia (np. metoda Box–Mullera).</li>
                <li><strong>Łamliwość kryptograficzna</strong> – na podstawie zaledwie trzech wyjść można odzyskać parametry generatora.</li>
            </ol>
            <h4 id="zestawienie-porównawcze">Zestawienie porównawcze</h4>
            <p>Poniżej tabela podsumowująca różnice między <code>std::mt19937</code> a <code>rand()</code>:</p>
            <p>
            <table>
                <tr>
                    <td>Kryterium</td>
                    <td><code>std::mt19937</code></td>
                    <td><code>rand()</code> (LCG)</td>
                </tr>
                <tr>
                    <td>Okres</td>
                    <td>$2^{19937}-1$</td>
                    <td>≤ $2^{31}$</td>
                </tr>
                <tr>
                    <td>Równomierność $d_{\max}$</td>
                    <td>623</td>
                    <td>≤ 5</td>
                </tr>
                <tr>
                    <td>Koszt generacji</td>
                    <td>\~10 ns</td>
                    <td>\~5 ns</td>
                </tr>
                <tr>
                    <td>Rozmiar stanu</td>
                    <td>2,5 KB</td>
                    <td>4 B</td>
                </tr>
                <tr>
                    <td>Kryptografia</td>
                    <td>❌ (liniowość)</td>
                    <td>❌</td>
                </tr>
                <tr>
                    <td>Wbudowane dystrybucje</td>
                    <td>✔ (\~20)</td>
                    <td>❌</td>
                </tr>
                <tr>
                    <td>Standaryzacja seeda</td>
                    <td>✔ (deterministyczna)</td>
                    <td>❌</td>
                </tr>
                <tr>
                    <td>Łatwość użycia</td>
                    <td>umiarkowana</td>
                    <td>wysoka</td>
                </tr>
            </table>
            </p>
        </section>
        <div id="table-of-contents">
            <h2>Spis Treści</h2>
            <ol><a href="#liczby-losowe-i-generatory-liczb-losowych">Liczby losowe i generatory liczb losowych</a>
                <ol>
                    <li><a href="#liczby-losowe">Liczby losowe</a>
                        <ol>
                            <li><a href="#własności-oczekiwane">Własności oczekiwane</a></li>
                            <li><a href="#prawdziwa-losowość-vs-pseudolosowość">Prawdziwa losowość vs. pseudolosowość</a></li>
                        </ol>
                    </li>
                    <li><a href="#generowanie-liczb-losowych">Generowanie liczb losowych</a>
                        <ol>
                            <li><a href="#dystrybucje">Dystrybucje</a></li>
                            <li><a href="#inicjalizacja-właściwości-ziarna">Inicjalizacja – właściwości ziarna</a></li>
                        </ol>
                    </li>
                    <li><a href="#przykłady-użycia-c-17-">Przykłady użycia (C++ 17)</a>
                        <ol>
                            <li><a href="#liczba-z-przedziału-a-b-subset-mathbb-z-">Liczba z przedziału $[a,b]\subset\mathbb Z$</a></li>
                            <li><a href="#rzut-monetą-dystrybucja-bernoulliego">Rzut monetą – dystrybucja Bernoulliego</a></li>
                            <li><a href="#rzut-sześciościenną-kostką">Rzut sześciościenną kostką</a></li>
                            <li><a href="#generator-silnych-haseł">Generator silnych haseł</a></li>
                            <li><a href="#metody-monte-carlo">Metody Monte Carlo</a></li>
                            <li><a href="#rng-kryptograficzne-csprng-">RNG kryptograficzne (CSPRNG)</a></li>
                        </ol>
                    </li>
                    <li><a href="#zastosowanie-różnych-dystrybucji">Zastosowanie różnych dystrybucji</a>
                        <ol>
                            <li><a href="#dystrybucja-równomierna">Dystrybucja równomierna</a></li>
                            <li><a href="#dystrybucja-normalna-gaussa-">Dystrybucja normalna (Gaussa)</a></li>
                            <li><a href="#dystrybucja-bernoulliego">Dystrybucja Bernoulliego</a></li>
                        </ol>
                    </li>
                    <li><a href="#zalety-i-wady-różnych-metod">Zalety i wady różnych metod</a>
                        <ol>
                            <li><a href="#std-random-c-11-">std::random (C++11)</a></li>
                            <li><a href="#rand-klasyczny-lcg">rand() – klasyczny LCG</a></li>
                            <li><a href="#zestawienie-porównawcze">Zestawienie porównawcze</a></li>
                        </ol>
                    </li>
                </ol>
            </ol>
            <div id="related-articles">
                <h2>Related Articles</h2>
                <ol>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/01_proces_kompilacji.html">Proces Kompilacji</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/02_preprocesor.html">Preprocesor</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/03_zmienne_i_typy_danych.html">Zmienne i Typy Danych</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/04_interakcja_z_konsola.html">Interakcja z Konsola</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/05_instrukcja_warunkowa.html">Instrukcja Warunkowa</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/06_petle.html">Petle</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/07_liczby_losowe.html">Liczby Losowe</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/08_typ_wyliczeniowy.html">Typ Wyliczeniowy</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/09_funkcje.html">Funkcje</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/10_l_wartosci_r_wartosci.html">L Wartosci R Wartosci</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/11_wskazniki.html">Wskazniki</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/12_tablice.html">Tablice</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/13_napisy.html">Napisy</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/14_operacje_bitowe.html">Operacje Bitowe</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/15_programowanie_obietkowe.html">Programowanie Obietkowe</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/16_dziedziczenie.html">Dziedziczenie</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/17_zaawansowane_wskazniki.html">Zaawansowane Wskazniki</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/18_przeciazanie.html">Przeciazanie</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/19_konwersje.html">Konwersje</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/20_lambdy.html">Lambdy</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/21_szablony.html">Szablony</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/22_wyjatki.html">Wyjatki</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/23_stl.html">Stl</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/24_praca_z_plikami.html">Praca z Plikami</a></li>
                    <li><a href="https://adamdjellouli.com/articles/od_c_do_cpp/25_c_vs_cpp.html">C vs Cpp</a></li>
                </ol>
            </div>
        </div>
    </div>
    <footer>
        <div class="footer-columns">
            <div class="footer-column">
                <img alt="Adam Djellouli Symbol" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/symbol.png" />
            </div>
            <div class="footer-column">
                <h2><a href="https://adamdjellouli.com/core/privacy_policy.html" title="Privacy Policy">Our Privacy Policy</a></h2>
                <p>
                    Thank you for visiting my personal website. All content here is free to use,
                    but please remember to be respectful and avoid any misuse of the site.
                    If you’d like to get in touch, feel free to reach out via my
                    <a href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" title="LinkedIn Profile">LinkedIn profile</a>
                    or connect with me on
                    <a href="https://github.com/djeada" title="GitHub Profile">GitHub</a>
                    if you have technical questions or ideas to share.
                    Wishing you all the best and a fantastic life ahead!
                </p>
            </div>
            <div class="footer-column">
                <h2>Follow me</h2>
                <ul class="social-media">
                    <li>
                        <a class="fa fa-youtube" href="https://www.youtube.com/channel/UCGPoHTVjMN77wcGknXPHl1Q" target="_blank" title="YouTube">
                        </a>YouTube
                    </li>
                    <li>
                        <a class="fa fa-linkedin" href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" target="_blank" title="LinkedIn">
                        </a>LinkedIn
                    </li>
                    <li>
                        <a class="fa fa-instagram" href="https://www.instagram.com/linuxchallenges/" target="_blank" title="Instagram">
                        </a>Instagram
                    </li>
                    <li>
                        <a class="fa fa-github" href="https://github.com/djeada" title="GitHub">
                        </a>Github
                    </li>
                </ul>
            </div>
        </div>
        <div>
            <p id="copyright">
                © Adam Djellouli. All rights reserved.
            </p>
        </div>
        <script>
            document.getElementById("copyright").innerHTML = "&copy; " + new Date().getFullYear() + " Adam Djellouli. All rights reserved.";
        </script>
        <script src="../../app.js"></script>
    </footer>
    <div id="pdf-spinner-overlay">
        <div class="spinner"></div>
    </div>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-bash.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-cpp.min.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
jax: ["input/TeX", "output/HTML-CSS"],
extensions: ["tex2jax.js"],
"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] },
tex2jax: { inlineMath: [ ["$", "$"] ], displayMath: [ ["$$","$$"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
TeX: { noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } } },
messageStyle: "none"
});
</script>
<script async="" id="MathJax-script" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>

</html>