<!DOCTYPE html>

<html lang="en">

<head>
    <script async="" crossorigin="anonymous" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5593122079896089"></script>
    <meta charset="utf-8" />
    <title>Matrices and 2D Grids</title>
    <meta content="Matrices represent images, game boards, and maps." name="description" />
    <meta content="Adam Djellouli" name="author" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <meta content="IE=edge" http-equiv="X-UA-Compatible" />
    <link crossorigin="" href="https://fonts.googleapis.com" rel="preconnect" />
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/icon.ico" rel="icon" />
    <link href="../../resources/style.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    <link href="https://adamdjellouli.com/articles/algorithms_and_data_structures/matrices" rel="canonical" />
    <script id="structured-data" type="application/ld+json">
        {
            "@context": "https://schema.org",
            "@type": "Article",
            "headline": "Matrices and 2D Grids",
            "author": {
                "@type": "Person",
                "name": "Adam Djellouli"
            },
            "mainEntityOfPage": {
                "@type": "WebPage",
                "@id": "https://adamdjellouli.com/articles/algorithms_and_data_structures/matrices"
            },
            "url": "https://adamdjellouli.com/articles/algorithms_and_data_structures/matrices",
            "description": "Matrices represent images, game boards, and maps.",
            "dateModified": "2020-08-03"
        }
    </script>
</head>

<body>
    <nav aria-label="Main navigation">
        <a class="logo" href="../../index.html">
            <img alt="Adam Djellouli - Home Page Logo" id="logo-image" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/logo.PNG" />
        </a>
        <input aria-label="Toggle navigation menu" id="navbar-toggle" type="checkbox" />
        <ul aria-labelledby="navbar-toggle" role="menu">
            <li role="menuitem">
                <a href="../../index.html" title="Go to Home Page"> Home </a>
            </li>
            <li role="menuitem">
                <a href="../../core/blog.html" title="Read Adam Djellouli Blog on Programming and Technology"> Blog </a>
            </li>
            <li role="menuitem">
                <a href="../../core/tools.html" title="Discover Tools Created by Adam Djellouli"> Tools </a>
            </li>
            <li role="menuitem">
                <a href="../../core/projects.html" title="Explore Projects Developed by Adam Djellouli"> Projects </a>
            </li>
            <li role="menuitem">
                <a href="../../core/courses.html" title="Browse Courses by Adam Djellouli"> Courses </a>
            </li>
            <li role="menuitem">
                <a href="../../core/resume.html" title="View Adam Djellouli Professional Resume"> Resume </a>
            </li>
            <li>
                <script async="" src="https://cse.google.com/cse.js?cx=8160ef9bb935f4f68"></script>
                <div class="gcse-search"></div>
            </li>
            <li>
                <button aria-label="Toggle dark mode" id="dark-mode-button"></button>
            </li>
        </ul>
    </nav>
    <div id="article-wrapper"><article-section id="article-body">
            <div class="article-action-buttons"><button class="btn-suggest-edit" title="Suggest Edit">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <path d="M4 21h4l11-11-4-4L4 17v4z" stroke="currentColor" stroke-width="2"></path>
                    </svg>
                </button><button class="btn-create-issue" title="Create Issue">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2"></circle>
                        <line stroke="currentColor" stroke-width="2" x1="12" x2="12" y1="8" y2="12"></line>
                        <circle cx="12" cy="16" fill="currentColor" r="1"></circle>
                    </svg>
                </button><button class="btn-download" title="Download">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <path d="M12 5v14m0 0l-6-6m6 6l6-6" stroke="currentColor" stroke-width="2"></path>
                    </svg>
                </button></div>
            <p style="text-align: right;"><i>Last modified: August 03, 2020</i></p>
            <p style="text-align: right;"><i>This article is written in: üá∫üá∏</i></p>
            <h2 id="matrices-and-2d-grids">Matrices and 2D Grids</h2>
            <p>Matrices represent images, game boards, and maps. Many classic problems reduce to transforming matrices, traversing them, or treating grids as graphs for search.</p>
            <h3 id="conventions">Conventions</h3>
            <p><strong>Rows indexed $0..R-1$, columns $0..C-1$; cell $(r,c)$.</strong></p>
            <p>Rows increase <strong>down</strong>, columns increase <strong>right</strong>. Think ‚Äútop-left is $(0,0)$‚Äù, not a Cartesian origin.</p>
            <p>Visual index map (example $R=6$, $C=8$; each cell labeled $rc$):</p>
            <div>
                <pre><code class="language-shell">c ‚Üí    0    1    2    3    4    5    6    7
r ‚Üì   +----+----+----+----+----+----+----+----+
0     | 00 | 01 | 02 | 03 | 04 | 05 | 06 | 07 |
	  +----+----+----+----+----+----+----+----+
1     | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 |
	  +----+----+----+----+----+----+----+----+
2     | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 |
	  +----+----+----+----+----+----+----+----+
3     | 30 | 31 | 32 | 33 | 34 | 35 | 36 | 37 |
	  +----+----+----+----+----+----+----+----+
4     | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 |
	  +----+----+----+----+----+----+----+----+
5     | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 |
	  +----+----+----+----+----+----+----+----+</code></pre>
            </div>
            <p>Handy conversions (for linearization / array-of-arrays):</p>
            <ul>
                <li>Linear index: $\text{id}=r\cdot C+c$.</li>
                <li>From id: $r=\lfloor \text{id}/C \rfloor$, $c=\text{id}\bmod C$.</li>
                <li>Row-major scan order (common in problems): for $r$ in $0..R-1$, for $c$ in $0..C-1$.</li>
            </ul>
            <p><strong>Row-major vs column-major arrows (same $3\times 6$ grid):</strong></p>
            <div>
                <pre><code class="language-shell">Row-major (r, then c):                  Column-major (c, then r):
‚Üí ‚Üí ‚Üí ‚Üí ‚Üí ‚Üí                              ‚Üì ‚Üì ‚Üì
          ‚Üì                              ‚Üì ‚Üì ‚Üì
‚Üê ‚Üê ‚Üê ‚Üê ‚Üê ‚Üê                              ‚Üì ‚Üì ‚Üì
‚Üì                                        ‚Üì ‚Üì ‚Üì
‚Üí ‚Üí ‚Üí ‚Üí ‚Üí ‚Üí                              ‚Üì ‚Üì ‚Üì</code></pre>
            </div>
            <p><strong>Neighborhoods: $\mathbf{4}$-dir $\Delta={(-1,0),(1,0),(0,-1),(0,1)}$; $\mathbf{8}$-dir adds diagonals.</strong></p>
            <p>The offsets $(\Delta r,\Delta c)$ are applied as $(r+\Delta r,\ c+\Delta c)$.</p>
            <p><strong>4-neighborhood (‚Äú+‚Äù):</strong></p>
            <div>
                <pre><code class="language-shell">#
		   (r-1,c)
			 ‚Üë
  (r,c-1) ‚Üê (r,c) ‚Üí (r,c+1)
			 ‚Üì
		   (r+1,c)</code></pre>
            </div>
            <p><strong>8-neighborhood (‚Äú√ó‚Äù adds diagonals):</strong></p>
            <div>
                <pre><code class="language-shell">(r-1,c-1)   (r-1,c)   (r-1,c+1)
	  \       ‚Üë       /
	   \      ‚îÇ      /
(r,c-1) ‚Üê‚Äî‚Äî‚Äî  (r,c)  ‚Äî‚Äî‚Äî‚Üí (r,c+1)
	   /      ‚îÇ      \
	  /       ‚Üì       \
(r+1,c-1)   (r+1,c)   (r+1,c+1)</code></pre>
            </div>
            <p>Typical direction arrays (keep them consistent to avoid bugs):</p>
            <div>
                <pre><code class="language-shell">// 4-dir
dr = [-1, 1,  0, 0]
dc = [ 0, 0, -1, 1]

// 8-dir
dr8 = [-1,-1,-1, 0, 0, 1, 1, 1]
dc8 = [-1, 0, 1,-1, 1,-1, 0, 1]</code></pre>
            </div>
            <p><strong>Boundary checks</strong> (always guard neighbors):</p>
            <div>
                <pre><code class="language-shell">0 ‚â§ nr &lt; R  and  0 ‚â§ nc &lt; C</code></pre>
            </div>
            <p><strong>Edge/inside intuition:</strong></p>
            <div>
                <pre><code class="language-shell">out of bounds
	‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
	‚îÇ ¬∑ ¬∑ ¬∑ ¬∑ ¬∑ ¬∑ ¬∑ ¬∑ ‚îÇ
	‚îÇ ¬∑ +---+---+---+ ‚îÇ
	‚îÇ ¬∑ | a | b | c | ‚îÇ   ‚Üê valid cells
	‚îÇ ¬∑ +---+---+---+ ‚îÇ
	‚îÇ ¬∑ | d | e | f | ‚îÇ
	‚îÇ ¬∑ +---+---+---+ ‚îÇ
	‚îÇ ¬∑ ¬∑ ¬∑ ¬∑ ¬∑ ¬∑ ¬∑ ¬∑ ‚îÇ
	‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò</code></pre>
            </div>
            <h3 id="basic-operations-building-blocks-">Basic Operations (Building Blocks)</h3>
            <h4 id="transpose">Transpose</h4>
            <p>Swap across the main diagonal: $A_{r,c} \leftrightarrow A_{c,r}$ (square). For non-square, result shape is $C\times R$.</p>
            <p><strong>Example inputs and outputs</strong></p>
            <p><em>Example 1 (square)</em></p>
            <p>$$
                A = \begin{bmatrix}
                1 &amp; 2 &amp; 3 \\
                4 &amp; 5 &amp; 6 \\
                7 &amp; 8 &amp; 9
                \end{bmatrix}
                \quad\Rightarrow\quad
                A^{\mathsf{T}} =
                \begin{bmatrix}
                1 &amp; 4 &amp; 7 \\
                2 &amp; 5 &amp; 8 \\
                3 &amp; 6 &amp; 9
                \end{bmatrix}
                $$</p>
            <p><strong>Mathematical formula (3√ó3)</strong></p>
            <p>$$
                (A^T)<em>{r,c}=A</em>{c,r},\quad 0\le r,c&lt;3
                $$</p>
            <p><strong>Pseudocode (square, in-place)</strong></p>
            <div>
                <pre><code class="language-shell">n = 3  # for this example; generalize to n = size
for r in 0..n-1:
  for c in r+1..n-1:
    swap A[r][c], A[c][r]</code></pre>
            </div>
            <p><em>Example 2 (rectangular)</em></p>
            <p>$$
                \text{Input: } \quad
                A = \begin{bmatrix}
                1 &amp; 2 &amp; 3 \\
                4 &amp; 5 &amp; 6
                \end{bmatrix}
                \ (2 \times 3)
                $$</p>
            <p>$$
                \text{Output: } \quad
                A^{\mathsf{T}} = \begin{bmatrix}
                1 &amp; 4 \\
                2 &amp; 5 \\
                3 &amp; 6
                \end{bmatrix}
                \ (3 \times 2)
                $$</p>
            <p><strong>Mathematical formula (2√ó3 ‚Üí 3√ó2)</strong></p>
            <p>$$
                (A^{\mathsf T})<em>{r,c}=A</em>{c,r},\quad 0\le r&lt;3,\ 0\le c&lt;2
                $$</p>
            <p><strong>Pseudocode (rectangular, new matrix)</strong></p>
            <div>
                <pre><code class="language-shell">R, C = 2, 3
B = zeros(C, R)
for r in 0..R-1:
  for c in 0..C-1:
    B[c][r] = A[r][c]</code></pre>
            </div>
            <p><strong>How it works</strong></p>
            <p>Iterate pairs once and swap. For square matrices, can be in-place by visiting only $c&gt;r$.</p>
            <ul>
                <li>Time: $O(R\cdot C)$</li>
                <li>Space: $O(1)$ in-place (square), else $O(R\cdot C)$ to allocate</li>
            </ul>
            <h4 id="reverse-rows-horizontal-flip-">Reverse Rows (Horizontal Flip)</h4>
            <p>Reverse each row left $\leftrightarrow$ right.</p>
            <p><strong>Example inputs and outputs</strong></p>
            <p><em>Example</em></p>
            <p>$$
                \text{Input: }
                \begin{bmatrix}
                1 &amp; 2 &amp; 3 \\
                4 &amp; 5 &amp; 6
                \end{bmatrix}
                \quad\Rightarrow\quad
                \text{Output: }
                \begin{bmatrix}
                3 &amp; 2 &amp; 1 \\
                6 &amp; 5 &amp; 4
                \end{bmatrix}
                $$</p>
            <p><strong>Mathematical formula (2√ó3)</strong></p>
            <p>$$
                B_{r,c}=A_{r,\ C-1-c},\quad 0\le r&lt;2,\ 0\le c&lt;3
                $$</p>
            <p><strong>Pseudocode (in-place)</strong></p>
            <div>
                <pre><code class="language-shell">R, C = 2, 3
for r in 0..R-1:
  for c in 0..(C//2 - 1):
    swap A[r][c], A[r][C-1-c]</code></pre>
            </div>
            <ul>
                <li>Time: $O(R\cdot C)$</li>
                <li>Space: $O(1)$</li>
            </ul>
            <h4 id="reverse-columns-vertical-flip-">Reverse Columns (Vertical Flip)</h4>
            <p>Reverse each column top $\leftrightarrow$ bottom.</p>
            <p><strong>Example inputs and outputs</strong></p>
            <p><em>Example</em></p>
            <p>$$
                \text{Input: }
                \begin{bmatrix}
                1 &amp; 2 &amp; 3 \\
                4 &amp; 5 &amp; 6 \\
                7 &amp; 8 &amp; 9
                \end{bmatrix}
                \quad\Rightarrow\quad
                \text{Output: }
                \begin{bmatrix}
                7 &amp; 8 &amp; 9 \\
                4 &amp; 5 &amp; 6 \\
                1 &amp; 2 &amp; 3
                \end{bmatrix}
                $$</p>
            <p><strong>Mathematical formula (3√ó3)</strong></p>
            <p>$$
                B_{r,c}=A_{R-1-r,\ c},\quad 0\le r,c&lt;3
                $$</p>
            <p><strong>Pseudocode (in-place)</strong></p>
            <div>
                <pre><code class="language-shell">R, C = 3, 3
for r in 0..(R//2 - 1):
  for c in 0..C-1:
    swap A[r][c], A[R-1-r][c]</code></pre>
            </div>
            <ul>
                <li>Time: $O(R\cdot C)$</li>
                <li>Space: $O(1)$</li>
            </ul>
            <h3 id="rotations-composed-from-basics-">Rotations (Composed from Basics)</h3>
            <p>Use transpose + reversals for square in-place rotations; rectangular rotations produce new shape $(R\times C)\to(C\times R)$.</p>
            <h4 id="90-clockwise-cw-">90¬∞ Clockwise (CW)</h4>
            <p>Transpose, then reverse each row.</p>
            <p><strong>Example inputs and outputs</strong></p>
            <p><em>Example 1 (3√ó3)</em></p>
            <p>$$
                \text{Input: }
                \begin{bmatrix}
                1 &amp; 2 &amp; 3 \\
                4 &amp; 5 &amp; 6 \\
                7 &amp; 8 &amp; 9
                \end{bmatrix}
                \quad\Rightarrow\quad
                \text{Output: }
                \begin{bmatrix}
                7 &amp; 4 &amp; 1 \\
                8 &amp; 5 &amp; 2 \\
                9 &amp; 6 &amp; 3
                \end{bmatrix}
                $$</p>
            <p><strong>Mathematical formula (n√ón)</strong></p>
            <p>$$
                B_{r,c}=A_{n-1-c,\ r},\quad 0\le r,c&lt;n
                $$</p>
            <p><strong>Pseudocode (square, in-place via basics)</strong></p>
            <div>
                <pre><code class="language-shell">n = 3
# transpose
for r in 0..n-1:
  for c in r+1..n-1:
    swap A[r][c], A[c][r]
# reverse each row
for r in 0..n-1:
  for c in 0..(n//2 - 1):
    swap A[r][c], A[r][n-1-c]</code></pre>
            </div>
            <p><em>Example 2 (2√ó3 ‚Üí 3√ó2)</em></p>
            <p>$$
                \text{Input: }
                \begin{bmatrix}
                1 &amp; 2 &amp; 3 \\
                4 &amp; 5 &amp; 6
                \end{bmatrix}
                \quad\Rightarrow\quad
                \text{Output: }
                \begin{bmatrix}
                4 &amp; 1 \\
                5 &amp; 2 \\
                6 &amp; 3
                \end{bmatrix}
                $$</p>
            <p><strong>Mathematical formula (R√óC ‚Üí C√óR)</strong></p>
            <p>$$
                B_{r,c}=A_{R-1-c,\ r},\quad 0\le r&lt;C,\ 0\le c&lt;R\ \ (R{=}2,\ C{=}3)
                $$</p>
            <p><strong>Pseudocode (rectangular, direct mapping)</strong></p>
            <div>
                <pre><code class="language-shell">R, C = 2, 3
B = zeros(C, R)
for r in 0..C-1:      # rows of B
  for c in 0..R-1:    # cols of B
    B[r][c] = A[R-1-c][r]</code></pre>
            </div>
            <p><strong>How it works</strong></p>
            <p>Transpose swaps axes; reversing each row aligns columns to rows of the rotated image.</p>
            <ul>
                <li>Time: $O(R\cdot C)$</li>
                <li>Space: $O(1)$ in-place for square, else $O(R\cdot C)$ new</li>
            </ul>
            <h4 id="90-counterclockwise-ccw-">90¬∞ Counterclockwise (CCW)</h4>
            <p>Transpose, then reverse each column (or reverse rows, then transpose).</p>
            <p><strong>Example inputs and outputs</strong></p>
            <p><em>Example</em></p>
            <p>$$
                \text{Input: }
                \begin{bmatrix}
                1 &amp; 2 &amp; 3 \\
                4 &amp; 5 &amp; 6 \\
                7 &amp; 8 &amp; 9
                \end{bmatrix}
                \quad\Rightarrow\quad
                \text{Output: }
                \begin{bmatrix}
                3 &amp; 6 &amp; 9 \\
                2 &amp; 5 &amp; 8 \\
                1 &amp; 4 &amp; 7
                \end{bmatrix}
                $$</p>
            <p><strong>Mathematical formula (n√ón)</strong></p>
            <p>$$
                B_{r,c}=A_{c,\ n-1-r},\quad 0\le r,c&lt;n
                $$</p>
            <p><strong>Pseudocode (square, via basics)</strong></p>
            <div>
                <pre><code class="language-shell">n = 3
# transpose
for r in 0..n-1:
  for c in r+1..n-1:
    swap A[r][c], A[c][r]
# reverse each column (vertical flip)
for r in 0..(n//2 - 1):
  for c in 0..n-1:
    swap A[r][c], A[n-1-r][c]</code></pre>
            </div>
            <p><strong>Pseudocode (general, direct mapping)</strong></p>
            <div>
                <pre><code class="language-shell"># A is R x C, B is C x R
B = zeros(C, R)
for r in 0..C-1:
  for c in 0..R-1:
    B[r][c] = A[c][C-1-r]</code></pre>
            </div>
            <p><strong>How it works</strong></p>
            <p>Transpose, then flip vertically to complete the counterclockwise rotation.</p>
            <ul>
                <li>Time: $O(R\cdot C)$</li>
                <li>Space: $O(1)$ (square) or $O(R\cdot C)$</li>
            </ul>
            <h4 id="180-rotation">180¬∞ Rotation</h4>
            <p>Equivalent to reversing rows, then reversing columns (or two 90¬∞ rotations).</p>
            <p><strong>Example inputs and outputs</strong></p>
            <p><em>Example</em></p>
            <p>$$
                \text{Input: }
                \begin{bmatrix}
                1 &amp; 2 &amp; 3 \\
                4 &amp; 5 &amp; 6 \\
                7 &amp; 8 &amp; 9
                \end{bmatrix}
                \quad\Rightarrow\quad
                \text{Output: }
                \begin{bmatrix}
                9 &amp; 8 &amp; 7 \\
                6 &amp; 5 &amp; 4 \\
                3 &amp; 2 &amp; 1
                \end{bmatrix}
                $$</p>
            <p><strong>Mathematical formula (R√óC ‚Üí R√óC)</strong></p>
            <p>$$
                B_{r,c}=A_{R-1-r,\ C-1-c},\quad 0\le r&lt;R,\ 0\le c&lt;C
                $$</p>
            <p><strong>Pseudocode (in-place via two flips)</strong></p>
            <div>
                <pre><code class="language-shell">R, C = 3, 3  # generalize as needed
# reverse rows
for r in 0..R-1:
  for c in 0..(C//2 - 1):
    swap A[r][c], A[r][C-1-c]
# reverse columns
for r in 0..(R//2 - 1):
  for c in 0..C-1:
    swap A[r][c], A[R-1-r][c]</code></pre>
            </div>
            <p><strong>Pseudocode (direct mapping to new matrix)</strong></p>
            <div>
                <pre><code class="language-shell">B = zeros(R, C)
for r in 0..R-1:
  for c in 0..C-1:
    B[r][c] = A[R-1-r][C-1-c]</code></pre>
            </div>
            <p><strong>How it works</strong></p>
            <p>Horizontal + vertical flips relocate each element to $(R-1-r,\ C-1-c)$.</p>
            <ul>
                <li>Time: $O(R\cdot C)$</li>
                <li>Space: $O(1)$ (square) or $O(R\cdot C)$</li>
            </ul>
            <h4 id="270-rotation">270¬∞ Rotation</h4>
            <p>270¬∞ CW = 90¬∞ CCW; 270¬∞ CCW = 90¬∞ CW. Reuse the 90¬∞ procedures.</p>
            <p><strong>Mathematical formulas (general)</strong></p>
            <p>270¬∞ CW (i.e., 90¬∞ CCW):</p>
            <p>$$
                B_{r,c}=A_{c,\ C-1-r},\quad B\in\mathbb{R}^{C\times R}.
                $$</p>
            <p>270¬∞ CCW (i.e., 90¬∞ CW):</p>
            <p>$$
                B_{r,c}=A_{R-1-c,\ r},\quad B\in\mathbb{R}^{C\times R}.
                $$</p>
            <p><strong>Pseudocode (via composition, square in-place)</strong></p>
            <div>
                <pre><code class="language-shell"># 270¬∞ CW == 90¬∞ CCW
transpose(A)
reverse_columns_in_place(A)

# 270¬∞ CCW == 90¬∞ CW
transpose(A)
reverse_rows_in_place(A)</code></pre>
            </div>
            <h4 id="layer-by-layer-square-90-cw">Layer-by-Layer (Square) 90¬∞ CW</h4>
            <p>Rotate each ring by cycling 4 positions.</p>
            <p><strong>How it works</strong></p>
            <p>For layer $\ell$ with bounds $ [\ell..n-1-\ell]$, for each offset move:</p>
            <div>
                <pre><code class="language-shell">top ‚Üê left, left ‚Üê bottom, bottom ‚Üê right, right ‚Üê top</code></pre>
            </div>
            <p><strong>Mathematical mapping (per moved element)</strong></p>
            <p>For an $n\times n$ matrix and a position $(r,c)$ on layer $\ell$, a 90¬∞ CW rotation sends</p>
            <p>$$
                (r,c)\ \mapsto\ (c,\ n-1-r)\ \mapsto\ (n-1-r,\ n-1-c)\ \mapsto\ (n-1-c,\ r)
                $$</p>
            <p><strong>Pseudocode (explicit loops, in-place)</strong></p>
            <div>
                <pre><code class="language-shell">n = size(A)
for layer in 0..(n//2 - 1):
  first = layer
  last  = n - 1 - layer
  for i in first..last-1:
    offset = i - first

    # save top
    tmp = A[first][i]

    # left -&gt; top
    A[first][i] = A[last - offset][first]

    # bottom -&gt; left
    A[last - offset][first] = A[last][last - offset]

    # right -&gt; bottom
    A[last][last - offset] = A[i][last]

    # top (saved) -&gt; right
    A[i][last] = tmp</code></pre>
            </div>
            <ul>
                <li>Time: $O(n^{2})$</li>
                <li>Space: $O(1)$</li>
            </ul>
            <h3 id="traversal-patterns">Traversal Patterns</h3>
            <h4 id="spiral-order">Spiral Order</h4>
            <p>Read outer layer, then shrink bounds.</p>
            <p><strong>Example inputs and outputs</strong></p>
            <p><em>Example</em></p>
            <p>$$
                \text{Input: }
                \begin{bmatrix}
                1 &amp; 2 &amp; 3 &amp; 4 \\
                5 &amp; 6 &amp; 7 &amp; 8 \\
                9 &amp; 10 &amp; 11 &amp; 12
                \end{bmatrix}
                $$</p>
            <p>$$
                \text{Output sequence: } 1,2,3,4,8,12,11,10,9,5,6,7
                $$</p>
            <p><strong>Mathematical formulation (general $R\times C$)</strong></p>
            <p>Let the matrix indices be $(r,c)$ with $0\le r&lt;R,\ 0\le c&lt;C$. For layer $\ell=0,1,\dots,L-1$ where $L=\left\lceil \tfrac{\min(R,C)}{2}\right\rceil$, set</p>
            <p>$$
                t=\ell,\quad b=R-1-\ell,\quad left=\ell,\quad rgt=C-1-\ell
                $$</p>
            <p>Visit, in order:</p>
            <ul>
                <li>Top edge: $(t,c)$ for $c=left,\ldots,rgt$.</li>
                <li>Right edge: $(r,rgt)$ for $r=t+1,\ldots,b$.</li>
                <li>Bottom edge (if $b&gt;t$): $(b,c)$ for $c=rgt-1,\ldots,left$ (decreasing).</li>
                <li>Left edge (if $rgt&gt;left$): $(r,left)$ for $r=b-1,\ldots,t+1$ (decreasing).</li>
            </ul>
            <p>Concatenate these per layer until all elements are visited.</p>
            <p><strong>Pseudocode (loops)</strong></p>
            <div>
                <pre><code class="language-shell">R, C = dims(A)
top, bottom = 0, R - 1
left, right = 0, C - 1
out = []

while top &lt;= bottom and left &lt;= right:
  # top row
  for c in left..right:
    out.append(A[top][c])
  top += 1

  # right column
  for r in top..bottom:
    out.append(A[r][right])
  right -= 1

  # bottom row (if any)
  if top &lt;= bottom:
    for c in right..left step -1:
      out.append(A[bottom][c])
    bottom -= 1

  # left column (if any)
  if left &lt;= right:
    for r in bottom..top step -1:
      out.append(A[r][left])
    left += 1</code></pre>
            </div>
            <p><strong>How it works</strong></p>
            <p>Maintain top, bottom, left, right. Walk edges in order; after each edge, move the corresponding bound inward.</p>
            <ul>
                <li>Time: $O(R\cdot C)$</li>
                <li>Space: $O(1)$ beyond output.</li>
            </ul>
            <h4 id="diagonal-order-r-c-layers-">Diagonal Order (r+c layers)</h4>
            <p>Visit cells grouped by $s=r+c$; alternate direction per diagonal to keep locality if desired.</p>
            <p><strong>Example inputs and outputs</strong></p>
            <p><em>Example</em></p>
            <p>$$
                \text{Input: }
                \begin{bmatrix}
                a &amp; b &amp; c \\
                d &amp; e &amp; f
                \end{bmatrix}
                \quad\Rightarrow\quad
                \text{One order: } a, b, d, e, c, f
                $$</p>
            <p><strong>Mathematical formulation (general $R\times C$)</strong></p>
            <p>Let $s=r+c$. For $s=0,1,\dots,R+C-2$, define</p>
            <p>$$
                r_{\min}(s)=\max!\big(0,\ s-(C-1)\big)
                $$</p>
            <p>$$
                r_{\max}(s)=\min!\big(R-1,\ s\big)
                $$</p>
            <p>The diagonal set is ${(r,s-r)\mid r_{\min}(s)\le r\le r_{\max}(s)}$.</p>
            <p>Traverse with alternating direction:</p>
            <p>$$
                \begin{cases}
                \text{if } s \text{ even: } r=r_{\max}(s), r_{\max}(s)-1,\dots,r_{\min}(s);\[2pt]
                \text{if } s \text{ odd: } r=r_{\min}(s), r_{\min}(s)+1,\dots,r_{\max}(s).
                \end{cases}
                $$</p>
            <p>(This parity choice reproduces the example order $a,b,d,e,c,f$ for $R=2,C=3$.)</p>
            <p><strong>Pseudocode (loops, alternating direction)</strong></p>
            <div>
                <pre><code class="language-shell">R, C = dims(A)
out = []

for s in 0..(R + C - 2):
  r_lo = max(0, s - (C - 1))
  r_hi = min(R - 1, s)

  if s % 2 == 0:
    # even s: go downward-left (decreasing r)
    for r in r_hi..r_lo step -1:
      c = s - r
      out.append(A[r][c])
  else:
    # odd s: go upward-right (increasing r)
    for r in r_lo..r_hi:
      c = s - r
      out.append(A[r][c])</code></pre>
            </div>
            <ul>
                <li>Time: $O(R\cdot C)$</li>
                <li>Space: $O(1)$</li>
            </ul>
            <h3 id="grids-as-graphs">Grids as Graphs</h3>
            <p>Each cell is a node; edges connect neighboring walkable cells.</p>
            <p><strong>Grid-as-graph view (4-dir edges).</strong> Each cell is a node; edges connect neighbors that are ‚Äúpassable‚Äù. Great for BFS shortest paths on unweighted grids.</p>
            <p><strong>Example map (walls <code>#</code>, free <code>.</code>, start <code>S</code>, target <code>T</code>).</strong></p>
            <p>Left: the map. Right: BFS distances (4-dir) from <code>S</code> until <code>T</code> is reached.</p>
            <div>
                <pre><code class="language-shell">Original Map:
#####################
#S..#....#....#.....#
#.#.#.##.#.##.#.##..#
#.#...#..#.......#.T#
#...###.....###.....#
#####################

BFS layers (distance mod 10):
#####################
#012#8901#9012#45678#
#1#3#7##2#8##1#3##89#
#2#456#43#7890123#7X#
#345###54567###34567#
#####################

Legend: walls (#), goal reached (X)</code></pre>
            </div>
            <p>BFS explores in <strong>expanding ‚Äúrings‚Äù</strong>; with 4-dir edges, each step increases Manhattan distance by 1 (unless blocked). Time $O(RC)$, space $O(RC)$ with a visited matrix/queue.</p>
            <p><strong>Obstacles / costs / diagonals.</strong></p>
            <ul>
                <li>Obstacles: skip neighbors that are <code>#</code> (or where cost is $\infty$).</li>
                <li>Weighted grids: Dijkstra / 0-1 BFS on the same neighbor structure.</li>
                <li>8-dir with Euclidean costs: use $1$ for orthogonal moves and $\sqrt{2}$ for diagonals (A* often pairs well here with an admissible heuristic).</li>
            </ul>
            <p><strong>Common symbols:</strong></p>
            <div>
                <pre><code class="language-shell">. = free cell      # = wall/obstacle
S = start          T = target/goal
V = visited        * = on current path / frontier</code></pre>
            </div>
            <h4 id="bfs-shortest-path-unweighted-">BFS Shortest Path (Unweighted)</h4>
            <p>Find the minimum steps from S to T.</p>
            <p><strong>Example inputs and outputs</strong></p>
            <p><em>Example</em></p>
            <p>$$
                \text{Grid (0 = open, 1 = wall), } S = (0,0), T = (2,3)
                $$</p>
            <p>$$
                \begin{bmatrix}
                S &amp; 0 &amp; 1 &amp; 0 \\
                0 &amp; 0 &amp; 0 &amp; 0 \\
                1 &amp; 1 &amp; 0 &amp; T
                \end{bmatrix}
                \quad\Rightarrow\quad
                \text{Output: distance } = 5
                $$</p>
            <p><strong>How it works</strong></p>
            <p>Push S to a queue, expand in 4-dir layers, track distance/visited; stop when T is dequeued.</p>
            <ul>
                <li>Time: $O(R\cdot C)$</li>
                <li>Space: $O(R\cdot C)$</li>
            </ul>
            <h4 id="connected-components-islands-">Connected Components (Islands)</h4>
            <p>Count regions of ‚Äò1‚Äôs via DFS/BFS.</p>
            <p><strong>Example inputs and outputs</strong></p>
            <p>$$
                \text{Input: }
                \begin{bmatrix}
                1 &amp; 1 &amp; 0 \\
                0 &amp; 1 &amp; 0 \\
                0 &amp; 0 &amp; 1
                \end{bmatrix}
                \quad\Rightarrow\quad
                \text{Output: } 2 \ \text{islands}
                $$</p>
            <p><strong>How it works</strong></p>
            <p>Scan cells; when an unvisited ‚Äò1‚Äô is found, flood it (DFS/BFS) to mark the whole island.</p>
            <ul>
                <li>Time: $O(R\cdot C)$</li>
                <li>Space: $O(R\cdot C)$ worst-case</li>
            </ul>
            <h3 id="backtracking-on-grids">Backtracking on Grids</h3>
            <h4 id="word-search-single-word-">Word Search (Single Word)</h4>
            <p>Find a word by moving to adjacent cells (4-dir), using each cell once per path.</p>
            <p><strong>Example inputs and outputs</strong></p>
            <p>$$
                \text{Board: }
                \begin{bmatrix}
                A &amp; B &amp; C &amp; E \\
                S &amp; F &amp; C &amp; S \\
                A &amp; D &amp; E &amp; E
                \end{bmatrix},
                \quad
                \text{Word: } "ABCCED"
                \quad\Rightarrow\quad
                \text{Output: true}
                $$</p>
            <p><strong>Mathematical formulation (general)</strong></p>
            <p>Let the word be $W=W_0W_1\cdots W_{L-1}$ and the grid be $G\in\Sigma^{R\times C}$.
                We seek a path $P=\big((r_0,c_0),\ldots,(r_{L-1},c_{L-1})\big)$ such that</p>
            <p>$$
                \begin{aligned}
                &amp;\text{(match)} &amp;&amp; G_{r_i,c_i}=W_i,\quad i=0,\ldots,L-1;\\
                &amp;\text{(adjacent)} &amp;&amp; |r_{i+1}-r_i|+|c_{i+1}-c_i|=1,\quad i=0,\ldots,L-2;\\
                &amp;\text{(no reuse)} &amp;&amp; (r_i,c_i)\neq(r_j,c_j)\ \text{for all }i\ne j.
                \end{aligned}
                $$</p>
            <p><strong>Instantiation for the example (one valid path)</strong></p>
            <p>$$
                P=\big((0,0),(0,1),(0,2),(1,2),(2,2),(2,1)\big)
                $$</p>
            <p>gives $A\to B\to C\to C\to E\to D = \text{"ABCCED"}$.</p>
            <p><strong>Pseudocode (DFS with loops over starts and 4-neighbors)</strong></p>
            <div>
                <pre><code class="language-shell">R, C = dims(board)
L = len(word)
visited = array(R, C, fill=false)
dr = [1, -1, 0, 0]
dc = [0, 0, 1, -1]

def dfs(r, c, i):
  if r &lt; 0 or r &gt;= R or c &lt; 0 or c &gt;= C: 
    return false
  if visited[r][c] or board[r][c] != word[i]:
    return false
  if i == L - 1:
    return true

  visited[r][c] = true
  for k in 0..3:
    nr = r + dr[k]
    nc = c + dc[k]
    if dfs(nr, nc, i + 1):
      return true
  visited[r][c] = false
  return false

# try every starting cell
for r in 0..R-1:
  for c in 0..C-1:
    if dfs(r, c, 0):
      return true
return false</code></pre>
            </div>
            <p><strong>How it works</strong></p>
            <p>From each starting match, DFS to next char; mark visited (temporarily), backtrack on failure.</p>
            <ul>
                <li>Time: up to $O(R\cdot C\cdot b^{L})$ (branching $b\in [3,4]$, word length $L$)</li>
                <li>Space: $O(L)$</li>
            </ul>
            <p>Pruning: early letter mismatch; frequency precheck; prefix trie when searching many words.</p>
            <h4 id="crossword-style-fill-multiple-words-">Crossword-style Fill (Multiple Words)</h4>
            <p>Place words to slots with crossings; verify consistency at intersections.</p>
            <p><strong>Mathematical formulation</strong></p>
            <p>Let $S$ be the set of slots (across/down). Each slot $s\in S$ has a length $\ell(s)$ and ordered cell coordinates
                $\mathrm{cells}(s) = \big((r_0,c_0),\ldots,(r_{\ell(s)-1},c_{\ell(s)-1})\big)$.
                Let $D$ be the dictionary; define $D_\ell={w\in D:|w|=\ell}$.
                Known letters from the grid induce a pattern constraint $P_s\in(\Sigma\cup{_})^{\ell(s)}$.</p>
            <p>Find an assignment $f:S\to D$ such that, for all $s\in S$,</p>
            <p>$$
                f(s)\in D_{\ell(s)}\quad\text{and}\quad
                \forall i\ (P_s[i]\neq _ \Rightarrow f(s)[i]=P_s[i]),
                $$</p>
            <p>and for every intersection between slots $s$ at index $i$ and $t$ at index $j$,</p>
            <p>$$
                f(s)[i]=f(t)[j].
                $$</p>
            <p>(Optionally enforce all-different: $s\neq t \Rightarrow f(s)\neq f(t)$.)</p>
            <p><strong>Pseudocode (backtracking with loops, MRV + trie filtering)</strong></p>
            <div>
                <pre><code class="language-shell"># Preprocess
slots = extract_slots(grid)                  # with cells(s) and pattern P_s
trie = build_trie(dictionary)                # for prefix/length checks

# Build initial domains from patterns and lengths
domains = dict()
for s in slots:
  domains[s] = { w in dictionary | len(w) == len(s) and matches_pattern(w, P_s) }

# Order slots: Most-Restricted-Variable (smallest domain first)
slots.sort_by(|domains[s]| ascending, tiebreak by number_of_intersections)

used = set()          # if words must be unique
assignment = dict()

def consistent(s, w):
  # check crossings vs assigned neighbors
  for each intersection (s,i) with (t,j):
    if t in assignment and assignment[t][j] != w[i]:
      return false
  return true

def forward_check_update_domains(s, w, removed):
  # reduce neighbor domains by letter constraints from placing w at s
  for each intersection (s,i) with (t,j):
    for each v in copy(domains[t]):
      if v[j] != w[i]:
        domains[t].remove(v); removed.append((t, v))

def undo_forward_check(removed):
  for (t, v) in removed:
    domains[t].add(v)

def backtrack(idx):
  if idx == len(slots):
    return true

  s = slots[idx]

  # iterate candidates; optionally skip ones already used
  for w in iterate(domains[s]):
    if w in used: 
      continue
    if not consistent(s, w):
      continue

    assignment[s] = w
    used.add(w)
    removed = []
    forward_check_update_domains(s, w, removed)

    if backtrack(idx + 1):
      return true

    undo_forward_check(removed)
    used.remove(w)
    del assignment[s]

  return false

# Start search
if backtrack(0):
  return assignment  # filled crossword
else:
  return failure</code></pre>
            </div>
            <p><strong>How it works</strong></p>
            <p>Backtrack over slot assignments; use a trie for prefix feasibility; order by most constrained slot first.</p>
            <ul>
                <li>Time: exponential in slots; strong pruning and good heuristics are important.</li>
            </ul>
        </article-section>
        <div id="table-of-contents">
            <h2>Table of Contents</h2>
            <ol><a href="#matrices-and-2d-grids">Matrices and 2D Grids</a>
                <ol>
                    <li><a href="#conventions">Conventions</a></li>
                    <li><a href="#basic-operations-building-blocks-">Basic Operations (Building Blocks)</a>
                        <ol>
                            <li><a href="#transpose">Transpose</a></li>
                            <li><a href="#reverse-rows-horizontal-flip-">Reverse Rows (Horizontal Flip)</a></li>
                            <li><a href="#reverse-columns-vertical-flip-">Reverse Columns (Vertical Flip)</a></li>
                        </ol>
                    </li>
                    <li><a href="#rotations-composed-from-basics-">Rotations (Composed from Basics)</a>
                        <ol>
                            <li><a href="#90-clockwise-cw-">90¬∞ Clockwise (CW)</a></li>
                            <li><a href="#90-counterclockwise-ccw-">90¬∞ Counterclockwise (CCW)</a></li>
                            <li><a href="#180-rotation">180¬∞ Rotation</a></li>
                            <li><a href="#270-rotation">270¬∞ Rotation</a></li>
                            <li><a href="#layer-by-layer-square-90-cw">Layer-by-Layer (Square) 90¬∞ CW</a></li>
                        </ol>
                    </li>
                    <li><a href="#traversal-patterns">Traversal Patterns</a>
                        <ol>
                            <li><a href="#spiral-order">Spiral Order</a></li>
                            <li><a href="#diagonal-order-r-c-layers-">Diagonal Order (r+c layers)</a></li>
                        </ol>
                    </li>
                    <li><a href="#grids-as-graphs">Grids as Graphs</a>
                        <ol>
                            <li><a href="#bfs-shortest-path-unweighted-">BFS Shortest Path (Unweighted)</a></li>
                            <li><a href="#connected-components-islands-">Connected Components (Islands)</a></li>
                        </ol>
                    </li>
                    <li><a href="#backtracking-on-grids">Backtracking on Grids</a>
                        <ol>
                            <li><a href="#word-search-single-word-">Word Search (Single Word)</a></li>
                            <li><a href="#crossword-style-fill-multiple-words-">Crossword-style Fill (Multiple Words)</a></li>
                        </ol>
                    </li>
                </ol>
            </ol>
            <div id="related-articles">
                <h2>Related Articles</h2>
                <ol>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/backtracking.html">Backtracking</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/basic_concepts.html">Basic Concepts</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/brain_teasers.html">Brain Teasers</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/data_structures.html">Data Structures</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/dynamic_programming.html">Dynamic Programming</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/graphs.html">Graphs</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/greedy_algorithms.html">Greedy Algorithms</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/matrices.html">Matrices</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/searching.html">Searching</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/sorting.html">Sorting</a></li>
                </ol>
            </div>
        </div>
    </div>
    <footer>
        <div class="footer-columns">
            <div class="footer-column footer-about">
                <h2>About</h2>
                <p class="footer-message">Thanks for stopping by. This site is free to use; please be respectful and avoid misuse. For questions or collaboration, reach me on <a href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" title="LinkedIn Profile">LinkedIn</a> or <a href="https://github.com/djeada" title="GitHub Profile">GitHub</a>.</p>
                <p class="footer-signature">Built with care in Berlin (UTC+1).</p>
            </div>
            <div class="footer-column footer-links">
                <h2>Quick Links</h2>
                <ul class="footer-links-list">
                    <li><a href="https://adamdjellouli.com/index.html" title="Home">Home</a></li>
                    <li><a href="https://adamdjellouli.com/core/projects.html" title="Projects">Projects</a></li>
                    <li><a href="https://adamdjellouli.com/core/tools.html" title="Tools">Tools</a></li>
                    <li><a href="https://adamdjellouli.com/core/courses.html" title="Courses">Courses</a></li>
                    <li><a href="https://adamdjellouli.com/core/resume.html" title="Resume">Resume</a></li>
                    <li><a href="https://adamdjellouli.com/core/privacy_policy.html" title="Privacy Policy">Privacy Policy</a></li>
                    <li><a href="https://adamdjellouli.com/sitemap.xml" title="Sitemap">Sitemap</a></li>
                </ul>
            </div>
            <div class="footer-column footer-social">
                <h2>Follow</h2>
                <ul class="social-media">
                    <li>
                        <a aria-label="YouTube" class="fa fa-youtube" href="https://www.youtube.com/channel/UCGPoHTVjMN77wcGknXPHl1Q" rel="noopener" target="_blank" title="YouTube"></a>
                        <span class="social-label">YouTube</span>
                    </li>
                    <li>
                        <a aria-label="LinkedIn" class="fa fa-linkedin" href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" rel="noopener" target="_blank" title="LinkedIn"></a>
                        <span class="social-label">LinkedIn</span>
                    </li>
                    <li>
                        <a aria-label="Instagram" class="fa fa-instagram" href="https://www.instagram.com/linuxchallenges/" rel="noopener" target="_blank" title="Instagram"></a>
                        <span class="social-label">Instagram</span>
                    </li>
                    <li>
                        <a aria-label="GitHub" class="fa fa-github" href="https://github.com/djeada" title="GitHub"></a>
                        <span class="social-label">GitHub</span>
                    </li>
                </ul>
                <img alt="" aria-hidden="true" class="footer-mark" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/symbol.png" />
            </div>
        </div>
        <div class="footer-bottom">
            <p id="copyright">
                ¬© Adam Djellouli. All rights reserved.
            </p>
        </div>
        <script>
            document.getElementById("copyright").innerHTML = "&copy; " + new Date().getFullYear() + " Adam Djellouli. All rights reserved.";
        </script>
        <script src="/app.js"></script>
    </footer>
    <div id="pdf-spinner-overlay">
        <div class="spinner"></div>
    </div>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-bash.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-cpp.min.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
jax: ["input/TeX", "output/HTML-CSS"],
extensions: ["tex2jax.js"],
"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] },
tex2jax: { inlineMath: [ ["$", "$"] ], displayMath: [ ["$$","$$"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
TeX: { noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } } },
messageStyle: "none"
});
</script>
<script async="" id="MathJax-script" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>

</html>