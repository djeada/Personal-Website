<!DOCTYPE html>

<html lang="en">

<head>
    <script async="" crossorigin="anonymous" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5593122079896089"></script>
    <meta charset="utf-8" />
    <title>Matrices and 2D Grids</title>
    <meta content="Matrices represent images, game boards, and maps." name="description" />
    <meta content="Adam Djellouli" name="author" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <meta content="IE=edge" http-equiv="X-UA-Compatible" />
    <link crossorigin="" href="https://fonts.googleapis.com" rel="preconnect" />
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/icon.ico" rel="icon" />
    <link href="../../resources/style.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
</head>

<body>
    <nav aria-label="Main navigation">
        <a class="logo" href="https://adamdjellouli.com">
            <img alt="Adam Djellouli - Home Page Logo" id="logo-image" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/logo.PNG" />
        </a>
        <input aria-label="Toggle navigation menu" id="navbar-toggle" type="checkbox" />
        <ul aria-labelledby="navbar-toggle" role="menu">
            <li role="menuitem">
                <a href="../../index.html" title="Go to Home Page"> Home </a>
            </li>
            <li role="menuitem">
                <a class="active" href="../../core/blog.html" title="Read Adam Djellouli Blog on Programming and Technology"> Blog </a>
            </li>
            <li role="menuitem">
                <a href="../../core/tools.html" title="Discover Tools Created by Adam Djellouli"> Tools </a>
            </li>
            <li role="menuitem">
                <a href="../../core/projects.html" title="Explore Projects Developed by Adam Djellouli"> Projects </a>
            </li>
            <li role="menuitem">
                <a href="../../core/resume.html" title="View Adam Djellouli Professional Resume"> Resume </a>
            </li>
            <li>
                <script async="" src="https://cse.google.com/cse.js?cx=8160ef9bb935f4f68"></script>
                <div class="gcse-search"></div>
            </li>
            <li>
                <button aria-label="Toggle dark mode" id="dark-mode-button"></button>
            </li>
        </ul>
    </nav>
    <div id="article-wrapper"><article-section id="article-body">
            <div class="article-action-buttons"><button class="btn-suggest-edit" title="Suggest Edit">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <path d="M4 21h4l11-11-4-4L4 17v4z" stroke="currentColor" stroke-width="2"></path>
                    </svg>
                </button><button class="btn-create-issue" title="Create Issue">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2"></circle>
                        <line stroke="currentColor" stroke-width="2" x1="12" x2="12" y1="8" y2="12"></line>
                        <circle cx="12" cy="16" fill="currentColor" r="1"></circle>
                    </svg>
                </button><button class="btn-download" title="Download">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <path d="M12 5v14m0 0l-6-6m6 6l6-6" stroke="currentColor" stroke-width="2"></path>
                    </svg>
                </button></div>
            <p style="text-align: right;"><i>Last modified: September 14, 2025</i></p>
            <p style="text-align: right;"><i>This article is written in: 🇺🇸</i></p>
            <h2 id="matrices-and-2d-grids">Matrices and 2D Grids</h2>
            <p>Matrices represent images, game boards, and maps. Many classic problems reduce to transforming matrices, traversing them, or treating grids as graphs for search.</p>
            <h3 id="conventions">Conventions</h3>
            <p><strong>Rows indexed $0..R-1$, columns $0..C-1$; cell $(r,c)$.</strong></p>
            <p>Rows increase <strong>down</strong>, columns increase <strong>right</strong>. Think “top-left is $(0,0)$”, not a Cartesian origin.</p>
            <p>Visual index map (example $R=6$, $C=8$; each cell labeled $rc$):</p>
            <p>
            <div>
                <pre><code class="language-shell">c →    0    1    2    3    4    5    6    7
r ↓   +----+----+----+----+----+----+----+----+
0     | 00 | 01 | 02 | 03 | 04 | 05 | 06 | 07 |
	  +----+----+----+----+----+----+----+----+
1     | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 |
	  +----+----+----+----+----+----+----+----+
2     | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 |
	  +----+----+----+----+----+----+----+----+
3     | 30 | 31 | 32 | 33 | 34 | 35 | 36 | 37 |
	  +----+----+----+----+----+----+----+----+
4     | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 |
	  +----+----+----+----+----+----+----+----+
5     | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 |
	  +----+----+----+----+----+----+----+----+</code></pre>
            </div>
            </p>
            <p>Handy conversions (for linearization / array-of-arrays):</p>
            <ul>
                <li>Linear index: $\text{id}=r\cdot C+c$.</li>
                <li>From id: $r=\lfloor \text{id}/C \rfloor$, $c=\text{id}\bmod C$.</li>
                <li>Row-major scan order (common in problems): for $r$ in $0..R-1$, for $c$ in $0..C-1$.</li>
            </ul>
            <p><strong>Row-major vs column-major arrows (same $3\times 6$ grid):</strong></p>
            <p>
            <div>
                <pre><code class="language-shell">Row-major (r, then c):                  Column-major (c, then r):
→ → → → → →                              ↓ ↓ ↓
          ↓                              ↓ ↓ ↓
← ← ← ← ← ←                              ↓ ↓ ↓
↓                                        ↓ ↓ ↓
→ → → → → →                              ↓ ↓ ↓</code></pre>
            </div>
            </p>
            <p><strong>Neighborhoods: $\mathbf{4}$-dir $\Delta={(-1,0),(1,0),(0,-1),(0,1)}$; $\mathbf{8}$-dir adds diagonals.</strong></p>
            <p>The offsets $(\Delta r,\Delta c)$ are applied as $(r+\Delta r,\ c+\Delta c)$.</p>
            <p><strong>4-neighborhood (“+”):</strong></p>
            <p>
            <div>
                <pre><code class="language-shell">#
		   (r-1,c)
			 ↑
  (r,c-1) ← (r,c) → (r,c+1)
			 ↓
		   (r+1,c)</code></pre>
            </div>
            </p>
            <p><strong>8-neighborhood (“×” adds diagonals):</strong></p>
            <p>
            <div>
                <pre><code class="language-shell">(r-1,c-1)   (r-1,c)   (r-1,c+1)
	  \       ↑       /
	   \      │      /
(r,c-1) ←———  (r,c)  ———→ (r,c+1)
	   /      │      \
	  /       ↓       \
(r+1,c-1)   (r+1,c)   (r+1,c+1)</code></pre>
            </div>
            </p>
            <p>Typical direction arrays (keep them consistent to avoid bugs):</p>
            <p>
            <div>
                <pre><code class="language-shell">// 4-dir
dr = [-1, 1,  0, 0]
dc = [ 0, 0, -1, 1]

// 8-dir
dr8 = [-1,-1,-1, 0, 0, 1, 1, 1]
dc8 = [-1, 0, 1,-1, 1,-1, 0, 1]</code></pre>
            </div>
            </p>
            <p><strong>Boundary checks</strong> (always guard neighbors):</p>
            <p>
            <div>
                <pre><code class="language-shell">0 ≤ nr &lt; R  and  0 ≤ nc &lt; C</code></pre>
            </div>
            </p>
            <p><strong>Edge/inside intuition:</strong></p>
            <p>
            <div>
                <pre><code class="language-shell">out of bounds
	┌─────────────────┐
	│ · · · · · · · · │
	│ · +---+---+---+ │
	│ · | a | b | c | │   ← valid cells
	│ · +---+---+---+ │
	│ · | d | e | f | │
	│ · +---+---+---+ │
	│ · · · · · · · · │
	└─────────────────┘</code></pre>
            </div>
            </p>
            <h3 id="basic-operations-building-blocks-">Basic Operations (Building Blocks)</h3>
            <h4 id="transpose">Transpose</h4>
            <p>Swap across the main diagonal: $A_{r,c} \leftrightarrow A_{c,r}$ (square). For non-square, result shape is $C\times R$.</p>
            <p><strong>Example inputs and outputs</strong></p>
            <p><em>Example 1 (square)</em></p>
            <p>$$
                A = \begin{bmatrix}
                1 &amp; 2 &amp; 3 \\
                4 &amp; 5 &amp; 6 \\
                7 &amp; 8 &amp; 9
                \end{bmatrix}
                \quad\Rightarrow\quad
                A^{\mathsf{T}} =
                \begin{bmatrix}
                1 &amp; 4 &amp; 7 \\
                2 &amp; 5 &amp; 8 \\
                3 &amp; 6 &amp; 9
                \end{bmatrix}
                $$</p>
            <p><strong>Mathematical formula (3×3)</strong></p>
            <p>$$
                (A^T)<em>{r,c}=A</em>{c,r},\quad 0\le r,c&lt;3
                $$</p>
            <p><strong>Pseudocode (square, in-place)</strong></p>
            <p>
            <div>
                <pre><code class="language-shell">n = 3  # for this example; generalize to n = size
for r in 0..n-1:
  for c in r+1..n-1:
    swap A[r][c], A[c][r]</code></pre>
            </div>
            </p>
            <p><em>Example 2 (rectangular)</em></p>
            <p>$$
                \text{Input: } \quad
                A = \begin{bmatrix}
                1 &amp; 2 &amp; 3 \\
                4 &amp; 5 &amp; 6
                \end{bmatrix}
                \ (2 \times 3)
                $$</p>
            <p>$$
                \text{Output: } \quad
                A^{\mathsf{T}} = \begin{bmatrix}
                1 &amp; 4 \\
                2 &amp; 5 \\
                3 &amp; 6
                \end{bmatrix}
                \ (3 \times 2)
                $$</p>
            <p><strong>Mathematical formula (2×3 → 3×2)</strong></p>
            <p>$$
                (A^{\mathsf T})<em>{r,c}=A</em>{c,r},\quad 0\le r&lt;3,\ 0\le c&lt;2
                $$</p>
            <p><strong>Pseudocode (rectangular, new matrix)</strong></p>
            <p>
            <div>
                <pre><code class="language-shell">R, C = 2, 3
B = zeros(C, R)
for r in 0..R-1:
  for c in 0..C-1:
    B[c][r] = A[r][c]</code></pre>
            </div>
            </p>
            <p><strong>How it works</strong></p>
            <p>Iterate pairs once and swap. For square matrices, can be in-place by visiting only $c&gt;r$.</p>
            <ul>
                <li>Time: $O(R\cdot C)$</li>
                <li>Space: $O(1)$ in-place (square), else $O(R\cdot C)$ to allocate</li>
            </ul>
            <h4 id="reverse-rows-horizontal-flip-">Reverse Rows (Horizontal Flip)</h4>
            <p>Reverse each row left $\leftrightarrow$ right.</p>
            <p><strong>Example inputs and outputs</strong></p>
            <p><em>Example</em></p>
            <p>$$
                \text{Input: }
                \begin{bmatrix}
                1 &amp; 2 &amp; 3 \\
                4 &amp; 5 &amp; 6
                \end{bmatrix}
                \quad\Rightarrow\quad
                \text{Output: }
                \begin{bmatrix}
                3 &amp; 2 &amp; 1 \\
                6 &amp; 5 &amp; 4
                \end{bmatrix}
                $$</p>
            <p><strong>Mathematical formula (2×3)</strong></p>
            <p>$$
                B_{r,c}=A_{r,\ C-1-c},\quad 0\le r&lt;2,\ 0\le c&lt;3
                $$</p>
            <p><strong>Pseudocode (in-place)</strong></p>
            <p>
            <div>
                <pre><code class="language-shell">R, C = 2, 3
for r in 0..R-1:
  for c in 0..(C//2 - 1):
    swap A[r][c], A[r][C-1-c]</code></pre>
            </div>
            </p>
            <ul>
                <li>Time: $O(R\cdot C)$</li>
                <li>Space: $O(1)$</li>
            </ul>
            <h4 id="reverse-columns-vertical-flip-">Reverse Columns (Vertical Flip)</h4>
            <p>Reverse each column top $\leftrightarrow$ bottom.</p>
            <p><strong>Example inputs and outputs</strong></p>
            <p><em>Example</em></p>
            <p>$$
                \text{Input: }
                \begin{bmatrix}
                1 &amp; 2 &amp; 3 \\
                4 &amp; 5 &amp; 6 \\
                7 &amp; 8 &amp; 9
                \end{bmatrix}
                \quad\Rightarrow\quad
                \text{Output: }
                \begin{bmatrix}
                7 &amp; 8 &amp; 9 \\
                4 &amp; 5 &amp; 6 \\
                1 &amp; 2 &amp; 3
                \end{bmatrix}
                $$</p>
            <p><strong>Mathematical formula (3×3)</strong></p>
            <p>$$
                B_{r,c}=A_{R-1-r,\ c},\quad 0\le r,c&lt;3
                $$</p>
            <p><strong>Pseudocode (in-place)</strong></p>
            <p>
            <div>
                <pre><code class="language-shell">R, C = 3, 3
for r in 0..(R//2 - 1):
  for c in 0..C-1:
    swap A[r][c], A[R-1-r][c]</code></pre>
            </div>
            </p>
            <ul>
                <li>Time: $O(R\cdot C)$</li>
                <li>Space: $O(1)$</li>
            </ul>
            <h3 id="rotations-composed-from-basics-">Rotations (Composed from Basics)</h3>
            <p>Use transpose + reversals for square in-place rotations; rectangular rotations produce new shape $(R\times C)\to(C\times R)$.</p>
            <h4 id="90-clockwise-cw-">90° Clockwise (CW)</h4>
            <p>Transpose, then reverse each row.</p>
            <p><strong>Example inputs and outputs</strong></p>
            <p><em>Example 1 (3×3)</em></p>
            <p>$$
                \text{Input: }
                \begin{bmatrix}
                1 &amp; 2 &amp; 3 \\
                4 &amp; 5 &amp; 6 \\
                7 &amp; 8 &amp; 9
                \end{bmatrix}
                \quad\Rightarrow\quad
                \text{Output: }
                \begin{bmatrix}
                7 &amp; 4 &amp; 1 \\
                8 &amp; 5 &amp; 2 \\
                9 &amp; 6 &amp; 3
                \end{bmatrix}
                $$</p>
            <p><strong>Mathematical formula (n×n)</strong></p>
            <p>$$
                B_{r,c}=A_{n-1-c,\ r},\quad 0\le r,c&lt;n
                $$</p>
            <p><strong>Pseudocode (square, in-place via basics)</strong></p>
            <p>
            <div>
                <pre><code class="language-shell">n = 3
# transpose
for r in 0..n-1:
  for c in r+1..n-1:
    swap A[r][c], A[c][r]
# reverse each row
for r in 0..n-1:
  for c in 0..(n//2 - 1):
    swap A[r][c], A[r][n-1-c]</code></pre>
            </div>
            </p>
            <p><em>Example 2 (2×3 → 3×2)</em></p>
            <p>$$
                \text{Input: }
                \begin{bmatrix}
                1 &amp; 2 &amp; 3 \\
                4 &amp; 5 &amp; 6
                \end{bmatrix}
                \quad\Rightarrow\quad
                \text{Output: }
                \begin{bmatrix}
                4 &amp; 1 \\
                5 &amp; 2 \\
                6 &amp; 3
                \end{bmatrix}
                $$</p>
            <p><strong>Mathematical formula (R×C → C×R)</strong></p>
            <p>$$
                B_{r,c}=A_{R-1-c,\ r},\quad 0\le r&lt;C,\ 0\le c&lt;R\ \ (R{=}2,\ C{=}3)
                $$</p>
            <p><strong>Pseudocode (rectangular, direct mapping)</strong></p>
            <p>
            <div>
                <pre><code class="language-shell">R, C = 2, 3
B = zeros(C, R)
for r in 0..C-1:      # rows of B
  for c in 0..R-1:    # cols of B
    B[r][c] = A[R-1-c][r]</code></pre>
            </div>
            </p>
            <p><strong>How it works</strong></p>
            <p>Transpose swaps axes; reversing each row aligns columns to rows of the rotated image.</p>
            <ul>
                <li>Time: $O(R\cdot C)$</li>
                <li>Space: $O(1)$ in-place for square, else $O(R\cdot C)$ new</li>
            </ul>
            <h4 id="90-counterclockwise-ccw-">90° Counterclockwise (CCW)</h4>
            <p>Transpose, then reverse each column (or reverse rows, then transpose).</p>
            <p><strong>Example inputs and outputs</strong></p>
            <p><em>Example</em></p>
            <p>$$
                \text{Input: }
                \begin{bmatrix}
                1 &amp; 2 &amp; 3 \\
                4 &amp; 5 &amp; 6 \\
                7 &amp; 8 &amp; 9
                \end{bmatrix}
                \quad\Rightarrow\quad
                \text{Output: }
                \begin{bmatrix}
                3 &amp; 6 &amp; 9 \\
                2 &amp; 5 &amp; 8 \\
                1 &amp; 4 &amp; 7
                \end{bmatrix}
                $$</p>
            <p><strong>Mathematical formula (n×n)</strong></p>
            <p>$$
                B_{r,c}=A_{c,\ n-1-r},\quad 0\le r,c&lt;n
                $$</p>
            <p><strong>Pseudocode (square, via basics)</strong></p>
            <p>
            <div>
                <pre><code class="language-shell">n = 3
# transpose
for r in 0..n-1:
  for c in r+1..n-1:
    swap A[r][c], A[c][r]
# reverse each column (vertical flip)
for r in 0..(n//2 - 1):
  for c in 0..n-1:
    swap A[r][c], A[n-1-r][c]</code></pre>
            </div>
            </p>
            <p><strong>Pseudocode (general, direct mapping)</strong></p>
            <p>
            <div>
                <pre><code class="language-shell"># A is R x C, B is C x R
B = zeros(C, R)
for r in 0..C-1:
  for c in 0..R-1:
    B[r][c] = A[c][C-1-r]</code></pre>
            </div>
            </p>
            <p><strong>How it works</strong></p>
            <p>Transpose, then flip vertically to complete the counterclockwise rotation.</p>
            <ul>
                <li>Time: $O(R\cdot C)$</li>
                <li>Space: $O(1)$ (square) or $O(R\cdot C)$</li>
            </ul>
            <h4 id="180-rotation">180° Rotation</h4>
            <p>Equivalent to reversing rows, then reversing columns (or two 90° rotations).</p>
            <p><strong>Example inputs and outputs</strong></p>
            <p><em>Example</em></p>
            <p>$$
                \text{Input: }
                \begin{bmatrix}
                1 &amp; 2 &amp; 3 \\
                4 &amp; 5 &amp; 6 \\
                7 &amp; 8 &amp; 9
                \end{bmatrix}
                \quad\Rightarrow\quad
                \text{Output: }
                \begin{bmatrix}
                9 &amp; 8 &amp; 7 \\
                6 &amp; 5 &amp; 4 \\
                3 &amp; 2 &amp; 1
                \end{bmatrix}
                $$</p>
            <p><strong>Mathematical formula (R×C → R×C)</strong></p>
            <p>$$
                B_{r,c}=A_{R-1-r,\ C-1-c},\quad 0\le r&lt;R,\ 0\le c&lt;C
                $$</p>
            <p><strong>Pseudocode (in-place via two flips)</strong></p>
            <p>
            <div>
                <pre><code class="language-shell">R, C = 3, 3  # generalize as needed
# reverse rows
for r in 0..R-1:
  for c in 0..(C//2 - 1):
    swap A[r][c], A[r][C-1-c]
# reverse columns
for r in 0..(R//2 - 1):
  for c in 0..C-1:
    swap A[r][c], A[R-1-r][c]</code></pre>
            </div>
            </p>
            <p><strong>Pseudocode (direct mapping to new matrix)</strong></p>
            <p>
            <div>
                <pre><code class="language-shell">B = zeros(R, C)
for r in 0..R-1:
  for c in 0..C-1:
    B[r][c] = A[R-1-r][C-1-c]</code></pre>
            </div>
            </p>
            <p><strong>How it works</strong></p>
            <p>Horizontal + vertical flips relocate each element to $(R-1-r,\ C-1-c)$.</p>
            <ul>
                <li>Time: $O(R\cdot C)$</li>
                <li>Space: $O(1)$ (square) or $O(R\cdot C)$</li>
            </ul>
            <h4 id="270-rotation">270° Rotation</h4>
            <p>270° CW = 90° CCW; 270° CCW = 90° CW. Reuse the 90° procedures.</p>
            <p><strong>Mathematical formulas (general)</strong></p>
            <p>270° CW (i.e., 90° CCW):</p>
            <p>$$
                B_{r,c}=A_{c,\ C-1-r},\quad B\in\mathbb{R}^{C\times R}.
                $$</p>
            <p>270° CCW (i.e., 90° CW):</p>
            <p>$$
                B_{r,c}=A_{R-1-c,\ r},\quad B\in\mathbb{R}^{C\times R}.
                $$</p>
            <p><strong>Pseudocode (via composition, square in-place)</strong></p>
            <p>
            <div>
                <pre><code class="language-shell"># 270° CW == 90° CCW
transpose(A)
reverse_columns_in_place(A)

# 270° CCW == 90° CW
transpose(A)
reverse_rows_in_place(A)</code></pre>
            </div>
            </p>
            <h4 id="layer-by-layer-square-90-cw">Layer-by-Layer (Square) 90° CW</h4>
            <p>Rotate each ring by cycling 4 positions.</p>
            <p><strong>How it works</strong></p>
            <p>For layer $\ell$ with bounds $ [\ell..n-1-\ell]$, for each offset move:</p>
            <p>
            <div>
                <pre><code class="language-shell">top ← left, left ← bottom, bottom ← right, right ← top</code></pre>
            </div>
            </p>
            <p><strong>Mathematical mapping (per moved element)</strong></p>
            <p>For an $n\times n$ matrix and a position $(r,c)$ on layer $\ell$, a 90° CW rotation sends</p>
            <p>$$
                (r,c)\ \mapsto\ (c,\ n-1-r)\ \mapsto\ (n-1-r,\ n-1-c)\ \mapsto\ (n-1-c,\ r)
                $$</p>
            <p><strong>Pseudocode (explicit loops, in-place)</strong></p>
            <p>
            <div>
                <pre><code class="language-shell">n = size(A)
for layer in 0..(n//2 - 1):
  first = layer
  last  = n - 1 - layer
  for i in first..last-1:
    offset = i - first

    # save top
    tmp = A[first][i]

    # left -&gt; top
    A[first][i] = A[last - offset][first]

    # bottom -&gt; left
    A[last - offset][first] = A[last][last - offset]

    # right -&gt; bottom
    A[last][last - offset] = A[i][last]

    # top (saved) -&gt; right
    A[i][last] = tmp</code></pre>
            </div>
            </p>
            <ul>
                <li>Time: $O(n^{2})$</li>
                <li>Space: $O(1)$</li>
            </ul>
            <h3 id="traversal-patterns">Traversal Patterns</h3>
            <h4 id="spiral-order">Spiral Order</h4>
            <p>Read outer layer, then shrink bounds.</p>
            <p><strong>Example inputs and outputs</strong></p>
            <p><em>Example</em></p>
            <p>$$
                \text{Input: }
                \begin{bmatrix}
                1 &amp; 2 &amp; 3 &amp; 4 \\
                5 &amp; 6 &amp; 7 &amp; 8 \\
                9 &amp; 10 &amp; 11 &amp; 12
                \end{bmatrix}
                $$</p>
            <p>$$
                \text{Output sequence: } 1,2,3,4,8,12,11,10,9,5,6,7
                $$</p>
            <p><strong>Mathematical formulation (general $R\times C$)</strong></p>
            <p>Let the matrix indices be $(r,c)$ with $0\le r&lt;R,\ 0\le c&lt;C$. For layer $\ell=0,1,\dots,L-1$ where $L=\left\lceil \tfrac{\min(R,C)}{2}\right\rceil$, set</p>
            <p>$$
                t=\ell,\quad b=R-1-\ell,\quad left=\ell,\quad rgt=C-1-\ell
                $$</p>
            <p>Visit, in order:</p>
            <ul>
                <li>Top edge: $(t,c)$ for $c=left,\ldots,rgt$.</li>
                <li>Right edge: $(r,rgt)$ for $r=t+1,\ldots,b$.</li>
                <li>Bottom edge (if $b&gt;t$): $(b,c)$ for $c=rgt-1,\ldots,left$ (decreasing).</li>
                <li>Left edge (if $rgt&gt;left$): $(r,left)$ for $r=b-1,\ldots,t+1$ (decreasing).</li>
            </ul>
            <p>Concatenate these per layer until all elements are visited.</p>
            <p><strong>Pseudocode (loops)</strong></p>
            <p>
            <div>
                <pre><code class="language-shell">R, C = dims(A)
top, bottom = 0, R - 1
left, right = 0, C - 1
out = []

while top &lt;= bottom and left &lt;= right:
  # top row
  for c in left..right:
    out.append(A[top][c])
  top += 1

  # right column
  for r in top..bottom:
    out.append(A[r][right])
  right -= 1

  # bottom row (if any)
  if top &lt;= bottom:
    for c in right..left step -1:
      out.append(A[bottom][c])
    bottom -= 1

  # left column (if any)
  if left &lt;= right:
    for r in bottom..top step -1:
      out.append(A[r][left])
    left += 1</code></pre>
            </div>
            </p>
            <p><strong>How it works</strong></p>
            <p>Maintain top, bottom, left, right. Walk edges in order; after each edge, move the corresponding bound inward.</p>
            <ul>
                <li>Time: $O(R\cdot C)$</li>
                <li>Space: $O(1)$ beyond output.</li>
            </ul>
            <h4 id="diagonal-order-r-c-layers-">Diagonal Order (r+c layers)</h4>
            <p>Visit cells grouped by $s=r+c$; alternate direction per diagonal to keep locality if desired.</p>
            <p><strong>Example inputs and outputs</strong></p>
            <p><em>Example</em></p>
            <p>$$
                \text{Input: }
                \begin{bmatrix}
                a &amp; b &amp; c \\
                d &amp; e &amp; f
                \end{bmatrix}
                \quad\Rightarrow\quad
                \text{One order: } a, b, d, e, c, f
                $$</p>
            <p><strong>Mathematical formulation (general $R\times C$)</strong></p>
            <p>Let $s=r+c$. For $s=0,1,\dots,R+C-2$, define</p>
            <p>$$
                r_{\min}(s)=\max!\big(0,\ s-(C-1)\big)
                $$</p>
            <p>$$
                r_{\max}(s)=\min!\big(R-1,\ s\big)
                $$</p>
            <p>The diagonal set is ${(r,s-r)\mid r_{\min}(s)\le r\le r_{\max}(s)}$.</p>
            <p>Traverse with alternating direction:</p>
            <p>$$
                \begin{cases}
                \text{if } s \text{ even: } r=r_{\max}(s), r_{\max}(s)-1,\dots,r_{\min}(s);\[2pt]
                \text{if } s \text{ odd: } r=r_{\min}(s), r_{\min}(s)+1,\dots,r_{\max}(s).
                \end{cases}
                $$</p>
            <p>(This parity choice reproduces the example order $a,b,d,e,c,f$ for $R=2,C=3$.)</p>
            <p><strong>Pseudocode (loops, alternating direction)</strong></p>
            <p>
            <div>
                <pre><code class="language-shell">R, C = dims(A)
out = []

for s in 0..(R + C - 2):
  r_lo = max(0, s - (C - 1))
  r_hi = min(R - 1, s)

  if s % 2 == 0:
    # even s: go downward-left (decreasing r)
    for r in r_hi..r_lo step -1:
      c = s - r
      out.append(A[r][c])
  else:
    # odd s: go upward-right (increasing r)
    for r in r_lo..r_hi:
      c = s - r
      out.append(A[r][c])</code></pre>
            </div>
            </p>
            <ul>
                <li>Time: $O(R\cdot C)$</li>
                <li>Space: $O(1)$</li>
            </ul>
            <h3 id="grids-as-graphs">Grids as Graphs</h3>
            <p>Each cell is a node; edges connect neighboring walkable cells.</p>
            <p><strong>Grid-as-graph view (4-dir edges).</strong> Each cell is a node; edges connect neighbors that are “passable”. Great for BFS shortest paths on unweighted grids.</p>
            <p><strong>Example map (walls <code>#</code>, free <code>.</code>, start <code>S</code>, target <code>T</code>).</strong></p>
            <p>Left: the map. Right: BFS distances (4-dir) from <code>S</code> until <code>T</code> is reached.</p>
            <p>
            <div>
                <pre><code class="language-shell">Original Map:
#####################
#S..#....#....#.....#
#.#.#.##.#.##.#.##..#
#.#...#..#.......#.T#
#...###.....###.....#
#####################

BFS layers (distance mod 10):
#####################
#012#8901#9012#45678#
#1#3#7##2#8##1#3##89#
#2#456#43#7890123#7X#
#345###54567###34567#
#####################

Legend: walls (#), goal reached (X)</code></pre>
            </div>
            </p>
            <p>BFS explores in <strong>expanding “rings”</strong>; with 4-dir edges, each step increases Manhattan distance by 1 (unless blocked). Time $O(RC)$, space $O(RC)$ with a visited matrix/queue.</p>
            <p><strong>Obstacles / costs / diagonals.</strong></p>
            <ul>
                <li>Obstacles: skip neighbors that are <code>#</code> (or where cost is $\infty$).</li>
                <li>Weighted grids: Dijkstra / 0-1 BFS on the same neighbor structure.</li>
                <li>8-dir with Euclidean costs: use $1$ for orthogonal moves and $\sqrt{2}$ for diagonals (A* often pairs well here with an admissible heuristic).</li>
            </ul>
            <p><strong>Common symbols:</strong></p>
            <p>
            <div>
                <pre><code class="language-shell">. = free cell      # = wall/obstacle
S = start          T = target/goal
V = visited        * = on current path / frontier</code></pre>
            </div>
            </p>
            <h4 id="bfs-shortest-path-unweighted-">BFS Shortest Path (Unweighted)</h4>
            <p>Find the minimum steps from S to T.</p>
            <p><strong>Example inputs and outputs</strong></p>
            <p><em>Example</em></p>
            <p>$$
                \text{Grid (0 = open, 1 = wall), } S = (0,0), T = (2,3)
                $$</p>
            <p>$$
                \begin{bmatrix}
                S &amp; 0 &amp; 1 &amp; 0 \\
                0 &amp; 0 &amp; 0 &amp; 0 \\
                1 &amp; 1 &amp; 0 &amp; T
                \end{bmatrix}
                \quad\Rightarrow\quad
                \text{Output: distance } = 5
                $$</p>
            <p><strong>How it works</strong></p>
            <p>Push S to a queue, expand in 4-dir layers, track distance/visited; stop when T is dequeued.</p>
            <ul>
                <li>Time: $O(R\cdot C)$</li>
                <li>Space: $O(R\cdot C)$</li>
            </ul>
            <h4 id="connected-components-islands-">Connected Components (Islands)</h4>
            <p>Count regions of ‘1’s via DFS/BFS.</p>
            <p><strong>Example inputs and outputs</strong></p>
            <p>$$
                \text{Input: }
                \begin{bmatrix}
                1 &amp; 1 &amp; 0 \\
                0 &amp; 1 &amp; 0 \\
                0 &amp; 0 &amp; 1
                \end{bmatrix}
                \quad\Rightarrow\quad
                \text{Output: } 2 \ \text{islands}
                $$</p>
            <p><strong>How it works</strong></p>
            <p>Scan cells; when an unvisited ‘1’ is found, flood it (DFS/BFS) to mark the whole island.</p>
            <ul>
                <li>Time: $O(R\cdot C)$</li>
                <li>Space: $O(R\cdot C)$ worst-case</li>
            </ul>
            <h3 id="backtracking-on-grids">Backtracking on Grids</h3>
            <h4 id="word-search-single-word-">Word Search (Single Word)</h4>
            <p>Find a word by moving to adjacent cells (4-dir), using each cell once per path.</p>
            <p><strong>Example inputs and outputs</strong></p>
            <p>$$
                \text{Board: }
                \begin{bmatrix}
                A &amp; B &amp; C &amp; E \\
                S &amp; F &amp; C &amp; S \\
                A &amp; D &amp; E &amp; E
                \end{bmatrix},
                \quad
                \text{Word: } "ABCCED"
                \quad\Rightarrow\quad
                \text{Output: true}
                $$</p>
            <p><strong>Mathematical formulation (general)</strong></p>
            <p>Let the word be $W=W_0W_1\cdots W_{L-1}$ and the grid be $G\in\Sigma^{R\times C}$.
                We seek a path $P=\big((r_0,c_0),\ldots,(r_{L-1},c_{L-1})\big)$ such that</p>
            <p>$$
                \begin{aligned}
                &amp;\text{(match)} &amp;&amp; G_{r_i,c_i}=W_i,\quad i=0,\ldots,L-1;\\
                &amp;\text{(adjacent)} &amp;&amp; |r_{i+1}-r_i|+|c_{i+1}-c_i|=1,\quad i=0,\ldots,L-2;\\
                &amp;\text{(no reuse)} &amp;&amp; (r_i,c_i)\neq(r_j,c_j)\ \text{for all }i\ne j.
                \end{aligned}
                $$</p>
            <p><strong>Instantiation for the example (one valid path)</strong></p>
            <p>$$
                P=\big((0,0),(0,1),(0,2),(1,2),(2,2),(2,1)\big)
                $$</p>
            <p>gives $A\to B\to C\to C\to E\to D = \text{"ABCCED"}$.</p>
            <p><strong>Pseudocode (DFS with loops over starts and 4-neighbors)</strong></p>
            <p>
            <div>
                <pre><code class="language-shell">R, C = dims(board)
L = len(word)
visited = array(R, C, fill=false)
dr = [1, -1, 0, 0]
dc = [0, 0, 1, -1]

def dfs(r, c, i):
  if r &lt; 0 or r &gt;= R or c &lt; 0 or c &gt;= C: 
    return false
  if visited[r][c] or board[r][c] != word[i]:
    return false
  if i == L - 1:
    return true

  visited[r][c] = true
  for k in 0..3:
    nr = r + dr[k]
    nc = c + dc[k]
    if dfs(nr, nc, i + 1):
      return true
  visited[r][c] = false
  return false

# try every starting cell
for r in 0..R-1:
  for c in 0..C-1:
    if dfs(r, c, 0):
      return true
return false</code></pre>
            </div>
            </p>
            <p><strong>How it works</strong></p>
            <p>From each starting match, DFS to next char; mark visited (temporarily), backtrack on failure.</p>
            <ul>
                <li>Time: up to $O(R\cdot C\cdot b^{L})$ (branching $b\in [3,4]$, word length $L$)</li>
                <li>Space: $O(L)$</li>
            </ul>
            <p>Pruning: early letter mismatch; frequency precheck; prefix trie when searching many words.</p>
            <h4 id="crossword-style-fill-multiple-words-">Crossword-style Fill (Multiple Words)</h4>
            <p>Place words to slots with crossings; verify consistency at intersections.</p>
            <p><strong>Mathematical formulation</strong></p>
            <p>Let $S$ be the set of slots (across/down). Each slot $s\in S$ has a length $\ell(s)$ and ordered cell coordinates
                $\mathrm{cells}(s) = \big((r_0,c_0),\ldots,(r_{\ell(s)-1},c_{\ell(s)-1})\big)$.
                Let $D$ be the dictionary; define $D_\ell={w\in D:|w|=\ell}$.
                Known letters from the grid induce a pattern constraint $P_s\in(\Sigma\cup{_})^{\ell(s)}$.</p>
            <p>Find an assignment $f:S\to D$ such that, for all $s\in S$,</p>
            <p>$$
                f(s)\in D_{\ell(s)}\quad\text{and}\quad
                \forall i\ (P_s[i]\neq _ \Rightarrow f(s)[i]=P_s[i]),
                $$</p>
            <p>and for every intersection between slots $s$ at index $i$ and $t$ at index $j$,</p>
            <p>$$
                f(s)[i]=f(t)[j].
                $$</p>
            <p>(Optionally enforce all-different: $s\neq t \Rightarrow f(s)\neq f(t)$.)</p>
            <p><strong>Pseudocode (backtracking with loops, MRV + trie filtering)</strong></p>
            <p>
            <div>
                <pre><code class="language-shell"># Preprocess
slots = extract_slots(grid)                  # with cells(s) and pattern P_s
trie = build_trie(dictionary)                # for prefix/length checks

# Build initial domains from patterns and lengths
domains = dict()
for s in slots:
  domains[s] = { w in dictionary | len(w) == len(s) and matches_pattern(w, P_s) }

# Order slots: Most-Restricted-Variable (smallest domain first)
slots.sort_by(|domains[s]| ascending, tiebreak by number_of_intersections)

used = set()          # if words must be unique
assignment = dict()

def consistent(s, w):
  # check crossings vs assigned neighbors
  for each intersection (s,i) with (t,j):
    if t in assignment and assignment[t][j] != w[i]:
      return false
  return true

def forward_check_update_domains(s, w, removed):
  # reduce neighbor domains by letter constraints from placing w at s
  for each intersection (s,i) with (t,j):
    for each v in copy(domains[t]):
      if v[j] != w[i]:
        domains[t].remove(v); removed.append((t, v))

def undo_forward_check(removed):
  for (t, v) in removed:
    domains[t].add(v)

def backtrack(idx):
  if idx == len(slots):
    return true

  s = slots[idx]

  # iterate candidates; optionally skip ones already used
  for w in iterate(domains[s]):
    if w in used: 
      continue
    if not consistent(s, w):
      continue

    assignment[s] = w
    used.add(w)
    removed = []
    forward_check_update_domains(s, w, removed)

    if backtrack(idx + 1):
      return true

    undo_forward_check(removed)
    used.remove(w)
    del assignment[s]

  return false

# Start search
if backtrack(0):
  return assignment  # filled crossword
else:
  return failure</code></pre>
            </div>
            </p>
            <p><strong>How it works</strong></p>
            <p>Backtrack over slot assignments; use a trie for prefix feasibility; order by most constrained slot first.</p>
            <ul>
                <li>Time: exponential in slots; strong pruning and good heuristics are important.</li>
            </ul>
        </article-section>
        <div id="table-of-contents">
            <h2>Table of Contents</h2>
            <ol><a href="#matrices-and-2d-grids">Matrices and 2D Grids</a>
                <ol>
                    <li><a href="#conventions">Conventions</a></li>
                    <li><a href="#basic-operations-building-blocks-">Basic Operations (Building Blocks)</a>
                        <ol>
                            <li><a href="#transpose">Transpose</a></li>
                            <li><a href="#reverse-rows-horizontal-flip-">Reverse Rows (Horizontal Flip)</a></li>
                            <li><a href="#reverse-columns-vertical-flip-">Reverse Columns (Vertical Flip)</a></li>
                        </ol>
                    </li>
                    <li><a href="#rotations-composed-from-basics-">Rotations (Composed from Basics)</a>
                        <ol>
                            <li><a href="#90-clockwise-cw-">90° Clockwise (CW)</a></li>
                            <li><a href="#90-counterclockwise-ccw-">90° Counterclockwise (CCW)</a></li>
                            <li><a href="#180-rotation">180° Rotation</a></li>
                            <li><a href="#270-rotation">270° Rotation</a></li>
                            <li><a href="#layer-by-layer-square-90-cw">Layer-by-Layer (Square) 90° CW</a></li>
                        </ol>
                    </li>
                    <li><a href="#traversal-patterns">Traversal Patterns</a>
                        <ol>
                            <li><a href="#spiral-order">Spiral Order</a></li>
                            <li><a href="#diagonal-order-r-c-layers-">Diagonal Order (r+c layers)</a></li>
                        </ol>
                    </li>
                    <li><a href="#grids-as-graphs">Grids as Graphs</a>
                        <ol>
                            <li><a href="#bfs-shortest-path-unweighted-">BFS Shortest Path (Unweighted)</a></li>
                            <li><a href="#connected-components-islands-">Connected Components (Islands)</a></li>
                        </ol>
                    </li>
                    <li><a href="#backtracking-on-grids">Backtracking on Grids</a>
                        <ol>
                            <li><a href="#word-search-single-word-">Word Search (Single Word)</a></li>
                            <li><a href="#crossword-style-fill-multiple-words-">Crossword-style Fill (Multiple Words)</a></li>
                        </ol>
                    </li>
                </ol>
            </ol>
            <div id="related-articles">
                <h2>Related Articles</h2>
                <ol>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/backtracking.html">Backtracking</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/basic_concepts.html">Basic Concepts</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/brain_teasers.html">Brain Teasers</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/data_structures.html">Data Structures</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/dynamic_programming.html">Dynamic Programming</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/graphs.html">Graphs</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/greedy_algorithms.html">Greedy Algorithms</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/matrices.html">Matrices</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/searching.html">Searching</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/sorting.html">Sorting</a></li>
                </ol>
            </div>
        </div>
    </div>
    <footer>
        <div class="footer-columns">
            <div class="footer-column">
                <img alt="Adam Djellouli Symbol" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/symbol.png" />
            </div>
            <div class="footer-column">
                <h2><a href="https://adamdjellouli.com/core/privacy_policy.html" title="Privacy Policy">Our Privacy Policy</a></h2>
                <p>Thank you for visiting my personal website. All content here is free to use, but please remember to be respectful and avoid any misuse of the site. If you’d like to get in touch, feel free to reach out via my <a href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" title="LinkedIn Profile">LinkedIn profile</a> or connect with me on <a href="https://github.com/djeada" title="GitHub Profile">GitHub</a> if you have technical questions or ideas to share. Wishing you all the best and a fantastic life ahead!</p>
            </div>
            <div class="footer-column">
                <h2>Follow me</h2>
                <ul class="social-media">
                    <li>
                        <a class="fa fa-youtube" href="https://www.youtube.com/channel/UCGPoHTVjMN77wcGknXPHl1Q" target="_blank" title="YouTube">
                        </a>YouTube
                    </li>
                    <li>
                        <a class="fa fa-linkedin" href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" target="_blank" title="LinkedIn">
                        </a>LinkedIn
                    </li>
                    <li>
                        <a class="fa fa-instagram" href="https://www.instagram.com/linuxchallenges/" target="_blank" title="Instagram">
                        </a>Instagram
                    </li>
                    <li>
                        <a class="fa fa-github" href="https://github.com/djeada" title="GitHub">
                        </a>Github
                    </li>
                </ul>
            </div>
        </div>
        <div>
            <p id="copyright">
                © Adam Djellouli. All rights reserved.
            </p>
        </div>
        <script>
            document.getElementById("copyright").innerHTML = "&copy; " + new Date().getFullYear() + " Adam Djellouli. All rights reserved.";
        </script>
        <script src="../../app.js"></script>
    </footer>
    <div id="pdf-spinner-overlay">
        <div class="spinner"></div>
    </div>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-bash.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-cpp.min.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
jax: ["input/TeX", "output/HTML-CSS"],
extensions: ["tex2jax.js"],
"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] },
tex2jax: { inlineMath: [ ["$", "$"] ], displayMath: [ ["$$","$$"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
TeX: { noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } } },
messageStyle: "none"
});
</script>
<script async="" id="MathJax-script" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>

</html>