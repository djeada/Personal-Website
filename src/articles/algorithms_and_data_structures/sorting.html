<!DOCTYPE html>

<html lang="en">

<head>
    <script async="" crossorigin="anonymous" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5593122079896089"></script>
    <meta charset="utf-8" />
    <title>Sorting</title>
    <meta content="In the realm of computer science, 'sorting' refers to the process of arranging a collection of items in a specific, predetermined order." name="description" />
    <meta content="Adam Djellouli" name="author" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <meta content="IE=edge" http-equiv="X-UA-Compatible" />
    <link crossorigin="" href="https://fonts.googleapis.com" rel="preconnect" />
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/icon.ico" rel="icon" />
    <link href="../../resources/style.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
</head>

<body>
    <nav aria-label="Main navigation">
        <a class="logo" href="https://adamdjellouli.com">
            <img alt="Adam Djellouli - Home Page Logo" id="logo-image" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/logo.PNG" />
        </a>
        <input aria-label="Toggle navigation menu" id="navbar-toggle" type="checkbox" />
        <ul aria-labelledby="navbar-toggle" role="menu">
            <li role="menuitem">
                <a href="../../index.html" title="Go to Home Page"> Home </a>
            </li>
            <li role="menuitem">
                <a class="active" href="../../core/blog.html" title="Read Adam Djellouli Blog on Programming and Technology"> Blog </a>
            </li>
            <li role="menuitem">
                <a href="../../core/tools.html" title="Discover Tools Created by Adam Djellouli"> Tools </a>
            </li>
            <li role="menuitem">
                <a href="../../core/projects.html" title="Explore Projects Developed by Adam Djellouli"> Projects </a>
            </li>
            <li role="menuitem">
                <a href="../../core/resume.html" title="View Adam Djellouli Professional Resume"> Resume </a>
            </li>
            <li>
                <script async="" src="https://cse.google.com/cse.js?cx=8160ef9bb935f4f68"></script>
                <div class="gcse-search"></div>
            </li>
            <li>
                <button aria-label="Toggle dark mode" id="dark-mode-button"></button>
            </li>
        </ul>
    </nav>
    <div id="article-wrapper">
        <section id="article-body">
            <div class="article-action-buttons"><button class="btn-suggest-edit" title="Suggest Edit">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <path d="M4 21h4l11-11-4-4L4 17v4z" stroke="currentColor" stroke-width="2"></path>
                    </svg>
                </button><button class="btn-create-issue" title="Create Issue">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2"></circle>
                        <line stroke="currentColor" stroke-width="2" x1="12" x2="12" y1="8" y2="12"></line>
                        <circle cx="12" cy="16" fill="currentColor" r="1"></circle>
                    </svg>
                </button><button class="btn-download" title="Download">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <path d="M12 5v14m0 0l-6-6m6 6l6-6" stroke="currentColor" stroke-width="2"></path>
                    </svg>
                </button></div>
            <p style="text-align: right;"><i>Last modified: August 31, 2025</i></p>
            <p style="text-align: right;"><i>This article is written in: üá∫üá∏</i></p>
            <h2 id="sorting">Sorting</h2>
            <p>In the realm of computer science, 'sorting' refers to the process of arranging a collection of items in a specific, predetermined order. This order is based on certain criteria that are defined beforehand.</p>
            <p>For instance:</p>
            <ul>
                <li><strong>Numbers</strong> can be sorted according to their numerical values, either in ascending or descending order.</li>
                <li><strong>Strings</strong> are typically sorted in alphabetical order, similar to how words are arranged in dictionaries.</li>
            </ul>
            <p>Sorting isn't limited to just numbers and strings. Virtually any type of object can be sorted, provided there is a clear definition of order for them.</p>
            <h3 id="stability-in-sorting">Stability in Sorting</h3>
            <p>Stability, in the context of sorting, refers to preserving the relative order of equal items in the sorted output. In simple terms, when two items have equal keys:</p>
            <ul>
                <li>In an <strong>unstable</strong> sorting algorithm, their order might be reversed in the sorted output.</li>
                <li>In a <strong>stable</strong> sorting algorithm, their relative order remains unchanged.</li>
            </ul>
            <p>Let‚Äôs take an analogous list of medieval knights (each with its original 0-based index):</p>
            <p>
            <div>
                <pre><code class="language-shell">[Lancelot0] [Gawain1] [Lancelot2] [Percival3] [Gawain4]</code></pre>
            </div>
            </p>
            <p>We‚Äôll ‚Äúsort‚Äù them by name, bringing all <strong>Lancelot</strong>s to the front, then <strong>Gawain</strong>, then <strong>Percival</strong>.</p>
            <h4 id="stable-sort">Stable Sort</h4>
            <p>A <strong>stable</strong> sort preserves the left-to-right order of equal items.</p>
            <p>I. <strong>Bring every ‚ÄúLancelot‚Äù to the front</strong>, in the order they appeared (index 0 before 2):</p>
            <p>
            <div>
                <pre><code class="language-shell">[Lancelot0] [Lancelot2] [Gawain1] [Percival3] [Gawain4]</code></pre>
            </div>
            </p>
            <p>II. <strong>Next, move the two ‚ÄúGawain‚Äùs</strong> ahead of ‚ÄúPercival‚Äù, again preserving 1 before 4:</p>
            <p>
            <div>
                <pre><code class="language-shell">[Lancelot0] [Lancelot2] [Gawain1] [Gawain4] [Percival3]</code></pre>
            </div>
            </p>
            <p>So the <strong>stable-sorted</strong> sequence is:</p>
            <p>
            <div>
                <pre><code class="language-shell">[Lancelot0] [Lancelot2] [Gawain1] [Gawain4] [Percival3]</code></pre>
            </div>
            </p>
            <h4 id="unstable-sort">Unstable Sort</h4>
            <p>An <strong>unstable</strong> sort may reorder equal items arbitrarily.</p>
            <p>I. When collecting the ‚ÄúLancelot‚Äùs, it might pick index 2 before 0:</p>
            <p>
            <div>
                <pre><code class="language-shell">[Lancelot2] [Lancelot0] [Gawain1] [Percival3] [Gawain4]</code></pre>
            </div>
            </p>
            <p>II. Later, the two ‚ÄúGawain‚Äùs might swap (4 before 1):</p>
            <p>
            <div>
                <pre><code class="language-shell">[Lancelot2] [Lancelot0] [Gawain4] [Gawain1] [Percival3]</code></pre>
            </div>
            </p>
            <p>So one possible <strong>unstable-sorted</strong> sequence is:</p>
            <p>
            <div>
                <pre><code class="language-shell">[Lancelot2] [Lancelot0] [Gawain4] [Gawain1] [Percival3]</code></pre>
            </div>
            </p>
            <p>If you then did a second pass (say, sorting by rank or battle-honors) you‚Äôd only want to reorder knights of different names, trusting that ties (same-name knights) are still in their intended original order‚Äîsomething only a stable sort guarantees.</p>
            <h3 id="bubble-sort">Bubble Sort</h3>
            <p>Bubble sort is one of the simplest sorting algorithms. It is often used as an <strong>introductory algorithm</strong> because it is easy to understand, even though it is not efficient for large datasets.</p>
            <p>The name comes from the way <strong>larger elements "bubble up"</strong> to the top (end of the list), just as bubbles rise in water.</p>
            <p>The basic idea:</p>
            <ul>
                <li>Compare <strong>adjacent elements</strong>.</li>
                <li>Swap them if they are in the wrong order.</li>
                <li>Repeat until no swaps are needed.</li>
            </ul>
            <p><strong>Step-by-Step Walkthrough</strong></p>
            <ol>
                <li>Start from the <strong>first element</strong>.</li>
                <li>Compare it with its <strong>neighbor to the right</strong>.</li>
                <li>If the left is greater, <strong>swap</strong> them.</li>
                <li>Move to the next pair and repeat until the end of the list.</li>
                <li>After the <strong>first pass</strong>, the largest element is at the end.</li>
                <li>On each new pass, ignore the elements already in their correct place.</li>
                <li>Continue until the list is sorted.</li>
            </ol>
            <p><strong>Example Run</strong></p>
            <p>We will sort the array:</p>
            <p>
            <div>
                <pre><code class="language-shell">[ 5 ][ 1 ][ 4 ][ 2 ][ 8 ]</code></pre>
            </div>
            </p>
            <p><strong>Pass 1</strong></p>
            <p>Compare adjacent pairs and push the largest to the end.</p>
            <p>
            <div>
                <pre><code class="language-shell">Initial:   [ 5 ][ 1 ][ 4 ][ 2 ][ 8 ]

Compare 5 and 1 ‚Üí swap
           [ 1 ][ 5 ][ 4 ][ 2 ][ 8 ]

Compare 5 and 4 ‚Üí swap
           [ 1 ][ 4 ][ 5 ][ 2 ][ 8 ]

Compare 5 and 2 ‚Üí swap
           [ 1 ][ 4 ][ 2 ][ 5 ][ 8 ]

Compare 5 and 8 ‚Üí no swap
           [ 1 ][ 4 ][ 2 ][ 5 ][ 8 ]</code></pre>
            </div>
            </p>
            <p>‚úî Largest element <strong>8</strong> has bubbled to the end.</p>
            <p><strong>Pass 2</strong></p>
            <p>Now we only need to check the first 4 elements.</p>
            <p>
            <div>
                <pre><code class="language-shell">Start:     [ 1 ][ 4 ][ 2 ][ 5 ] [8]

Compare 1 and 4 ‚Üí no swap
           [ 1 ][ 4 ][ 2 ][ 5 ] [8]

Compare 4 and 2 ‚Üí swap
           [ 1 ][ 2 ][ 4 ][ 5 ] [8]

Compare 4 and 5 ‚Üí no swap
           [ 1 ][ 2 ][ 4 ][ 5 ] [8]</code></pre>
            </div>
            </p>
            <p>‚úî Second largest element <strong>5</strong> is now in place.</p>
            <p><strong>Pass 3</strong></p>
            <p>Check only the first 3 elements.</p>
            <p>
            <div>
                <pre><code class="language-shell">Start:     [ 1 ][ 2 ][ 4 ] [5][8]

Compare 1 and 2 ‚Üí no swap
           [ 1 ][ 2 ][ 4 ] [5][8]

Compare 2 and 4 ‚Üí no swap
           [ 1 ][ 2 ][ 4 ] [5][8]</code></pre>
            </div>
            </p>
            <p>‚úî Sorted order is now reached.</p>
            <p><strong>Final Result</strong></p>
            <p>
            <div>
                <pre><code class="language-shell">[ 1 ][ 2 ][ 4 ][ 5 ][ 8 ]</code></pre>
            </div>
            </p>
            <p><strong>Visual Illustration of Bubble Effect</strong></p>
            <p>Here‚Äôs how the <strong>largest values "bubble up"</strong> to the right after each pass:</p>
            <p>
            <div>
                <pre><code class="language-shell">Pass 1:  [ 5  1  4  2  8 ] ‚Üí [ 1  4  2  5  8 ]
Pass 2:  [ 1  4  2  5 ]       ‚Üí [ 1  2  4  5 ]  [8]
Pass 3:  [ 1  2  4 ]          ‚Üí [ 1  2  4 ]     [5 8]</code></pre>
            </div>
            </p>
            <p>Sorted! ‚úÖ</p>
            <p><strong>Optimizations</strong></p>
            <ul>
                <li>By keeping track of whether any swaps were made during a pass, Bubble Sort can terminate early if the array is already sorted. This optimization makes Bubble Sort‚Äôs <strong>best case</strong> much faster ($O(n)$).</li>
            </ul>
            <p><strong>Stability</strong></p>
            <p>Bubble sort is <strong>stable</strong>.</p>
            <ul>
                <li>If two elements have the same value, they remain in the same order relative to each other after sorting.</li>
                <li>This is important when sorting complex records where a secondary key matters.</li>
            </ul>
            <p><strong>Complexity</strong></p>
            <p>
            <table>
                <tr>
                    <td>Case</td>
                    <td>Time Complexity</td>
                    <td>Notes</td>
                </tr>
                <tr>
                    <td><strong>Worst Case</strong></td>
                    <td>$O(n^2)$</td>
                    <td>Array in reverse order</td>
                </tr>
                <tr>
                    <td><strong>Average Case</strong></td>
                    <td>$O(n^2)$</td>
                    <td>Typically quadratic comparisons</td>
                </tr>
                <tr>
                    <td><strong>Best Case</strong></td>
                    <td>$O(n)$</td>
                    <td>Already sorted + early exit optimization</td>
                </tr>
                <tr>
                    <td><strong>Space</strong></td>
                    <td>$O(1)$</td>
                    <td>In-place, requires no extra memory</td>
                </tr>
            </table>
            </p>
            <p><strong>Implementation</strong></p>
            <ul>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/blob/master/src/sorting/cpp/bubble_sort/src/bubble_sort.cpp">C++</a></li>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/blob/master/src/sorting/python/bubble_sort/src/bubble_sort.py">Python</a></li>
            </ul>
            <h3 id="selection-sort">Selection Sort</h3>
            <p>Selection sort is another simple sorting algorithm, often introduced right after bubble sort because it is equally easy to understand.</p>
            <p>Instead of repeatedly "bubbling" elements, <strong>selection sort works by repeatedly selecting the smallest (or largest) element</strong> from the unsorted portion of the array and placing it into its correct position.</p>
            <p>Think of it like arranging books:</p>
            <ul>
                <li>Look through all the books, find the smallest one, and put it first.</li>
                <li>Then, look through the rest, find the next smallest, and put it second.</li>
                <li>Repeat until the shelf is sorted.</li>
            </ul>
            <p><strong>Step-by-Step Walkthrough</strong></p>
            <ol>
                <li>Start at the <strong>first position</strong>.</li>
                <li>Search the <strong>entire unsorted region</strong> to find the smallest element.</li>
                <li>Swap it with the element in the current position.</li>
                <li>Move the boundary of the sorted region one step forward.</li>
                <li>Repeat until all elements are sorted.</li>
            </ol>
            <p><strong>Example Run</strong></p>
            <p>We will sort the array:</p>
            <p>
            <div>
                <pre><code class="language-shell">[ 64 ][ 25 ][ 12 ][ 22 ][ 11 ]</code></pre>
            </div>
            </p>
            <p><strong>Pass 1</strong></p>
            <p>Find the smallest element in the entire array and put it in the first position.</p>
            <p>
            <div>
                <pre><code class="language-shell">Initial:    [ 64 ][ 25 ][ 12 ][ 22 ][ 11 ]

Smallest = 11  
Swap 64 ‚Üî 11  

Result:     [ 11 ][ 25 ][ 12 ][ 22 ][ 64 ]</code></pre>
            </div>
            </p>
            <p>‚úî The first element is now in its correct place.</p>
            <p><strong>Pass 2</strong></p>
            <p>Find the smallest element in the remaining unsorted region.</p>
            <p>
            <div>
                <pre><code class="language-shell">Start:      [ 11 ][ 25 ][ 12 ][ 22 ][ 64 ]

Smallest in [25,12,22,64] = 12  
Swap 25 ‚Üî 12  

Result:     [ 11 ][ 12 ][ 25 ][ 22 ][ 64 ]</code></pre>
            </div>
            </p>
            <p>‚úî The second element is now in place.</p>
            <p><strong>Pass 3</strong></p>
            <p>Repeat for the next unsorted region.</p>
            <p>
            <div>
                <pre><code class="language-shell">Start:      [ 11 ][ 12 ][ 25 ][ 22 ][ 64 ]

Smallest in [25,22,64] = 22  
Swap 25 ‚Üî 22  

Result:     [ 11 ][ 12 ][ 22 ][ 25 ][ 64 ]</code></pre>
            </div>
            </p>
            <p>‚úî The third element is now in place.</p>
            <p><strong>Pass 4</strong></p>
            <p>Finally, sort the last two.</p>
            <p>
            <div>
                <pre><code class="language-shell">Start:      [ 11 ][ 12 ][ 22 ][ 25 ][ 64 ]

Smallest in [25,64] = 25  
Already in correct place ‚Üí no swap  

Result:     [ 11 ][ 12 ][ 22 ][ 25 ][ 64 ]</code></pre>
            </div>
            </p>
            <p>‚úî Array fully sorted.</p>
            <p><strong>Final Result</strong></p>
            <p>
            <div>
                <pre><code class="language-shell">[ 11 ][ 12 ][ 22 ][ 25 ][ 64 ]</code></pre>
            </div>
            </p>
            <p><strong>Visual Illustration of Selection</strong></p>
            <p>Here‚Äôs how the <strong>sorted region expands</strong> from left to right:</p>
            <p>
            <div>
                <pre><code class="language-shell">Pass 1:  [ 64  25  12  22  11 ] ‚Üí [ 11 ] [ 25  12  22  64 ]
Pass 2:  [ 11 ][ 25  12  22  64 ] ‚Üí [ 11  12 ] [ 25  22  64 ]
Pass 3:  [ 11  12 ][ 25  22  64 ] ‚Üí [ 11  12  22 ] [ 25  64 ]
Pass 4:  [ 11  12  22 ][ 25  64 ] ‚Üí [ 11  12  22  25 ] [ 64 ]</code></pre>
            </div>
            </p>
            <p>At each step:</p>
            <ul>
                <li>The <strong>left region is sorted</strong> ‚úÖ</li>
                <li>The <strong>right region is unsorted</strong> üîÑ</li>
            </ul>
            <p><strong>Optimizations</strong></p>
            <ul>
                <li>Unlike bubble sort, <strong>early exit is not possible</strong> because selection sort always scans the entire unsorted region to find the minimum.</li>
                <li>But it does fewer swaps: <strong>at most (n-1) swaps</strong>, compared to potentially many in bubble sort.</li>
            </ul>
            <p><strong>Stability</strong></p>
            <ul>
                <li><strong>Selection sort is NOT stable</strong> in its classic form.</li>
                <li>If two elements are equal, their order may change due to swapping.</li>
                <li>Stability can be achieved by inserting instead of swapping, but this makes the algorithm more complex.</li>
            </ul>
            <p><strong>Complexity</strong></p>
            <p>
            <table>
                <tr>
                    <td>Case</td>
                    <td>Time Complexity</td>
                    <td>Notes</td>
                </tr>
                <tr>
                    <td><strong>Worst Case</strong></td>
                    <td>$O(n^2)$</td>
                    <td>Scanning full unsorted region every pass</td>
                </tr>
                <tr>
                    <td><strong>Average Case</strong></td>
                    <td>$O(n^2)$</td>
                    <td>Quadratic comparisons</td>
                </tr>
                <tr>
                    <td><strong>Best Case</strong></td>
                    <td>$O(n^2)$</td>
                    <td>No improvement, still must scan every pass</td>
                </tr>
                <tr>
                    <td><strong>Space</strong></td>
                    <td>$O(1)$</td>
                    <td>In-place sorting</td>
                </tr>
            </table>
            </p>
            <p><strong>Implementation</strong></p>
            <ul>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/blob/master/src/sorting/cpp/selection_sort/src/selection_sort.cpp">C++</a></li>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/blob/master/src/sorting/python/selection_sort/src/selection_sort.py">Python</a></li>
            </ul>
            <h3 id="insertion-sort">Insertion Sort</h3>
            <p>Insertion sort is a simple, intuitive sorting algorithm that works the way people often sort playing cards in their hands.</p>
            <p>It builds the <strong>sorted portion one element at a time</strong>, by repeatedly taking the next element from the unsorted portion and inserting it into its correct position among the already sorted elements.</p>
            <p>The basic idea:</p>
            <ol>
                <li>Start with the <strong>second element</strong> (the first element by itself is trivially sorted).</li>
                <li>Compare it with elements to its <strong>left</strong>.</li>
                <li>Shift larger elements one position to the right.</li>
                <li>Insert the element into the correct spot.</li>
                <li>Repeat until all elements are processed.</li>
            </ol>
            <p><strong>Example Run</strong></p>
            <p>We will sort the array:</p>
            <p>
            <div>
                <pre><code class="language-shell">[ 12 ][ 11 ][ 13 ][ 5 ][ 6 ]</code></pre>
            </div>
            </p>
            <p><strong>Pass 1: Insert 11</strong></p>
            <p>Compare 11 with 12 ‚Üí shift 12 right ‚Üí insert 11 before it.</p>
            <p>
            <div>
                <pre><code class="language-shell">Before:  [ 12 ][ 11 ][ 13 ][ 5 ][ 6 ]
Action:  Insert 11 before 12
After:   [ 11 ][ 12 ][ 13 ][ 5 ][ 6 ]</code></pre>
            </div>
            </p>
            <p>‚úî Sorted portion: $[11, 12]$</p>
            <p><strong>Pass 2: Insert 13</strong></p>
            <p>Compare 13 with 12 ‚Üí already greater ‚Üí stays in place.</p>
            <p>
            <div>
                <pre><code class="language-shell">Before:  [ 11 ][ 12 ][ 13 ][ 5 ][ 6 ]
After:   [ 11 ][ 12 ][ 13 ][ 5 ][ 6 ]</code></pre>
            </div>
            </p>
            <p>‚úî Sorted portion: [11, 12, 13]</p>
            <p><strong>Pass 3: Insert 5</strong></p>
            <p>Compare 5 with 13 ‚Üí shift 13
                Compare 5 with 12 ‚Üí shift 12
                Compare 5 with 11 ‚Üí shift 11
                Insert 5 at start.</p>
            <p>
            <div>
                <pre><code class="language-shell">Before:  [ 11 ][ 12 ][ 13 ][ 5 ][ 6 ]
Action:  Move 13 ‚Üí Move 12 ‚Üí Move 11 ‚Üí Insert 5
After:   [ 5 ][ 11 ][ 12 ][ 13 ][ 6 ]</code></pre>
            </div>
            </p>
            <p>‚úî Sorted portion: [5, 11, 12, 13]</p>
            <p><strong>Pass 4: Insert 6</strong></p>
            <p>Compare 6 with 13 ‚Üí shift 13
                Compare 6 with 12 ‚Üí shift 12
                Compare 6 with 11 ‚Üí shift 11
                Insert 6 after 5.</p>
            <p>
            <div>
                <pre><code class="language-shell">Before:  [ 5 ][ 11 ][ 12 ][ 13 ][ 6 ]
Action:  Move 13 ‚Üí Move 12 ‚Üí Move 11 ‚Üí Insert 6
After:   [ 5 ][ 6 ][ 11 ][ 12 ][ 13 ]</code></pre>
            </div>
            </p>
            <p>‚úî Sorted!</p>
            <p><strong>Final Result</strong></p>
            <p>
            <div>
                <pre><code class="language-shell">[ 5 ][ 6 ][ 11 ][ 12 ][ 13 ]</code></pre>
            </div>
            </p>
            <p><strong>Visual Growth of Sorted Region</strong></p>
            <p>
            <div>
                <pre><code class="language-shell">Start:   [ 12 | 11  13  5  6 ]
Pass 1:  [ 11  12 | 13  5  6 ]
Pass 2:  [ 11  12  13 | 5  6 ]
Pass 3:  [ 5  11  12  13 | 6 ]
Pass 4:  [ 5  6  11  12  13 ]</code></pre>
            </div>
            </p>
            <p>‚úî The <strong>bar ( | )</strong> shows the boundary between <strong>sorted</strong> and <strong>unsorted</strong>.</p>
            <p><strong>Optimizations</strong></p>
            <ul>
                <li>Efficient for <strong>small arrays</strong>.</li>
                <li>Useful as a <strong>helper inside more complex sorts</strong> (e.g., Quick Sort or Merge Sort) for small subarrays.</li>
                <li>Can be optimized with <strong>binary search</strong> to find insertion positions faster (but shifting still takes linear time).</li>
            </ul>
            <p><strong>Stability</strong></p>
            <p>Insertion sort is <strong>stable</strong> (equal elements keep their relative order).</p>
            <p><strong>Complexity</strong></p>
            <p>
            <table>
                <tr>
                    <td>Case</td>
                    <td>Time Complexity</td>
                    <td>Notes</td>
                </tr>
                <tr>
                    <td><strong>Worst Case</strong></td>
                    <td>$O(n^2)$</td>
                    <td>Reverse-sorted input</td>
                </tr>
                <tr>
                    <td><strong>Average Case</strong></td>
                    <td>$O(n^2)$</td>
                    <td></td>
                </tr>
                <tr>
                    <td><strong>Best Case</strong></td>
                    <td>$O(n)$</td>
                    <td>Already sorted input ‚Äî only comparisons, no shifts</td>
                </tr>
                <tr>
                    <td><strong>Space</strong></td>
                    <td>$O(1)$</td>
                    <td>In-place</td>
                </tr>
            </table>
            </p>
            <p><strong>Implementation</strong></p>
            <ul>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/blob/master/src/sorting/cpp/insertion_sort/src/insertion_sort.cpp">C++</a></li>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/blob/master/src/sorting/python/insertion_sort/src/insertion_sort.py">Python</a></li>
            </ul>
            <h3 id="quick-sort">Quick Sort</h3>
            <p>Quick Sort is a <strong>divide-and-conquer</strong> algorithm. Unlike bubble sort or selection sort, which work by repeatedly scanning the whole array, Quick Sort works by <strong>partitioning</strong> the array into smaller sections around a "pivot" element and then sorting those sections independently.</p>
            <p>It is one of the <strong>fastest sorting algorithms in practice</strong>, widely used in libraries and systems.</p>
            <p>The basic idea:</p>
            <ol>
                <li>Choose a <strong>pivot element</strong> (commonly the last, first, middle, or random element).</li>
                <li>Rearrange (partition) the array so that:</li>
                <li>All elements <strong>smaller than the pivot</strong> come before it.</li>
                <li>All elements <strong>larger than the pivot</strong> come after it.</li>
                <li>The pivot is now in its <strong>final sorted position</strong>.</li>
                <li>Recursively apply Quick Sort to the <strong>left subarray</strong> and <strong>right subarray</strong>.</li>
            </ol>
            <p><strong>Example Run</strong></p>
            <p>We will sort the array:</p>
            <p>
            <div>
                <pre><code class="language-shell">[ 10 ][ 80 ][ 30 ][ 90 ][ 40 ][ 50 ][ 70 ]</code></pre>
            </div>
            </p>
            <p><strong>Step 1: Choose Pivot (last element = 70)</strong></p>
            <p>Partition around 70.</p>
            <p>
            <div>
                <pre><code class="language-shell">Initial:   [ 10 ][ 80 ][ 30 ][ 90 ][ 40 ][ 50 ][ 70 ]

‚Üí Elements &lt; 70: [ 10, 30, 40, 50 ]  
‚Üí Pivot (70) goes here ‚Üì
Sorted split:  [ 10 ][ 30 ][ 40 ][ 50 ][ 70 ][ 90 ][ 80 ]</code></pre>
            </div>
            </p>
            <p><em>(ordering of right side may vary during partition; only pivot‚Äôs position is guaranteed)</em></p>
            <p>‚úî Pivot (70) is in correct place.</p>
            <p><strong>Step 2: Left Subarray [10, 30, 40, 50]</strong></p>
            <p>Choose pivot = 50.</p>
            <p>
            <div>
                <pre><code class="language-shell">[ 10 ][ 30 ][ 40 ][ 50 ]   ‚Üí pivot = 50

‚Üí Elements &lt; 50: [10, 30, 40]  
‚Üí Pivot at correct place  

Result: [ 10 ][ 30 ][ 40 ][ 50 ]</code></pre>
            </div>
            </p>
            <p>‚úî Pivot (50) fixed.</p>
            <p><strong>Step 3: Left Subarray of Left [10, 30, 40]</strong></p>
            <p>Choose pivot = 40.</p>
            <p>
            <div>
                <pre><code class="language-shell">[ 10 ][ 30 ][ 40 ]   ‚Üí pivot = 40

‚Üí Elements &lt; 40: [10, 30]  
‚Üí Pivot at correct place  

Result: [ 10 ][ 30 ][ 40 ]</code></pre>
            </div>
            </p>
            <p>‚úî Pivot (40) fixed.</p>
            <p><strong>Step 4: [10, 30]</strong></p>
            <p>Choose pivot = 30.</p>
            <p>
            <div>
                <pre><code class="language-shell">[ 10 ][ 30 ]   ‚Üí pivot = 30

‚Üí Elements &lt; 30: [10]  

Result: [ 10 ][ 30 ]</code></pre>
            </div>
            </p>
            <p>‚úî Sorted.</p>
            <p><strong>Final Result</strong></p>
            <p>
            <div>
                <pre><code class="language-shell">[ 10 ][ 30 ][ 40 ][ 50 ][ 70 ][ 80 ][ 90 ]</code></pre>
            </div>
            </p>
            <p><strong>Visual Partition Illustration</strong></p>
            <p>Here‚Äôs how the array gets partitioned step by step:</p>
            <p>
            <div>
                <pre><code class="language-shell">Pass 1:  [ 10  80  30  90  40  50 | 70 ]  
          ‚Üì pivot = 70  
          [ 10  30  40  50 | 70 | 90  80 ]

Pass 2:  [ 10  30  40 | 50 ] [70] [90  80]  
          ‚Üì pivot = 50  
          [ 10  30  40 | 50 ] [70] [90  80]

Pass 3:  [ 10  30 | 40 ] [50] [70] [90  80]  
          ‚Üì pivot = 40  
          [ 10  30 | 40 ] [50] [70] [90  80]

Pass 4:  [ 10 | 30 ] [40] [50] [70] [90  80]  
          ‚Üì pivot = 30  
          [ 10 | 30 ] [40] [50] [70] [90  80]</code></pre>
            </div>
            </p>
            <p>‚úî Each pivot splits the problem smaller and smaller until fully sorted.</p>
            <p><strong>Optimizations</strong></p>
            <ul>
                <li><strong>Pivot Choice:</strong> Choosing a good pivot (e.g., median or random) improves performance.</li>
                <li><strong>Small Subarrays:</strong> For very small partitions, switch to Insertion Sort for efficiency.</li>
                <li><strong>Tail Recursion:</strong> Can optimize recursion depth.</li>
            </ul>
            <p><strong>Stability</strong></p>
            <ul>
                <li>Quick Sort is <strong>not stable</strong> by default (equal elements may be reordered).</li>
                <li>Stable versions exist, but require modifications.</li>
            </ul>
            <p><strong>Complexity</strong></p>
            <p>
            <table>
                <tr>
                    <td>Case</td>
                    <td>Time Complexity</td>
                    <td>Notes</td>
                </tr>
                <tr>
                    <td><strong>Worst Case</strong></td>
                    <td>$O(n^2)$</td>
                    <td>Poor pivot choices (e.g., always smallest/largest in sorted array)</td>
                </tr>
                <tr>
                    <td><strong>Average Case</strong></td>
                    <td>$O(n \log n)$</td>
                    <td>Expected performance, very fast in practice</td>
                </tr>
                <tr>
                    <td><strong>Best Case</strong></td>
                    <td>$O(n \log n)$</td>
                    <td>Balanced partitions</td>
                </tr>
                <tr>
                    <td><strong>Space</strong></td>
                    <td>$O(\log n)$</td>
                    <td>Due to recursion stack</td>
                </tr>
            </table>
            </p>
            <p><strong>Implementation</strong></p>
            <ul>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/blob/master/src/sorting/cpp/quick_sort/src/quick_sort.cpp">C++</a></li>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/blob/master/src/sorting/python/quick_sort/src/quick_sort.py">Python</a></li>
            </ul>
            <h3 id="heap-sort">Heap sort</h3>
            <p>Heap Sort is a <strong>comparison-based sorting algorithm</strong> that uses a special data structure called a <strong>binary heap</strong>.
                It is efficient, with guaranteed $O(n \log n)$ performance, and sorts <strong>in-place</strong> (no extra array needed).</p>
            <p>The basic idea:</p>
            <ol>
                <li><strong>Build a max heap</strong> from the input array.</li>
                <li>In a max heap, every parent is greater than its children.</li>
                <li>This ensures the <strong>largest element is at the root</strong> (first index).</li>
                <li>Swap the <strong>root (largest element)</strong> with the <strong>last element</strong> of the heap.</li>
                <li>Reduce the heap size by 1 (ignore the last element, which is now in place).</li>
                <li><strong>Heapify</strong> (restore heap property).</li>
                <li>Repeat until all elements are sorted.</li>
            </ol>
            <p><strong>Example Run</strong></p>
            <p>We will sort the array:</p>
            <p>
            <div>
                <pre><code class="language-shell">[ 4 ][ 10 ][ 3 ][ 5 ][ 1 ]</code></pre>
            </div>
            </p>
            <p><strong>Step 1: Build Max Heap</strong></p>
            <p>Binary tree view:</p>
            <p>
            <div>
                <pre><code class="language-shell">4
      /   \
    10     3
   /  \
  5    1</code></pre>
            </div>
            </p>
            <p>Heapify ‚Üí Largest at top:</p>
            <p>
            <div>
                <pre><code class="language-shell">10
      /   \
     5     3
    / \
   4   1

Array: [ 10 ][ 5 ][ 3 ][ 4 ][ 1 ]</code></pre>
            </div>
            </p>
            <p><strong>Step 2: Swap Root with Last</strong></p>
            <p>Swap 10 ‚Üî 1 ‚Üí largest (10) moves to correct final place.</p>
            <p>
            <div>
                <pre><code class="language-shell">[ 1 ][ 5 ][ 3 ][ 4 ][ 10 ]</code></pre>
            </div>
            </p>
            <p>Heapify the reduced heap [1,5,3,4]:</p>
            <p>
            <div>
                <pre><code class="language-shell">5
      / \
     4   3
    /
   1

Array: [ 5 ][ 4 ][ 3 ][ 1 ][ 10 ]</code></pre>
            </div>
            </p>
            <p><strong>Step 3: Swap Root with Last</strong></p>
            <p>Swap 5 ‚Üî 1.</p>
            <p>
            <div>
                <pre><code class="language-shell">[ 1 ][ 4 ][ 3 ][ 5 ][ 10 ]</code></pre>
            </div>
            </p>
            <p>Heapify reduced heap [1,4,3]:</p>
            <p>
            <div>
                <pre><code class="language-shell">4
      / \
     1   3

Array: [ 4 ][ 1 ][ 3 ][ 5 ][ 10 ]</code></pre>
            </div>
            </p>
            <p><strong>Step 4: Swap Root with Last</strong></p>
            <p>Swap 4 ‚Üî 3.</p>
            <p>
            <div>
                <pre><code class="language-shell">[ 3 ][ 1 ][ 4 ][ 5 ][ 10 ]</code></pre>
            </div>
            </p>
            <p>Heapify reduced heap [3,1]:</p>
            <p>
            <div>
                <pre><code class="language-shell">3
      /
     1

Array: [ 3 ][ 1 ][ 4 ][ 5 ][ 10 ]</code></pre>
            </div>
            </p>
            <p><strong>Step 5: Swap Root with Last</strong></p>
            <p>Swap 3 ‚Üî 1.</p>
            <p>
            <div>
                <pre><code class="language-shell">[ 1 ][ 3 ][ 4 ][ 5 ][ 10 ]</code></pre>
            </div>
            </p>
            <p>‚úî Sorted array achieved.</p>
            <p><strong>Final Result</strong></p>
            <p>
            <div>
                <pre><code class="language-shell">[ 1 ][ 3 ][ 4 ][ 5 ][ 10 ]</code></pre>
            </div>
            </p>
            <p><strong>Visual Progress</strong></p>
            <p>
            <div>
                <pre><code class="language-shell">Initial:   [ 4  10  3  5  1 ]
Heapify:   [ 10  5  3  4  1 ]
Step 1:    [ 5  4  3  1 | 10 ]
Step 2:    [ 4  1  3 | 5  10 ]
Step 3:    [ 3  1 | 4  5  10 ]
Step 4:    [ 1 | 3  4  5  10 ]
Sorted:    [ 1  3  4  5  10 ]</code></pre>
            </div>
            </p>
            <p>‚úî Each step places the largest element into its correct final position.</p>
            <p><strong>Optimizations</strong></p>
            <ul>
                <li>Building the heap can be done in <strong>O(n)</strong> time using bottom-up heapify.</li>
                <li>After building, each extract-max + heapify takes <strong>O(log n)</strong>.</li>
            </ul>
            <p><strong>Stability</strong></p>
            <p>Heap sort is <strong>not stable</strong>. Equal elements may not preserve their original order because of swaps.</p>
            <p><strong>Complexity</strong></p>
            <p>
            <table>
                <tr>
                    <td>Case</td>
                    <td>Time Complexity</td>
                    <td>Notes</td>
                </tr>
                <tr>
                    <td><strong>Worst Case</strong></td>
                    <td>$O(n \log n)$</td>
                    <td></td>
                </tr>
                <tr>
                    <td><strong>Average Case</strong></td>
                    <td>$O(n \log n)$</td>
                    <td></td>
                </tr>
                <tr>
                    <td><strong>Best Case</strong></td>
                    <td>$O(n \log n)$</td>
                    <td>No early exit possible</td>
                </tr>
                <tr>
                    <td><strong>Space</strong></td>
                    <td>$O(1)$</td>
                    <td>In-place</td>
                </tr>
            </table>
            </p>
            <p><strong>Implementation</strong></p>
            <ul>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/blob/master/src/sorting/cpp/heap_sort/src/heap_sort.cpp">C++</a></li>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/blob/master/src/sorting/python/heap_sort/src/heap_sort.py">Python</a></li>
            </ul>
            <h3 id="radix-sort">Radix Sort</h3>
            <p>Radix Sort is a <strong>non-comparison-based sorting algorithm</strong>.
                Instead of comparing elements directly, it processes numbers digit by digit, from either the <strong>least significant digit (LSD)</strong> or the <strong>most significant digit (MSD)</strong>, using a stable intermediate sorting algorithm (commonly <strong>Counting Sort</strong>).</p>
            <p>Because it avoids comparisons, Radix Sort can achieve <strong>linear time complexity</strong> in many cases.</p>
            <p>The basic idea:</p>
            <ol>
                <li>Pick a <strong>digit position</strong> (units, tens, hundreds, etc.).</li>
                <li>Sort the array by that digit using a <strong>stable sorting algorithm</strong>.</li>
                <li>Move to the next digit.</li>
                <li>Repeat until all digits are processed.</li>
            </ol>
            <p><strong>Example Run (LSD Radix Sort)</strong></p>
            <p>We will sort the array:</p>
            <p>
            <div>
                <pre><code class="language-shell">[ 170 ][ 45 ][ 75 ][ 90 ][ 802 ][ 24 ][ 2 ][ 66 ]</code></pre>
            </div>
            </p>
            <p><strong>Step 1: Sort by 1s place (units digit)</strong></p>
            <p>
            <div>
                <pre><code class="language-shell">Original: [170, 45, 75, 90, 802, 24, 2, 66]

By 1s digit:
[170][90] (0)
[802][2]  (2)
[24]      (4)
[45][75]  (5)
[66]      (6)

Result: [170][90][802][2][24][45][75][66]</code></pre>
            </div>
            </p>
            <p><strong>Step 2: Sort by 10s place</strong></p>
            <p>
            <div>
                <pre><code class="language-shell">[170][90][802][2][24][45][75][66]

By 10s digit:
[802][2]   (0)
[24]       (2)
[45]       (4)
[66]       (6)
[170][75]  (7)
[90]       (9)

Result: [802][2][24][45][66][170][75][90]</code></pre>
            </div>
            </p>
            <p><strong>Step 3: Sort by 100s place</strong></p>
            <p>
            <div>
                <pre><code class="language-shell">[802][2][24][45][66][170][75][90]

By 100s digit:
[2][24][45][66][75][90]  (0)
[170]                   (1)
[802]                   (8)

Result: [2][24][45][66][75][90][170][802]</code></pre>
            </div>
            </p>
            <p><strong>Final Result</strong></p>
            <p>
            <div>
                <pre><code class="language-shell">[ 2 ][ 24 ][ 45 ][ 66 ][ 75 ][ 90 ][ 170 ][ 802 ]</code></pre>
            </div>
            </p>
            <p><strong>Visual Process</strong></p>
            <p>
            <div>
                <pre><code class="language-shell">Step 1 (1s):   [170  90  802  2  24  45  75  66]
Step 2 (10s):  [802  2  24  45  66  170  75  90]
Step 3 (100s): [2  24  45  66  75  90  170  802]</code></pre>
            </div>
            </p>
            <p>‚úî Each pass groups by digit ‚Üí final sorted order.</p>
            <p><strong>LSD vs MSD</strong></p>
            <ul>
                <li><strong>LSD (Least Significant Digit first):</strong> Process digits from right (units) to left (hundreds). Most common, simpler.</li>
                <li><strong>MSD (Most Significant Digit first):</strong> Process from left to right, useful for variable-length data like strings.</li>
            </ul>
            <p><strong>Stability</strong></p>
            <ul>
                <li>Radix Sort <strong>is stable</strong>, because it relies on a stable intermediate sort (like Counting Sort).</li>
                <li>Equal elements remain in the same order across passes.</li>
            </ul>
            <p><strong>Complexity</strong></p>
            <ul>
                <li>
                    <p><strong>Time Complexity:</strong> $O(n \cdot k)$</p>
                </li>
                <li>
                    <p>$n$ = number of elements</p>
                </li>
                <li>
                    <p>$k$ = number of digits (or max digit length)</p>
                </li>
                <li>
                    <p><strong>Space Complexity:</strong> $O(n + k)$ (depends on the stable sorting method used, e.g., Counting Sort).</p>
                </li>
                <li>
                    <p>For integers with fixed number of digits, Radix Sort can be considered <strong>linear time</strong>.</p>
                </li>
            </ul>
            <p><strong>Implementation</strong></p>
            <ul>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/blob/master/src/sorting/cpp/radix_sort/src/radix_sort.cpp">C++</a></li>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/blob/master/src/sorting/python/radix_sort/src/radix_sort.py">Python</a></li>
            </ul>
            <h3 id="counting-sort">Counting Sort</h3>
            <p>Counting Sort is a <strong>non-comparison-based sorting algorithm</strong> that works by <strong>counting occurrences</strong> of each distinct element and then calculating their positions in the output array.</p>
            <p>It is especially efficient when:</p>
            <ul>
                <li>The input values are integers.</li>
                <li>The <strong>range of values (k)</strong> is not significantly larger than the number of elements (n).</li>
            </ul>
            <p>The basic idea:</p>
            <ol>
                <li>Find the <strong>range</strong> of the input (min to max).</li>
                <li>Create a <strong>count array</strong> to store the frequency of each number.</li>
                <li>Modify the count array to store <strong>prefix sums</strong> (cumulative counts).</li>
                <li>This gives the final position of each element.</li>
                <li>Place elements into the output array in order, using the count array.</li>
            </ol>
            <p><strong>Example Run</strong></p>
            <p>We will sort the array:</p>
            <p>
            <div>
                <pre><code class="language-shell">[ 4 ][ 2 ][ 2 ][ 8 ][ 3 ][ 3 ][ 1 ]</code></pre>
            </div>
            </p>
            <p><strong>Step 1: Count Frequencies</strong></p>
            <p>
            <div>
                <pre><code class="language-shell">Elements:  1  2  3  4  5  6  7  8
Counts:    1  2  2  1  0  0  0  1</code></pre>
            </div>
            </p>
            <p><strong>Step 2: Prefix Sums</strong></p>
            <p>
            <div>
                <pre><code class="language-shell">Elements:  1  2  3  4  5  6  7  8
Counts:    1  3  5  6  6  6  6  7</code></pre>
            </div>
            </p>
            <p>‚úî Now each number tells us the <strong>last index position</strong> where that value should go.</p>
            <p><strong>Step 3: Place Elements</strong></p>
            <p>Process input from right ‚Üí left (for stability).</p>
            <p>
            <div>
                <pre><code class="language-shell">Input:  [4,2,2,8,3,3,1]

Place 1 ‚Üí index 0
Place 3 ‚Üí index 4
Place 3 ‚Üí index 3
Place 8 ‚Üí index 6
Place 2 ‚Üí index 2
Place 2 ‚Üí index 1
Place 4 ‚Üí index 5</code></pre>
            </div>
            </p>
            <p><strong>Final Result</strong></p>
            <p>
            <div>
                <pre><code class="language-shell">[ 1 ][ 2 ][ 2 ][ 3 ][ 3 ][ 4 ][ 8 ]</code></pre>
            </div>
            </p>
            <p><strong>Visual Process</strong></p>
            <p>
            <div>
                <pre><code class="language-shell">Step 1 Count:   [0,1,2,2,1,0,0,0,1]
Step 2 Prefix:  [0,1,3,5,6,6,6,6,7]
Step 3 Output:  [1,2,2,3,3,4,8]</code></pre>
            </div>
            </p>
            <p>‚úî Linear-time sorting by counting positions.</p>
            <p><strong>Stability</strong></p>
            <p>Counting Sort is <strong>stable</strong> if we place elements <strong>from right to left</strong> into the output array.</p>
            <p><strong>Complexity</strong></p>
            <p>
            <table>
                <tr>
                    <td>Case</td>
                    <td>Time Complexity</td>
                    <td>Notes</td>
                </tr>
                <tr>
                    <td><strong>Overall</strong></td>
                    <td>$O(n + k)$</td>
                    <td>$n$ = number of elements, $k$ = value range</td>
                </tr>
                <tr>
                    <td><strong>Space</strong></td>
                    <td>$O(n + k)$</td>
                    <td>Extra array for counts + output</td>
                </tr>
            </table>
            </p>
            <p><strong>Implementation</strong></p>
            <ul>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/blob/master/src/sorting/cpp/counting_sort/src/counting_sort.cpp">C++</a></li>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/blob/master/src/sorting/python/counting_sort/src/counting_sort.py">Python</a></li>
            </ul>
            <h3 id="comparison-table">Comparison Table</h3>
            <p>Below is a consolidated <strong>side-by-side comparison</strong> of all the sorts we‚Äôve covered so far:</p>
            <p>
            <table>
                <tr>
                    <td>Algorithm</td>
                    <td>Best Case</td>
                    <td>Average</td>
                    <td>Worst Case</td>
                    <td>Space</td>
                    <td>Stable?</td>
                    <td>Notes</td>
                </tr>
                <tr>
                    <td><strong>Bubble Sort</strong></td>
                    <td>O(n)</td>
                    <td>O(n¬≤)</td>
                    <td>O(n¬≤)</td>
                    <td>O(1)</td>
                    <td>Yes</td>
                    <td>Simple, slow</td>
                </tr>
                <tr>
                    <td><strong>Selection Sort</strong></td>
                    <td>O(n¬≤)</td>
                    <td>O(n¬≤)</td>
                    <td>O(n¬≤)</td>
                    <td>O(1)</td>
                    <td>No</td>
                    <td>Few swaps</td>
                </tr>
                <tr>
                    <td><strong>Insertion Sort</strong></td>
                    <td>O(n)</td>
                    <td>O(n¬≤)</td>
                    <td>O(n¬≤)</td>
                    <td>O(1)</td>
                    <td>Yes</td>
                    <td>Good for small inputs</td>
                </tr>
                <tr>
                    <td><strong>Quick Sort</strong></td>
                    <td>O(n log n)</td>
                    <td>O(n log n)</td>
                    <td>O(n¬≤)</td>
                    <td>O(log n)</td>
                    <td>No</td>
                    <td>Very fast in practice</td>
                </tr>
                <tr>
                    <td><strong>Heap Sort</strong></td>
                    <td>O(n log n)</td>
                    <td>O(n log n)</td>
                    <td>O(n log n)</td>
                    <td>O(1)</td>
                    <td>No</td>
                    <td>Guaranteed performance</td>
                </tr>
                <tr>
                    <td><strong>Counting Sort</strong></td>
                    <td>O(n + k)</td>
                    <td>O(n + k)</td>
                    <td>O(n + k)</td>
                    <td>O(n + k)</td>
                    <td>Yes</td>
                    <td>Integers only</td>
                </tr>
                <tr>
                    <td><strong>Radix Sort</strong></td>
                    <td>O(nk)</td>
                    <td>O(nk)</td>
                    <td>O(nk)</td>
                    <td>O(n + k)</td>
                    <td>Yes</td>
                    <td>Uses Counting Sort</td>
                </tr>
            </table>
            </p>
        </section>
        <div id="table-of-contents">
            <h2>Table of Contents</h2>
            <ol><a href="#sorting">Sorting</a>
                <ol>
                    <li><a href="#stability-in-sorting">Stability in Sorting</a>
                        <ol>
                            <li><a href="#stable-sort">Stable Sort</a></li>
                            <li><a href="#unstable-sort">Unstable Sort</a></li>
                        </ol>
                    </li>
                    <li><a href="#bubble-sort">Bubble Sort</a></li>
                    <li><a href="#selection-sort">Selection Sort</a></li>
                    <li><a href="#insertion-sort">Insertion Sort</a></li>
                    <li><a href="#quick-sort">Quick Sort</a></li>
                    <li><a href="#heap-sort">Heap sort</a></li>
                    <li><a href="#radix-sort">Radix Sort</a></li>
                    <li><a href="#counting-sort">Counting Sort</a></li>
                    <li><a href="#comparison-table">Comparison Table</a></li>
                </ol>
            </ol>
            <div id="related-articles">
                <h2>Related Articles</h2>
                <ol>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/backtracking.html">Backtracking</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/basic_concepts.html">Basic Concepts</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/brain_teasers.html">Brain Teasers</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/data_structures.html">Data Structures</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/dynamic_programming.html">Dynamic Programming</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/graphs.html">Graphs</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/greedy_algorithms.html">Greedy Algorithms</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/matrices.html">Matrices</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/searching.html">Searching</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/sorting.html">Sorting</a></li>
                </ol>
            </div>
        </div>
    </div>
    <footer>
        <div class="footer-columns">
            <div class="footer-column">
                <img alt="Adam Djellouli Symbol" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/symbol.png" />
            </div>
            <div class="footer-column">
                <h2><a href="https://adamdjellouli.com/core/privacy_policy.html" title="Privacy Policy">Our Privacy Policy</a></h2>
                <p>Thank you for visiting my personal website. All content here is free to use, but please remember to be respectful and avoid any misuse of the site. If you‚Äôd like to get in touch, feel free to reach out via my <a href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" title="LinkedIn Profile">LinkedIn profile</a> or connect with me on <a href="https://github.com/djeada" title="GitHub Profile">GitHub</a> if you have technical questions or ideas to share. Wishing you all the best and a fantastic life ahead!</p>
            </div>
            <div class="footer-column">
                <h2>Follow me</h2>
                <ul class="social-media">
                    <li>
                        <a class="fa fa-youtube" href="https://www.youtube.com/channel/UCGPoHTVjMN77wcGknXPHl1Q" target="_blank" title="YouTube">
                        </a>YouTube
                    </li>
                    <li>
                        <a class="fa fa-linkedin" href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" target="_blank" title="LinkedIn">
                        </a>LinkedIn
                    </li>
                    <li>
                        <a class="fa fa-instagram" href="https://www.instagram.com/linuxchallenges/" target="_blank" title="Instagram">
                        </a>Instagram
                    </li>
                    <li>
                        <a class="fa fa-github" href="https://github.com/djeada" title="GitHub">
                        </a>Github
                    </li>
                </ul>
            </div>
        </div>
        <div>
            <p id="copyright">
                ¬© Adam Djellouli. All rights reserved.
            </p>
        </div>
        <script>
            document.getElementById("copyright").innerHTML = "&copy; " + new Date().getFullYear() + " Adam Djellouli. All rights reserved.";
        </script>
        <script src="../../app.js"></script>
    </footer>
    <div id="pdf-spinner-overlay">
        <div class="spinner"></div>
    </div>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-bash.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-cpp.min.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
jax: ["input/TeX", "output/HTML-CSS"],
extensions: ["tex2jax.js"],
"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] },
tex2jax: { inlineMath: [ ["$", "$"] ], displayMath: [ ["$$","$$"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
TeX: { noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } } },
messageStyle: "none"
});
</script>
<script async="" id="MathJax-script" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>

</html>