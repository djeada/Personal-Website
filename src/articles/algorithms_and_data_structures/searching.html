<!DOCTYPE html>

<html lang="en">

<head>
    <script async="" crossorigin="anonymous" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5593122079896089"></script>
    <meta charset="utf-8" />
    <title>Searching</title>
    <meta content="Searching refers to the process of finding the location of a specific element within a collection of data, such as an array, list, tree, or graph." name="description" />
    <meta content="Adam Djellouli" name="author" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <meta content="IE=edge" http-equiv="X-UA-Compatible" />
    <link crossorigin="" href="https://fonts.googleapis.com" rel="preconnect" />
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/icon.ico" rel="icon" />
    <link href="../../resources/style.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
</head>

<body>
    <nav aria-label="Main navigation">
        <a class="logo" href="https://adamdjellouli.com">
            <img alt="Adam Djellouli - Home Page Logo" id="logo-image" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/logo.PNG" />
        </a>
        <input aria-label="Toggle navigation menu" id="navbar-toggle" type="checkbox" />
        <ul aria-labelledby="navbar-toggle" role="menu">
            <li role="menuitem">
                <a href="../../index.html" title="Go to Home Page"> Home </a>
            </li>
            <li role="menuitem">
                <a class="active" href="../../core/blog.html" title="Read Adam Djellouli Blog on Programming and Technology"> Blog </a>
            </li>
            <li role="menuitem">
                <a href="../../core/tools.html" title="Discover Tools Created by Adam Djellouli"> Tools </a>
            </li>
            <li role="menuitem">
                <a href="../../core/projects.html" title="Explore Projects Developed by Adam Djellouli"> Projects </a>
            </li>
            <li role="menuitem">
                <a href="../../core/resume.html" title="View Adam Djellouli Professional Resume"> Resume </a>
            </li>
            <li>
                <script async="" src="https://cse.google.com/cse.js?cx=8160ef9bb935f4f68"></script>
                <div class="gcse-search"></div>
            </li>
            <li>
                <button aria-label="Toggle dark mode" id="dark-mode-button"></button>
            </li>
        </ul>
    </nav>
    <div id="article-wrapper">
        <section id="article-body">
            <div class="article-action-buttons"><button class="btn-suggest-edit" title="Suggest Edit">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <path d="M4 21h4l11-11-4-4L4 17v4z" stroke="currentColor" stroke-width="2"></path>
                    </svg>
                </button><button class="btn-create-issue" title="Create Issue">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2"></circle>
                        <line stroke="currentColor" stroke-width="2" x1="12" x2="12" y1="8" y2="12"></line>
                        <circle cx="12" cy="16" fill="currentColor" r="1"></circle>
                    </svg>
                </button><button class="btn-download" title="Download">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <path d="M12 5v14m0 0l-6-6m6 6l6-6" stroke="currentColor" stroke-width="2"></path>
                    </svg>
                </button></div>
            <p style="text-align: right;"><i>Last modified: September 01, 2025</i></p>
            <p style="text-align: right;"><i>This article is written in: üá∫üá∏</i></p>
            <h2 id="searching">Searching</h2>
            <p>Searching refers to the process of finding the location of a specific element within a collection of data, such as an array, list, tree, or graph. It underpins many applications, from databases and information retrieval to routing and artificial intelligence. Depending on the organization of the data, different search techniques are used‚Äîsuch as linear search for unsorted data, binary search for sorted data, and more advanced approaches like hash-based lookup or tree traversals for hierarchical structures. Efficient searching is important because it directly impacts the performance and scalability of software systems.</p>
            <h3 id="linear-sequential-search">Linear &amp; Sequential Search</h3>
            <h4 id="linear-search">Linear Search</h4>
            <p>Scan the list from left to right, comparing the target with each element until you either find a match (return its index) or finish the list (report ‚Äúnot found‚Äù).</p>
            <p><strong>Example inputs and outputs</strong></p>
            <p><em>Example 1</em></p>
            <p>$$
                \text{Input: } [7, 3, 5, 2, 9], \quad \text{target} = 5
                $$</p>
            <p>$$
                \text{Output: } \text{index} = 2
                $$</p>
            <p><em>Example 2</em></p>
            <p>$$
                \text{Input: } [4, 4, 4], \quad \text{target} = 4
                $$</p>
            <p>$$
                \text{Output: } \text{index} = 0 (\text{first match})
                $$</p>
            <p><em>Example 3</em></p>
            <p>$$
                \text{Input: } [10, 20, 30], \quad \text{target} = 25
                $$</p>
            <p>$$
                \text{Output: } \text{not found}
                $$</p>
            <p><strong>How Linear Search Works</strong></p>
            <p>We start at index <code>0</code>, compare the value with the target, and keep moving right until we either <strong>find it</strong> or reach the <strong>end</strong>.</p>
            <p>Target <strong>5</strong> in <code>[7, 3, 5, 2, 9]</code></p>
            <p>
            <div>
                <pre><code class="language-shell">Indexes:   0    1    2    3    4
List:     [7]  [3]  [5]  [2]  [9]
Target: 5</code></pre>
            </div>
            </p>
            <p><em>Step 1:</em> pointer at index 0</p>
            <p>
            <div>
                <pre><code class="language-shell">|
v
7   3   5   2   9

‚Üí compare 7 vs 5  ‚Üí no</code></pre>
            </div>
            </p>
            <p><em>Step 2:</em> pointer moves to index 1</p>
            <p>
            <div>
                <pre><code class="language-shell">|
    v
7   3   5   2   9

‚Üí compare 3 vs 5  ‚Üí no</code></pre>
            </div>
            </p>
            <p><em>Step 3:</em> pointer moves to index 2</p>
            <p>
            <div>
                <pre><code class="language-shell">|
        v
7   3   5   2   9

‚Üí compare 5 vs 5  ‚Üí YES ‚úÖ ‚Üí return index 2</code></pre>
            </div>
            </p>
            <p><strong>Worst Case (Not Found)</strong></p>
            <p>Target <strong>9</strong> in <code>[1, 2, 3]</code></p>
            <p>
            <div>
                <pre><code class="language-shell">Indexes:   0    1    2
List:     [1]  [2]  [3]
Target: 9</code></pre>
            </div>
            </p>
            <p>Checks:</p>
            <p>
            <div>
                <pre><code class="language-shell">‚Üí  1 ‚â† 9
‚Üí  2 ‚â† 9
‚Üí  3 ‚â† 9
‚Üí  end
‚Üí not found ‚ùå</code></pre>
            </div>
            </p>
            <ul>
                <li>Works on any list; no sorting or structure required.</li>
                <li>Returns the first index containing the target; if absent, reports ‚Äúnot found.‚Äù</li>
                <li>Time: $O(n)$ comparisons on average and in the worst case; best case $O(1)$ if the first element matches.</li>
                <li>Space: $O(1)$ extra memory.</li>
                <li>Naturally finds the earliest occurrence when duplicates exist.</li>
                <li>Simple and dependable for short or unsorted data.</li>
                <li>Assumes 0-based indexing in these notes.</li>
            </ul>
            <h4 id="sentinel-linear-search">Sentinel Linear Search</h4>
            <p>Place one copy of the target at the very end as a ‚Äúsentinel‚Äù so the scan can run without checking bounds each step; afterward, decide whether the match was inside the original list or only at the sentinel position.</p>
            <p><strong>Example inputs and outputs</strong></p>
            <p><em>Example 1</em></p>
            <p>$$
                \text{Input: } [12, 8, 6, 15], \quad \text{target} = 6
                $$</p>
            <p>$$
                \text{Output: } \text{index} = 2
                $$</p>
            <p><em>Example 2</em></p>
            <p>$$
                \text{Input: } [2, 4, 6, 8], \quad \text{target} = 5
                $$</p>
            <p>$$
                \text{Output: } \text{not found } (\text{only the sentinel matched})
                $$</p>
            <p><strong>How it works</strong></p>
            <p>Put the target at one extra slot at the end so the loop is guaranteed to stop on a match; afterward, check whether the match was inside the original range.</p>
            <p>Target <strong>11</strong> not in the list</p>
            <p>
            <div>
                <pre><code class="language-shell">Original list (n=5):
[ 4 ][ 9 ][ 1 ][ 7 ][ 6 ]
Target: 11</code></pre>
            </div>
            </p>
            <p>Add sentinel (extra slot):</p>
            <p>
            <div>
                <pre><code class="language-shell">[ 4 ][ 9 ][ 1 ][ 7 ][ 6 ][ 11 ]
  0    1    2    3    4     5  ‚Üê sentinel</code></pre>
            </div>
            </p>
            <p>Scan step by step:</p>
            <p>
            <div>
                <pre><code class="language-shell">4 ‚â† 11   ‚Üí pointer at 0
9 ‚â† 11   ‚Üí pointer at 1
1 ‚â† 11   ‚Üí pointer at 2
7 ‚â† 11   ‚Üí pointer at 3
6 ‚â† 11   ‚Üí pointer at 4
11 = 11  ‚Üí pointer at 5 (sentinel)</code></pre>
            </div>
            </p>
            <p>Therefore, <strong>not found</strong> in original list.</p>
            <p>Target <strong>6</strong> inside the list</p>
            <p>
            <div>
                <pre><code class="language-shell">Original list (n=4):
[ 12 ][ 8 ][ 6 ][ 15 ]
Target: 6</code></pre>
            </div>
            </p>
            <p>Add sentinel:</p>
            <p>
            <div>
                <pre><code class="language-shell">[ 12 ][ 8 ][ 6 ][ 15 ][ 6 ]
  0     1    2    3     4</code></pre>
            </div>
            </p>
            <p>Scan:</p>
            <p>
            <div>
                <pre><code class="language-shell">12 ‚â† 6   ‚Üí index 0
 8 ‚â† 6   ‚Üí index 1
 6 = 6   ‚Üí index 2 ‚úÖ</code></pre>
            </div>
            </p>
            <ul>
                <li>Removes the per-iteration ‚Äúhave we reached the end?‚Äù check; the sentinel guarantees termination.</li>
                <li>Same $O(n)$ time in big-O terms, but slightly fewer comparisons in tight loops.</li>
                <li>Space: needs one extra slot; if you cannot append, you can temporarily overwrite the last element (store it, write the target, then restore it).</li>
                <li>After scanning, decide by index: if the first match index &lt; original length, it‚Äôs a real match; otherwise, it‚Äôs only the sentinel.</li>
                <li>Use when micro-optimizing linear scans over arrays where bounds checks are costly.</li>
                <li>Behavior with duplicates: still returns the first occurrence within the original range.</li>
                <li>Be careful to restore any overwritten last element if you used the in-place variant.</li>
            </ul>
            <h3 id="divide-conquer-search">Divide &amp; Conquer Search</h3>
            <h4 id="binary-search">Binary Search</h4>
            <p>On a sorted array, repeatedly halve the search interval by comparing the target to the middle element until found or the interval is empty.</p>
            <p><strong>Example inputs and outputs</strong></p>
            <p><em>Example 1</em></p>
            <p>$$
                \text{Input: } A = [2, 5, 8, 12, 16, 23, 38], \quad \text{target} = 16
                $$</p>
            <p>$$
                \text{Output: } \text{index} = 4
                $$</p>
            <p><em>Example 2</em></p>
            <p>$$
                \text{Input: } A = [1, 3, 3, 3, 9], \quad \text{target} = 3
                $$</p>
            <p>$$
                \text{Output: } \text{index} = 2 \quad (\text{any valid match; first/last needs a variant})
                $$</p>
            <p><em>Example 3</em></p>
            <p>$$
                \text{Input: } A = [10, 20, 30, 40], \quad \text{target} = 35
                $$</p>
            <p>$$
                \text{Output: } \text{not found}
                $$</p>
            <p><strong>How it works</strong></p>
            <p>We repeatedly check the <strong>middle</strong> element, and then discard half the list based on comparison.</p>
            <p>Find <strong>16</strong> in:</p>
            <p>
            <div>
                <pre><code class="language-shell">A = [  2 ][  5 ][  8 ][ 12 ][ 16 ][ 23 ][ 38 ]
i =    0     1     2     3     4     5     6</code></pre>
            </div>
            </p>
            <p><em>Step 1</em></p>
            <p>
            <div>
                <pre><code class="language-shell">low = 0, high = 6
mid = (0+6)//2 = 3
A[3] = 12 &lt; 16  ‚Üí  target is to the RIGHT  ‚Üí  new low = mid + 1 = 4

A = [  2 ][  5 ][  8 ][ 12 ][ 16 ][ 23 ][ 38 ]
i =    0     1     2     3     4     5     6
        ‚ÜëL                ‚ÜëM                ‚ÜëH
        0                 3                 6
Active range: indices 0..6</code></pre>
            </div>
            </p>
            <p><em>Step 2</em></p>
            <p>
            <div>
                <pre><code class="language-shell">low = 4, high = 6
mid = (4+6)//2 = 5
A[5] = 23 &gt; 16  ‚Üí  target is to the LEFT   ‚Üí  new high = mid - 1 = 4

A = [  2 ][  5 ][  8 ][ 12 ][ 16 ][ 23 ][ 38 ]
i =    0     1     2     3     4     5     6
                              ‚ÜëL      ‚ÜëM      ‚ÜëH
                              4       5       6
Active range: indices 4..6</code></pre>
            </div>
            </p>
            <p><em>Step 3</em></p>
            <p>
            <div>
                <pre><code class="language-shell">low = 4, high = 4
mid = 4
A[4] = 16 == target ‚úÖ

A = [  2 ][  5 ][  8 ][ 12 ][ 16 ][ 23 ][ 38 ]
i =    0     1     2     3     4     5     6
                              ‚ÜëLMH
                              4
Active range: indices 4..4</code></pre>
            </div>
            </p>
            <p>FOUND at index 4</p>
            <ul>
                <li>Requires a sorted array (assume ascending here).</li>
                <li>Time: $O(log n)$; Space: $O(1)$ iterative.</li>
                <li>Returns any one matching index by default; ‚Äúfirst/last occurrence‚Äù is a small, common refinement.</li>
                <li>Robust, cache-friendly, and a building block for many higher-level searches.</li>
                <li>Beware of off-by-one errors when shrinking bounds.</li>
            </ul>
            <h4 id="ternary-search">Ternary Search</h4>
            <p>Like binary, but splits the current interval into three parts using two midpoints; used mainly for unimodal functions or very specific array cases.</p>
            <p><strong>Example inputs and outputs</strong></p>
            <p><em>Example 1</em></p>
            <p>$$
                \text{Input: } A = [1, 4, 7, 9, 12, 15], \quad \text{target} = 9
                $$</p>
            <p>$$
                \text{Output: } \text{index} = 3
                $$</p>
            <p><em>Example 2</em></p>
            <p>$$
                \text{Input: } A = [2, 6, 10, 14], \quad \text{target} = 5
                $$</p>
            <p>$$
                \text{Output: } \text{not found}
                $$</p>
            <p><strong>How it works</strong></p>
            <p>We divide the array into <strong>three parts</strong> using two midpoints <code>m1</code> and <code>m2</code>.</p>
            <ul>
                <li>If <code>target &lt; A[m1]</code> ‚Üí search $[low .. m1-1]$</li>
                <li>Else if <code>target &gt; A[m2]</code> ‚Üí search $[m2+1 .. high]$</li>
                <li>Else ‚Üí search $[m1+1 .. m2-1]$</li>
            </ul>
            <p>
            <div>
                <pre><code class="language-shell">A = [  1 ][  4 ][  7 ][  9 ][ 12 ][ 15 ]
i =    0     1     2     3     4     5
Target: 9</code></pre>
            </div>
            </p>
            <p><em>Step 1</em></p>
            <p>
            <div>
                <pre><code class="language-shell">low = 0, high = 5

m1 = low + (high - low)//3  = 0 + (5)//3 = 1
m2 = high - (high - low)//3 = 5 - (5)//3 = 3

A[m1] = 4
A[m2] = 9

A = [  1 ][  4 ][  7 ][  9 ][ 12 ][ 15 ]
i =    0     1     2     3     4     5
        ‚ÜëL    ‚Üëm1        ‚Üëm2           ‚ÜëH
        0     1          3             5</code></pre>
            </div>
            </p>
            <p>FOUND at index 3</p>
            <ul>
                <li>Also assumes a sorted array.</li>
                <li>For discrete sorted arrays, it does <strong>not</strong> beat binary search asymptotically; it performs more comparisons per step.</li>
                <li>Most valuable for searching the extremum of a <strong>unimodal function</strong> on a continuous domain; for arrays, prefer binary search.</li>
                <li>Complexity: $O(log n)$ steps but with larger constant factors than binary search.</li>
            </ul>
            <h4 id="jump-search">Jump Search</h4>
            <p>On a sorted array, jump ahead in fixed block sizes to find the block that may contain the target, then do a linear scan inside that block.</p>
            <p><strong>Example inputs and outputs</strong></p>
            <p><em>Example 1</em></p>
            <p>$$
                \text{Input: } A = [1, 4, 9, 16, 25, 36, 49], \quad \text{target} = 25, \quad \text{jump} = \lfloor \sqrt{7} \rfloor = 2
                $$</p>
            <p>$$
                \text{Output: } \text{index} = 4
                $$</p>
            <p><em>Example 2</em></p>
            <p>$$
                \text{Input: } A = [3, 8, 15, 20, 22, 27], \quad \text{target} = 21, \quad \text{jump} = 2
                $$</p>
            <p>$$
                \text{Output: } \text{not found}
                $$</p>
            <p><strong>How it works</strong></p>
            <p>Perfect ‚Äî that‚Äôs a <strong>jump search trace</strong>. Let me reformat and polish it so the steps are crystal clear and the ‚Äújump + linear scan‚Äù pattern pops visually:</p>
            <p>We‚Äôre applying <strong>jump search</strong> to find $25$ in</p>
            <p>$$
                A = [1, 4, 9, 16, 25, 36, 49]
                $$</p>
            <p>with $n=7$, block size $\approx \sqrt{7} \approx 2$, so <strong>jump=2</strong>.</p>
            <p>We probe every 2nd index:</p>
            <ul>
                <li>probe = 0 ‚Üí $A[0] = 1 &lt; 25$ ‚Üí jump to 2</li>
                <li>probe = 2 ‚Üí $A[2] = 9 &lt; 25$ ‚Üí jump to 4</li>
                <li>probe = 4 ‚Üí $A[4] = 25 \geq 25$ ‚Üí stop</li>
            </ul>
            <p>So target is in block $(2..4]$</p>
            <p>
            <div>
                <pre><code class="language-shell">[ 1 ][ 4 ] | [ 9 ][16 ] | [25 ][36 ] | [49 ]
    ^            ^            ^            ^
   probe=0      probe=2      probe=4      probe=6</code></pre>
            </div>
            </p>
            <p>Linear Scan in block (indexes 3..4)</p>
            <ul>
                <li>i = 3 ‚Üí $A[3] = 16 &lt; 25$</li>
                <li>i = 4 ‚Üí $A[4] = 25 = 25$ ‚úÖ FOUND</li>
            </ul>
            <p>
            <div>
                <pre><code class="language-shell">Block [16 ][25 ]
       ^    ^
      i=3  i=4 (found!)</code></pre>
            </div>
            </p>
            <p>The element $25$ is found at <strong>index 4</strong>.</p>
            <ul>
                <li>Works on sorted arrays; pick jump ‚âà ‚àön for good balance.</li>
                <li>Time: $O(‚àön)$ comparisons on average; Space: $O(1)$.</li>
                <li>Useful when random access is cheap but full binary search isn‚Äôt desirable (e.g., limited CPU branch prediction, or when scanning in blocks is cache-friendly).</li>
                <li>Degrades gracefully to ‚Äúscan block then stop.‚Äù</li>
            </ul>
            <h4 id="exponential-search">Exponential Search</h4>
            <p>On a sorted array, grow the right boundary exponentially (1, 2, 4, 8, ‚Ä¶) to find a containing range, then finish with binary search in that range.</p>
            <p><strong>Example inputs and outputs</strong></p>
            <p><em>Example 1</em></p>
            <p>$$
                \text{Input: } A = [2, 3, 5, 7, 11, 13, 17, 19, 23], \quad \text{target} = 19
                $$</p>
            <p>$$
                \text{Output: } \text{index} = 7
                $$</p>
            <p><em>Example 2</em></p>
            <p>$$
                \text{Input: } A = [10, 20, 30, 40, 50], \quad \text{target} = 12
                $$</p>
            <p>$$
                \text{Output: } \text{not found}
                $$</p>
            <p><strong>How it works</strong></p>
            <p>
            <div>
                <pre><code class="language-shell">A = [  2 ][  3 ][  5 ][  7 ][ 11 ][ 13 ][ 17 ][ 19 ][ 23 ]
i =    0     1     2     3    4     5     6     7     8
Target = 19</code></pre>
            </div>
            </p>
            <p>Find range by exponential jumps</p>
            <p><em>Start</em> at <code>i=1</code>, double each step until <code>A[i] ‚â• target</code> (or end).</p>
            <p><em>Jump 1:</em> <code>i=1</code></p>
            <p>
            <div>
                <pre><code class="language-shell">A[i]=3 ‚â§ 19  ‚Üí continue
A = [  2 ][  3 ][  5 ][  7 ][ 11 ][ 13 ][ 17 ][ 19 ][ 23 ]
i =    0     1     2     3    4     5     6     7     8
             ‚Üë</code></pre>
            </div>
            </p>
            <p><em>Jump 2:</em> <code>i=2</code></p>
            <p>
            <div>
                <pre><code class="language-shell">A[i]=5 ‚â§ 19  ‚Üí continue
A = [  2 ][  3 ][  5 ][  7 ][ 11 ][ 13 ][ 17 ][ 19 ][ 23 ]
i =    0     1     2     3    4     5     6     7     8
                   ‚Üë</code></pre>
            </div>
            </p>
            <p><em>Jump 3:</em> <code>i=4</code></p>
            <p>
            <div>
                <pre><code class="language-shell">A[i]=11 ‚â§ 19 ‚Üí continue
A = [  2 ][  3 ][  5 ][  7 ][ 11 ][ 13 ][ 17 ][ 19 ][ 23 ]
i =    0     1     2     3    4     5     6     7     8
                               ‚Üë</code></pre>
            </div>
            </p>
            <p><em>Jump 4:</em> <code>i=8</code></p>
            <p>
            <div>
                <pre><code class="language-shell">A[i]=23 &gt; 19  ‚Üí stop
Range is (previous power of two .. i] = (4 .. 8] ‚Üí search indices 5..8
A = [  2 ][  3 ][  5 ][  7 ][ 11 ][ 13 ][ 17 ][ 19 ][ 23 ]
i =    0     1     2     3    4     5     6     7     8
                                                         ‚Üë</code></pre>
            </div>
            </p>
            <p><em>Range for binary search:</em> <code>low=5, high=8</code>.</p>
            <p>Binary search on $A[5..8]$</p>
            <p>
            <div>
                <pre><code class="language-shell">Subarray: [ 13 ][ 17 ][ 19 ][ 23 ]
Indices :    5     6     7     8</code></pre>
            </div>
            </p>
            <p><em>Step 1</em></p>
            <p>
            <div>
                <pre><code class="language-shell">low=5, high=8 ‚Üí mid=(5+8)//2=6
A[6]=17 &lt; 19 ‚Üí move right ‚Üí low=7
A = [  2 ][  3 ][  5 ][  7 ][ 11 ][ 13 ][ 17 ][ 19 ][ 23 ]
i =    0     1     2     3    4     5     6     7     8
                                    ‚ÜëL      ‚ÜëM             ‚ÜëH
                                    5       6              8</code></pre>
            </div>
            </p>
            <p><em>Step 2</em></p>
            <p>
            <div>
                <pre><code class="language-shell">low=7, high=8 ‚Üí mid=(7+8)//2=7
A[7]=19 == target ‚úÖ ‚Üí FOUND
A = [  2 ][  3 ][  5 ][  7 ][ 11 ][ 13 ][ 17 ][ 19 ][ 23 ]
i =    0     1     2     3    4     5     6     7     8
                                           ‚ÜëL M H
                                              7</code></pre>
            </div>
            </p>
            <p>Found at <strong>index 7</strong>.</p>
            <ul>
                <li>Great when the target is likely to be near the beginning or when the array is <strong>unbounded</strong>/<strong>stream-like</strong> but sorted (you can probe indices safely).</li>
                <li>Time: $O(log p)$ to find the range where p is the final bound, plus $O(log p)$ for binary search ‚Üí overall $O(log p)$.</li>
                <li>Space: $O(1)$.</li>
                <li>Often paired with data sources where you can test ‚Äúis index i valid?‚Äù while doubling i.</li>
            </ul>
            <h4 id="interpolation-search">Interpolation Search</h4>
            <p>On a sorted (roughly uniformly distributed) array, estimate the likely position using the values themselves and probe there; repeat on the narrowed side.</p>
            <p><strong>Example inputs and outputs</strong></p>
            <p><em>Example 1</em></p>
            <p>$$
                \text{Input: } A = [10, 20, 30, 40, 50, 60, 70], \quad \text{target} = 55
                $$</p>
            <p>$$
                \text{Output: } \text{not found } (\text{probes near indices } 4\text{‚Äì}5)
                $$</p>
            <p><em>Example 2</em></p>
            <p>$$
                \text{Input: } A = [5, 15, 25, 35, 45, 55, 65], \quad \text{target} = 45
                $$</p>
            <p>$$
                \text{Output: } \text{index} = 4
                $$</p>
            <p><em>Example 3</em></p>
            <p>$$
                \text{Input: } A = [1, 1000, 1001, 1002], \quad \text{target} = 2
                $$</p>
            <p>$$
                \text{Output: } \text{not found } (\text{bad distribution for interpolation})
                $$</p>
            <p><strong>How it works</strong></p>
            <ul>
                <li>Guard against division by zero: if <code>A[high] == A[low]</code>, stop (or binary-search fallback).</li>
                <li>Clamp the computed <code>pos</code> to <code>[low, high]</code> before probing.</li>
                <li>Works best when values are <strong>uniformly distributed</strong>; otherwise it can degrade toward linear time.</li>
                <li>Assumes <code>A</code> is sorted and values are uniform.</li>
            </ul>
            <p>Probe formula:</p>
            <p>
            <div>
                <pre><code class="language-shell">pos ‚âà low + (high - low) * (target - A[low]) / (A[high] - A[low])</code></pre>
            </div>
            </p>
            <p>Let say we have following array and target:</p>
            <p>
            <div>
                <pre><code class="language-shell">A = [ 10 ][ 20 ][ 30 ][ 40 ][ 50 ][ 60 ][ 70 ]
i =    0     1     2     3     4     5     6
target = 45</code></pre>
            </div>
            </p>
            <p><em>Step 1 ‚Äî initial probe</em></p>
            <p>
            <div>
                <pre><code class="language-shell">low=0 (A[0]=10), high=6 (A[6]=70)

pos ‚âà 0 + (6-0) * (45-10)/(70-10)
    ‚âà 6 * 35/60
    ‚âà 3.5  ‚Üí probe near 3.5

A = [ 10 ][ 20 ][ 30 ][ 40 ][ 50 ][ 60 ][ 70 ]
i =    0     1     2     3     4     5     6
      ‚ÜëL                                   ‚ÜëH
            ‚Üëpos‚âà3.5 ‚Üí choose ‚åäpos‚åã=3 (or ‚åàpos‚åâ=4)</code></pre>
            </div>
            </p>
            <p>Probe <strong>index 3</strong>: <code>A[3]=40 &lt; 45</code> ‚Üí set <code>low = 3 + 1 = 4</code></p>
            <p><em>Step 2 ‚Äî after moving low</em></p>
            <p>
            <div>
                <pre><code class="language-shell">A = [ 10 ][ 20 ][ 30 ][ 40 ][ 50 ][ 60 ][ 70 ]
i =    0     1     2     3     4     5     6
                                ‚ÜëL         ‚ÜëH</code></pre>
            </div>
            </p>
            <p>At this point, an <strong>early-stop check</strong> already tells us <code>target (45) &lt; A[low] (50)</code> ‚Üí cannot exist in <code>A[4..6]</code> ‚Üí <strong>not found</strong>.</p>
            <ul>
                <li>Best on <strong>uniformly distributed</strong> sorted data; expected time $O(log log n)$.</li>
                <li>Worst case can degrade to $O(n)$, especially on skewed or clustered values.</li>
                <li>Space: $O(1)$.</li>
                <li>Very fast when value-to-index mapping is close to linear (e.g., near-uniform numeric keys).</li>
                <li>Requires careful handling when A[high] = A[low] (avoid division by zero); also sensitive to integer rounding in discrete arrays.</li>
            </ul>
            <h3 id="hash-based-search">Hash-based Search</h3>
            <ul>
                <li><strong>Separate chaining:</strong> Easiest deletions, steady $O(1)$ with Œ±‚âà1; good when memory fragmentation isn‚Äôt a concern.</li>
                <li><strong>Open addressing (double hashing):</strong> Best probe quality among OA variants; great cache locality; keep Œ± &lt; 0.8.</li>
                <li><strong>Open addressing (linear/quadratic):</strong> Simple and fast at low Œ±; watch clustering and tombstones.</li>
                <li><strong>Cuckoo hashing:</strong> Tiny and predictable lookup cost; inserts costlier and may rehash; great for read-heavy workloads.</li>
                <li>In all cases: pick strong hash functions and resize early to keep Œ± healthy.</li>
            </ul>
            <h4 id="hash-table-search">Hash Table Search</h4>
            <p>Map a key to an array index with a hash function; look at that bucket to find the key, giving expected $O(1)$ lookups under a good hash and healthy load factor.</p>
            <p><strong>Example inputs and outputs</strong></p>
            <p><em>Example 1</em></p>
            <p>$$
                \text{Table size: } m = 7,
                \quad \text{Keys stored: } {10, 24, 31},
                \quad \text{Target: } 24
                $$</p>
            <p>$$
                \text{Output: } \text{found (bucket 3)}
                $$</p>
            <p><em>Example 2</em></p>
            <p>$$
                \text{Table size: } m = 7,
                \quad \text{Keys stored: } {10, 24, 31},
                \quad \text{Target: } 18
                $$</p>
            <p>$$
                \text{Output: } \text{not found}
                $$</p>
            <p><strong>How it works</strong></p>
            <p>
            <div>
                <pre><code class="language-shell">+-----+      hash       +-----------------+      search/compare      +--------+
| key | --------------&gt; | index in array  | ----------------------&gt; | match? |
+-----+                  +-----------------+                         +--------+</code></pre>
            </div>
            </p>
            <ul>
                <li>With chaining, the ‚Äúcollision path‚Äù is the <strong>list inside one bucket</strong>.</li>
                <li>With linear probing, the ‚Äúcollision path‚Äù is the <strong>probe sequence</strong> across buckets (3 ‚Üí 4 ‚Üí 5 ‚Üí ‚Ä¶).</li>
                <li>Both keep your original flow: hash ‚Üí inspect bucket (and collision path) ‚Üí match?</li>
            </ul>
            <p>
            <div>
                <pre><code class="language-shell">Array (buckets/indexes 0..6):

Idx:   0     1     2     3     4     5     6
      +---+-----+-----+-----+-----+-----+-----+
      |   |     |     |     |     |     |     |
      +---+-----+-----+-----+-----+-----+-----+</code></pre>
            </div>
            </p>
            <p><strong>Example mapping with</strong> <code>h(k) = k mod 7</code>, <strong>stored keys</strong> <code>{10, 24, 31}</code> all hash to index <code>3</code>.</p>
            <p><em>Strategy A ‚Äî Separate Chaining (linked list per bucket)</em></p>
            <p>Insertions</p>
            <p>
            <div>
                <pre><code class="language-shell">10 -&gt; 3
24 -&gt; 3   (collides with 10; append to bucket[3] list)
31 -&gt; 3   (collides again; append to bucket[3] list)

Idx:   0     1     2     3     4     5     6
      +---+-----+-----+-----+-----+-----+-----+
      |   |     |     | ‚Ä¢   |     |     |     |
      +---+-----+-----+-----+-----+-----+-----+

bucket[3] chain:  [10] ‚Üí [24] ‚Üí [31] ‚Üí ‚àÖ</code></pre>
            </div>
            </p>
            <p><em>Search(24)</em></p>
            <p>
            <div>
                <pre><code class="language-shell">1) Compute index = h(24) = 3
2) Inspect bucket 3's chain:
      [10]  ‚Üí  [24]  ‚Üí  [31]
               ‚Üë found here
3) Return FOUND (bucket 3)</code></pre>
            </div>
            </p>
            <p><em>Strategy B ‚Äî Open Addressing (Linear Probing)</em></p>
            <p>Insertions</p>
            <p>
            <div>
                <pre><code class="language-shell">10 -&gt; 3                    place at 3
24 -&gt; 3  (occupied)  ‚Üí  probe 4  ‚Üí place at 4
31 -&gt; 3  (occ) ‚Üí 4 (occ) ‚Üí probe 5 ‚Üí place at 5

Idx:   0     1     2     3     4     5     6
      +---+-----+-----+-----+-----+-----+-----+
      |   |     |     | 10  | 24  | 31  |     |
      +---+-----+-----+-----+-----+-----+-----+</code></pre>
            </div>
            </p>
            <p><em>Search(24)</em></p>
            <p>
            <div>
                <pre><code class="language-shell">1) Compute index = h(24) = 3
2) Probe sequence:
      3: 10 ‚â† 24  ‚Üí continue
      4: 24 = target  ‚Üí FOUND at index 4
   (If not found, continue probing until an empty slot or wrap limit.)</code></pre>
            </div>
            </p>
            <ul>
                <li>Quality hash + low load factor (Œ± = n/m) ‚áí expected $O(1)$ search/insert/delete.</li>
                <li>Collisions are inevitable; the collision strategy (open addressing vs. chaining vs. cuckoo) dictates actual steps.</li>
                <li>Rehashing (growing and re-inserting) is used to keep Œ± under control.</li>
                <li>Uniform hashing assumption underpins the $O(1)$ expectation; adversarial keys or poor hashes can degrade performance.</li>
            </ul>
            <h4 id="open-addressing-linear-probing">Open Addressing ‚Äî Linear Probing</h4>
            <p>Keep everything in one array; on collision, probe alternative positions in a deterministic sequence until an empty slot or the key is found.</p>
            <p><strong>Example inputs and outputs</strong></p>
            <p><em>Example 1</em></p>
            <p>$$
                m = 10,
                \quad \text{Stored keys: } {12, 22, 32},
                \quad \text{Target: } 22
                $$</p>
            <p>$$
                \text{Output: } \text{found (index 3)}
                $$</p>
            <p><em>Example 2</em></p>
            <p>$$
                m = 10,
                \quad \text{Stored keys: } {12, 22, 32},
                \quad \text{Target: } 42
                $$</p>
            <p>$$
                \text{Output: } \text{not found}
                $$</p>
            <p><strong>How it works</strong></p>
            <p><em>Hash function:</em></p>
            <p>
            <div>
                <pre><code class="language-shell">h(k) = k mod 10
Probe sequence: i, i+1, i+2, ... (wrap around)</code></pre>
            </div>
            </p>
            <p><em>Insertions</em></p>
            <ul>
                <li>Insert 12 ‚Üí <code>h(12)=2</code> ‚Üí place at index 2</li>
                <li>Insert 22 ‚Üí <code>h(22)=2</code> occupied ‚Üí probe 3 ‚Üí place at 3</li>
                <li>Insert 32 ‚Üí <code>h(32)=2</code> occupied ‚Üí probe 3 (occupied) ‚Üí probe 4 ‚Üí place at 4</li>
            </ul>
            <p>Resulting table (indexes 0..9):</p>
            <p>
            <div>
                <pre><code class="language-shell">Index:   0   1   2    3    4   5   6   7   8   9
        +---+---+----+----+----+---+---+---+---+---+
Value:  |   |   | 12 | 22 | 32 |   |   |   |   |   |
        +---+---+----+----+----+---+---+---+---+---+</code></pre>
            </div>
            </p>
            <p><em>Search(22)</em></p>
            <ul>
                <li>Start at <code>h(22)=2</code></li>
                <li>index 2 ‚Üí 12 ‚â† 22 ‚Üí probe ‚Üí</li>
                <li>index 3 ‚Üí 22 ‚úÖ FOUND</li>
            </ul>
            <p>Path followed:</p>
            <p>
            <div>
                <pre><code class="language-shell">2 ‚Üí 3</code></pre>
            </div>
            </p>
            <p><em>Search(42)</em></p>
            <ul>
                <li>Start at <code>h(42)=2</code></li>
                <li>index 2 ‚Üí 12 ‚â† 42 ‚Üí probe ‚Üí</li>
                <li>index 3 ‚Üí 22 ‚â† 42 ‚Üí probe ‚Üí</li>
                <li>index 4 ‚Üí 32 ‚â† 42 ‚Üí probe ‚Üí</li>
                <li>index 5 ‚Üí empty slot ‚Üí stop ‚Üí ‚ùå NOT FOUND</li>
            </ul>
            <p>Path followed:</p>
            <p>
            <div>
                <pre><code class="language-shell">2 ‚Üí 3 ‚Üí 4 ‚Üí 5 (‚àÖ)</code></pre>
            </div>
            </p>
            <ul>
                <li>Simple and cache-friendly; clusters form (‚Äúprimary clustering‚Äù) which can slow probes.</li>
                <li>Deletion uses <strong>tombstones</strong> to keep probe chains intact.</li>
                <li>Performance depends sharply on load factor; keep Œ± well below 1 (e.g., Œ± ‚â§ 0.7).</li>
                <li>Expected search \~ $O(1)$ at low Œ±; degrades as clusters grow.</li>
            </ul>
            <h4 id="open-addressing-quadratic-probing">Open Addressing ‚Äî Quadratic Probing</h4>
            <p><strong>Example inputs and outputs</strong></p>
            <p><em>Example 1</em></p>
            <p>$$
                m = 11 (\text{prime}),
                \quad \text{Stored keys: } {22, 33, 44},
                \quad \text{Target: } 33
                $$</p>
            <p>$$
                h(k) = k \bmod m, \quad h(33) = 33 \bmod 11 = 0
                $$</p>
            <p>$$
                \text{Output: found (index 4)}
                $$</p>
            <p><em>Example 2</em></p>
            <p>$$
                m = 11 (\text{prime}),
                \quad \text{Stored keys: } {22, 33, 44},
                \quad \text{Target: } 55
                $$</p>
            <p>$$
                h(55) = 55 \bmod 11 = 0
                $$</p>
            <p>$$
                \text{Output: not found}
                $$</p>
            <p><strong>How it works</strong></p>
            <p><em>Hash function:</em></p>
            <p>
            <div>
                <pre><code class="language-shell">h(k) = k mod 11</code></pre>
            </div>
            </p>
            <p><em>Probe sequence (relative offsets):</em></p>
            <p>
            <div>
                <pre><code class="language-shell">+1¬≤, +2¬≤, +3¬≤, ... mod 11
= +1, +4, +9, +5, +3, +3¬≤‚Ä¶ (wrapping around table size)</code></pre>
            </div>
            </p>
            <p>So from <code>h(k)</code>, we try slots in this order:</p>
            <p>
            <div>
                <pre><code class="language-shell">h, h+1, h+4, h+9, h+5, h+3, ...   (all mod 11)</code></pre>
            </div>
            </p>
            <p><em>Insertions</em></p>
            <ul>
                <li>Insert <strong>22</strong> ‚Üí <code>h(22)=0</code> ‚Üí place at index 0</li>
                <li>Insert <strong>33</strong> ‚Üí <code>h(33)=0</code> occupied ‚Üí try <code>0+1¬≤=1</code> ‚Üí index 1 free ‚Üí place at 1</li>
                <li>Insert <strong>44</strong> ‚Üí <code>h(44)=0</code> occupied ‚Üí probe 1 (occupied) ‚Üí probe <code>0+4=4</code> ‚Üí place at 4</li>
            </ul>
            <p>Resulting table:</p>
            <p>
            <div>
                <pre><code class="language-shell">Idx:   0    1    2   3   4   5  6  7  8  9  10
      +----+----+---+---+----+---+--+--+--+---+
Val:  | 22 | 33 |   |   | 44 |   |  |  |  |  |   |
      +----+----+---+---+----+---+--+--+--+--+---+</code></pre>
            </div>
            </p>
            <p><em>Search(33)</em></p>
            <ul>
                <li>Start <code>h(33)=0</code> ‚Üí slot 0 = 22 ‚â† 33</li>
                <li>Probe <code>0+1¬≤=1</code> ‚Üí slot 1 = 33 ‚úÖ FOUND</li>
            </ul>
            <p>Path:</p>
            <p>
            <div>
                <pre><code class="language-shell">0 ‚Üí 1</code></pre>
            </div>
            </p>
            <p><em>Search(55)</em></p>
            <ul>
                <li>Start <code>h(55)=0</code> ‚Üí slot 0 = 22 ‚â† 55</li>
                <li>Probe <code>0+1¬≤=1</code> ‚Üí slot 1 = 33 ‚â† 55</li>
                <li>Probe <code>0+2¬≤=4</code> ‚Üí slot 4 = 44 ‚â† 55</li>
                <li>Probe <code>0+3¬≤=9</code> ‚Üí slot 9 = empty ‚Üí stop ‚Üí ‚ùå NOT FOUND</li>
            </ul>
            <p>Path:</p>
            <p>
            <div>
                <pre><code class="language-shell">0 ‚Üí 1 ‚Üí 4 ‚Üí 9 (‚àÖ)</code></pre>
            </div>
            </p>
            <ul>
                <li>Reduces primary clustering but can exhibit <strong>secondary clustering</strong> (keys with same h(k) follow same probe squares).</li>
                <li>Table size choice matters (often prime); ensure the probe sequence can reach many slots.</li>
                <li>Keep Œ± modest; deletion still needs tombstones.</li>
                <li>Expected $O(1)$ at healthy Œ±; simpler than double hashing.</li>
            </ul>
            <h4 id="open-addressing-double-hashing">Open Addressing ‚Äî Double Hashing</h4>
            <p><strong>Example inputs and outputs</strong></p>
            <p><em>Hash functions</em></p>
            <p>$$
                h_{1}(k) = k \bmod 11,
                \quad h_{2}(k) = 1 + (k \bmod 10)
                $$</p>
            <p>Probing sequence:</p>
            <p>$$
                h(k,i) = \big(h_{1}(k) + i \cdot h_{2}(k)\big) \bmod 11
                $$</p>
            <p><em>Example 1</em></p>
            <p>$$
                m = 11,
                \quad \text{Stored keys: } {22, 33, 44},
                \quad \text{Target: } 33
                $$</p>
            <p>For $k = 33$:</p>
            <p>$$
                h_{1}(33) = 33 \bmod 11 = 0,
                \quad h_{2}(33) = 1 + (33 \bmod 10) = 1 + 3 = 4
                $$</p>
            <p>So probe sequence is</p>
            <p>$$
                h(33,0) = 0,
                h(33,1) = (0 + 1\cdot 4) \bmod 11 = 4,
                h(33,2) = (0 + 2\cdot 4) \bmod 11 = 8, \dots
                $$</p>
            <p>Since the stored layout places $33$ at index $4$, the search succeeds.</p>
            <p>$$
                \text{Output: found (index 4)}
                $$</p>
            <p><em>Example 2</em></p>
            <p>$$
                m = 11,
                \quad \text{Stored keys: } {22, 33, 44},
                \quad \text{Target: } 55
                $$</p>
            <p>For $k = 55$:</p>
            <p>$$
                h_{1}(55) = 55 \bmod 11 = 0,
                \quad h_{2}(55) = 1 + (55 \bmod 10) = 1 + 5 = 6
                $$</p>
            <p>Probing sequence:</p>
            <p>$$
                0, (0+6)\bmod 11 = 6, (0+2\cdot 6)\bmod 11 = 1, (0+3\cdot 6)\bmod 11 = 7, \dots
                $$</p>
            <p>No slot matches $55$.</p>
            <p>$$
                \text{Output: not found}
                $$</p>
            <p><strong>How it works</strong></p>
            <p>We use <strong>two hash functions</strong>:</p>
            <p>
            <div>
                <pre><code class="language-shell">h‚ÇÅ(k) = k mod m
h‚ÇÇ(k) = 1 + (k mod 10)</code></pre>
            </div>
            </p>
            <p><em>Probe sequence:</em></p>
            <p>
            <div>
                <pre><code class="language-shell">i, i + h‚ÇÇ, i + 2¬∑h‚ÇÇ, i + 3¬∑h‚ÇÇ, ...  (all mod m)</code></pre>
            </div>
            </p>
            <p>This ensures fewer clustering issues compared to linear or quadratic probing.</p>
            <p><em>Insertions (m = 11)</em></p>
            <p>Insert <strong>22</strong></p>
            <ul>
                <li><code>h‚ÇÅ(22)=0</code> ‚Üí place at index 0</li>
            </ul>
            <p>Insert <strong>33</strong></p>
            <ul>
                <li><code>h‚ÇÅ(33)=0</code> (occupied)</li>
                <li><code>h‚ÇÇ(33)=1+(33 mod 10)=4</code></li>
                <li>Probe sequence: 0, 4 ‚Üí place at index 4</li>
            </ul>
            <p>Insert <strong>44</strong></p>
            <ul>
                <li><code>h‚ÇÅ(44)=0</code> (occupied)</li>
                <li><code>h‚ÇÇ(44)=1+(44 mod 10)=5</code></li>
                <li>Probe sequence: 0, 5 ‚Üí place at index 5</li>
            </ul>
            <p><em>Table State</em></p>
            <p>
            <div>
                <pre><code class="language-shell">Idx:   0   1  2  3   4   5  6  7  8  9  10
      +---+---+---+---+---+---+---+---+---+---+
Val:  |22 |   |   |   |33 |44 |   |   |   |   |   |
      +---+---+---+---+---+---+---+---+---+---+---+</code></pre>
            </div>
            </p>
            <p><em>Search(33)</em></p>
            <ul>
                <li>Start at <code>h‚ÇÅ(33)=0</code> ‚Üí slot 0 = 22 ‚â† 33</li>
                <li>Next: <code>0+1¬∑h‚ÇÇ(33)=0+4=4</code> ‚Üí slot 4 = 33 ‚úÖ FOUND</li>
            </ul>
            <p>Path:</p>
            <p>
            <div>
                <pre><code class="language-shell">0 ‚Üí 4</code></pre>
            </div>
            </p>
            <p><em>Search(55)</em></p>
            <ul>
                <li><code>h‚ÇÅ(55)=0</code>, <code>h‚ÇÇ(55)=1+(55 mod 10)=6</code></li>
                <li>slot 0 = 22 ‚â† 55</li>
                <li>slot 6 = empty ‚Üí stop ‚Üí ‚ùå NOT FOUND</li>
            </ul>
            <p>Path:</p>
            <p>
            <div>
                <pre><code class="language-shell">0 ‚Üí 6 (‚àÖ)</code></pre>
            </div>
            </p>
            <ul>
                <li>Minimizes clustering; probe steps depend on the key.</li>
                <li>Choose h‚ÇÇ so it‚Äôs <strong>non-zero</strong> and relatively prime to m, ensuring a full cycle.</li>
                <li>Excellent performance at higher Œ± than linear/quadratic, but still sensitive if Œ± ‚Üí 1.</li>
                <li>Deletion needs tombstones; implementation slightly more complex.</li>
            </ul>
            <h4 id="separate-chaining">Separate Chaining</h4>
            <p>Each array cell holds a small container (e.g., a linked list); colliding keys live together in that bucket.</p>
            <p><strong>Example inputs and outputs</strong></p>
            <p><em>Setup</em></p>
            <p>$$
                m = 5, \quad h(k) = k \bmod 5, \quad \text{buckets hold linked lists}
                $$</p>
            <p>Keys stored:</p>
            <p>$$
                {12, 22, 7, 3, 14}
                $$</p>
            <p>Bucket contents after hashing:</p>
            <p>$$
                \begin{aligned}
                h(12) &amp;= 12 \bmod 5 = 2 \Rightarrow&amp; \text{bucket 2: } [12] [6pt]
                h(22) &amp;= 22 \bmod 5 = 2 \Rightarrow&amp; \text{bucket 2: } [12, 22] [6pt]
                h(7) &amp;= 7 \bmod 5 = 2 \Rightarrow&amp; \text{bucket 2: } [12, 22, 7] [6pt]
                h(3) &amp;= 3 \bmod 5 = 3 \Rightarrow&amp; \text{bucket 3: } [3] [6pt]
                h(14) &amp;= 14 \bmod 5 = 4 \Rightarrow&amp; \text{bucket 4: } [14]
                \end{aligned}
                $$</p>
            <p><em>Example 1</em></p>
            <p>$$
                \text{Target: } 22
                $$</p>
            <p>$$
                h(22) = 2 \Rightarrow \text{bucket 2} = [12, 22, 7]
                $$</p>
            <p>Found at <strong>position 2</strong> in the list.</p>
            <p>$$
                \text{Output: found (bucket 2, position 2)}
                $$</p>
            <p><em>Example 2</em></p>
            <p>$$
                \text{Target: } 9
                $$</p>
            <p>$$
                h(9) = 9 \bmod 5 = 4 \Rightarrow \text{bucket 4} = [14]
                $$</p>
            <p>No match.</p>
            <p>$$
                \text{Output: not found}
                $$</p>
            <p><strong>How it works</strong></p>
            <p>
            <div>
                <pre><code class="language-shell">h(k) = k mod 5
Buckets store small lists (linked lists or dynamic arrays)

Idx:   0             1           2                    3            4
     [  ]         [  ]       [ 12 ‚Üí 22 ‚Üí 7 ]       [ 3 ]       [ 14 ]

Search(22):
- Compute bucket b = h(22) = 2
- Linearly scan bucket 2 ‚Üí find 22

Search(9):
- b = h(9) = 4
- Bucket 4: [14] ‚Üí 9 not present ‚Üí NOT FOUND</code></pre>
            </div>
            </p>
            <ul>
                <li>Simple deletes (remove from a bucket) and no tombstones.</li>
                <li>Expected $O(1 + Œ±)$ time; with good hashing and Œ± kept near/below 1, bucket lengths stay tiny.</li>
                <li>Memory overhead for bucket nodes; cache locality worse than open addressing.</li>
                <li>Buckets can use <strong>ordered lists</strong> or <strong>small vectors</strong> to accelerate scans.</li>
                <li>Rehashing still needed as n grows; Œ± = n/m controls performance.</li>
            </ul>
            <h4 id="cuckoo-hashing">Cuckoo Hashing</h4>
            <p>Keep two (or more) hash positions per key; insert by ‚Äúkicking out‚Äù occupants to their alternate home so lookups check only a couple of places.</p>
            <p><strong>Example inputs and outputs</strong></p>
            <p><em>Setup</em>
                Two hash tables $T_{1}$ and $T_{2}$, each of size</p>
            <p>$$
                m = 5
                $$</p>
            <p>Two independent hash functions:</p>
            <p>$$
                h_{1}(k), \quad h_{2}(k)
                $$</p>
            <p>Cuckoo hashing invariant:</p>
            <ul>
                <li>Each key is stored either in $T_{1}[h_{1}(k)]$ or $T_{2}[h_{2}(k)]$.</li>
                <li>On insertion, if a spot is occupied, the existing key is <strong>kicked out</strong> and reinserted into the other table.</li>
                <li>If relocations form a cycle, the table is <strong>rebuilt (rehash)</strong> with new hash functions.</li>
            </ul>
            <p><em>Example 1</em></p>
            <p>$$
                \text{Target: } 15
                $$</p>
            <p>Lookup procedure:</p>
            <ol>
                <li>Check $T_{1}[h_{1}(15)]$.</li>
                <li>If not found, check $T_{2}[h_{2}(15)]$.</li>
            </ol>
            <p>Result:</p>
            <p>$$
                \text{found in } T_{2} \text{ at index } 4
                $$</p>
            <p>$$
                \text{Output: found (T‚ÇÇ, index 4)}
                $$</p>
            <p><em>Example 2</em></p>
            <p>If insertion causes repeated displacements and eventually loops:</p>
            <p>$$
                \text{Cycle detected } \Rightarrow \text{rehash with new } h_{1}, h_{2}
                $$</p>
            <p>$$
                \text{Output: rebuild / rehash required}
                $$</p>
            <p><strong>How it works</strong> </p>
            <p>We keep <strong>two hash tables (T‚ÇÅ, T‚ÇÇ)</strong>, each with its own hash function. Every key can live in <strong>exactly one of two possible slots</strong>:</p>
            <p>Hash functions:</p>
            <p>$$
                h_1(k) = k \bmod 5, \quad h_2(k) = 1 + (k \bmod 4)
                $$</p>
            <p>Every key can live in <strong>exactly one of two slots</strong>: $T_1[h_1(k)]$ or $T_2[h_2(k)]$.
                If a slot is occupied, we <strong>evict</strong> the old occupant and reinsert it at its alternate location.</p>
            <p><em>Start empty:</em></p>
            <p>
            <div>
                <pre><code class="language-shell">T‚ÇÅ: [   ][   ][   ][   ][   ]
T‚ÇÇ: [   ][   ][   ][   ][   ]</code></pre>
            </div>
            </p>
            <p><em>Insert 10</em> ‚Üí goes to $T_1[h_1(10)=0]$:</p>
            <p>
            <div>
                <pre><code class="language-shell">T‚ÇÅ: [10 ][   ][   ][   ][   ]
T‚ÇÇ: [   ][   ][   ][   ][   ]</code></pre>
            </div>
            </p>
            <p><em>Insert 15</em></p>
            <ul>
                <li>$T_1[0]$ already has 10 ‚Üí evict 10</li>
                <li>Place 15 at $T_1[0]$</li>
                <li>Reinsert evicted 10 at $T_2[h_2(10)=3]$:</li>
            </ul>
            <p>
            <div>
                <pre><code class="language-shell">T‚ÇÅ: [15 ][   ][   ][   ][   ]
T‚ÇÇ: [   ][   ][   ][10 ][   ]</code></pre>
            </div>
            </p>
            <p><em>Insert 20</em></p>
            <ul>
                <li>$T_1[0]$ has 15 ‚Üí evict 15</li>
                <li>Place 20 at $T_1[0]$</li>
                <li>Reinsert 15 at $T_2[h_2(15)=4]$:</li>
            </ul>
            <p>
            <div>
                <pre><code class="language-shell">T‚ÇÅ: [20 ][   ][   ][   ][   ]
T‚ÇÇ: [   ][   ][   ][10 ][15 ]</code></pre>
            </div>
            </p>
            <p><em>Insert 25</em></p>
            <ul>
                <li>$T_1[0]$ has 20 ‚Üí evict 20</li>
                <li>Place 25 at $T_1[0]$</li>
                <li>Reinsert 20 at $T_2[h_2(20)=1]$:</li>
            </ul>
            <p>
            <div>
                <pre><code class="language-shell">T‚ÇÅ: [25 ][   ][   ][   ][   ]
T‚ÇÇ: [   ][20 ][   ][10 ][15 ]</code></pre>
            </div>
            </p>
            <p>üîé <em>Search(15)</em></p>
            <ul>
                <li>$T_1[h_1(15)=0] \to 25 \neq 15$</li>
                <li>$T_2[h_2(15)=4] \to 15$ ‚úÖ FOUND</li>
            </ul>
            <p><strong>FOUND in T‚ÇÇ at index 4</strong></p>
            <ul>
                <li>Lookups probe at <strong>most two places</strong> (with two hashes) ‚Üí excellent constant factors.</li>
                <li>Inserts may trigger a chain of evictions; detect cycles and <strong>rehash</strong> with new functions.</li>
                <li>High load factors achievable (e.g., \~0.5‚Äì0.9 depending on variant and number of hashes/tables).</li>
                <li>Deletions are easy (remove key); no tombstones, but ensure invariants remain.</li>
                <li>Sensitive to hash quality; poor hashes increase cycle risk.</li>
            </ul>
            <h3 id="probabilistic-approximate-search">Probabilistic &amp; Approximate Search</h3>
            <h4 id="bloom-filter">Bloom Filter</h4>
            <p>Space-efficient structure for fast membership tests; answers <strong>‚Äúmaybe present‚Äù</strong> or <strong>‚Äúdefinitely not present‚Äù</strong> with a tunable false-positive rate and no false negatives (if built correctly, without deletions).</p>
            <p><strong>Example inputs and outputs</strong></p>
            <p><em>Setup</em></p>
            <p>$$
                m = 16 \text{bits},
                \quad k = 3 \text{hash functions } (h_{1}, h_{2}, h_{3})
                $$</p>
            <p>Inserted set:</p>
            <p>$$
                {"cat", "dog"}
                $$</p>
            <p><em>Example 1</em></p>
            <p>$$
                \text{Query: contains("cat")}
                $$</p>
            <p>All $h_{i}(\text{"cat"})$ bits are set ‚Üí actual member.</p>
            <p>$$
                \text{Output: maybe present (true positive)}
                $$</p>
            <p><em>Example 2</em></p>
            <p>$$
                \text{Query: contains("cow")}
                $$</p>
            <p>One probed bit = 0 ‚Üí cannot be present.</p>
            <p>$$
                \text{Output: definitely not present}
                $$</p>
            <p><em>Example 3</em></p>
            <p>$$
                \text{Query: contains("eel")}
                $$</p>
            <p>All $h_{i}(\text{"eel"})$ bits happen to be set, even though "eel" was never inserted.</p>
            <p>$$
                \text{Output: maybe present (false positive)}
                $$</p>
            <p><strong>How it works</strong></p>
            <p><em>Initial state</em> (all zeros):</p>
            <p>
            <div>
                <pre><code class="language-shell">Idx:   0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
A  =  [0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0]</code></pre>
            </div>
            </p>
            <p>Insert <code>"cat"</code></p>
            <p>
            <div>
                <pre><code class="language-shell">h1(cat) = 3,  h2(cat) = 7,  h3(cat) = 12
‚Üí Set bits at 3, 7, 12

Idx:   0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
A  =  [0  0  0  1  0  0  0  1  0  0  0  0  1  0  0  0]
                 ^              ^              ^
                 3              7              12</code></pre>
            </div>
            </p>
            <p>Insert <code>"dog"</code></p>
            <p>
            <div>
                <pre><code class="language-shell">h1(dog) = 1,  h2(dog) = 7,  h3(dog) = 9
‚Üí Set bits at 1, 7, 9  (7 already set)

Idx:   0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
A  =  [0  1  0  1  0  0  0  1  0  1  0  0  1  0  0  0]
           ^              ^       ^
           1              7       9</code></pre>
            </div>
            </p>
            <p>Query <code>"cow"</code></p>
            <p>
            <div>
                <pre><code class="language-shell">h1(cow) = 1 ‚Üí bit[1] = 1
h2(cow) = 3 ‚Üí bit[3] = 1
h3(cow) = 6 ‚Üí bit[6] = 0  ‚ùå

Idx:   0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
A  =  [0  1  0  1  0  0  0  1  0  1  0  0  1  0  0  0]
           ‚úì              ‚úì     ‚úó</code></pre>
            </div>
            </p>
            <p>At least one zero ‚Üí <strong>DEFINITELY NOT PRESENT</strong></p>
            <p>Query <code>"eel"</code></p>
            <p>
            <div>
                <pre><code class="language-shell">h1(eel) = 7 ‚Üí bit[7] = 1
h2(eel) = 9 ‚Üí bit[9] = 1
h3(eel) = 12 ‚Üí bit[12] = 1

Idx:   0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
A  =  [0  1  0  1  0  0  0  1  0  1  0  0  1  0  0  0]
                             ‚úì     ‚úì        ‚úì</code></pre>
            </div>
            </p>
            <p>All ones ‚Üí <strong>MAYBE PRESENT</strong> (could be a <strong>false positive</strong>)</p>
            <ul>
                <li>Answers: <strong>maybe present</strong> / <strong>definitely not present</strong>; never false negatives (without deletions).</li>
                <li>False-positive rate is tunable via bit-array size <strong>m</strong>, number of hashes <strong>k</strong>, and items <strong>n</strong>; more space &amp; good <strong>k</strong> ‚Üí lower FPR.</li>
                <li>Time: $O(k)$ per insert/lookup; Space: \~m bits.</li>
                <li>No deletions in the basic form; duplicates are harmless (idempotent sets).</li>
                <li>Union = bitwise OR; intersection = bitwise AND (for same m,k,hashes).</li>
                <li>Choose independent, well-mixed hash functions to avoid correlated bits.</li>
            </ul>
            <h4 id="counting-bloom-filter">Counting Bloom Filter</h4>
            <p>Bloom filter variant that keeps a small counter per bit so you can <strong>delete</strong> by decrementing; still probabilistic and may have false positives.</p>
            <p><strong>Example inputs and outputs</strong></p>
            <p><em>Setup</em></p>
            <p>$$
                m = 12 \text{counters (each 2‚Äì4 bits)},
                \quad k = 3 \text{hash functions}
                $$</p>
            <p>Inserted set:</p>
            <p>$$
                {\text{"alpha"}, \text{"beta"}}
                $$</p>
            <p>Then delete <code>"alpha"</code>.</p>
            <p><em>Example 1</em></p>
            <p>$$
                \text{Query: contains("alpha")}
                $$</p>
            <p>Counters for <code>"alpha"</code> decremented; at least one probed counter is now $0$.</p>
            <p>$$
                \text{Output: definitely not present}
                $$</p>
            <p><em>Example 2</em></p>
            <p>$$
                \text{Query: contains("beta")}
                $$</p>
            <p>All three counters for <code>"beta"</code> remain $&gt;0$.</p>
            <p>$$
                \text{Output: maybe present}
                $$</p>
            <p><em>Example 3</em></p>
            <p>$$
                \text{Query: contains("gamma")}
                $$</p>
            <p>At least one probed counter is $0$.</p>
            <p>$$
                \text{Output: definitely not present}
                $$</p>
            <p><strong>How it works</strong></p>
            <p>Each cell is a <strong>small counter</strong> (e.g. 4-bits, range 0..15).
                This allows <strong>deletions</strong>: increment on insert, decrement on delete.</p>
            <p>Initial state</p>
            <p>
            <div>
                <pre><code class="language-shell">Idx:   0  1  2  3  4  5  6  7  8  9 10 11
A  =  [0  0  0  0  0  0  0  0  0  0  0  0]</code></pre>
            </div>
            </p>
            <p>Insert <code>"alpha"</code></p>
            <p>
            <div>
                <pre><code class="language-shell">Hashes: {2, 5, 9}
‚Üí Increment those counters

Idx:   0  1  2  3  4  5  6  7  8  9 10 11
A  =  [0  0  1  0  0  1  0  0  0  1  0  0]
             ‚Üë        ‚Üë              ‚Üë
             2        5              9</code></pre>
            </div>
            </p>
            <p>Insert <code>"beta"</code></p>
            <p>
            <div>
                <pre><code class="language-shell">Hashes: {3, 5, 11}
‚Üí Increment those counters

Idx:   0  1  2  3  4  5  6  7  8  9 10 11
A  =  [0  0  1  1  0  2  0  0  0  1  0  1]
                ‚Üë        ‚Üë              ‚Üë
                3        5              11</code></pre>
            </div>
            </p>
            <p>Lookup <code>"beta"</code></p>
            <p>
            <div>
                <pre><code class="language-shell">Hashes: {3, 5, 11}
Counters = {1, 2, 1} ‚Üí all &gt; 0
‚Üí Result: MAYBE PRESENT

Idx:   0  1  2  3  4  5  6  7  8  9 10 11
A  =  [0  0  1  1  0  2  0  0  0  1  0  1]
                ‚úì        ‚úì              ‚úì</code></pre>
            </div>
            </p>
            <p>Delete <code>"alpha"</code></p>
            <p>
            <div>
                <pre><code class="language-shell">Hashes: {2, 5, 9}
‚Üí Decrement those counters

Idx:   0  1  2  3  4  5  6  7  8  9 10 11
A  =  [0  0  0  1  0  1  0  0  0  0  0  1]
             ‚Üì        ‚Üì              ‚Üì
             2        5              9</code></pre>
            </div>
            </p>
            <p>Lookup <code>"alpha"</code></p>
            <p>
            <div>
                <pre><code class="language-shell">Hashes: {2, 5, 9}
Counters = {0, 1, 0}
‚Üí At least one zero
‚Üí Result: DEFINITELY NOT PRESENT

Idx:   0  1  2  3  4  5  6  7  8  9 10 11
A  =  [0  0  0  1  0  1  0  0  0  0  0  1]
             ‚úó        ‚úì              ‚úó</code></pre>
            </div>
            </p>
            <ul>
                <li>Supports <strong>deletion</strong> by decrementing counters; insertion increments.</li>
                <li>Still probabilistic: may return false positives; avoids false negatives <strong>if counters never underflow</strong> and hashes are consistent.</li>
                <li>Space: more than Bloom (a few bits per counter instead of 1).</li>
                <li>Watch for counter <strong>saturation</strong> (caps at max value) and <strong>underflow</strong> (don‚Äôt decrement below 0).</li>
                <li>Good for dynamic sets with frequent inserts and deletes.</li>
            </ul>
            <h4 id="cuckoo-filter">Cuckoo Filter</h4>
            <p>Hash-table‚Äìstyle filter that stores short <strong>fingerprints</strong> in two possible buckets; supports <strong>insert, lookup, delete</strong> with low false-positive rates and high load factors.</p>
            <p><strong>Example inputs and outputs</strong></p>
            <p><em>Setup</em></p>
            <p>$$
                b = 8 \text{buckets},
                \quad \text{bucket size} = 2,
                \quad \text{fingerprint size} = 8 \text{bits}
                $$</p>
            <p>Inserted set:</p>
            <p>$$
                {\text{"cat"}, \text{"dog"}, \text{"eel"}}
                $$</p>
            <p>Each element is stored as a short fingerprint in one of two candidate buckets.</p>
            <p><em>Example 1</em></p>
            <p>$$
                \text{Query: contains("cat")}
                $$</p>
            <p>Fingerprint for <code>"cat"</code> is present in one of its candidate buckets.</p>
            <p>$$
                \text{Output: maybe present (true positive)}
                $$</p>
            <p><em>Example 2</em></p>
            <p>$$
                \text{Query: contains("fox")}
                $$</p>
            <p>Fingerprint for <code>"fox"</code> is absent from both candidate buckets.</p>
            <p>$$
                \text{Output: definitely not present}
                $$</p>
            <p><em>Example 3 (Deletion)</em></p>
            <p>$$
                \text{Operation: remove("dog")}
                $$</p>
            <p>Fingerprint for <code>"dog"</code> is removed from its bucket.</p>
            <p>$$
                \text{Result: deletion supported directly by removing the fingerprint}
                $$</p>
            <p><strong>How it works</strong></p>
            <p>Each key <code>x</code> ‚Üí short <strong>fingerprint</strong> <code>f = FP(x)</code>
                Two candidate buckets:</p>
            <ul>
                <li><code>i1 = H(x) mod b</code></li>
                <li><code>i2 = i1 XOR H(f) mod b</code>
                    (<code>f</code> can be stored in either bucket; moving between buckets preserves the invariant.)</li>
            </ul>
            <p>Start (empty)</p>
            <p>
            <div>
                <pre><code class="language-shell">[0]: [ -- , -- ]   [1]: [ -- , -- ]   [2]: [ -- , -- ]   [3]: [ -- , -- ]
[4]: [ -- , -- ]   [5]: [ -- , -- ]   [6]: [ -- , -- ]   [7]: [ -- , -- ]</code></pre>
            </div>
            </p>
            <p>Insert <code>"cat"</code></p>
            <p>
            <div>
                <pre><code class="language-shell">f = 0xA7
i1 = 1
i2 = 1 XOR H(0xA7) = 5

Bucket 1 has free slot ‚Üí place 0xA7 in [1]

[1]: [ A7 , -- ]</code></pre>
            </div>
            </p>
            <p>Insert <code>"dog"</code></p>
            <p>
            <div>
                <pre><code class="language-shell">f = 0x3C
i1 = 5
i2 = 5 XOR H(0x3C) = 2

Bucket 5 has free slot ‚Üí place 0x3C in [5]

[1]: [ A7 , -- ]        [5]: [ 3C , -- ]</code></pre>
            </div>
            </p>
            <p>Insert <code>"eel"</code></p>
            <p>
            <div>
                <pre><code class="language-shell">f = 0xD2
i1 = 1
i2 = 1 XOR H(0xD2) = 4

Bucket 1 has one free slot ‚Üí place 0xD2 in [1]

[1]: [ A7 , D2 ]        [5]: [ 3C , -- ]</code></pre>
            </div>
            </p>
            <p>Lookup <code>"cat"</code></p>
            <p>
            <div>
                <pre><code class="language-shell">f = 0xA7
Buckets: i1 = 1, i2 = 5
Check: bucket[1] has A7 ‚Üí found</code></pre>
            </div>
            </p>
            <p>Result: MAYBE PRESENT</p>
            <p>Lookup <code>"fox"</code></p>
            <p>
            <div>
                <pre><code class="language-shell">f = 0x9B
i1 = 0
i2 = 0 XOR H(0x9B) = 7

Check buckets 0 and 7 ‚Üí fingerprint not found</code></pre>
            </div>
            </p>
            <p>Result: DEFINITELY NOT PRESENT</p>
            <ul>
                <li>Stores <strong>fingerprints</strong>, not full keys; answers <strong>maybe present</strong> / <strong>definitely not present</strong>.</li>
                <li>Supports <strong>deletion</strong> by removing a matching fingerprint from either bucket.</li>
                <li>Very high load factors (often 90%+ with small buckets) and excellent cache locality.</li>
                <li>False-positive rate controlled by fingerprint length (more bits ‚Üí lower FPR).</li>
                <li>Insertions can trigger <strong>eviction chains</strong>; worst case requires a <strong>rehash/resize</strong>.</li>
                <li>Two buckets per item (or more in variants); lookups check a tiny, fixed set of places.</li>
            </ul>
            <h3 id="string-search-algorithms">String Search Algorithms</h3>
            <ul>
                <li><strong>KMP:</strong> Best all-rounder for guaranteed $O(n + m)$ and tiny memory.</li>
                <li><strong>Boyer‚ÄìMoore:</strong> Fastest in practice on long patterns / large alphabets due to big skips.</li>
                <li><strong>Rabin‚ÄìKarp:</strong> Great for <strong>many patterns</strong> or streaming; hashing enables batched checks.</li>
                <li><strong>Naive:</strong> Fine for tiny inputs or as a baseline; simplest to reason about.</li>
            </ul>
            <h4 id="naive-string-search">Naive String Search</h4>
            <p>Slide the pattern one position at a time over the text; at each shift compare characters left-to-right until a mismatch or a full match.</p>
            <p><strong>Example inputs and outputs</strong></p>
            <p><em>Example 1</em></p>
            <p>$$
                \text{Text: } "abracadabra",
                \quad \text{Pattern: } "abra"
                $$</p>
            <p>$$
                \text{Output: matches at indices } 0 \text{and} 7
                $$</p>
            <p><em>Example 2</em></p>
            <p>$$
                \text{Text: } "aaaaa",
                \quad \text{Pattern: } "aaa"
                $$</p>
            <p>$$
                \text{Output: matches at indices } 0, 1, 2
                $$</p>
            <p><strong>How it works</strong></p>
            <p><em>Text</em> (length 11):</p>
            <p>
            <div>
                <pre><code class="language-shell">Text:   a b r a c a d a b r  a
Idx:    0 1 2 3 4 5 6 7 8 9 10</code></pre>
            </div>
            </p>
            <p><em>Pattern</em> (length 4):</p>
            <p>
            <div>
                <pre><code class="language-shell">Pattern: a b r a</code></pre>
            </div>
            </p>
            <p><em>Shift 0</em></p>
            <p>
            <div>
                <pre><code class="language-shell">Text:    a b r a
Pattern: a b r a</code></pre>
            </div>
            </p>
            <p>‚úÖ All match ‚Üí <strong>REPORT at index 0</strong></p>
            <p><em>Shift 1</em></p>
            <p>
            <div>
                <pre><code class="language-shell">Text:     b r a c
Pattern:  a b r a</code></pre>
            </div>
            </p>
            <p>‚ùå Mismatch at first char ‚Üí advance</p>
            <p><em>Shift 2</em></p>
            <p>
            <div>
                <pre><code class="language-shell">Text:      r a c a
Pattern:   a b r a</code></pre>
            </div>
            </p>
            <p>‚ùå Mismatch ‚Üí advance</p>
            <p><em>Shift 3</em></p>
            <p>
            <div>
                <pre><code class="language-shell">Text:       a c a d
Pattern:    a b r a</code></pre>
            </div>
            </p>
            <p>‚ùå Mismatch ‚Üí advance</p>
            <p><em>Shift 4</em></p>
            <p>
            <div>
                <pre><code class="language-shell">Text:        c a d a
Pattern:     a b r a</code></pre>
            </div>
            </p>
            <p>‚ùå Mismatch ‚Üí advance</p>
            <p><em>Shift 5</em></p>
            <p>
            <div>
                <pre><code class="language-shell">Text:         a d a b
Pattern:      a b r a</code></pre>
            </div>
            </p>
            <p>‚ùå Mismatch ‚Üí advance</p>
            <p><em>Shift 6</em></p>
            <p>
            <div>
                <pre><code class="language-shell">Text:          d a b r
Pattern:       a b r a</code></pre>
            </div>
            </p>
            <p>‚ùå Mismatch ‚Üí advance</p>
            <p><em>Shift 7</em></p>
            <p>
            <div>
                <pre><code class="language-shell">Text:           a b r a
Pattern:        a b r a</code></pre>
            </div>
            </p>
            <p>‚úÖ All match ‚Üí <strong>REPORT at index 7</strong></p>
            <ul>
                <li>Works anywhere; no preprocessing.</li>
                <li>Time: worst/average $O(n¬∑m)$ (text length n, pattern length m).</li>
                <li>Space: $O(1)$.</li>
                <li>Good for very short patterns or tiny inputs; otherwise use KMP/BM/RK.</li>
            </ul>
            <h4 id="knuth-morris-pratt-kmp-">Knuth‚ÄìMorris‚ÄìPratt (KMP)</h4>
            <p>Precompute a table (LPS / prefix-function) for the pattern so that on a mismatch you ‚Äújump‚Äù the pattern to the longest proper prefix that is also a suffix, avoiding rechecks.</p>
            <p><strong>Example inputs and outputs</strong></p>
            <p><em>Example 1</em></p>
            <p>$$
                \text{Text: } "ababcabcabababd",
                \quad \text{Pattern: } "ababd"
                $$</p>
            <p>$$
                \text{Output: match at index } 10
                $$</p>
            <p><em>Example 2</em></p>
            <p>$$
                \text{Text: } "aaaaab",
                \quad \text{Pattern: } "aaab"
                $$</p>
            <p>$$
                \text{Output: match at index } 2
                $$</p>
            <p><strong>How it works</strong></p>
            <p>We want to find the pattern <code>"ababd"</code> in the text <code>"ababcabca babab d"</code>.</p>
            <p><em>1) Precompute LPS (Longest Proper Prefix that is also a Suffix)</em></p>
            <p>Pattern:</p>
            <p>
            <div>
                <pre><code class="language-shell">a   b   a   b   d
0   1   2   3   4   ‚Üê index</code></pre>
            </div>
            </p>
            <p>LPS array:</p>
            <p>
            <div>
                <pre><code class="language-shell">0   0   1   2   0</code></pre>
            </div>
            </p>
            <p>Meaning:</p>
            <ul>
                <li>At each position, how many chars can we ‚Äúfall back‚Äù within the pattern itself if a mismatch happens.</li>
                <li>Example: at index 3 (pattern <code>"abab"</code>), LPS=2 means if mismatch occurs, restart comparison from <code>"ab"</code> inside the pattern.</li>
            </ul>
            <p><em>2) Scan Text with Two Pointers</em></p>
            <ul>
                <li><code>i</code> = text index</li>
                <li><code>j</code> = pattern index</li>
            </ul>
            <p>Text:</p>
            <p>
            <div>
                <pre><code class="language-shell">a b a b c a b c a b a b a b d
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14
Pattern: a b a b d</code></pre>
            </div>
            </p>
            <p><em>Step A: Initial matches</em></p>
            <p>
            <div>
                <pre><code class="language-shell">i=0..3: "abab" matched ‚Üí j=4 points to 'd'</code></pre>
            </div>
            </p>
            <p><em>Step B: Mismatch at i=4</em></p>
            <p>
            <div>
                <pre><code class="language-shell">text[i=4] = 'c'
pattern[j=4] = 'd' ‚Üí mismatch</code></pre>
            </div>
            </p>
            <p>Instead of restarting, use LPS:</p>
            <p>
            <div>
                <pre><code class="language-shell">j = LPS[j-1] = LPS[3] = 2</code></pre>
            </div>
            </p>
            <p>So pattern jumps back to <code>"ab"</code> (no wasted text comparisons).
                i stays at 4.</p>
            <p><em>Step C: Continue scanning</em></p>
            <p>The algorithm keeps moving forward, reusing LPS whenever mismatches occur.</p>
            <p><em>Step D: Full match found</em></p>
            <p>At <code>i=14</code>, j advances to 5 (pattern length).</p>
            <p>
            <div>
                <pre><code class="language-shell">‚Üí FULL MATCH found!
Start index = i - m + 1 = 14 - 5 + 1 = 10</code></pre>
            </div>
            </p>
            <p>‚úÖ Pattern <code>"ababd"</code> occurs in the text starting at <strong>index 10</strong>.</p>
            <ul>
                <li>Time: $O(n + m)$ (preprocessing + scan).</li>
                <li>Space: $O(m)$ for LPS table.</li>
                <li>Never moves i backward; avoids redundant comparisons.</li>
                <li>Ideal for repeated searches with the same pattern.</li>
                <li>LPS is also called prefix-function / failure-function.</li>
            </ul>
            <h4 id="boyer-moore-bm-">Boyer‚ÄìMoore (BM)</h4>
            <p>Compare the pattern right-to-left; on a mismatch, skip ahead using bad-character and good-suffix rules so many text characters are never touched.</p>
            <p><strong>Example inputs and outputs</strong></p>
            <p><em>Example 1</em></p>
            <p>$$
                \text{Text: } "HERE IS A SIMPLE EXAMPLE",
                \quad \text{Pattern: } "EXAMPLE"
                $$</p>
            <p>$$
                \text{Output: match at index } 17
                $$</p>
            <p><em>Example 2</em></p>
            <p>$$
                \text{Text: } "NEEDLE IN A HAYSTACK",
                \quad \text{Pattern: } "STACK"
                $$</p>
            <p>$$
                \text{Output: match at index } 15
                $$</p>
            <p><strong>How it works</strong></p>
            <ul>
                <li>Align the pattern under the text.</li>
                <li>Compare <strong>right ‚Üí left</strong>.</li>
                <li>On mismatch, shift the pattern by the <strong>max</strong> of:</li>
                <li><strong>Bad-character rule</strong>: align the mismatched text char with its last occurrence in the pattern (or skip it if absent).</li>
                <li><strong>Good-suffix rule</strong>: if a suffix matched, align another occurrence of it (or a prefix).</li>
            </ul>
            <p><em>Text</em> (with spaces shown as <code>_</code>):</p>
            <p>
            <div>
                <pre><code class="language-shell">0        10        20        30
H E R E _ I S _ A _ S I M P L E _ E X A M P L E</code></pre>
            </div>
            </p>
            <p><strong>Pattern</strong>: <code>"EXAMPLE"</code> (length = 7)</p>
            <p><em>Step 1: Align pattern at text[10..16] = <code>"SIMPLE"</code></em></p>
            <p>
            <div>
                <pre><code class="language-shell">Text:    ... S I M P L E ...
Pattern:       E X A M P L E
               ‚Üë (start comparing right ‚Üí left)</code></pre>
            </div>
            </p>
            <p>Compare right-to-left:</p>
            <p>
            <div>
                <pre><code class="language-shell">E=E, L=L, P=P, M=M, A=A, 
X vs I ‚Üí mismatch</code></pre>
            </div>
            </p>
            <ul>
                <li>Bad character = <code>I</code> (from text).</li>
                <li>Does pattern contain <code>I</code>? ‚Üí ‚ùå no.</li>
                <li>‚Üí Shift pattern <strong>past <code>I</code></strong>.</li>
            </ul>
            <p><em>Step 2: Shift until pattern under <code>"EXAMPLE"</code></em></p>
            <p>
            <div>
                <pre><code class="language-shell">Text:    ... E X A M P L E
Pattern:     E X A M P L E</code></pre>
            </div>
            </p>
            <p>Compare right-to-left:</p>
            <p>
            <div>
                <pre><code class="language-shell">E=E, L=L, P=P, M=M, A=A, X=X, E=E</code></pre>
            </div>
            </p>
            <p>‚úÖ <strong>Full match</strong> found at <strong>index 17</strong>.</p>
            <ul>
                <li>Average case sublinear (often skips large chunks of text).</li>
                <li>Worst case can be $O(n¬∑m)$; with both rules + Galil‚Äôs optimization, comparisons can be bounded $O(n + m)$.</li>
                <li>Space: $O(œÉ + m)$ for tables (œÉ = alphabet size).</li>
                <li>Shines on long patterns over large alphabets (e.g., English text, logs).</li>
                <li>Careful table prep (bad-character &amp; good-suffix) is crucial.</li>
            </ul>
            <h4 id="rabin-karp-rk-">Rabin‚ÄìKarp (RK)</h4>
            <p>Compare rolling hashes of the current text window and the pattern; only if hashes match do a direct character check (to rule out collisions).</p>
            <p><strong>Example inputs and outputs</strong></p>
            <p><em>Example 1</em></p>
            <p>$$
                \text{Text: } "ABCDABCABCD",
                \quad \text{Pattern: } "ABC"
                $$</p>
            <p>$$
                \text{Output: matches at indices } 0, 4, 7
                $$</p>
            <p><em>Example 2</em></p>
            <p>$$
                \text{Text: } "ABCDE",
                \quad \text{Pattern: } "FG"
                $$</p>
            <p>$$
                \text{Output: no match}
                $$</p>
            <p><strong>How it works</strong></p>
            <p>We‚Äôll use the classic choices:</p>
            <ul>
                <li>Base <strong>B = 256</strong></li>
                <li>Modulus <strong>M = 101</strong> (prime)</li>
                <li>Character value <code>val(c) = ASCII(c)</code> (e.g., <code>A=65, B=66, C=67, D=68</code>)</li>
                <li>Pattern <strong>P = "ABC"</strong> (length <strong>m = 3</strong>)</li>
                <li>Text <strong>T = "ABCDABCABCD"</strong> (length 11)</li>
            </ul>
            <p>
            <div>
                <pre><code class="language-shell">Text:    A B C D A B C A B C D
Index:   0 1 2 3 4 5 6 7 8 9 10
Pattern: A B C   (m = 3)</code></pre>
            </div>
            </p>
            <p><em>Precompute</em></p>
            <p>
            <div>
                <pre><code class="language-shell">pow = B^(m-1) mod M = 256^2 mod 101 = 88
HP = H(P) = H("ABC")</code></pre>
            </div>
            </p>
            <p>Start <code>h=0</code>, then for each char <code>h = (B*h + val) mod M</code>:</p>
            <ul>
                <li>After 'A': <code>(256*0 + 65) % 101 = 65</code></li>
                <li>After 'B': <code>(256*65 + 66) % 101 = 41</code></li>
                <li>After 'C': <code>(256*41 + 67) % 101 = 59</code></li>
            </ul>
            <p>So <strong>HP = 59</strong>.</p>
            <p><em>Rolling all windows</em></p>
            <p>Initial window <code>T[0..2]="ABC"</code>:</p>
            <p><code>h0 = 59</code> (matches HP ‚Üí verify chars ‚Üí ‚úÖ match at 0)</p>
            <p>For rolling:</p>
            <p><code>h_next = ( B * (h_curr ‚àí val(left) * pow) + val(new) ) mod M</code></p>
            <p>(If the inner term is negative, add <code>M</code> before multiplying.)</p>
            <p><em>First two rolls</em></p>
            <p>From $[0..2]$ "ABC" $(h0=59)$ ‚Üí $[1..3]$ "BCD":</p>
            <p>
            <div>
                <pre><code class="language-shell">left='A'(65), new='D'(68)
inner = (59 ‚àí 65*88) mod 101 = (59 ‚àí 5720) mod 101 = 96
h1 = (256*96 + 68) mod 101 = 24644 mod 101 = 0</code></pre>
            </div>
            </p>
            <p>From $[3..5]$ "DAB" $(h3=66)$ ‚Üí $[4..6]$ "ABC":</p>
            <p>
            <div>
                <pre><code class="language-shell">left='D'(68), new='C'(67)
inner = (66 ‚àí 68*88) mod 101 = (66 ‚àí 5984) mod 101 = 41
h4 = (256*41 + 67) mod 101 = 10563 mod 101 = 59  (= HP)</code></pre>
            </div>
            </p>
            <p><em>All windows (start index s)</em></p>
            <p>
            <div>
                <pre><code class="language-shell">s   window   hash   =HP?
0   ABC      59     ‚úì  ‚Üí verify ‚Üí ‚úÖ MATCH at 0
1   BCD       0
2   CDA      38
3   DAB      66
4   ABC      59     ‚úì  ‚Üí verify ‚Üí ‚úÖ MATCH at 4
5   BCA      98
6   CAB      79
7   ABC      59     ‚úì  ‚Üí verify ‚Üí ‚úÖ MATCH at 7
8   BCD       0</code></pre>
            </div>
            </p>
            <p>Matches at indices: <strong>0, 4, 7</strong>.</p>
            <ul>
                <li>Expected time $O(n + m)$ with a good modulus and low collision rate; worst case $O(n¬∑m)$ if many collisions.</li>
                <li>Space: $O(1)$ beyond the text/pattern and precomputed powers.</li>
                <li>Excellent for multi-pattern search (compute many pattern hashes, reuse rolling windows).</li>
                <li>Choose modulus to reduce collisions; verify on hash hits to ensure correctness.</li>
                <li>Works naturally on streams/very large texts since it needs only the current window.</li>
            </ul>
        </section>
        <div id="table-of-contents">
            <h2>Table of Contents</h2>
            <ol><a href="#searching">Searching</a>
                <ol>
                    <li><a href="#linear-sequential-search">Linear &amp; Sequential Search</a>
                        <ol>
                            <li><a href="#linear-search">Linear Search</a></li>
                            <li><a href="#sentinel-linear-search">Sentinel Linear Search</a></li>
                        </ol>
                    </li>
                    <li><a href="#divide-conquer-search">Divide &amp; Conquer Search</a>
                        <ol>
                            <li><a href="#binary-search">Binary Search</a></li>
                            <li><a href="#ternary-search">Ternary Search</a></li>
                            <li><a href="#jump-search">Jump Search</a></li>
                            <li><a href="#exponential-search">Exponential Search</a></li>
                            <li><a href="#interpolation-search">Interpolation Search</a></li>
                        </ol>
                    </li>
                    <li><a href="#hash-based-search">Hash-based Search</a>
                        <ol>
                            <li><a href="#hash-table-search">Hash Table Search</a></li>
                            <li><a href="#open-addressing-linear-probing">Open Addressing ‚Äî Linear Probing</a></li>
                            <li><a href="#open-addressing-quadratic-probing">Open Addressing ‚Äî Quadratic Probing</a></li>
                            <li><a href="#open-addressing-double-hashing">Open Addressing ‚Äî Double Hashing</a></li>
                            <li><a href="#separate-chaining">Separate Chaining</a></li>
                            <li><a href="#cuckoo-hashing">Cuckoo Hashing</a></li>
                        </ol>
                    </li>
                    <li><a href="#probabilistic-approximate-search">Probabilistic &amp; Approximate Search</a>
                        <ol>
                            <li><a href="#bloom-filter">Bloom Filter</a></li>
                            <li><a href="#counting-bloom-filter">Counting Bloom Filter</a></li>
                            <li><a href="#cuckoo-filter">Cuckoo Filter</a></li>
                        </ol>
                    </li>
                    <li><a href="#string-search-algorithms">String Search Algorithms</a>
                        <ol>
                            <li><a href="#naive-string-search">Naive String Search</a></li>
                            <li><a href="#knuth-morris-pratt-kmp-">Knuth‚ÄìMorris‚ÄìPratt (KMP)</a></li>
                            <li><a href="#boyer-moore-bm-">Boyer‚ÄìMoore (BM)</a></li>
                            <li><a href="#rabin-karp-rk-">Rabin‚ÄìKarp (RK)</a></li>
                        </ol>
                    </li>
                </ol>
            </ol>
            <div id="related-articles">
                <h2>Related Articles</h2>
                <ol>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/backtracking.html">Backtracking</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/basic_concepts.html">Basic Concepts</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/brain_teasers.html">Brain Teasers</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/data_structures.html">Data Structures</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/dynamic_programming.html">Dynamic Programming</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/graphs.html">Graphs</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/greedy_algorithms.html">Greedy Algorithms</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/matrices.html">Matrices</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/searching.html">Searching</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/sorting.html">Sorting</a></li>
                </ol>
            </div>
        </div>
    </div>
    <footer>
        <div class="footer-columns">
            <div class="footer-column">
                <img alt="Adam Djellouli Symbol" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/symbol.png" />
            </div>
            <div class="footer-column">
                <h2><a href="https://adamdjellouli.com/core/privacy_policy.html" title="Privacy Policy">Our Privacy Policy</a></h2>
                <p>
                    Thank you for visiting my personal website. All of the <br />
                    content on this site is free to use, but please remember <br />
                    to be a good human being and refrain from any abuse<br />
                    of the site. If you would like to contact me, please use <br />
                    my <a href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" title="LinkedIn Profile">LinkedIn profile</a> or my <a href="https://github.com/djeada" title="GitHub Profile">GitHub</a> if you have any technical <br />
                    issues or ideas to share. I wish you the best and hope you <br />
                    have a fantastic life. <br />
                </p>
            </div>
            <div class="footer-column">
                <h2>Follow me</h2>
                <ul class="social-media">
                    <li>
                        <a class="fa fa-youtube" href="https://www.youtube.com/channel/UCGPoHTVjMN77wcGknXPHl1Q" target="_blank" title="YouTube">
                        </a>YouTube
                    </li>
                    <li>
                        <a class="fa fa-linkedin" href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" target="_blank" title="LinkedIn">
                        </a>LinkedIn
                    </li>
                    <li>
                        <a class="fa fa-instagram" href="https://www.instagram.com/linuxchallenges/" target="_blank" title="Instagram">
                        </a>Instagram
                    </li>
                    <li>
                        <a class="fa fa-github" href="https://github.com/djeada" title="GitHub">
                        </a>Github
                    </li>
                </ul>
            </div>
        </div>
        <div>
            <p id="copyright">
                ¬© Adam Djellouli. All rights reserved.
            </p>
        </div>
        <script>
            document.getElementById("copyright").innerHTML = "&copy; " + new Date().getFullYear() + " Adam Djellouli. All rights reserved.";
        </script>
        <script src="../../app.js"></script>
    </footer>
    <div id="pdf-spinner-overlay">
        <div class="spinner"></div>
    </div>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-bash.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-cpp.min.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
jax: ["input/TeX", "output/HTML-CSS"],
extensions: ["tex2jax.js"],
"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] },
tex2jax: { inlineMath: [ ["$", "$"] ], displayMath: [ ["$$","$$"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
TeX: { noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } } },
messageStyle: "none"
});
</script>
<script async="" id="MathJax-script" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>

</html>