<!DOCTYPE html>

<html lang="en">

<head>
    <script async="" crossorigin="anonymous" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5593122079896089"></script>
    <meta charset="utf-8" />
    <title>Backtracking</title>
    <meta content="Backtracking is a method used to solve problems by building potential solutions step by step." name="description" />
    <meta content="Adam Djellouli" name="author" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <meta content="IE=edge" http-equiv="X-UA-Compatible" />
    <link crossorigin="" href="https://fonts.googleapis.com" rel="preconnect" />
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/icon.ico" rel="icon" />
    <link href="../../resources/style.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
</head>

<body>
    <nav aria-label="Main navigation">
        <a class="logo" href="https://adamdjellouli.com">
            <img alt="Adam Djellouli - Home Page Logo" id="logo-image" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/logo.PNG" />
        </a>
        <input aria-label="Toggle navigation menu" id="navbar-toggle" type="checkbox" />
        <ul aria-labelledby="navbar-toggle" role="menu">
            <li role="menuitem">
                <a href="../../index.html" title="Go to Home Page"> Home </a>
            </li>
            <li role="menuitem">
                <a class="active" href="../../core/blog.html" title="Read Adam Djellouli Blog on Programming and Technology"> Blog </a>
            </li>
            <li role="menuitem">
                <a href="../../core/tools.html" title="Discover Tools Created by Adam Djellouli"> Tools </a>
            </li>
            <li role="menuitem">
                <a href="../../core/projects.html" title="Explore Projects Developed by Adam Djellouli"> Projects </a>
            </li>
            <li role="menuitem">
                <a href="../../core/resume.html" title="View Adam Djellouli Professional Resume"> Resume </a>
            </li>
            <li>
                <script async="" src="https://cse.google.com/cse.js?cx=8160ef9bb935f4f68"></script>
                <div class="gcse-search"></div>
            </li>
            <li>
                <button aria-label="Toggle dark mode" id="dark-mode-button"></button>
            </li>
        </ul>
    </nav>
    <div id="article-wrapper">
        <section id="article-body">
            <div class="article-action-buttons"><button class="btn-suggest-edit" title="Suggest Edit">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <path d="M4 21h4l11-11-4-4L4 17v4z" stroke="currentColor" stroke-width="2"></path>
                    </svg>
                </button><button class="btn-create-issue" title="Create Issue">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2"></circle>
                        <line stroke="currentColor" stroke-width="2" x1="12" x2="12" y1="8" y2="12"></line>
                        <circle cx="12" cy="16" fill="currentColor" r="1"></circle>
                    </svg>
                </button><button class="btn-download" title="Download">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <path d="M12 5v14m0 0l-6-6m6 6l6-6" stroke="currentColor" stroke-width="2"></path>
                    </svg>
                </button></div>
            <p style="text-align: right;"><i>Last modified: August 31, 2025</i></p>
            <p style="text-align: right;"><i>This article is written in: ðŸ‡ºðŸ‡¸</i></p>
            <h2 id="backtracking">Backtracking</h2>
            <p>Backtracking is a method used to solve problems by building potential solutions step by step. If it becomes clear that a partial solution cannot lead to a valid final solution, the process "backtracks" by undoing the last step and trying a different path. This approach is commonly applied to <strong>constraint satisfaction problems</strong>, <strong>combinatorial optimization</strong>, and puzzles like <strong>N-Queens</strong> or <strong>Sudoku</strong>, where all possibilities need to be explored systematically while avoiding unnecessary computations.</p>
            <h3 id="recursive-functions">Recursive Functions</h3>
            <p>Recursive functions are functions that call themselves directly or indirectly to solve a problem by breaking it down into smaller, more manageable subproblems. This concept is fundamental in computer science and mathematics, as it allows for elegant solutions to complex problems through repeated application of a simple process.</p>
            <p>Main idea:</p>
            <ol>
                <li><strong>Base Case (Termination Condition)</strong> is the condition under which the recursion stops. It prevents infinite recursion by providing an explicit solution for the simplest instance of the problem.</li>
                <li><strong>Recursive Case</strong> is the part of the function where it calls itself with a modified parameter, moving towards the base case.</li>
            </ol>
            <h4 id="mathematical-foundation">Mathematical Foundation</h4>
            <p>Recursion closely relates to mathematical induction, where a problem is solved by assuming that the solution to a smaller instance of the problem is known and building upon it.</p>
            <p>A recursive function can often be expressed using a recurrence relation:</p>
            <p>$$ f(n) =
                \begin{cases}
                g(n) &amp; \text{if } n = \text{base case} \\
                h(f(n - 1), n) &amp; \text{otherwise}
                \end{cases}
                $$</p>
            <p>where:</p>
            <ul>
                <li>$g(n)$ is the base case value,</li>
                <li>$h$ is a function that defines how to build the solution from the smaller instance.</li>
            </ul>
            <h4 id="example-calculating-factorial">Example: Calculating Factorial</h4>
            <p>The factorial of a non-negative integer $n$ is the product of all positive integers less than or equal to $n$. Mathematically, it is defined as:</p>
            <p>$$ n! =
                \begin{cases}
                1 &amp; \text{if } n = 0 \\
                n \times (n - 1)! &amp; \text{if } n &gt; 0
                \end{cases}
                $$</p>
            <p>Python Implementation:</p>
            <p>
            <div>
                <pre><code class="language-python">def factorial(n):
    if n == 0:
        return 1  # Base case: 0! = 1
    else:
        return n * factorial(n - 1)  # Recursive case</code></pre>
            </div>
            </p>
            <h5>Detailed Computation for $n = 5$</h5>
            <p>Let's trace the recursive calls for <code>factorial(5)</code>:</p>
            <ul>
                <li>Call <code>factorial(5)</code> and compute $5 \times factorial(4)$ because $5 \neq 0$. </li>
                <li>Call <code>factorial(4)</code> and compute $4 \times factorial(3)$. </li>
                <li>Call <code>factorial(3)</code> and compute $3 \times factorial(2)$. </li>
                <li>Call <code>factorial(2)</code> and compute $2 \times factorial(1)$. </li>
                <li>Call <code>factorial(1)</code> and compute $1 \times factorial(0)$. </li>
                <li>Call <code>factorial(0)</code> and return $1$ as the base case is reached. </li>
            </ul>
            <p>Now, we backtrack and compute the results:</p>
            <ol>
                <li><code>factorial(1)</code> returns $1 \times 1 = 1$.</li>
                <li><code>factorial(2)</code> returns $2 \times 1 = 2$.</li>
                <li><code>factorial(3)</code> returns $3 \times 2 = 6$.</li>
                <li><code>factorial(4)</code> returns $4 \times 6 = 24$.</li>
                <li><code>factorial(5)</code> returns $5 \times 24 = 120$.</li>
            </ol>
            <p>Thus, $5! = 120$.</p>
            <h4 id="visualization-with-recursion-tree">Visualization with Recursion Tree</h4>
            <p>Each recursive call can be visualized as a node in a tree:</p>
            <p>
            <div>
                <pre><code class="language-shell">factorial(5)
|
+-- factorial(4)
    |
    +-- factorial(3)
        |
        +-- factorial(2)
            |
            +-- factorial(1)
                |
                +-- factorial(0)</code></pre>
            </div>
            </p>
            <p>The leaves represent the base case, and the tree unwinds as each recursive call returns.</p>
            <p><strong>Important Considerations:</strong></p>
            <ul>
                <li>When using recursion, ensure <strong>termination</strong> by designing the recursive function such that all possible paths eventually reach a base case. This prevents infinite recursion.</li>
                <li>Be mindful of <strong>stack depth</strong>, as each recursive call adds a new frame to the call stack. Too many recursive calls, especially in deep recursion, can result in a stack overflow error.</li>
                <li>Consider <strong>efficiency</strong> when choosing a recursive approach. While recursive solutions can be elegant and clean, they may not always be optimal in terms of time and space, particularly when dealing with large input sizes or deep recursive calls.</li>
            </ul>
            <h3 id="depth-first-search-dfs-">Depth-First Search (DFS)</h3>
            <p>Depth-First Search is an algorithm for traversing or searching tree or graph data structures. It starts at a selected node and explores as far as possible along each branch before backtracking.</p>
            <p>Main idea:</p>
            <ul>
                <li>The <strong>traversal strategy</strong> of Depth-First Search (DFS) involves exploring each branch of a graph or tree to its deepest point before backtracking to explore other branches.</li>
                <li><strong>Implementation</strong> of DFS can be achieved either through recursion, which implicitly uses the call stack, or by using an explicit stack data structure to manage the nodes.</li>
                <li><strong>Applications</strong> of DFS include tasks such as topological sorting, identifying connected components in a graph, solving puzzles like mazes, and finding paths in trees or graphs.</li>
            </ul>
            <h4 id="algorithm-steps">Algorithm Steps</h4>
            <ul>
                <li><strong>Start at the root node</strong> by marking it as visited to prevent revisiting it during the traversal.</li>
                <li><strong>Explore each branch</strong> by recursively performing DFS on each unvisited neighbor, diving deeper into the graph or tree structure.</li>
                <li><strong>Backtrack</strong> once all neighbors of a node are visited, returning to the previous node to continue exploring other branches.</li>
            </ul>
            <p>Pseudocode:</p>
            <p>
            <div>
                <pre><code class="language-pseudo">DFS(node):
    mark node as visited
    for each neighbor in node.neighbors:
        if neighbor is not visited:
            DFS(neighbor)</code></pre>
            </div>
            </p>
            <h4 id="example-tree-traversal">Example: Tree Traversal</h4>
            <p>Consider the following tree:</p>
            <p>
            <div>
                <pre><code class="language-shell">Tree:
       A
      / \
     B   C
        / \
       D   E</code></pre>
            </div>
            </p>
            <p>Traversal using DFS starting from node 'A':</p>
            <ul>
                <li><strong>Visit 'A'</strong> to begin the traversal, marking it as visited.</li>
                <li><strong>Move to 'B'</strong>, but since 'B' has no unvisited neighbors, <strong>backtrack to 'A'</strong> to explore other branches.</li>
                <li><strong>Move to 'C'</strong>, continuing the traversal to the next unvisited node.</li>
                <li><strong>Move to 'D'</strong>, but as 'D' has no unvisited neighbors, <strong>backtrack to 'C'</strong>.</li>
                <li><strong>Move to 'E'</strong>, but since 'E' also has no unvisited neighbors, <strong>backtrack to 'C'</strong>, and then further <strong>backtrack to 'A'</strong> to complete the exploration.</li>
            </ul>
            <p>Traversal order: $A â†’ B â†’ C â†’ D â†’ E$</p>
            <p>Implementation in Python:</p>
            <p>
            <div>
                <pre><code class="language-python">class Node:
    def __init__(self, value):
        self.value = value
        self.children = []
        self.visited = False

def dfs(node):
    node.visited = True
    print(node.value)
    for child in node.children:
        if not child.visited:
            dfs(child)

# Create nodes
node_a = Node('A')
node_b = Node('B')
node_c = Node('C')
node_d = Node('D')
node_e = Node('E')

# Build the tree
node_a.children = [node_b, node_c]
node_c.children = [node_d, node_e]

# Perform DFS
dfs(node_a)</code></pre>
            </div>
            </p>
            <p>Analysis:</p>
            <ul>
                <li>The <strong>time complexity</strong> of Depth-First Search (DFS) is $O(V + E)$, where $V$ represents the number of vertices and $E$ represents the number of edges in the graph.</li>
                <li>The <strong>space complexity</strong> is $O(V)$, primarily due to the space used by the recursion stack or an explicit stack, as well as the memory required for tracking visited nodes.</li>
            </ul>
            <h4 id="applications">Applications</h4>
            <ul>
                <li><strong>Cycle detection</strong> in directed and undirected graphs.</li>
                <li><strong>Topological sorting</strong> in directed acyclic graphs (DAGs).</li>
                <li><strong>Solving mazes and puzzles</strong> by exploring all possible paths.</li>
                <li>Identifying <strong>connected components</strong> in a network or graph.</li>
            </ul>
            <h3 id="backtracking">Backtracking</h3>
            <p>Backtracking is an algorithmic technique for solving problems recursively by trying to build a solution incrementally, removing solutions that fail to satisfy the constraints at any point.</p>
            <p>Main Idea:</p>
            <ul>
                <li>Building solutions one piece at a time and evaluating them against the constraints.</li>
                <li>Early detection of invalid solutions to prune the search space.</li>
                <li>When a partial solution cannot be extended to a complete solution, the algorithm backtracks to try different options.</li>
            </ul>
            <h4 id="general-algorithm-framework">General Algorithm Framework</h4>
            <ol>
                <li>Understand the possible configurations of the solution.</li>
                <li>Start with an empty solution.</li>
                <li>At each step, try to add a new component to the solution.</li>
                <li>After adding a component, check if the partial solution is valid.</li>
                <li>If not valid, backtrack.</li>
                <li>If the partial solution is complete and valid, record or output it.</li>
                <li>If all options are exhausted at a level, remove the last component and backtrack to the previous level.</li>
            </ol>
            <p>General Template (pseudocode)</p>
            <p>
            <div>
                <pre><code class="language-shell">function backtrack(partial):
    if is_complete(partial):
        handle_solution(partial)
        return    // or continue if looking for all solutions

    for candidate in generate_candidates(partial):
        if is_valid(candidate, partial):
            place(candidate, partial)          // extend partial with candidate
            backtrack(partial)
            unplace(candidate, partial)        // undo extension (backtrack)</code></pre>
            </div>
            </p>
            <p>Pieces you supply per problem:</p>
            <ul>
                <li><code>is_complete</code>: does <code>partial</code> represent a full solution?</li>
                <li><code>handle_solution</code>: record/output the solution.</li>
                <li><code>generate_candidates</code>: possible next choices given current partial.</li>
                <li><code>is_valid</code>: pruning test to reject infeasible choices early.</li>
                <li><code>place</code> / <code>unplace</code>: apply and revert the choice.</li>
            </ul>
            <p>Python-ish Generic Framework</p>
            <p>
            <div>
                <pre><code class="language-python">def backtrack(partial, is_complete, generate_candidates, is_valid, handle_solution):
    if is_complete(partial):
        handle_solution(partial)
        return

    for candidate in generate_candidates(partial):
        if not is_valid(candidate, partial):
            continue
        # make move
        partial.append(candidate)
        backtrack(partial, is_complete, generate_candidates, is_valid, handle_solution)
        # undo move
        partial.pop()</code></pre>
            </div>
            </p>
            <p>You can wrap those callbacks into a class or closures for stateful problems.</p>
            <h4 id="n-queens-problem">N-Queens Problem</h4>
            <p>The N-Queens problem is a classic puzzle in which the goal is to place $N$ queens on an $N \times N$ chessboard such that no two queens threaten each other. In chess, a queen can move any number of squares along a row, column, or diagonal. Therefore, no two queens can share the same row, column, or diagonal.</p>
            <p>Objective:</p>
            <ul>
                <li>Place $N$ queens on the board.</li>
                <li>Ensure that no two queens attack each other.</li>
                <li>Find all possible arrangements that satisfy the above conditions.</li>
            </ul>
            <h5>Visual Representation</h5>
            <p>To better understand the problem, let's visualize it using ASCII graphics.</p>
            <p><strong>Empty $4 \times 4$ Chessboard:</strong></p>
            <p>
            <div>
                <pre><code class="language-shell">0   1   2   3  (Columns)
+---+---+---+---+
0|   |   |   |   |
+---+---+---+---+
1|   |   |   |   |
+---+---+---+---+
2|   |   |   |   |
+---+---+---+---+
3|   |   |   |   |
+---+---+---+---+
(Rows)</code></pre>
            </div>
            </p>
            <p>Each cell can be identified by its row and column indices ((row, column)).</p>
            <p><strong>Example Solution for $N = 4$:</strong></p>
            <p>One of the possible solutions for placing 4 queens on a $4 \times 4$ chessboard is:</p>
            <p>
            <div>
                <pre><code class="language-shell">0   1   2   3  (Columns)
+---+---+---+---+
0| Q |   |   |   |  (Queen at position (0, 0))
+---+---+---+---+
1|   |   | Q |   |  (Queen at position (1, 2))
+---+---+---+---+
2|   |   |   | Q |  (Queen at position (2, 3))
+---+---+---+---+
3|   | Q |   |   |  (Queen at position (3, 1))
+---+---+---+---+
(Rows)</code></pre>
            </div>
            </p>
            <ul>
                <li><code>Q</code> represents a queen.</li>
                <li>Blank spaces represent empty cells.</li>
            </ul>
            <h5>Constraints</h5>
            <ul>
                <li>Only one queen per row.</li>
                <li>Only one queen per column.</li>
                <li>No two queens share the same diagonal.</li>
            </ul>
            <h5>Approach Using Backtracking</h5>
            <p>Backtracking is an ideal algorithmic approach for solving the N-Queens problem due to its constraint satisfaction nature. The algorithm incrementally builds the solution and backtracks when a partial solution violates the constraints.</p>
            <p>High-Level Steps:</p>
            <ol>
                <li>Initialize an empty chessboard of size $N \times N$.</li>
                <li>Try placing a queen in each column of the first row and check for conflicts.</li>
                <li>Move to the next row.</li>
                <li>For each column, attempt to place a queen.</li>
                <li>Check if the placement is safe (no conflicts with existing queens).</li>
                <li>If no safe position is found in the current row, backtrack to the previous row.</li>
                <li>Try the next available position in the previous row.</li>
                <li>When $N$ queens have been successfully placed without conflicts, record the solution.</li>
                <li>Continue the process to find all possible solutions.</li>
            </ol>
            <h5>Python Implementation</h5>
            <p>Below is a Python implementation of the N-Queens problem using backtracking.</p>
            <p>
            <div>
                <pre><code class="language-python">def solve_n_queens(N):
    solutions = []
    board = [-1] * N  # board[row] = column position of queen in that row

    def is_safe(row, col):
        for prev_row in range(row):
            # Check column conflict
            if board[prev_row] == col:
                return False
            # Check diagonal conflicts
            if abs(board[prev_row] - col) == abs(prev_row - row):
                return False
        return True

    def place_queen(row):
        if row == N:
            # All queens are placed successfully
            solutions.append(board.copy())
            return
        for col in range(N):
            if is_safe(row, col):
                board[row] = col  # Place queen
                place_queen(row + 1)  # Move to next row
                board[row] = -1  # Backtrack

    place_queen(0)
    return solutions

# Example usage
N = 4
solutions = solve_n_queens(N)
print(f"Number of solutions for N={N}: {len(solutions)}")
for index, sol in enumerate(solutions):
    print(f"\nSolution {index + 1}:")
    for row in range(N):
        line = ['.'] * N
        if sol[row] != -1:
            line[sol[row]] = 'Q'
        print(' '.join(line))</code></pre>
            </div>
            </p>
            <h5>Execution Flow</h5>
            <ol>
                <li>Try placing a queen in columns <code>0</code> to <code>N - 1</code>.</li>
                <li>For each valid placement, proceed to row <code>1</code>.</li>
                <li>At each row, attempt to place a queen in a safe column.</li>
                <li>If no safe column is found, backtrack to the previous row.</li>
                <li>When a valid placement is found for all $N$ rows, record the solution.</li>
            </ol>
            <h5>All Solutions for $N = 4$</h5>
            <p>There are two distinct solutions for $N = 4$:</p>
            <p><strong>Solution 1:</strong></p>
            <p>
            <div>
                <pre><code class="language-shell">Board Representation: [1, 3, 0, 2]

  0   1   2   3
+---+---+---+---+
0|   | Q |   |   |
+---+---+---+---+
1|   |   |   | Q |
+---+---+---+---+
2| Q |   |   |   |
+---+---+---+---+
3|   |   | Q |   |
+---+---+---+---+</code></pre>
            </div>
            </p>
            <p><strong>Solution 2:</strong></p>
            <p>
            <div>
                <pre><code class="language-shell">Board Representation: [2, 0, 3, 1]

  0   1   2   3
+---+---+---+---+
0|   |   | Q |   |
+---+---+---+---+
1| Q |   |   |   |
+---+---+---+---+
2|   |   |   | Q |
+---+---+---+---+
3|   | Q |   |   |
+---+---+---+---+</code></pre>
            </div>
            </p>
            <h5>Output of the Program</h5>
            <p>
            <div>
                <pre><code class="language-shell">Number of solutions for N=4: 2

Solution 1:
. Q . .
. . . Q
Q . . .
. . Q .

Solution 2:
. . Q .
Q . . .
. . . Q
. Q . .</code></pre>
            </div>
            </p>
            <h5>Visualization of the Backtracking Tree</h5>
            <p>The algorithm explores the solution space as a tree, where each node represents a partial solution (queens placed up to a certain row). The branches represent the possible positions for the next queen.</p>
            <ul>
                <li><strong>Nodes</strong> represent partial solutions where a certain number of queens have already been placed in specific rows.</li>
                <li><strong>Branches</strong> correspond to the possible positions for placing the next queen in the following row, exploring each valid option.</li>
                <li><strong>Leaves</strong> are the complete solutions when all $N$ queens have been successfully placed on the board without conflicts.</li>
            </ul>
            <p>The backtracking occurs when a node has no valid branches (no safe positions in the next row), prompting the algorithm to return to the previous node and try other options.</p>
            <h5>Analysis</h5>
            <p>I. The <strong>time complexity</strong> of the N-Queens problem is $O(N!)$ as the algorithm explores permutations of queen placements across rows.</p>
            <p>II. The <strong>space complexity</strong> is $O(N)$, where:</p>
            <ul>
                <li>The <code>board</code> array stores the positions of the $N$ queens.</li>
                <li>The recursion stack can go as deep as $N$ levels during the backtracking process.</li>
            </ul>
            <h5>Applications</h5>
            <ul>
                <li><strong>Constraint satisfaction problems</strong> often use the N-Queens problem as a classic example to study and develop solutions for placing constraints on variable assignments.</li>
                <li>In <strong>algorithm design</strong>, the N-Queens problem helps illustrate the principles of backtracking and recursive problem-solving.</li>
                <li>In <strong>artificial intelligence</strong>, it serves as a foundational example for search algorithms and optimization techniques.</li>
            </ul>
            <h5>Potential Improvements</h5>
            <ul>
                <li>Implementing more efficient conflict detection methods.</li>
                <li>Using heuristics to choose the order of columns to try first.</li>
                <li>Converting the recursive solution to an iterative one using explicit stacks to handle larger values of $N$ without stack overflow.</li>
            </ul>
            <h4 id="example-maze-solver">Example: Maze Solver</h4>
            <p>Given a maze represented as a 2D grid, find a path from the starting point to the goal using backtracking. The maze consists of open paths and walls, and movement is allowed in four directions: up, down, left, and right (no diagonal moves). The goal is to determine a sequence of moves that leads from the start to the goal without crossing any walls.</p>
            <h5>Maze Representation</h5>
            <p><strong>Grid Cells:</strong></p>
            <ul>
                <li><code>.</code> (dot) represents an <strong>open path</strong>.</li>
                <li><code>#</code> (hash) represents a <strong>wall</strong> or <strong>obstacle</strong>.</li>
            </ul>
            <p><strong>Allowed Moves:</strong></p>
            <ul>
                <li>Up, down, left, right.</li>
                <li>No diagonal movement.</li>
            </ul>
            <h5>ASCII Representation</h5>
            <p>Let's visualize the maze using ASCII graphics to better understand the problem.</p>
            <p>
            <div>
                <pre><code class="language-shell">Maze Layout:

Start (S) at position (0, 0)
Goal (G) at position (5, 5)

  0 1 2 3 4 5 (Columns)
0 S . # . . .
1 . # . . . .
2 . . . . # .
3 . # # # . .
4 . . . # . .
5 # # # # . G

Legend:
S - Start
G - Goal
. - Open path
# - Wall</code></pre>
            </div>
            </p>
            <p>Here's the maze grid with indices:</p>
            <p>
            <div>
                <pre><code class="language-shell">0   1   2   3   4   5
  +---+---+---+---+---+---+
0 | S | . | # | . | . | . |
  +---+---+---+---+---+---+
1 | . | # | . | . | . | . |
  +---+---+---+---+---+---+
2 | . | . | . | . | # | . |
  +---+---+---+---+---+---+
3 | . | # | # | # | . | . |
  +---+---+---+---+---+---+
4 | . | . | . | # | . | . |
  +---+---+---+---+---+---+
5 | # | # | # | # | . | G |
  +---+---+---+---+---+---+</code></pre>
            </div>
            </p>
            <p>Objective:</p>
            <p>Find a sequence of moves from <code>S</code> to <code>G</code>, navigating only through open paths (<code>.</code>) and avoiding walls (<code>#</code>). The path should be returned as a list of grid coordinates representing the steps from the start to the goal.</p>
            <h5>Python Implementation</h5>
            <p>
            <div>
                <pre><code class="language-python">def solve_maze(maze, start, goal):
    rows, cols = len(maze), len(maze[0])
    path = []

    def is_valid(x, y):
        return (0 &lt;= x &lt; rows and 0 &lt;= y &lt; cols and maze[x][y] == '.')

    def explore(x, y):
        if not is_valid(x, y):
            return False
        if (x, y) == goal:
            path.append((x, y))
            return True
        maze[x][y] = 'V'  # Mark as visited
        path.append((x, y))
        # Try all possible directions: down, up, right, left
        if (explore(x + 1, y) or
            explore(x - 1, y) or
            explore(x, y + 1) or
            explore(x, y - 1)):
            return True
        path.pop()          # Backtrack
        maze[x][y] = '.'    # Unmark visited
        return False

    if explore(*start):
        return path
    else:
        return None

# Sample maze (as a list of lists)
maze = [
    ['.', '.', '#', '.', '.', '.'],
    ['.', '#', '.', '.', '.', '.'],
    ['.', '.', '.', '.', '#', '.'],
    ['.', '#', '#', '#', '.', '.'],
    ['.', '.', '.', '#', '.', '.'],
    ['#', '#', '#', '#', '.', '.']
]

start = (0, 0)
goal = (5, 5)
solution = solve_maze(maze, start, goal)

if solution:
    print("Path to goal:")
    for step in solution:
        print(step)
else:
    print("No path found.")</code></pre>
            </div>
            </p>
            <h5>Recursive Function <code>explore(x, y)</code></h5>
            <p>I. <strong>Base Cases:</strong></p>
            <ul>
                <li>If <code>(x, y)</code> is not valid (out of bounds, wall, or visited), return <code>False</code>.</li>
                <li>If <code>(x, y)</code> equals the goal position, append it to <code>path</code> and return <code>True</code>.</li>
            </ul>
            <p>II. <strong>Recursive Exploration:</strong></p>
            <ul>
                <li>Mark the current cell <code>(x, y)</code> as visited by setting <code>maze[x][y] = 'V'</code>.</li>
                <li>Append <code>(x, y)</code> to the <code>path</code>.</li>
                <li>Recursively attempt to explore neighboring cells in the following order:</li>
                <li>Move <strong>Down</strong>: <code>explore(x + 1, y)</code></li>
                <li>Move <strong>Up</strong>: <code>explore(x - 1, y)</code></li>
                <li>Move <strong>Right</strong>: <code>explore(x, y + 1)</code></li>
                <li>Move <strong>Left</strong>: <code>explore(x, y - 1)</code></li>
                <li>If any recursive call returns <code>True</code>, propagate the <code>True</code> value upwards.</li>
            </ul>
            <p>III. <strong>Backtracking:</strong></p>
            <ul>
                <li>If none of the neighboring cells lead to a solution, backtrack:</li>
                <li>Remove <code>(x, y)</code> from <code>path</code> using <code>path.pop()</code>.</li>
                <li>Unmark the cell by setting <code>maze[x][y] = '.'</code>.</li>
                <li>Return <code>False</code> to indicate that this path does not lead to the goal.</li>
            </ul>
            <h5>Execution Flow</h5>
            <p>I. <strong>Start at <code>(0, 0)</code></strong>:</p>
            <ul>
                <li>The algorithm begins at the starting position.</li>
                <li>Marks <code>(0, 0)</code> as visited and adds it to the path.</li>
            </ul>
            <p>II. <strong>Explore Neighbors</strong>:</p>
            <ul>
                <li>Tries moving <strong>Down</strong> to <code>(1, 0)</code>.</li>
            </ul>
            <p>III. <strong>Recursive Exploration</strong>:</p>
            <ul>
                <li>From <code>(1, 0)</code>, continues moving <strong>Down</strong> to <code>(2, 0)</code>.</li>
                <li>From <code>(2, 0)</code>, attempts <strong>Right</strong> to <code>(2, 1)</code>.</li>
            </ul>
            <p>IV. <strong>Dead Ends and Backtracking</strong>:</p>
            <ul>
                <li>If a path leads to a wall or visited cell, the algorithm backtracks to the previous cell and tries a different direction.</li>
                <li>This process continues, exploring all possible paths recursively.</li>
            </ul>
            <p>V. <strong>Reaching the Goal</strong>:</p>
            <ul>
                <li>Eventually, the algorithm reaches the goal <code>(5, 5)</code> if a path exists.</li>
                <li>The function returns <code>True</code>, and the full path is constructed via the recursive calls.</li>
            </ul>
            <h5>Output</h5>
            <ul>
                <li>If a path is found, it prints "Path to goal:" followed by the list of coordinates in the path.</li>
                <li>If no path exists, it prints "No path found."</li>
            </ul>
            <h5>Final Path Found</h5>
            <p>The path from start to goal:</p>
            <p>
            <div>
                <pre><code class="language-shell">[(0, 0), (1, 0), (2, 0), (2, 1), (2, 2), (2, 3),
 (1, 3), (1, 4), (1, 5), (2, 5), (3, 5), (4, 5),
 (5, 5)]</code></pre>
            </div>
            </p>
            <h5>Visual Representation of the Path</h5>
            <p>Let's overlay the path onto the maze for better visualization. We'll use <code>*</code> to indicate the path.</p>
            <p>
            <div>
                <pre><code class="language-shell">Maze with Path:

    0   1   2   3   4   5
  +---+---+---+---+---+---+
0 | * | * | # | . | . | . |
  +---+---+---+---+---+---+
1 | * | # | . | * | * | * |
  +---+---+---+---+---+---+
2 | * | * | * | * | # | * |
  +---+---+---+---+---+---+
3 | . | # | # | # | . | * |
  +---+---+---+---+---+---+
4 | . | . | . | # | . | * |
  +---+---+---+---+---+---+
5 | # | # | # | # | . | * |
  +---+---+---+---+---+---+

Legend:
* - Path taken
# - Wall
. - Open path</code></pre>
            </div>
            </p>
            <h5>Advantages of Using Backtracking for Maze Solving</h5>
            <ul>
                <li>Ensures that all possible paths are explored until the goal is found.</li>
                <li>Only the current path and visited cells are stored, reducing memory usage compared to storing all possible paths.</li>
                <li>Recursive implementation leads to clean and understandable code.</li>
            </ul>
            <h5>Potential Improvements</h5>
            <ul>
                <li>This algorithm finds a path but not necessarily the shortest path.</li>
                <li>To find the shortest path, algorithms like Breadth-First Search (BFS) are more suitable.</li>
                <li>Modify the code to collect all possible paths by removing early returns when the goal is found.</li>
                <li>Allowing diagonal movements would require adjusting the <code>explore</code> function to include additional directions.</li>
            </ul>
            <h3 id="list-of-problems">List of Problems</h3>
            <h4 id="permutations">Permutations</h4>
            <p>Develop an algorithm to generate all possible permutations of a given list of elements. This problem requires creating different arrangements of the elements where the order matters.</p>
            <ul>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/tree/master/src/backtracking/cpp/all_permutations">C++ Solution</a></li>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/tree/master/src/backtracking/python/all_permutations">Python Solution</a></li>
            </ul>
            <h4 id="combinations">Combinations</h4>
            <p>Design an algorithm to generate all possible combinations of 'k' elements selected from a given list of elements. This involves selecting elements where the order does not matter, but the selection size does.</p>
            <ul>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/tree/master/src/backtracking/cpp/all_combinations">C++ Solution</a></li>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/tree/master/src/backtracking/python/all_combinations">Python Solution</a></li>
            </ul>
            <h4 id="string-pattern">String Pattern</h4>
            <p>Create a solution to determine whether a given string adheres to a specified pattern, where the pattern may include letters and wildcard characters that represent any character. This problem often involves checking for matches and handling special pattern symbols.</p>
            <ul>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/tree/master/src/backtracking/cpp/string_pattern">C++ Solution</a></li>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/tree/master/src/backtracking/python/string_pattern">Python Solution</a></li>
            </ul>
            <h4 id="generating-words">Generating Words</h4>
            <p>Generate all possible words that can be formed from a given list of characters and match a specified pattern. The pattern can contain letters and wildcard characters, requiring the algorithm to account for flexible matching.</p>
            <ul>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/tree/master/src/backtracking/cpp/generating_words">C++ Solution</a></li>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/tree/master/src/backtracking/python/generating_words">Python Solution</a></li>
            </ul>
            <h4 id="hamiltonian-path">Hamiltonian Path</h4>
            <p>Create an algorithm that identifies whether a simple path exists within a provided undirected or directed graph. This path should visit every vertex exactly once. Known as the "traveling salesman problem," it can be addressed using depth-first search to explore possible paths.</p>
            <ul>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/tree/master/src/backtracking/cpp/hamiltonian_paths">C++ Solution</a></li>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/tree/master/src/backtracking/python/hamiltonian_paths">Python Solution</a></li>
            </ul>
            <h4 id="k-colorable-configurations">K-Colorable Configurations</h4>
            <p>Develop an algorithm to find all possible ways to color a given graph with 'k' colors such that no two adjacent vertices share the same color. This graph coloring problem requires ensuring valid color assignments for all vertices.</p>
            <ul>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/tree/master/src/backtracking/cpp/k_colorable_configurations">C++ Solution</a></li>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/tree/master/src/backtracking/python/k_colorable_configurations">Python Solution</a></li>
            </ul>
            <h4 id="knight-tour">Knight Tour</h4>
            <p>Create an algorithm to find all potential paths a knight can take on an 'n' x 'n' chessboard to visit every square exactly once. This classic chess problem involves ensuring the knight moves in an L-shape and covers all board positions.</p>
            <ul>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/tree/master/src/backtracking/cpp/knight_tour">C++ Solution</a></li>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/tree/master/src/backtracking/python/knight_tour">Python Solution</a></li>
            </ul>
            <h4 id="topological-orderings">Topological Orderings</h4>
            <p>Determine a topological ordering of the vertices in a given directed graph, if one exists. This involves sorting the vertices such that for every directed edge UV from vertex U to vertex V, U comes before V in the ordering.</p>
            <ul>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/tree/master/src/backtracking/cpp/topological_sort">C++ Solution</a></li>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/tree/master/src/backtracking/python/topological_sort">Python Solution</a></li>
            </ul>
            <h4 id="tic-tac-toe-minimax-">Tic-Tac-Toe (Minimax)</h4>
            <p>Develop an algorithm to determine the optimal move for a player in a game of tic-tac-toe using the minimax algorithm. This requires evaluating possible moves to find the best strategy for winning or drawing the game.</p>
            <ul>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/tree/master/src/backtracking/cpp/minimax">C++ Solution</a></li>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/tree/master/src/backtracking/python/minimax">Python Solution</a></li>
            </ul>
        </section>
        <div id="table-of-contents">
            <h2>Table of Contents</h2>
            <ol><a href="#backtracking">Backtracking</a>
                <ol>
                    <li><a href="#recursive-functions">Recursive Functions</a>
                        <ol>
                            <li><a href="#mathematical-foundation">Mathematical Foundation</a></li>
                            <li><a href="#example-calculating-factorial">Example: Calculating Factorial</a></li>
                            <li><a href="#visualization-with-recursion-tree">Visualization with Recursion Tree</a></li>
                        </ol>
                    </li>
                    <li><a href="#depth-first-search-dfs-">Depth-First Search (DFS)</a>
                        <ol>
                            <li><a href="#algorithm-steps">Algorithm Steps</a></li>
                            <li><a href="#example-tree-traversal">Example: Tree Traversal</a></li>
                            <li><a href="#applications">Applications</a></li>
                        </ol>
                    </li>
                    <li><a href="#backtracking">Backtracking</a>
                        <ol>
                            <li><a href="#general-algorithm-framework">General Algorithm Framework</a></li>
                            <li><a href="#n-queens-problem">N-Queens Problem</a></li>
                            <li><a href="#example-maze-solver">Example: Maze Solver</a></li>
                        </ol>
                    </li>
                    <li><a href="#list-of-problems">List of Problems</a>
                        <ol>
                            <li><a href="#permutations">Permutations</a></li>
                            <li><a href="#combinations">Combinations</a></li>
                            <li><a href="#string-pattern">String Pattern</a></li>
                            <li><a href="#generating-words">Generating Words</a></li>
                            <li><a href="#hamiltonian-path">Hamiltonian Path</a></li>
                            <li><a href="#k-colorable-configurations">K-Colorable Configurations</a></li>
                            <li><a href="#knight-tour">Knight Tour</a></li>
                            <li><a href="#topological-orderings">Topological Orderings</a></li>
                            <li><a href="#tic-tac-toe-minimax-">Tic-Tac-Toe (Minimax)</a></li>
                        </ol>
                    </li>
                </ol>
            </ol>
            <div id="related-articles">
                <h2>Related Articles</h2>
                <ol>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/backtracking.html">Backtracking</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/basic_concepts.html">Basic Concepts</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/brain_teasers.html">Brain Teasers</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/data_structures.html">Data Structures</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/dynamic_programming.html">Dynamic Programming</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/graphs.html">Graphs</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/greedy_algorithms.html">Greedy Algorithms</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/matrices.html">Matrices</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/searching.html">Searching</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/sorting.html">Sorting</a></li>
                </ol>
            </div>
        </div>
    </div>
    <footer>
        <div class="footer-columns">
            <div class="footer-column">
                <img alt="Adam Djellouli Symbol" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/symbol.png" />
            </div>
            <div class="footer-column">
                <h2><a href="https://adamdjellouli.com/core/privacy_policy.html" title="Privacy Policy">Our Privacy Policy</a></h2>
                <p>
                    Thank you for visiting my personal website. All content here is free to use,
                    but please remember to be respectful and avoid any misuse of the site.
                    If youâ€™d like to get in touch, feel free to reach out via my
                    <a href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" title="LinkedIn Profile">LinkedIn profile</a>
                    or connect with me on
                    <a href="https://github.com/djeada" title="GitHub Profile">GitHub</a>
                    if you have technical questions or ideas to share.
                    Wishing you all the best and a fantastic life ahead!
                </p>
            </div>
            <div class="footer-column">
                <h2>Follow me</h2>
                <ul class="social-media">
                    <li>
                        <a class="fa fa-youtube" href="https://www.youtube.com/channel/UCGPoHTVjMN77wcGknXPHl1Q" target="_blank" title="YouTube">
                        </a>YouTube
                    </li>
                    <li>
                        <a class="fa fa-linkedin" href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" target="_blank" title="LinkedIn">
                        </a>LinkedIn
                    </li>
                    <li>
                        <a class="fa fa-instagram" href="https://www.instagram.com/linuxchallenges/" target="_blank" title="Instagram">
                        </a>Instagram
                    </li>
                    <li>
                        <a class="fa fa-github" href="https://github.com/djeada" title="GitHub">
                        </a>Github
                    </li>
                </ul>
            </div>
        </div>
        <div>
            <p id="copyright">
                Â© Adam Djellouli. All rights reserved.
            </p>
        </div>
        <script>
            document.getElementById("copyright").innerHTML = "&copy; " + new Date().getFullYear() + " Adam Djellouli. All rights reserved.";
        </script>
        <script src="../../app.js"></script>
    </footer>
    <div id="pdf-spinner-overlay">
        <div class="spinner"></div>
    </div>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-bash.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-cpp.min.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
jax: ["input/TeX", "output/HTML-CSS"],
extensions: ["tex2jax.js"],
"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] },
tex2jax: { inlineMath: [ ["$", "$"] ], displayMath: [ ["$$","$$"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
TeX: { noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } } },
messageStyle: "none"
});
</script>
<script async="" id="MathJax-script" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>

</html>