<!DOCTYPE html>

<html lang="en">

<head>
    <script async="" crossorigin="anonymous" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5593122079896089"></script>
    <meta charset="utf-8" />
    <title>Dynamic Programming</title>
    <meta content="Dynamic Programming (DP) is a fundamental algorithmic technique used to solve optimization problems by breaking them down into simpler subproblems." name="description" />
    <meta content="Adam Djellouli" name="author" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <meta content="IE=edge" http-equiv="X-UA-Compatible" />
    <link crossorigin="" href="https://fonts.googleapis.com" rel="preconnect" />
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/icon.ico" rel="icon" />
    <link href="../../resources/style.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />
</head>

<body>
    <nav aria-label="Main navigation">
        <a class="logo" href="https://adamdjellouli.com">
            <img alt="Adam Djellouli - Home Page Logo" id="logo-image" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/logo.PNG" />
        </a>
        <input aria-label="Toggle navigation menu" id="navbar-toggle" type="checkbox" />
        <ul aria-labelledby="navbar-toggle" role="menu">
            <li role="menuitem">
                <a href="../../index.html" title="Go to Home Page"> Home </a>
            </li>
            <li role="menuitem">
                <a class="active" href="../../core/blog.html" title="Read Adam Djellouli Blog on Programming and Technology"> Blog </a>
            </li>
            <li role="menuitem">
                <a href="../../core/tools.html" title="Discover Tools Created by Adam Djellouli"> Tools </a>
            </li>
            <li role="menuitem">
                <a href="../../core/projects.html" title="Explore Projects Developed by Adam Djellouli"> Projects </a>
            </li>
            <li role="menuitem">
                <a href="../../core/resume.html" title="View Adam Djellouli Professional Resume"> Resume </a>
            </li>
            <li>
                <script async="" src="https://cse.google.com/cse.js?cx=8160ef9bb935f4f68"></script>
                <div class="gcse-search"></div>
            </li>
            <li>
                <button aria-label="Toggle dark mode" id="dark-mode-button"></button>
            </li>
        </ul>
    </nav>
    <div id="article-wrapper">
        <section id="article-body">
            <p style="text-align: right;"><i>Last modified: September 23, 2024</i></p>
            <p style="text-align: right;"><i>This article is written in: ðŸ‡ºðŸ‡¸</i></p>
            <header>Dynamic Programming</header>
            <p>Dynamic Programming (DP) is a fundamental algorithmic technique used to solve optimization problems by breaking them down into simpler subproblems. The core idea is to solve each subproblem only once and store its solutionâ€”typically using a memory-based data structure (array, table, or map)â€”thus avoiding the computational overhead of recomputing the same solutions multiple times. This approach is particularly powerful for problems exhibiting the properties of <strong>optimal substructure</strong> and <strong>overlapping subproblems</strong>.</p>
            <p>Originally developed by Richard Bellman in the 1950s, dynamic programming has since become an essential tool in fields such as computer science, economics, and operations research. It provides a structured approach to problem-solving that can transform exponential-time algorithms into polynomial-time solutions, greatly improving computational efficiency.</p>
            <h2 id="fundamental-principles-of-dynamic-programming">Fundamental Principles of Dynamic Programming</h2>
            <p>To effectively apply dynamic programming, a problem must satisfy two key properties:</p>
            <h3 id="1-optimal-substructure">1. Optimal Substructure</h3>
            <p><strong>Definition</strong>: A problem exhibits <strong>optimal substructure</strong> if an optimal solution to the problem contains optimal solutions to its subproblems. Formally, if the optimal solution $S_n$ for problem size $n$ can be constructed from optimal solutions $S_k$ for smaller sizes $k &lt; n$, then the problem has an optimal substructure.</p>
            <p><strong>Mathematical Representation</strong>:</p>
            <p>Consider a problem where we want to find the optimal value $V(n)$ for a given parameter $n$. If there exists a function $f$ such that:</p>
            <p>$$ V(n) = \min_{k} { f(V(k), V(n - k)) } $$</p>
            <p>then the problem exhibits optimal substructure.</p>
            <p><strong>Example</strong>: Shortest Path in Graphs</p>
            <p>In the context of graph algorithms, suppose we want to find the shortest path from vertex $A$ to vertex $C$. If $B$ is an intermediate vertex on the shortest path from $A$ to $C$, then the shortest path from $A$ to $C$ is the concatenation of the shortest path from $A$ to $B$ and the shortest path from $B$ to $C$.</p>
            <h3 id="2-overlapping-subproblems">2. Overlapping Subproblems</h3>
            <p><strong>Definition</strong>: A problem has <strong>overlapping subproblems</strong> if it can be broken down into subproblems that are reused multiple times. This means that the recursive solution involves solving the same subproblem repeatedly.</p>
            <p><strong>Mathematical Representation</strong>:</p>
            <p>Let $S(n)$ be the set of subproblems for problem size $n$. If there exists $s \in S(n)$ such that $s$ appears in $S(k)$ for multiple $k$, the problem has overlapping subproblems.</p>
            <p><strong>Example</strong>: Fibonacci Numbers</p>
            <p>The recursive computation of Fibonacci numbers $F(n) = F(n - 1) + F(n - 2)$ involves recalculating the same Fibonacci numbers multiple times. For instance, to compute $F(5)$, we need to compute $F(4)$ and $F(3)$, both of which require computing $F(2)$ and $F(1)$ multiple times.</p>
            <h2 id="dynamic-programming-techniques">Dynamic Programming Techniques</h2>
            <p>There are two primary methods for implementing dynamic programming algorithms:</p>
            <h3 id="1-memoization-top-down-approach-">1. Memoization (Top-Down Approach)</h3>
            <p><strong>Concept</strong>: Memoization involves solving the problem recursively while storing the results of solved subproblems in a data structure (typically a hash table or array). Before computing a subproblem, the algorithm checks if the result is already known and returns the cached result if it is.</p>
            <p><strong>Algorithm Steps</strong>:</p>
            <ol>
                <li>Identify the parameters that uniquely define a subproblem and create a <strong>recursive function</strong> using these parameters.</li>
                <li>Establish <strong>base cases</strong> to terminate recursion.</li>
                <li>Initialize a data structure to <strong>store</strong> computed subproblem results.</li>
                <li>Before computing a subproblem, <strong>check if its result is already stored</strong>.</li>
                <li>If not already computed, <strong>compute the subproblem's result</strong> and store it.</li>
            </ol>
            <p><strong>Example</strong>: Computing Fibonacci Numbers with Memoization</p>
            <p>
            <div>
                <pre><code class="language-python">def fibonacci(n, memo={}):
    if n in memo:
        return memo[n]
    if n &lt;= 1:
        memo[n] = n
    else:
        memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo)
    return memo[n]</code></pre>
            </div>
            </p>
            <p><strong>Analysis</strong>:</p>
            <ul>
                <li><strong>Time Complexity</strong>: $O(n)$, since each number up to $n$ is computed once.</li>
                <li><strong>Space Complexity</strong>: $O(n)$, due to the memoization structure.</li>
            </ul>
            <h3 id="2-tabulation-bottom-up-approach-">2. Tabulation (Bottom-Up Approach)</h3>
            <p><strong>Concept</strong>: Tabulation involves solving all smaller subproblems first and then combining them to solve larger subproblems. It typically uses iteration and a table (array) to store solutions to subproblems, building up to the solution of the original problem.</p>
            <p><strong>Algorithm Steps</strong>:</p>
            <ol>
                <li><strong>Initialize the table</strong> by setting up a structure to store the results of subproblems, and ensure that base cases are properly initialized to handle the simplest instances of the problem.</li>
                <li><strong>Iterative computation</strong> is carried out using loops to fill the table, making sure that each subproblem is solved in the correct order before being used to solve larger subproblems.</li>
                <li><strong>Construct the solution</strong> by referencing the filled table, using the stored values to derive the final solution to the original problem efficiently.</li>
            </ol>
            <p><strong>Example</strong>: Computing Fibonacci Numbers with Tabulation</p>
            <p>
            <div>
                <pre><code class="language-python">def fibonacci(n):
    if n &lt;= 1:
        return n
    fib_table = [0] * (n + 1)
    fib_table[0], fib_table[1] = 0, 1
    for i in range(2, n + 1):
        fib_table[i] = fib_table[i - 1] + fib_table[i - 2]
    return fib_table[n]</code></pre>
            </div>
            </p>
            <p><strong>Analysis</strong>:</p>
            <ul>
                <li>The <strong>time complexity</strong> is ( O(n) ), since the algorithm iterates from 2 to ( n ), computing each Fibonacci number sequentially.</li>
                <li>The <strong>space complexity</strong> is ( O(n) ), due to the storage required for the table that holds the Fibonacci numbers up to ( n ).</li>
            </ul>
            <h3 id="comparison-of-memoization-and-tabulation">Comparison of Memoization and Tabulation</h3>
            <p>
            <table>
                <tr>
                    <td>Aspect</td>
                    <td>Memoization (Top-Down)</td>
                    <td>Tabulation (Bottom-Up)</td>
                </tr>
                <tr>
                    <td><strong>Approach</strong></td>
                    <td>Recursive</td>
                    <td>Iterative</td>
                </tr>
                <tr>
                    <td><strong>Storage</strong></td>
                    <td>Stores solutions as needed</td>
                    <td>Pre-fills table with solutions to all subproblems</td>
                </tr>
                <tr>
                    <td><strong>Overhead</strong></td>
                    <td>Function call overhead due to recursion</td>
                    <td>Minimal overhead due to iteration</td>
                </tr>
                <tr>
                    <td><strong>Flexibility</strong></td>
                    <td>May be easier to implement for complex recursive problems</td>
                    <td>May require careful ordering of computations</td>
                </tr>
                <tr>
                    <td><strong>Space Efficiency</strong></td>
                    <td>Potentially higher due to recursion stack and memoization</td>
                    <td>Can be more space-efficient with careful table design</td>
                </tr>
            </table>
            </p>
            <h2 id="implementation-techniques-with-mathematical-rigor">Implementation Techniques with Mathematical Rigor</h2>
            <p>Dynamic programming problems are often formulated using recurrence relations, which express the solution to a problem in terms of its subproblems.</p>
            <h3 id="formulating-recurrence-relations">Formulating Recurrence Relations</h3>
            <p><strong>Example</strong>: Longest Common Subsequence (LCS)</p>
            <p>Given two sequences $X = x_1, x_2, ..., x_m$ and $Y = y_1, y_2, ..., y_n$, the length of their LCS can be defined recursively:</p>
            <p>$$ LCS(i, j) = \begin{cases}
                0 &amp; \text{if } i = 0 \text{ or } j = 0 \\
                LCS(i - 1, j - 1) + 1 &amp; \text{if } x_i = y_j \\
                \max(LCS(i - 1, j), LCS(i, j - 1)) &amp; \text{if } x_i \neq y_j
                \end{cases} $$</p>
            <p><strong>Implementation</strong>:</p>
            <p>We can implement the LCS problem using either memoization or tabulation. With tabulation, we build a two-dimensional table $LCS[0..m][0..n]$ iteratively.</p>
            <ul>
                <li>The <strong>time complexity</strong> is ( O(mn) ), as the algorithm processes a grid or matrix of size ( m \times n ), iterating through each cell.</li>
                <li>The <strong>space complexity</strong> is ( O(mn) ), due to the table storing intermediate results, but this can be reduced to ( O(n) ) by optimizing the storage to only keep necessary data for the current and previous rows.</li>
            </ul>
            <h3 id="state-representation">State Representation</h3>
            <p>Properly defining the state is crucial for dynamic programming.</p>
            <ul>
                <li><strong>State variables</strong> are the parameters that uniquely define each subproblem, helping to break down the problem into smaller, manageable components.</li>
                <li><strong>State transition</strong> refers to the rules or formulas that describe how to move from one state to another, typically using the results of smaller subproblems to solve larger ones.</li>
            </ul>
            <p><strong>Example</strong>: 0/1 Knapsack Problem</p>
            <ul>
                <li>The <strong>problem statement</strong> focuses on selecting ( n ) items, each with a weight ( w_i ) and value ( v_i ), while ensuring the total weight stays within the knapsack capacity ( W ), in order to maximize the total value.</li>
                <li>In <strong>state representation</strong>, ( dp[i][w] ) represents the maximum value that can be achieved using the first ( i ) items with a total weight capacity of ( w ).</li>
                <li><strong>State Transition</strong>:</li>
            </ul>
            <p>$$ dp[i][w] = \begin{cases}
                dp[i - 1][w] &amp; \text{if } w_i &gt; w \\
                \max(dp[i - 1][w], dp[i - 1][w - w_i] + v_i) &amp; \text{if } w_i \leq w
                \end{cases} $$</p>
            <p><strong>Implementation</strong>:</p>
            <p>We fill the table $dp[0..n][0..W]$ iteratively based on the state transition.</p>
            <ul>
                <li>The <strong>time complexity</strong> is ( O(nW) ), where ( n ) is the number of items and ( W ) is the capacity of the knapsack, as the algorithm iterates through both items and weights.</li>
                <li>The <strong>space complexity</strong> is ( O(nW) ), but this can be optimized to ( O(W) ) because each row in the table depends only on the values from the previous row, allowing for space reduction.</li>
            </ul>
            <h2 id="advanced-dynamic-programming-concepts">Advanced Dynamic Programming Concepts</h2>
            <h3 id="memory-optimization">Memory Optimization</h3>
            <p>In some cases, we can optimize space complexity by noting dependencies between states.</p>
            <p><strong>Example</strong>: Since $dp[i][w]$ depends only on $dp[i - 1][w]$ and $dp[i - 1][w - w_i]$, we can use a one-dimensional array and update it in reverse.</p>
            <p>
            <div>
                <pre><code class="language-python">dp = [0] * (W + 1)
for i in range(1, n + 1):
    for w in range(W, w_i - 1, -1):
        dp[w] = max(dp[w], dp[w - w_i] + v_i)</code></pre>
            </div>
            </p>
            <h3 id="dealing-with-non-overlapping-subproblems">Dealing with Non-Overlapping Subproblems</h3>
            <p>If a problem does not have overlapping subproblems but does have optimal substructure, it may be more appropriate to use <strong>Divide and Conquer</strong> rather than dynamic programming.</p>
            <p><strong>Example</strong>: Merge Sort algorithm divides the list into halves, sorts each half, and then merges the sorted halves.</p>
            <h2 id="common-terms-in-dynamic-programming-context">Common Terms in Dynamic Programming Context</h2>
            <h3 id="recursion">Recursion</h3>
            <p><strong>Definition</strong>: A process where a function calls itself directly or indirectly to solve a smaller instance of the same problem until it reaches a base case.</p>
            <p><strong>Mathematical Perspective</strong>:</p>
            <p>A recursive function $f(n)$ satisfies:</p>
            <p>$$ f(n) = g(f(k), f(n - k)) $$</p>
            <p>for some function $g$ and smaller subproblem size $k &lt; n$.</p>
            <p><strong>Example</strong>: Computing $n!$:</p>
            <p>$$ n! = n \times (n - 1)! $$</p>
            <p>with base case $0! = 1$.</p>
            <h3 id="subset">Subset</h3>
            <p><strong>Definition</strong>: For a set $S$, a subset $T$ is a set where every element of $T$ is also an element of $S$. Denoted as $T \subseteq S$.</p>
            <p><strong>Mathematical Properties</strong>:</p>
            <ul>
                <li>The <strong>total subsets</strong> of a set with ( n ) elements is ( 2^n ), as each element can either be included or excluded from a subset.</li>
                <li>The <strong>power set</strong> of a set ( S ), denoted as ( \mathcal{P}(S) ), is the set of all possible subsets of ( S ), including the empty set and ( S ) itself.</li>
            </ul>
            <p><strong>Relevance to DP</strong>:</p>
            <p>Subsets often represent different states or configurations in combinatorial problems, such as the subset-sum problem.</p>
            <h3 id="subarray">Subarray</h3>
            <p><strong>Definition</strong>: A contiguous segment of an array $A$. A subarray is defined by a starting index $i$ and an ending index $j$, with $0 \leq i \leq j &lt; n$, where $n$ is the length of the array.</p>
            <p><strong>Mathematical Representation</strong>:</p>
            <p>$$ \text{Subarray } A[i..j] = [A_i, A_{i+1}, ..., A_j] $$</p>
            <p><strong>Example</strong>:</p>
            <p>Given $A = [3, 5, 7, 9]$, the subarray from index $1$ to $2$ is $[5, 7]$.</p>
            <p><strong>Relevance to DP</strong>:</p>
            <p>Subarray problems include finding the maximum subarray sum (Kadane's algorithm), where dynamic programming efficiently computes optimal subarrays.</p>
            <h3 id="substring">Substring</h3>
            <p><strong>Definition</strong>: A contiguous sequence of characters within a string $S$. Analogous to subarrays in arrays.</p>
            <p><strong>Mathematical Representation</strong>:</p>
            <p>A substring $S[i..j]$ is:</p>
            <p>$$ S_iS_{i+1}...S_j $$</p>
            <p>with $0 \leq i \leq j &lt; \text{length}(S)$.</p>
            <p><strong>Example</strong>:</p>
            <p>For $S = "dynamic"$, the substring from index $2$ to $4$ is $"nam"$.</p>
            <p><strong>Relevance to DP</strong>:</p>
            <p>Substring problems include finding the longest palindromic substring or the longest common substring between two strings.</p>
            <h3 id="subsequence">Subsequence</h3>
            <p><strong>Definition</strong>: A sequence derived from another sequence by deleting zero or more elements without changing the order of the remaining elements.</p>
            <p><strong>Mathematical Representation</strong>:</p>
            <p>Given sequence $S$, subsequence $T$ is:</p>
            <p>$$ T = [S_{i_1}, S_{i_2}, ..., S_{i_k}] $$</p>
            <p>where $0 \leq i_1 &lt; i_2 &lt; ... &lt; i_k &lt; n$.</p>
            <p><strong>Example</strong>:</p>
            <p>For $S = [a, b, c, d]$, $[a, c, d]$ is a subsequence.</p>
            <p><strong>Relevance to DP</strong>:</p>
            <p>The Longest Common Subsequence (LCS) problem is a classic dynamic programming problem.</p>
            <p><strong>LCS Dynamic Programming Formulation</strong>:</p>
            <p>Let $X = x_1 x_2 ... x_m$ and $Y = y_1 y_2 ... y_n$. Define $L[i][j]$ as the length of the LCS of $X[1..i]$ and $Y[1..j]$.</p>
            <p><strong>Recurrence Relation</strong>:</p>
            <p>$$ L[i][j] = \begin{cases}
                0 &amp; \text{if } i = 0 \text{ or } j = 0 \\
                L[i - 1][j - 1] + 1 &amp; \text{if } x_i = y_j \\
                \max(L[i - 1][j], L[i][j - 1]) &amp; \text{if } x_i \neq y_j
                \end{cases} $$</p>
            <p><strong>Implementation</strong>:</p>
            <p>We build a two-dimensional table $L[0..m][0..n]$ using the above recurrence.</p>
            <p><strong>Time Complexity</strong>: $O(mn)$</p>
            <h2 id="practical-considerations-in-dynamic-programming">Practical Considerations in Dynamic Programming</h2>
            <h3 id="identifying-dp-problems">Identifying DP Problems</h3>
            <p>Not all problems are amenable to dynamic programming. To determine if DP is appropriate:</p>
            <ul>
                <li>Can the problem's optimal solution be constructed from optimal solutions to its subproblems?</li>
                <li>Are the same subproblems being solved multiple times?</li>
            </ul>
            <h3 id="state-design-and-transition">State Design and Transition</h3>
            <ul>
                <li>Choose variables that capture the essence of subproblems.</li>
                <li>Clearly define how to move from one state to another.</li>
            </ul>
            <h3 id="complexity-optimization">Complexity Optimization</h3>
            <ul>
                <li>Reduce the storage requirements by identifying and storing only necessary states.</li>
                <li>Prune unnecessary computations, possibly using techniques like memoization with pruning.</li>
            </ul>
            <h3 id="common-pitfalls">Common Pitfalls</h3>
            <ul>
                <li>Leads to missing subproblems or incorrect dependencies.</li>
                <li>Can cause incorrect results or infinite recursion.</li>
                <li>Failing to handle special inputs can result in errors.</li>
            </ul>
            <h2 id="list-of-problems">List of Problems</h2>
            <h3 id="fibonacci-sequence">Fibonacci Sequence</h3>
            <p>The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, starting with 0 and 1. This sequence is a classic example used to demonstrate recursive algorithms and dynamic programming techniques.</p>
            <ul>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/blob/master/src/dynamic_programming/cpp/fibonacci/">C++</a></li>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/blob/master/src/dynamic_programming/python/fibonacci/">Python</a></li>
            </ul>
            <h3 id="grid-traveler">Grid Traveler</h3>
            <p>The Grid Traveler problem involves finding the total number of ways to traverse an <code>m x n</code> grid from the top-left corner to the bottom-right corner, with the constraint that you can only move right or down.</p>
            <ul>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/blob/master/src/dynamic_programming/cpp/grid_traveler">C++</a></li>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/blob/master/src/dynamic_programming/python/grid_traveler">Python</a></li>
            </ul>
            <h3 id="climbing-stairs">Climbing Stairs</h3>
            <p>The Climbing Stairs problem requires determining the number of distinct ways to reach the top of a staircase with 'n' steps, given that you can climb either 1, 2, or 3 steps at a time.</p>
            <ul>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/blob/master/src/dynamic_programming/cpp/climb_stairs">C++</a></li>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/blob/master/src/dynamic_programming/python/climbing_stairs">Python</a></li>
            </ul>
            <h3 id="can-sum">Can Sum</h3>
            <p>The Can Sum problem involves determining if it is possible to achieve a target sum using any number of elements from a given list of numbers. Each number in the list can be used multiple times.</p>
            <ul>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/blob/master/src/dynamic_programming/cpp/can_sum">C++</a></li>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/blob/master/src/dynamic_programming/python/can_sum">Python</a></li>
            </ul>
            <h3 id="how-sum">How Sum</h3>
            <p>The How Sum problem extends the Can Sum problem by identifying which elements from the list can be combined to sum up to the target value.</p>
            <ul>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/blob/master/src/dynamic_programming/cpp/how_sum">C++</a></li>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/blob/master/src/dynamic_programming/python/how_sum">Python</a></li>
            </ul>
            <h3 id="best-sum">Best Sum</h3>
            <p>The Best Sum problem further extends the How Sum problem by finding the smallest combination of numbers that add up to exactly the target sum.</p>
            <ul>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/blob/master/src/dynamic_programming/cpp/best_sum">C++</a></li>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/blob/master/src/dynamic_programming/python/best_sum">Python</a></li>
            </ul>
            <h3 id="can-construct">Can Construct</h3>
            <p>The Can Construct problem involves determining if a target string can be constructed from a given list of substrings.</p>
            <ul>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/blob/master/src/dynamic_programming/cpp/can_construct">C++</a></li>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/blob/master/src/dynamic_programming/python/can_construct">Python</a></li>
            </ul>
            <h3 id="count-construct">Count Construct</h3>
            <p>The Count Construct problem expands on the Can Construct problem by determining the number of ways a target string can be constructed using a list of substrings.</p>
            <ul>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/blob/master/src/dynamic_programming/cpp/count_construct">C++</a></li>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/blob/master/src/dynamic_programming/python/count_construct">Python</a></li>
            </ul>
            <h3 id="all-constructs">All Constructs</h3>
            <p>The All Constructs problem is a variation of the Count Construct problem, which identifies all the possible combinations of substrings from a list that can be used to form the target string.</p>
            <ul>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/blob/master/src/dynamic_programming/cpp/all_construct">C++</a></li>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/blob/master/src/dynamic_programming/python/all_construct">Python</a></li>
            </ul>
            <h3 id="coins">Coins</h3>
            <p>The Coins problem aims to find the minimum number of coins needed to make a given value, provided an infinite supply of each coin denomination.</p>
            <ul>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/blob/master/src/dynamic_programming/cpp/coin_change">C++</a></li>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/blob/master/src/dynamic_programming/python/coins">Python</a></li>
            </ul>
            <h3 id="longest-common-subsequence">Longest Common Subsequence</h3>
            <p>The Longest Common Subsequence problem involves finding the longest subsequence that two sequences have in common, where a subsequence is derived by deleting some or no elements without changing the order of the remaining elements.</p>
            <ul>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/blob/master/src/dynamic_programming/cpp/longest_common_subsequence">C++</a></li>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/blob/master/src/dynamic_programming/python/longest_common_subsequence">Python</a></li>
            </ul>
            <h3 id="longest-increasing-subarray">Longest Increasing Subarray</h3>
            <p>The Longest Increasing Subarray problem involves identifying the longest contiguous subarray where the elements are strictly increasing.</p>
            <ul>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/blob/master/src/dynamic_programming/cpp/longest_increasing_subarray">C++</a></li>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/blob/master/src/dynamic_programming/python/longest_increasing_subarray">Python</a></li>
            </ul>
            <h3 id="knuth-morris-pratt">Knuth-Morris-Pratt</h3>
            <p>The Knuth-Morris-Pratt (KMP) algorithm is a pattern searching algorithm that looks for occurrences of a "word" within a main "text string" using preprocessing over the pattern to achieve linear time complexity.</p>
            <ul>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/blob/master/src/dynamic_programming/cpp/kmp">C++</a></li>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/blob/master/src/dynamic_programming/python/kmp">Python</a></li>
            </ul>
            <h3 id="minimum-insertions-to-form-a-palindrome">Minimum Insertions to Form a Palindrome</h3>
            <p>This problem involves finding the minimum number of insertions needed to transform a given string into a palindrome. The goal is to make the string read the same forwards and backwards with the fewest insertions possible.</p>
            <ul>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/blob/master/src/dynamic_programming/cpp/minimum_insertions_for_palindrome">C++</a></li>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/blob/master/src/dynamic_programming/python/minimum_insertions_for_palindrome">Python</a></li>
            </ul>
        </section>
        <div id="table-of-contents">
            <h2>Table of Contents</h2>
            <ol>
                <li><a href="#fundamental-principles-of-dynamic-programming">Fundamental Principles of Dynamic Programming</a>
                    <ol>
                        <li><a href="#1-optimal-substructure">1. Optimal Substructure</a></li>
                        <li><a href="#2-overlapping-subproblems">2. Overlapping Subproblems</a></li>
                    </ol>
                </li>
                <li><a href="#dynamic-programming-techniques">Dynamic Programming Techniques</a>
                    <ol>
                        <li><a href="#1-memoization-top-down-approach-">1. Memoization (Top-Down Approach)</a></li>
                        <li><a href="#2-tabulation-bottom-up-approach-">2. Tabulation (Bottom-Up Approach)</a></li>
                        <li><a href="#comparison-of-memoization-and-tabulation">Comparison of Memoization and Tabulation</a></li>
                    </ol>
                </li>
                <li><a href="#implementation-techniques-with-mathematical-rigor">Implementation Techniques with Mathematical Rigor</a>
                    <ol>
                        <li><a href="#formulating-recurrence-relations">Formulating Recurrence Relations</a></li>
                        <li><a href="#state-representation">State Representation</a></li>
                    </ol>
                </li>
                <li><a href="#advanced-dynamic-programming-concepts">Advanced Dynamic Programming Concepts</a>
                    <ol>
                        <li><a href="#memory-optimization">Memory Optimization</a></li>
                        <li><a href="#dealing-with-non-overlapping-subproblems">Dealing with Non-Overlapping Subproblems</a></li>
                    </ol>
                </li>
                <li><a href="#common-terms-in-dynamic-programming-context">Common Terms in Dynamic Programming Context</a>
                    <ol>
                        <li><a href="#recursion">Recursion</a></li>
                        <li><a href="#subset">Subset</a></li>
                        <li><a href="#subarray">Subarray</a></li>
                        <li><a href="#substring">Substring</a></li>
                        <li><a href="#subsequence">Subsequence</a></li>
                    </ol>
                </li>
                <li><a href="#practical-considerations-in-dynamic-programming">Practical Considerations in Dynamic Programming</a>
                    <ol>
                        <li><a href="#identifying-dp-problems">Identifying DP Problems</a></li>
                        <li><a href="#state-design-and-transition">State Design and Transition</a></li>
                        <li><a href="#complexity-optimization">Complexity Optimization</a></li>
                        <li><a href="#common-pitfalls">Common Pitfalls</a></li>
                    </ol>
                </li>
                <li><a href="#list-of-problems">List of Problems</a>
                    <ol>
                        <li><a href="#fibonacci-sequence">Fibonacci Sequence</a></li>
                        <li><a href="#grid-traveler">Grid Traveler</a></li>
                        <li><a href="#climbing-stairs">Climbing Stairs</a></li>
                        <li><a href="#can-sum">Can Sum</a></li>
                        <li><a href="#how-sum">How Sum</a></li>
                        <li><a href="#best-sum">Best Sum</a></li>
                        <li><a href="#can-construct">Can Construct</a></li>
                        <li><a href="#count-construct">Count Construct</a></li>
                        <li><a href="#all-constructs">All Constructs</a></li>
                        <li><a href="#coins">Coins</a></li>
                        <li><a href="#longest-common-subsequence">Longest Common Subsequence</a></li>
                        <li><a href="#longest-increasing-subarray">Longest Increasing Subarray</a></li>
                        <li><a href="#knuth-morris-pratt">Knuth-Morris-Pratt</a></li>
                        <li><a href="#minimum-insertions-to-form-a-palindrome">Minimum Insertions to Form a Palindrome</a></li>
                    </ol>
                </li>
            </ol>
            <div id="related-articles">
                <h2>Related Articles</h2>
                <ol>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/backtracking.html">Backtracking</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/basic_concepts.html">Basic Concepts</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/brain_teasers.html">Brain Teasers</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/data_structures.html">Data Structures</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/dynamic_programming.html">Dynamic Programming</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/graphs.html">Graphs</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/sorting.html">Sorting</a></li>
                </ol>
            </div>
        </div>
    </div>
    <footer>
        <div class="footer-columns">
            <div class="footer-column">
                <img alt="Adam Djellouli Symbol" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/symbol.png" />
            </div>
            <div class="footer-column">
                <h2><a href="https://adamdjellouli.com/core/privacy_policy.html" title="Privacy Policy">Our Privacy Policy</a></h2>
                <p>
                    Thank you for visiting my personal website. All of the <br />
                    content on this site is free to use, but please remember <br />
                    to be a good human being and refrain from any abuse<br />
                    of the site. If you would like to contact me, please use <br />
                    my <a href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" title="LinkedIn Profile">LinkedIn profile</a> or my <a href="https://github.com/djeada" title="GitHub Profile">GitHub</a> if you have any technical <br />
                    issues or ideas to share. I wish you the best and hope you <br />
                    have a fantastic life. <br />
                </p>
            </div>
            <div class="footer-column">
                <h2>Follow me</h2>
                <ul class="social-media">
                    <li>
                        <a class="fa fa-youtube" href="https://www.youtube.com/channel/UCGPoHTVjMN77wcGknXPHl1Q" target="_blank" title="YouTube">
                        </a>YouTube
                    </li>
                    <li>
                        <a class="fa fa-linkedin" href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" target="_blank" title="LinkedIn">
                        </a>LinkedIn
                    </li>
                    <li>
                        <a class="fa fa-instagram" href="https://www.instagram.com/linuxchallenges/" target="_blank" title="Instagram">
                        </a>Instagram
                    </li>
                    <li>
                        <a class="fa fa-github" href="https://github.com/djeada" title="GitHub">
                        </a>Github
                    </li>
                </ul>
            </div>
        </div>
        <div>
            <p id="copyright">
                Â© Adam Djellouli. All rights reserved.
            </p>
        </div>
        <script>
            document.getElementById("copyright").innerHTML = "&copy; " + new Date().getFullYear() + " Adam Djellouli. All rights reserved.";
        </script>
        <script src="../../app.js"></script>
    </footer>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-bash.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-cpp.min.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
jax: ["input/TeX", "output/HTML-CSS"],
extensions: ["tex2jax.js"],
"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] },
tex2jax: { inlineMath: [ ["$", "$"] ], displayMath: [ ["$$","$$"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
TeX: { noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } } },
messageStyle: "none"
});
</script>
<script async="" id="MathJax-script" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>

</html>