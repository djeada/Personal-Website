<!DOCTYPE html>

<html lang="en">

<head>
    <script async="" crossorigin="anonymous" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5593122079896089"></script>
    <meta charset="utf-8" />
    <title>Graphs</title>
    <meta content="In many areas of life, we come across systems where elements are deeply interconnectedâ€”whether through physical routes, digital networks, or abstract relationships." name="description" />
    <meta content="Adam Djellouli" name="author" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <meta content="IE=edge" http-equiv="X-UA-Compatible" />
    <link crossorigin="" href="https://fonts.googleapis.com" rel="preconnect" />
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/icon.ico" rel="icon" />
    <link href="../../resources/style.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />
</head>

<body>
    <nav aria-label="Main navigation">
        <a class="logo" href="https://adamdjellouli.com">
            <img alt="Adam Djellouli - Home Page Logo" id="logo-image" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/logo.PNG" />
        </a>
        <input aria-label="Toggle navigation menu" id="navbar-toggle" type="checkbox" />
        <ul aria-labelledby="navbar-toggle" role="menu">
            <li role="menuitem">
                <a href="../../index.html" title="Go to Home Page"> Home </a>
            </li>
            <li role="menuitem">
                <a class="active" href="../../core/blog.html" title="Read Adam Djellouli Blog on Programming and Technology"> Blog </a>
            </li>
            <li role="menuitem">
                <a href="../../core/tools.html" title="Discover Tools Created by Adam Djellouli"> Tools </a>
            </li>
            <li role="menuitem">
                <a href="../../core/projects.html" title="Explore Projects Developed by Adam Djellouli"> Projects </a>
            </li>
            <li role="menuitem">
                <a href="../../core/resume.html" title="View Adam Djellouli Professional Resume"> Resume </a>
            </li>
            <li>
                <script async="" src="https://cse.google.com/cse.js?cx=8160ef9bb935f4f68"></script>
                <div class="gcse-search"></div>
            </li>
            <li>
                <button aria-label="Toggle dark mode" id="dark-mode-button"></button>
            </li>
        </ul>
    </nav>
    <div id="article-wrapper">
        <section id="article-body">
            <p style="text-align: right;"><i>Last modified: January 27, 2025</i></p>
            <p style="text-align: right;"><i>This article is written in: ðŸ‡ºðŸ‡¸</i></p>
            <h2 id="graphs">Graphs</h2>
            <p>In many areas of life, we come across systems where elements are deeply interconnectedâ€”whether through physical routes, digital networks, or abstract relationships. Graphs offer a flexible way to represent and make sense of these connections.</p>
            <p>Some real-world examples include:</p>
            <ul>
                <li>Underground tunnel networks (subways and transportation systems below the city surface)</li>
                <li>Railway maps (train routes connecting different towns and cities)</li>
                <li>Cities linked by flights (air travel routes between global destinations)</li>
                <li>Networks of pipes (piping systems transporting water, gas, or oil)</li>
                <li>Electrical grids (networks distributing electricity across regions)</li>
                <li>Carbon atoms in a molecule (chemical compounds and the bonds between their constituent atoms)</li>
                <li>Internet (webpages interlinked through hyperlinks or networks of computers)</li>
                <li>Task scheduling (dependencies among tasks that determine their sequence or priority)</li>
                <li>Spread of a disease (understanding how diseases propagate through populations)</li>
                <li>Social networks (people connected through friendships, family ties, or professional relationships)</li>
                <li>Countries and their political alliances (diplomatic ties, trade partnerships, or defense pacts between nations)</li>
            </ul>
            <p>Viewing these systems as graphs allows for deeper analysis, better optimization, and more accurate predictions of their behavior. In computer science and mathematics, graphs serve as a powerful data structure that provides the tools needed for this kind of modeling.</p>
            <h3 id="graph-terminology">Graph Terminology</h3>
            <p>Graph theory has its own language, full of terms that make it easier to talk about and define different types of graphs and their features. Here's an explanation of some important terms:</p>
            <ul>
                <li>A <strong>graph</strong> $G$ is a mathematical structure consisting of a set $V(G)$ of vertices (also known as points or nodes) and a set $E(G)$ of pairs of these vertices. These pairs, denoted as ${x, y} \in E(G)$, are called edges (or links or lines).</li>
                <li>If ${x, y} \in E(G)$, then $x$ and $y$ are said to be <strong>adjacent</strong>. The number of vertices adjacent to a vertex $v$ defines its degree. Interestingly, the total degrees of all vertices in a graph is always even.</li>
                <li>A <strong>path</strong> of length $n$ is a series of vertices $v_1 \sim v_2 \sim \dots \sim v_{n+1}$ such that $(v_i, v_{i+1}) \in E(G)$ with all vertices in the sequence being distinct.</li>
                <li>A <strong>cycle</strong> is a special type of path where $v_1 = v_{n+1}$, and all other vertices from $v_1$ to $v_n$ are unique.</li>
                <li>Distance represents the length of the shortest path between two vertices. When assessing the distance between vertices $x$ and $y$, you are looking for the most direct route connecting them.</li>
                <li>A <strong>simple graph</strong> is a graph with no self-loops (edges connected at both ends to the same vertex) and at most one edge between any two vertices.</li>
                <li>In a <strong>directed graph</strong> (digraph), edges have direction. They are an ordered pair of vertices, often called arcs. In contrast, undirected graphs lack directionality, meaning an edge from vertex $A$ to vertex $B$ is the same as one from $B$ to $A$.</li>
                <li>A <strong>weighted graph</strong> assigns a weight to each edge, typically a non-negative integer. A binary weight represents the presence (1) or absence (0) of a connection between nodes. A numeric weight indicates the strength or cost of a connection. A normalized weight ensures that all outgoing edges from a node sum to one, often used in probabilistic contexts.</li>
                <li>In terms of <strong>connectivity</strong>, an undirected graph is termed connected if every vertex pair is linked by some path. In a directed graph, weakly connected means a path exists from vertex $A$ to $B$ or $B$ to $A$ for any vertices $A$ and $B$. Strongly connected means paths exist in both directions between every pair of vertices.</li>
                <li><strong>Vertices</strong> $A$ and $B$, if connected by an edge $e$, are neighbors. This edge $e$ is incident to both $A$ and $B$. When two edges share a vertex (like edges from $A$ to $B$ and $B$ to $C$), they are adjacent.</li>
                <li>The concept of an <strong>isolated vertex</strong> refers to a vertex with no edges connected to it. This means the vertex has a degree of zero since it is not adjacent to any other vertex.</li>
                <li><strong>Subgraphs</strong> are smaller graphs formed from a subset of the vertices and edges of a larger graph. If $G$ is a graph, a subgraph $H$ is a graph such that the vertex set of $H$ is a subset of the vertex set of $G$ and the edge set of $H$ is a subset of the edge set of $G$.</li>
                <li>A <strong>spanning tree</strong> of a graph $G$ is a subgraph that includes all the vertices of $G$ and is a single connected tree. A spanning tree has exactly $|V| - 1$ edges where $|V|$ is the number of vertices in the graph.</li>
                <li><strong>Bipartite graphs</strong> are graphs whose vertices can be divided into two disjoint sets such that no two vertices within the same set are adjacent. Formally, a graph $G$ is bipartite if there exists a partition $V(G) = V_1 \cup V_2$ where $V_1$ and $V_2$ are disjoint and every edge connects a vertex in $V_1$ to a vertex in $V_2$.</li>
                <li>A <strong>complete graph</strong> is a simple graph in which there is an edge between every pair of vertices. If a complete graph has $n$ vertices, it is denoted by $K_n$ and has $\frac{n(n-1)}{2}$ edges.</li>
                <li><strong>Planar graphs</strong> can be drawn on a plane without any edges crossing. A graph is planar if it can be embedded in the plane, meaning it can be drawn on a flat surface such that its edges intersect only at their endpoints.</li>
                <li>The <strong>Eulerian path</strong> is a path in a graph that visits every edge exactly once. If such a path exists and starts and ends at different vertices, it is an Eulerian path. If it starts and ends at the same vertex, it is an Eulerian circuit. A graph has an Eulerian circuit if and only if all vertices have an even degree, and it is connected. A graph has an Eulerian path if it has exactly zero or two vertices of odd degree, and it is connected.</li>
                <li>The <strong>Hamiltonian path</strong> is a path in a graph that visits every vertex exactly once. If such a path exists and starts and ends at different vertices, it is a Hamiltonian path. If it starts and ends at the same vertex, it is a Hamiltonian circuit. Determining whether a Hamiltonian path or circuit exists in a graph is a well-known NP-complete problem.</li>
                <li><strong>Graph isomorphism</strong> refers to a condition where two graphs $G$ and $H$ are considered isomorphic if there is a one-to-one correspondence between their vertex sets and their edge sets that preserves adjacency. In other words, $G$ and $H$ are structurally identical but may have different vertex and edge labels.</li>
                <li><strong>Degree sequence</strong> is a list of the degrees of the vertices in a graph, usually written in non-increasing order. The degree sequence is a graph invariant, meaning it is the same for any isomorphic graphs.</li>
                <li><strong>Graph coloring</strong> is the assignment of labels (colors) to vertices of a graph such that no two adjacent vertices share the same color. The minimum number of colors needed to color a graph $G$ is known as its chromatic number.</li>
                <li><strong>Tree</strong> is a connected, acyclic graph. In a tree, any two vertices are connected by exactly one path, and adding any edge to a tree will create a cycle. Trees have several important properties and applications in computer science, particularly in data structures and algorithms.</li>
                <li><strong>Forest</strong> is a disjoint set of trees. It is an acyclic graph that may consist of multiple disconnected components, each being a tree.</li>
                <li><strong>Cut vertices and cut edges</strong> refer to vertices and edges whose removal increases the number of connected components of the graph. A cut vertex (or articulation point) is a vertex that, if removed, would split the graph into two or more disconnected subgraphs. A cut edge (or bridge) is an edge that, if removed, would increase the number of connected components.</li>
                <li><strong>Matching</strong> in a graph is a set of edges without common vertices. A maximum matching is a matching that contains the largest possible number of edges. If every vertex of the graph is incident to exactly one edge of the matching, it is called a perfect matching.</li>
                <li><strong>Independent set</strong> is a set of vertices in a graph, no two of which are adjacent. The size of the largest independent set is called the independence number of the graph.</li>
                <li><strong>Clique</strong> is a subset of vertices such that every two distinct vertices are adjacent. The size of the largest clique in a graph is called the clique number.</li>
                <li><strong>Vertex cover</strong> is a set of vertices such that each edge of the graph is incident to at least one vertex of the set. The size of the smallest vertex cover is called the vertex cover number.</li>
                <li><strong>Dominating set</strong> is a set of vertices such that each vertex in the graph is either in the dominating set or adjacent to a vertex in the dominating set. The size of the smallest dominating set is called the domination number.</li>
                <li><strong>Planarity testing</strong> determines whether a graph can be drawn in a plane without edge crossings. Kuratowski's theorem provides a criterion for planarity based on the presence of subgraphs homeomorphic to $K_5$ (complete graph on five vertices) or $K_{3,3}$ (complete bipartite graph on six vertices, three in each set).</li>
                <li><strong>Graph algorithms</strong> encompass a variety of procedures and techniques used to solve problems related to graphs. Examples include depth-first search (DFS), breadth-first search (BFS), Dijkstra's algorithm for shortest paths, Kruskal's and Prim's algorithms for minimum spanning trees, and the Bellman-Ford algorithm for shortest paths in graphs with negative weights.</li>
            </ul>
            <h3 id="representation-of-graphs-in-computer-memory">Representation of Graphs in Computer Memory</h3>
            <p>Graphs, with their versatile applications in numerous domains, necessitate efficient storage and manipulation mechanisms in computer memory. The choice of representation often depends on the graph's characteristics, such as sparsity, and the specific operations to be performed. Among the various methods available, the adjacency matrix and the adjacency list are the most prevalent.</p>
            <h4 id="adjacency-matrix">Adjacency Matrix</h4>
            <p>An adjacency matrix represents a graph $G$ as a two-dimensional matrix. Given $V$ vertices, it utilizes a $V \times V$ matrix $A$. The rows and columns correspond to the graph's vertices, and each cell $A_{ij}$ holds:</p>
            <ul>
                <li><code>1</code> if there is an edge between vertex $i$ and vertex $j$</li>
                <li><code>0</code> if no such edge exists</li>
            </ul>
            <p>For graphs with edge weights, $A_{ij}$ contains the weight of the edge between vertices $i$ and $j$.</p>
            <p>Example:</p>
            <p>
            <table>
                <tr>
                    <td></td>
                    <td>A</td>
                    <td>B</td>
                    <td>C</td>
                    <td>D</td>
                </tr>
                <tr>
                    <td>A</td>
                    <td>0</td>
                    <td>1</td>
                    <td>0</td>
                    <td>1</td>
                </tr>
                <tr>
                    <td>B</td>
                    <td>1</td>
                    <td>0</td>
                    <td>1</td>
                    <td>0</td>
                </tr>
                <tr>
                    <td>C</td>
                    <td>0</td>
                    <td>1</td>
                    <td>0</td>
                    <td>1</td>
                </tr>
                <tr>
                    <td>D</td>
                    <td>1</td>
                    <td>0</td>
                    <td>1</td>
                    <td>0</td>
                </tr>
            </table>
            </p>
            <p>Here, the matrix indicates a graph with vertices A to D. For instance, vertex A connects with vertices B and D, hence the respective 1s in the matrix.</p>
            <p><strong>Benefits</strong>:</p>
            <ul>
                <li>Fixed-time ($O(1)$) edge existence checks.</li>
                <li>Particularly suitable for dense graphs, where the edge-to-vertex ratio is high.</li>
            </ul>
            <p><strong>Drawbacks</strong>:</p>
            <ul>
                <li>Consumes more space for sparse graphs.</li>
                <li>Traversing neighbors can be slower due to the need to check all vertices.</li>
            </ul>
            <h4 id="adjacency-list">Adjacency List</h4>
            <p>An adjacency list uses a collection (often an array or a linked list) to catalog the neighbors of each vertex. Each vertex points to its own list, enumerating its direct neighbors.</p>
            <p>Example:</p>
            <p>
            <div>
                <pre><code class="language-shell">A -&gt; [B, D]
B -&gt; [A, C]
C -&gt; [B, D]
D -&gt; [A, C]</code></pre>
            </div>
            </p>
            <p>This list reflects the same graph as our matrix example. Vertex A's neighbors, for instance, are B and D.</p>
            <p><strong>Benefits</strong>:</p>
            <ul>
                <li>Space-efficient for sparse graphs, where edges are relatively fewer.</li>
                <li>Facilitates faster traversal of a vertex's neighbors since the direct neighbors are listed without extraneous checks.</li>
            </ul>
            <p><strong>Drawbacks</strong>:</p>
            <ul>
                <li>Edge existence checks can take up to $O(V)$ time in the worst case.</li>
                <li>Potentially consumes more space for dense graphs.</li>
            </ul>
            <p>In practice, the choice between these (and other) representations often hinges on the graph's characteristics and the specific tasks or operations envisioned.</p>
            <h3 id="planarity">Planarity</h3>
            <p>Planarity is a fundamental concept in graph theory that examines whether a graph can be drawn on a flat surface without any of its edges overlapping. This idea holds significant importance in areas such as circuit design, urban planning, and geography.</p>
            <h4 id="what-is-a-planar-graph-">What is a Planar Graph?</h4>
            <p>A graph is considered "planar" if there exists a representation of it on a two-dimensional plane where its edges intersect only at their vertices and nowhere in between. Being able to redraw a graph without any edges crossing, even if it starts out messy with overlaps, is what shows if itâ€™s planar or not.</p>
            <h4 id="planar-embedding">Planar Embedding</h4>
            <p>A "planar embedding" refers to a way of drawing a graph on a plane so that none of its edges cross each other. If a graph is first drawn with overlapping edges, itâ€™s considered planar if you can rearrange it so no edges cross.</p>
            <h4 id="examples">Examples</h4>
            <p>To understand planarity better, let's explore some examples:</p>
            <ol>
                <li><strong>Cycle Graphs</strong>: Graphs like triangles, squares, or hexagons, which are simple loops or cycles, are intrinsically planar. These shapes can always be illustrated without intersecting edges.</li>
            </ol>
            <p>
            <div>
                <pre><code class="language-shell">A-----B
|     |
C-----D</code></pre>
            </div>
            </p>
            <ol>
                <li><strong>Complete Graph with Four Vertices ($K_4$)</strong>: This graph has every vertex connected to all other vertices. Despite its complexity, $K_4$ remains planar and resembles a tetrahedron.</li>
            </ol>
            <p>
            <div>
                <pre><code class="language-shell">#
   A--------
  / \      |
 B---C     |
  \ /      |
   D--------</code></pre>
            </div>
            </p>
            <ol>
                <li><strong>Complete Graph with Five Vertices ($K_5$)</strong>: Unlike $K_4$, $K_5$ cannot be sketched without crossing edges, thus classifying it as non-planar.</li>
            </ol>
            <p>
            <div>
                <pre><code class="language-shell">#
      -  A  -
    /  /   \  \
  /   |     |   \
 B----+-----+---C
  \   |     |  /
    \ D-----E /</code></pre>
            </div>
            </p>
            <p>In the $K_5$ graph, edges like AD and AE overlap with BC.</p>
            <h4 id="strategies-for-assessing-planarity">Strategies for Assessing Planarity</h4>
            <ul>
                <li>The <strong>planarity</strong> of a graph refers to whether it can be drawn on a flat surface without any edges crossing each other.</li>
                <li><strong>Small graphs</strong> can be tested for planarity by manually rearranging their vertices and edges to check if a crossing-free drawing is possible.</li>
                <li><strong>Kuratowski's theorem</strong> states that a graph is planar if it does not contain a subgraph that can be transformed into $K_5$ (a graph with five vertices all connected to each other) or $K_{3,3}$ (a graph with two groups of three vertices, where every vertex in one group connects to every vertex in the other).</li>
                <li><strong>$K_5$</strong> is a complete graph with five vertices where every pair of vertices has a direct edge connecting them.</li>
                <li><strong>$K_{3,3}$</strong> is a bipartite graph where two sets of three vertices are connected such that each vertex in the first set is connected to all vertices in the second set, with no edges within the same set.</li>
                <li><strong>Wagnerâ€™s theorem</strong> provides an alternative way to determine planarity, stating that a graph is planar if it does not have $K_5$ or $K_{3,3}$ as a "minor." A minor is a smaller graph formed by deleting edges, deleting vertices, or merging connected vertices.</li>
                <li>For <strong>larger graphs</strong>, manual testing becomes impractical, and planarity algorithms are often used instead.</li>
                <li>The <strong>Hopcroft-Tarjan algorithm</strong> is a linear-time method for testing planarity. It uses depth-first search to efficiently decide if a graph can be drawn without crossing edges.</li>
                <li>The <strong>Boyer-Myrvold algorithm</strong> is another linear-time approach that tests planarity and can also provide an embedding of the graph (a specific way to draw it without crossings) if it is planar.</li>
                <li>Both <strong>algorithms</strong> are widely used in computer science for applications that involve networks, circuit design, and data visualization, where planarity helps simplify complex structures.</li>
            </ul>
            <h3 id="traversals">Traversals</h3>
            <ul>
                <li>When we <strong>traverse</strong> a graph, we visit its vertices in an organized way to make sure we donâ€™t miss any vertices or edges.</li>
                <li>Graphs, unlike <strong>trees</strong>, donâ€™t have a single starting point like a root. This means we either need to be given a starting vertex or pick one randomly.</li>
                <li>Letâ€™s say we start from a specific vertex, like <strong>$i$</strong>. From there, the traversal explores all connected vertices according to the rules of the chosen method.</li>
                <li>In both <strong>breadth-first search (BFS)</strong> and <strong>depth-first search (DFS)</strong>, the order of visiting vertices depends on how the algorithm is implemented.</li>
                <li>For example, if the starting vertex <strong>A</strong> has three neighbors, like $C, F,$ and $G$, the algorithm doesnâ€™t have a fixed rule for which neighbor to visit first. It could choose any of them based on the way itâ€™s programmed.</li>
                <li>Because of this flexibility, we talk about <strong>a result</strong> of BFS or DFS, rather than <strong>the result</strong>, since different implementations might visit vertices in different orders.</li>
            </ul>
            <h4 id="breadth-first-search-bfs-">Breadth-First Search (BFS)</h4>
            <p>Breadth-First Search (BFS) is a fundamental graph traversal algorithm that explores the vertices of a graph in layers, starting from a specified source vertex. It progresses by visiting all immediate neighbors of the starting point, then the neighbors of those neighbors, and so on.</p>
            <p>To efficiently keep track of the traversal, BFS employs two primary data structures:</p>
            <ul>
                <li>A queue, typically named <code>unexplored</code> or <code>queue</code>, to store nodes that are pending exploration.</li>
                <li>A hash table or a set called <code>visited</code> to ensure that we do not revisit nodes.</li>
            </ul>
            <h5>Algorithm Steps</h5>
            <ol>
                <li>Begin from a starting vertex, $i$.</li>
                <li>Mark the vertex $i$ as visited.</li>
                <li>Explore each of its neighbors. If the neighbor hasn't been visited yet, mark it as visited and enqueue it in <code>unexplored</code>.</li>
                <li>Dequeue the front vertex from <code>unexplored</code> and repeat step 3.</li>
                <li>Continue this process until the <code>unexplored</code> queue becomes empty.</li>
            </ol>
            <p>To ensure the algorithm doesn't fall into an infinite loop due to cycles in the graph, it could be useful to mark nodes as visited as soon as they are enqueued. This prevents them from being added to the queue multiple times.</p>
            <h5>Example</h5>
            <p>
            <div>
                <pre><code class="language-shell">Queue: Empty          Visited: A, B, C, D, E

   A
  / \
 B   C
 |   |
 D   E</code></pre>
            </div>
            </p>
            <p>In this example, BFS started at the top of the graph and worked its way down, visiting nodes in order of their distance from the starting node. The ASCII representation provides a step-by-step visualization of BFS using a queue and a list of visited nodes.</p>
            <h5>Applications</h5>
            <p>BFS is not only used for simple graph traversal. Its applications span multiple domains:</p>
            <ol>
                <li>BFS can determine the <strong>shortest path</strong> in an unweighted graph from a source to all other nodes.</li>
                <li>To find all <strong>connected components</strong> in an undirected graph, you can run BFS on every unvisited node.</li>
                <li>BFS mirrors the propagation in broadcasting networks, where a message is forwarded to neighboring nodes, and they subsequently forward it to their neighbors.</li>
                <li>If during BFS traversal, an already visited node is encountered (and it's not the parent of the current node in traversal), then there exists a cycle in the graph.</li>
            </ol>
            <h5>Implementation</h5>
            <ul>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/tree/master/src/graphs/cpp/bfs">C++</a></li>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/tree/master/src/graphs/python/bfs">Python</a></li>
            </ul>
            <h4 id="depth-first-search-dfs-">Depth-First Search (DFS)</h4>
            <p>Depth-First Search (DFS) is another fundamental graph traversal algorithm, but unlike BFS which traverses level by level, DFS dives deep into the graph, exploring as far as possible along each branch before backtracking.</p>
            <p>To implement DFS, we use two main data structures:</p>
            <ul>
                <li>A stack, either implicitly using the call stack through recursion or explicitly using a data structure. This stack is responsible for tracking vertices that are to be explored.</li>
                <li>A hash table or set called <code>visited</code> to ensure nodes aren't revisited.</li>
            </ul>
            <h5>Algorithm Steps</h5>
            <ol>
                <li>Begin from a starting vertex, $i$.</li>
                <li>Mark vertex $i$ as visited.</li>
                <li>Visit an unvisited neighbor of $i$, mark it as visited, and move to that vertex.</li>
                <li>Repeat the above step until the current vertex has no unvisited neighbors.</li>
                <li>Backtrack to the previous vertex and explore other unvisited neighbors.</li>
                <li>Continue this process until you've visited all vertices connected to the initial start vertex.</li>
            </ol>
            <p>Marking nodes as visited as soon as you encounter them is important to avoid infinite loops, particularly in graphs with cycles.</p>
            <h5>Example</h5>
            <p>
            <div>
                <pre><code class="language-shell">Stack: Empty          Visited: A, B, D, C, E

   A
  / \
 B   C
 |   |
 D   E</code></pre>
            </div>
            </p>
            <p>In this example, DFS explored as deep as possible along the left side (branch with B and D) of the graph before backtracking and moving to the right side (branch with C and E). The ASCII representation provides a step-by-step visualization of DFS using a stack and a list of visited nodes.</p>
            <h5>Applications</h5>
            <p>DFS, with its inherent nature of diving deep, has several intriguing applications:</p>
            <ol>
                <li>Topological Sorting is used in scheduling tasks, where one task should be completed before another starts.</li>
                <li>To find all strongly connected components in a directed graph.</li>
                <li>DFS can be employed to find a path between two nodes, though it might not guarantee the shortest path.</li>
                <li>If during DFS traversal, an already visited node is encountered (and it's not the direct parent of the current node in traversal), then there's a cycle in the graph.</li>
            </ol>
            <h5>Implementation</h5>
            <ul>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/tree/master/src/graphs/cpp/dfs">C++</a></li>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/tree/master/src/graphs/python/dfs">Python</a></li>
            </ul>
            <h3 id="shortest-paths">Shortest paths</h3>
            <p>A common task when dealing with weighted graphs is to find the shortest route between two vertices, such as from vertex $A$ to vertex $B$. Note that there might not be a unique shortest path, since several paths could have the same length.</p>
            <h4 id="dijkstra-s-algorithm">Dijkstra's Algorithm</h4>
            <ul>
                <li><strong>Dijkstra's algorithm</strong> is a method to find the shortest paths from a starting vertex to all other vertices in a weighted graph.</li>
                <li>A <strong>weighted graph</strong> is one where each edge has a numerical value (cost, distance, or time).</li>
                <li>The algorithm starts at a <strong>starting vertex</strong>, often labeled <strong>A</strong>, and computes the shortest path to every other vertex.</li>
                <li>It keeps a <strong>tentative distance</strong> for each vertex, representing the current known shortest distance from the start.</li>
                <li>It repeatedly <strong>selects the vertex</strong> with the smallest tentative distance that hasn't been finalized (or "finished") yet.</li>
                <li>Once a vertex is selected, the algorithm <strong>relaxes all its edges</strong>: it checks if going through this vertex offers a shorter path to its neighbors.</li>
                <li>This continues until all vertices are processed, yielding the shortest paths from the starting vertex to every other vertex.</li>
                <li><strong>Important</strong>: Dijkstraâ€™s algorithm requires <strong>non-negative edge weights</strong>, or else results can be incorrect.</li>
            </ul>
            <h5>Algorithm Steps</h5>
            <p><strong>Input</strong></p>
            <ul>
                <li>A weighted graph where each edge has a cost or distance</li>
                <li>A starting vertex <code>A</code></li>
            </ul>
            <p><strong>Output</strong></p>
            <ul>
                <li>An array <code>distances</code> where <code>distances[v]</code> is the shortest distance from <code>A</code> to vertex <code>v</code></li>
            </ul>
            <p><strong>Containers and Data Structures</strong></p>
            <ul>
                <li>An array <code>distances</code>, initialized to <code>âˆž</code> for all vertices except <code>A</code>, which is set to <code>0</code></li>
                <li>A hash table <code>finished</code> to mark vertices with confirmed shortest paths</li>
                <li>A priority queue to efficiently select the vertex with the smallest current distance</li>
            </ul>
            <p><strong>Steps</strong></p>
            <p>I. Initialize <code>distances[A]</code> to <code>0</code></p>
            <p>II. Initialize <code>distances[v]</code> to <code>âˆž</code> for every other vertex <code>v</code></p>
            <p>III. While not all vertices are marked as finished</p>
            <ul>
                <li>Select vertex <code>u</code> with the smallest <code>distances[u]</code> among unfinished vertices</li>
                <li>Mark <code>finished[u]</code> as <code>true</code></li>
                <li>For each neighbor <code>w</code> of <code>u</code>, if <code>distances[u] + weights[u][w]</code> is less than <code>distances[w]</code>, update <code>distances[w]</code> to <code>distances[u] + weights[u][w]</code></li>
            </ul>
            <h5>Step by Step Example</h5>
            <p>Consider a graph with vertices A, B, C, D, and E, and edges:</p>
            <p>
            <div>
                <pre><code class="language-shell">A-B: 4
A-C: 2
C-B: 1
B-D: 5
C-D: 8
C-E: 10
D-E: 2</code></pre>
            </div>
            </p>
            <p>The adjacency matrix looks like this (âˆž means no direct edge):</p>
            <p>
            <table>
                <tr>
                    <td></td>
                    <td>A</td>
                    <td>B</td>
                    <td>C</td>
                    <td>D</td>
                    <td>E</td>
                </tr>
                <tr>
                    <td><strong>A</strong></td>
                    <td>0</td>
                    <td>4</td>
                    <td>2</td>
                    <td>âˆž</td>
                    <td>âˆž</td>
                </tr>
                <tr>
                    <td><strong>B</strong></td>
                    <td>4</td>
                    <td>0</td>
                    <td>1</td>
                    <td>5</td>
                    <td>âˆž</td>
                </tr>
                <tr>
                    <td><strong>C</strong></td>
                    <td>2</td>
                    <td>1</td>
                    <td>0</td>
                    <td>8</td>
                    <td>10</td>
                </tr>
                <tr>
                    <td><strong>D</strong></td>
                    <td>âˆž</td>
                    <td>5</td>
                    <td>8</td>
                    <td>0</td>
                    <td>2</td>
                </tr>
                <tr>
                    <td><strong>E</strong></td>
                    <td>âˆž</td>
                    <td>âˆž</td>
                    <td>10</td>
                    <td>2</td>
                    <td>0</td>
                </tr>
            </table>
            </p>
            <p><strong>Starting from A</strong>, hereâ€™s how Dijkstraâ€™s algorithm proceeds:</p>
            <p>I. Initialize all distances with âˆž except A=0:</p>
            <p>
            <div>
                <pre><code class="language-shell">A: 0
B: âˆž
C: âˆž
D: âˆž
E: âˆž</code></pre>
            </div>
            </p>
            <p>II. From A (distance 0), update neighbors:</p>
            <p>
            <div>
                <pre><code class="language-shell">A: 0
B: 4  (via A)
C: 2  (via A)
D: âˆž
E: âˆž</code></pre>
            </div>
            </p>
            <p>III. Pick the smallest unvisited vertex (C with distance 2). Update its neighbors:</p>
            <ul>
                <li>B can be updated to 3 if 2 + 1 &lt; 4 </li>
                <li>D can be updated to 10 if 2 + 8 &lt; âˆž </li>
                <li>E can be updated to 12 if 2 + 10 &lt; âˆž</li>
            </ul>
            <p>
            <div>
                <pre><code class="language-shell">A: 0
B: 3  (via C)
C: 2
D: 10 (via C)
E: 12 (via C)</code></pre>
            </div>
            </p>
            <p>IV. Pick the next smallest unvisited vertex (B with distance 3). Update its neighbors:</p>
            <ul>
                <li>D becomes 8 if 3 + 5 &lt; 10 </li>
                <li>E remains 12 (no direct edge from B to E)</li>
            </ul>
            <p>
            <div>
                <pre><code class="language-shell">A: 0
B: 3
C: 2
D: 8  (via B)
E: 12</code></pre>
            </div>
            </p>
            <p>V. Pick the next smallest unvisited vertex (D with distance 8). Update its neighbors:</p>
            <ul>
                <li>E becomes 10 if 8 + 2 &lt; 12</li>
            </ul>
            <p>
            <div>
                <pre><code class="language-shell">A: 0
B: 3
C: 2
D: 8
E: 10 (via D)</code></pre>
            </div>
            </p>
            <p>VI. The only remaining vertex is E (distance 10). No further updates are possible.</p>
            <p><strong>Final shortest paths from A</strong>:</p>
            <p>
            <div>
                <pre><code class="language-shell">A: 0
B: 3
C: 2
D: 8
E: 10</code></pre>
            </div>
            </p>
            <h5>Optimizing Time Complexity</h5>
            <ul>
                <li>A basic (array-based) implementation of Dijkstra's algorithm runs in <strong>O(n^2)</strong> time.</li>
                <li>Using a priority queue (min-heap) to select the vertex with the smallest distance reduces the complexity to <strong>O((V+E) log V)</strong>, where <strong>V</strong> is the number of vertices and <strong>E</strong> is the number of edges.</li>
            </ul>
            <h5>Applications</h5>
            <ul>
                <li><strong>Internet routing</strong> protocols use it to determine efficient paths for data packets.</li>
                <li><strong>Mapping software</strong> (e.g., Google Maps, Waze) employ variations of Dijkstra to compute driving routes.</li>
                <li><strong>Telecommunication networks</strong> use it to determine paths with minimal cost.</li>
            </ul>
            <h5>Implementation</h5>
            <ul>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/tree/master/src/graphs/cpp/dijkstra">C++</a></li>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/tree/master/src/graphs/python/dijkstra">Python</a></li>
            </ul>
            <h4 id="bellman-ford-algorithm">Bellman-Ford Algorithm</h4>
            <ul>
                <li><strong>Bellman-Ford algorithm</strong> is a method for finding the shortest paths from a single starting vertex to all other vertices in a weighted graph.</li>
                <li>Unlike <strong>Dijkstraâ€™s algorithm</strong>, Bellman-Ford can handle <strong>negative edge weights</strong>, making it more flexible for certain types of graphs.</li>
                <li>The algorithm works by <strong>repeatedly relaxing all edges</strong> in the graph. Relaxing an edge means updating the current shortest distance to a vertex if a shorter path is found via another vertex.</li>
                <li>The algorithm performs this <strong>relaxation process</strong> exactly <strong>$V - 1$ times</strong>, where $V$ is the number of vertices. This ensures that every possible shortest path is discovered.</li>
                <li>After completing $V - 1$ relaxations, the algorithm does one more pass to detect <strong>negative weight cycles</strong>. If any edge can still be relaxed, a negative cycle exists and no finite shortest path is defined.</li>
                <li>Bellman-Fordâ€™s time complexity is <strong>$O(V \times E)$</strong>, which is generally slower than Dijkstraâ€™s algorithm for large graphs.</li>
            </ul>
            <h5>Algorithm Steps</h5>
            <p><strong>Input</strong></p>
            <ul>
                <li>A weighted graph with possible negative edge weights</li>
                <li>A starting vertex <code>A</code></li>
            </ul>
            <p><strong>Output</strong></p>
            <ul>
                <li>An array <code>distances</code> where <code>distances[v]</code> represents the shortest path from <code>A</code> to vertex <code>v</code></li>
            </ul>
            <p><strong>Containers and Data Structures</strong></p>
            <ul>
                <li>An array <code>distances</code>, set to <code>âˆž</code> for all vertices except the start vertex (set to <code>0</code>)</li>
                <li>A <code>predecessor</code> array to help reconstruct the actual shortest path</li>
            </ul>
            <p><strong>Steps</strong></p>
            <p>I. Initialize <code>distances[A]</code> to <code>0</code> and <code>distances[v]</code> to <code>âˆž</code> for all other vertices <code>v</code></p>
            <p>II. Repeat <code>V - 1</code> times</p>
            <ul>
                <li>For every edge <code>(u, v)</code> with weight <code>w</code>, if <code>distances[u] + w &lt; distances[v]</code>, update <code>distances[v]</code> to <code>distances[u] + w</code> and <code>predecessor[v]</code> to <code>u</code></li>
            </ul>
            <p>III. Check for negative cycles by iterating over all edges <code>(u, v)</code> again</p>
            <ul>
                <li>If <code>distances[u] + w &lt; distances[v]</code> for any edge, a negative weight cycle exists</li>
            </ul>
            <h5>Step by Step Example</h5>
            <p>We have vertices A, B, C, D, and E. The edges and weights (including a self-loop on E):</p>
            <p>
            <div>
                <pre><code class="language-shell">A-B: 6
A-C: 7
B-C: 8
B-D: -4
B-E: 5
C-E: -3
D-A: 2
D-C: 7
E-E: 9</code></pre>
            </div>
            </p>
            <p>Adjacency matrix (âˆž means no direct edge):</p>
            <p>
            <table>
                <tr>
                    <td></td>
                    <td>A</td>
                    <td>B</td>
                    <td>C</td>
                    <td>D</td>
                    <td>E</td>
                </tr>
                <tr>
                    <td><strong>A</strong></td>
                    <td>0</td>
                    <td>6</td>
                    <td>7</td>
                    <td>âˆž</td>
                    <td>âˆž</td>
                </tr>
                <tr>
                    <td><strong>B</strong></td>
                    <td>âˆž</td>
                    <td>0</td>
                    <td>8</td>
                    <td>-4</td>
                    <td>5</td>
                </tr>
                <tr>
                    <td><strong>C</strong></td>
                    <td>âˆž</td>
                    <td>âˆž</td>
                    <td>0</td>
                    <td>âˆž</td>
                    <td>-3</td>
                </tr>
                <tr>
                    <td><strong>D</strong></td>
                    <td>2</td>
                    <td>âˆž</td>
                    <td>7</td>
                    <td>0</td>
                    <td>âˆž</td>
                </tr>
                <tr>
                    <td><strong>E</strong></td>
                    <td>âˆž</td>
                    <td>âˆž</td>
                    <td>âˆž</td>
                    <td>âˆž</td>
                    <td>9</td>
                </tr>
            </table>
            </p>
            <p><strong>Initialization</strong>:</p>
            <p>
            <div>
                <pre><code class="language-shell">dist[A] = 0
dist[B] = âˆž
dist[C] = âˆž
dist[D] = âˆž
dist[E] = âˆž</code></pre>
            </div>
            </p>
            <p><strong>Iteration 1</strong> (relax edges from A):</p>
            <p>
            <div>
                <pre><code class="language-shell">dist[B] = 6
dist[C] = 7</code></pre>
            </div>
            </p>
            <p><strong>Iteration 2</strong> (relax edges from B, then C):</p>
            <p>
            <div>
                <pre><code class="language-shell">dist[D] = 2        (6 + (-4))
dist[E] = 11       (6 + 5)
dist[E] = 4        (7 + (-3))  // C â†’ E is better</code></pre>
            </div>
            </p>
            <p><strong>Iteration 3</strong> (relax edges from D):</p>
            <p>
            <div>
                <pre><code class="language-shell">dist[A] = 4        (2 + 2)
(No update for C since dist[C]=7 is already &lt; 9)</code></pre>
            </div>
            </p>
            <p><strong>Iteration 4</strong>:</p>
            <p>
            <div>
                <pre><code class="language-shell">No changes in this round</code></pre>
            </div>
            </p>
            <p><strong>Final distances from A</strong>:</p>
            <p>
            <div>
                <pre><code class="language-shell">dist[A] = 0
dist[B] = 6
dist[C] = 7
dist[D] = 2
dist[E] = 4</code></pre>
            </div>
            </p>
            <h5>Special Characteristics</h5>
            <ul>
                <li>It can manage <strong>negative edge weights</strong> but cannot produce valid results when <strong>negative cycles</strong> are present.</li>
                <li>It is often used when edges can be negative, though it is slower than Dijkstraâ€™s algorithm.</li>
            </ul>
            <h5>Applications</h5>
            <ul>
                <li><strong>Financial arbitrage</strong> detection in currency exchange markets.</li>
                <li><strong>Routing</strong> in networks where edges might have negative costs.</li>
                <li><strong>Game development</strong> scenarios with penalties or negative terrain effects.</li>
            </ul>
            <h5>Implementation</h5>
            <ul>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/tree/master/src/graphs/cpp/bellman_ford">C++</a></li>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/tree/master/src/graphs/python/bellman_ford">Python</a></li>
            </ul>
            <h4 id="a-a-star-algorithm">A* (A-Star) Algorithm</h4>
            <ul>
                <li><strong>A*</strong> is an informed search algorithm used for <strong>pathfinding</strong> and <strong>graph traversal</strong>.</li>
                <li>It is a <strong>best-first search</strong> because it prioritizes the most promising paths first, combining known and estimated costs.</li>
                <li>The algorithm relies on:</li>
                <li><strong>g(n)</strong>: The actual cost from the start node to the current node <strong>n</strong>.</li>
                <li><strong>h(n)</strong>: A <strong>heuristic</strong> estimating the cost from <strong>n</strong> to the goal.</li>
                <li>The total cost function is <strong>f(n) = g(n) + h(n)</strong>, guiding the search toward a potentially optimal path.</li>
                <li>At each step, A<em> expands the node with the </em><em>lowest f(n)</em>* in the priority queue.</li>
                <li>The heuristic <strong>h(n)</strong> must be <strong>admissible</strong> (never overestimates the real cost) to guarantee an optimal result.</li>
                <li>A<em> terminates when it either reaches the </em><em>goal</em>* or exhausts all possibilities if no solution exists.</li>
                <li>It is efficient for many applications because it balances <strong>exploration</strong> with being <strong>goal-directed</strong>, but its performance depends on the heuristic quality.</li>
                <li>A<em> is broadly used in </em><em>games</em><em>, </em><em>robotics</em><em>, and </em><em>navigation</em>* due to its effectiveness in real-world pathfinding.</li>
            </ul>
            <h5>Algorithm Steps</h5>
            <p><strong>Input</strong></p>
            <ul>
                <li>A graph</li>
                <li>A start vertex <code>A</code></li>
                <li>A goal vertex <code>B</code></li>
                <li>A heuristic function <code>h(v)</code> that estimates the cost from <code>v</code> to <code>B</code></li>
            </ul>
            <p><strong>Output</strong></p>
            <ul>
                <li>The shortest path from <code>A</code> to <code>B</code> if one exists</li>
            </ul>
            <p><strong>Used Data Structures</strong></p>
            <p>I. <strong>g(n)</strong>: The best-known cost from the start vertex to vertex <code>n</code></p>
            <p>II. <strong>h(n)</strong>: The heuristic estimate from vertex <code>n</code> to the goal</p>
            <p>III. <strong>f(n) = g(n) + h(n)</strong>: The estimated total cost from start to goal via <code>n</code></p>
            <p>IV. <strong>openSet</strong>: Starting with the initial node, contains nodes to be evaluated</p>
            <p>V. <strong>closedSet</strong>: Contains nodes already fully evaluated</p>
            <p>VI. <strong>cameFrom</strong>: Structure to record the path taken</p>
            <p><strong>Steps</strong></p>
            <p>I. Add the starting node to the <strong>openSet</strong></p>
            <p>II. While the <strong>openSet</strong> is not empty</p>
            <ul>
                <li>Get the node <code>current</code> in <strong>openSet</strong> with the lowest <strong>f(n)</strong></li>
                <li>If <code>current</code> is the goal node, reconstruct the path and return it</li>
                <li>Remove <code>current</code> from <strong>openSet</strong> and add it to <strong>closedSet</strong></li>
                <li>For each neighbor <code>n</code> of <code>current</code>, skip it if it is in <strong>closedSet</strong></li>
                <li>If <code>n</code> is not in <strong>openSet</strong>, add it and compute <strong>g(n)</strong>, <strong>h(n)</strong>, and <strong>f(n)</strong></li>
                <li>If a better path to <code>n</code> is found, update <strong>cameFrom</strong> for <code>n</code></li>
            </ul>
            <p>III. If the algorithm terminates without finding the goal, no path exists</p>
            <h5>Step by Step Example</h5>
            <p>We have a graph with vertices A, B, C, D, and E:</p>
            <p>
            <div>
                <pre><code class="language-shell">A-B: 1
A-C: 2
B-D: 3
C-D: 2
D-E: 1</code></pre>
            </div>
            </p>
            <p>Heuristic estimates to reach E:</p>
            <p>
            <div>
                <pre><code class="language-shell">h(A) = 3
h(B) = 2
h(C) = 2
h(D) = 1
h(E) = 0</code></pre>
            </div>
            </p>
            <p>Adjacency matrix (âˆž = no direct path):</p>
            <p>
            <table>
                <tr>
                    <td></td>
                    <td>A</td>
                    <td>B</td>
                    <td>C</td>
                    <td>D</td>
                    <td>E</td>
                </tr>
                <tr>
                    <td><strong>A</strong></td>
                    <td>0</td>
                    <td>1</td>
                    <td>2</td>
                    <td>âˆž</td>
                    <td>âˆž</td>
                </tr>
                <tr>
                    <td><strong>B</strong></td>
                    <td>âˆž</td>
                    <td>0</td>
                    <td>âˆž</td>
                    <td>3</td>
                    <td>âˆž</td>
                </tr>
                <tr>
                    <td><strong>C</strong></td>
                    <td>âˆž</td>
                    <td>âˆž</td>
                    <td>0</td>
                    <td>2</td>
                    <td>âˆž</td>
                </tr>
                <tr>
                    <td><strong>D</strong></td>
                    <td>âˆž</td>
                    <td>âˆž</td>
                    <td>âˆž</td>
                    <td>0</td>
                    <td>1</td>
                </tr>
                <tr>
                    <td><strong>E</strong></td>
                    <td>âˆž</td>
                    <td>âˆž</td>
                    <td>âˆž</td>
                    <td>âˆž</td>
                    <td>0</td>
                </tr>
            </table>
            </p>
            <p><strong>Initialization</strong>:</p>
            <p>
            <div>
                <pre><code class="language-shell">g(A) = 0
f(A) = g(A) + h(A) = 0 + 3 = 3
openSet = [A]
closedSet = []</code></pre>
            </div>
            </p>
            <p>Expand <strong>A</strong>:</p>
            <p>
            <div>
                <pre><code class="language-shell">f(B) = 0 + 1 + 2 = 3
f(C) = 0 + 2 + 2 = 4</code></pre>
            </div>
            </p>
            <p>Expand <strong>B</strong> next (lowest f=3):</p>
            <p>
            <div>
                <pre><code class="language-shell">f(D) = g(B) + cost(B,D) + h(D) = 1 + 3 + 1 = 5</code></pre>
            </div>
            </p>
            <p>Next lowest is <strong>C</strong> (f=4):</p>
            <p>
            <div>
                <pre><code class="language-shell">f(D) = g(C) + cost(C,D) + h(D) = 2 + 2 + 1 = 5 (no improvement)</code></pre>
            </div>
            </p>
            <p>Expand <strong>D</strong> (f=5):</p>
            <p>
            <div>
                <pre><code class="language-shell">f(E) = g(D) + cost(D,E) + h(E) = 5 + 1 + 0 = 6
E is the goal; algorithm stops.</code></pre>
            </div>
            </p>
            <p>Resulting path: <strong>A -&gt; B -&gt; D -&gt; E</strong> with total cost <strong>5</strong>.</p>
            <h5>Special Characteristics</h5>
            <ul>
                <li><strong>A*</strong> finds an optimal path if the heuristic is <strong>admissible</strong>.</li>
                <li>Edges must have <strong>non-negative weights</strong> for A* to work correctly.</li>
                <li>A good heuristic drastically improves its efficiency.</li>
            </ul>
            <h5>Applications</h5>
            <ul>
                <li>Used in <strong>video games</strong> for enemy AI or player navigation.</li>
                <li>Employed in <strong>robotics</strong> for motion planning.</li>
                <li>Integral to <strong>mapping</strong> and <strong>GPS</strong> systems for shortest route calculations.</li>
            </ul>
            <h5>Implementation</h5>
            <ul>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/tree/master/src/graphs/cpp/a_star">C++</a></li>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/tree/master/src/graphs/python/a_star">Python</a></li>
            </ul>
            <h3 id="minimal-spanning-trees">Minimal Spanning Trees</h3>
            <p>Suppose we have a graph that represents a network of houses. Weights represent the distances between vertices, which each represent a single house. All houses must have water, electricity, and internet, but we want the cost of installation to be as low as possible. We need to identify a subgraph of our graph with the following properties:</p>
            <ul>
                <li>There are no cycles in the graph.</li>
                <li>All vertices are connected.</li>
                <li>The total sum of weights is minimum.</li>
            </ul>
            <p>Such a subgraph is called a minimal spanning tree.</p>
            <h4 id="prim-s-algorithm">Prim's Algorithm</h4>
            <ul>
                <li><strong>Prim's Algorithm</strong> is used to find a <strong>minimum spanning tree (MST)</strong>, which is a subset of a graph that connects all its vertices with the smallest total edge weight. </li>
                <li>It works on a <strong>weighted undirected graph</strong>, meaning the edges have weights, and the direction of edges doesnâ€™t matter. </li>
                <li>It starts with an <strong>arbitrary vertex</strong> and grows the MST by adding one edge at a time. </li>
                <li>At each step, it chooses the <strong>smallest weight edge</strong> that connects a vertex in the MST to a vertex not yet in the MST (a <strong>greedy</strong> approach). </li>
                <li>This process continues until <strong>all vertices</strong> are included. </li>
                <li>The resulting MST is <strong>connected</strong>, ensuring a path between any two vertices, and the total edge weight is minimized. </li>
                <li>Using a <strong>priority queue</strong> (min-heap), it can achieve a time complexity of <strong>O(E log V)</strong> with adjacency lists, where E is the number of edges and V is the number of vertices. </li>
                <li>With an adjacency matrix, the algorithm can be implemented in <strong>O(V^2)</strong> time.</li>
            </ul>
            <h5>Algorithm Steps</h5>
            <p><strong>Input</strong></p>
            <ul>
                <li>A connected, undirected graph with weighted edges</li>
                <li>A start vertex <code>A</code></li>
            </ul>
            <p><strong>Output</strong></p>
            <ul>
                <li>A minimum spanning tree, which is a subset of the edges that connects all vertices together without any cycles and with the minimum total edge weight</li>
            </ul>
            <p><strong>Containers and Data Structures</strong></p>
            <ul>
                <li>An array <code>key[]</code> to store the minimum reachable edge weight for each vertex. Initially, <code>key[v] = âˆž</code> for all <code>v</code> except the first chosen vertex (set to <code>0</code>)</li>
                <li>A boolean array <code>mstSet[]</code> to keep track of whether a vertex is included in the MST. Initially, all values are <code>false</code></li>
                <li>An array <code>parent[]</code> to store the MST. Each <code>parent[v]</code> indicates the vertex connected to <code>v</code> in the MST</li>
            </ul>
            <p><strong>Steps</strong></p>
            <p>I. Start with an arbitrary node as the initial MST node</p>
            <p>II. While there are vertices not yet included in the MST</p>
            <ul>
                <li>Pick a vertex <code>v</code> with the smallest <code>key[v]</code></li>
                <li>Include <code>v</code> in <code>mstSet[]</code></li>
                <li>For each neighboring vertex <code>u</code> of <code>v</code> not in the MST</li>
                <li>If the weight of edge <code>(u, v)</code> is less than <code>key[u]</code>, update <code>key[u]</code> and set <code>parent[u]</code> to <code>v</code></li>
            </ul>
            <p>III. The MST is formed using the <code>parent[]</code> array once all vertices are included</p>
            <h5>Step by Step Example</h5>
            <p>Consider a simple graph with vertices <strong>A</strong>, <strong>B</strong>, <strong>C</strong>, <strong>D</strong>, and <strong>E</strong>. The edges with weights are:</p>
            <p>
            <div>
                <pre><code class="language-shell">A-B: 2
A-C: 3
B-D: 1
B-E: 3
C-D: 4
C-E: 5
D-E: 2</code></pre>
            </div>
            </p>
            <p>The adjacency matrix for the graph (using âˆž where no direct edge exists) is:</p>
            <p>
            <table>
                <tr>
                    <td></td>
                    <td>A</td>
                    <td>B</td>
                    <td>C</td>
                    <td>D</td>
                    <td>E</td>
                </tr>
                <tr>
                    <td><strong>A</strong></td>
                    <td>0</td>
                    <td>2</td>
                    <td>3</td>
                    <td>âˆž</td>
                    <td>âˆž</td>
                </tr>
                <tr>
                    <td><strong>B</strong></td>
                    <td>2</td>
                    <td>0</td>
                    <td>âˆž</td>
                    <td>1</td>
                    <td>3</td>
                </tr>
                <tr>
                    <td><strong>C</strong></td>
                    <td>3</td>
                    <td>âˆž</td>
                    <td>0</td>
                    <td>4</td>
                    <td>5</td>
                </tr>
                <tr>
                    <td><strong>D</strong></td>
                    <td>âˆž</td>
                    <td>1</td>
                    <td>4</td>
                    <td>0</td>
                    <td>2</td>
                </tr>
                <tr>
                    <td><strong>E</strong></td>
                    <td>âˆž</td>
                    <td>3</td>
                    <td>5</td>
                    <td>2</td>
                    <td>0</td>
                </tr>
            </table>
            </p>
            <p>Run Prim's algorithm starting from vertex <strong>A</strong>:</p>
            <p>I. <strong>Initialization</strong> </p>
            <p>
            <div>
                <pre><code class="language-shell">Chosen vertex: A  
Not in MST: B, C, D, E</code></pre>
            </div>
            </p>
            <p>II. <strong>Pick the smallest edge from A</strong> </p>
            <p>
            <div>
                <pre><code class="language-shell">Closest vertex is B with a weight of 2.  
MST now has: A, B  
Not in MST: C, D, E</code></pre>
            </div>
            </p>
            <p>III. <strong>From A and B, pick the smallest edge</strong> </p>
            <p>
            <div>
                <pre><code class="language-shell">Closest vertex is D (from B) with a weight of 1.  
MST now has: A, B, D  
Not in MST: C, E</code></pre>
            </div>
            </p>
            <p>IV. <strong>Next smallest edge from A, B, or D</strong> </p>
            <p>
            <div>
                <pre><code class="language-shell">Closest vertex is E (from D) with a weight of 2.  
MST now has: A, B, D, E  
Not in MST: C</code></pre>
            </div>
            </p>
            <p>V. <strong>Pick the final vertex</strong> </p>
            <p>
            <div>
                <pre><code class="language-shell">The closest remaining vertex is C (from A) with a weight of 3.  
MST now has: A, B, D, E, C</code></pre>
            </div>
            </p>
            <p>The MST includes the edges: <strong>A-B (2), B-D (1), D-E (2),</strong> and <strong>A-C (3)</strong>, with a total weight of <strong>8</strong>.</p>
            <h5>Special Characteristics</h5>
            <ul>
                <li>It always selects the smallest edge that can connect a new vertex to the existing MST. </li>
                <li>Different choices of starting vertex can still result in the same total MST weight (though the exact edges might differ if multiple edges have the same weight). </li>
                <li>With adjacency lists and a priority queue, the time complexity is <strong>O(E log V)</strong>; with an adjacency matrix, it is <strong>O(V^2)</strong>.</li>
            </ul>
            <h5>Applications</h5>
            <ul>
                <li><strong>Network design</strong>: Building telecommunication networks with minimal cable length. </li>
                <li><strong>Road infrastructure</strong>: Constructing roads, tunnels, or bridges at minimal total cost. </li>
                <li><strong>Utility services</strong>: Designing water, electrical, or internet infrastructure to connect all locations at minimum cost.</li>
            </ul>
            <h5>Implementation</h5>
            <ul>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/tree/master/src/graphs/cpp/prim">C++</a></li>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/tree/master/src/graphs/python/prim">Python</a></li>
            </ul>
            <h4 id="kruskal-s-algorithm">Kruskal's Algorithm</h4>
            <ul>
                <li><strong>Kruskal's Algorithm</strong> is used to find a <strong>minimum spanning tree (MST)</strong> in a connected, undirected graph with weighted edges. </li>
                <li>It <strong>sorts all edges</strong> from smallest to largest by weight. </li>
                <li>It <strong>adds edges</strong> one by one to the MST if they do not form a cycle. </li>
                <li><strong>Cycle detection</strong> is managed by a <strong>disjoint-set</strong> (union-find) data structure, which helps quickly determine if two vertices belong to the same connected component. </li>
                <li>If adding an edge connects two different components, it is safe to include; if both vertices are already in the same component, including that edge would create a cycle and is skipped. </li>
                <li>The process continues until the MST has <strong>V-1</strong> edges, where <strong>V</strong> is the number of vertices. </li>
                <li>Its time complexity is <strong>O(E \log E)</strong>, dominated by sorting the edges, while union-find operations typically take near-constant time (<strong>O(Î±(V))</strong>, where Î± is the inverse Ackermann function).</li>
            </ul>
            <h5>Algorithm Steps</h5>
            <p><strong>Input</strong></p>
            <ul>
                <li>A connected, undirected graph with weighted edges</li>
            </ul>
            <p><strong>Output</strong></p>
            <ul>
                <li>A subset of edges forming a MST, ensuring all vertices are connected with no cycles and minimal total weight</li>
            </ul>
            <p><strong>Containers and Data Structures</strong></p>
            <ul>
                <li>A list or priority queue to sort the edges by weight</li>
                <li>A <code>disjoint-set (union-find)</code> structure to manage and merge connected components</li>
            </ul>
            <p><strong>Steps</strong></p>
            <p>I. Sort all edges in increasing order of their weights</p>
            <p>II. Initialize a forest where each vertex is its own tree</p>
            <p>III. Iterate through the sorted edges</p>
            <ul>
                <li>If the edge <code>(u, v)</code> connects two different components, include it in the MST and perform a <code>union</code> of the sets</li>
                <li>If it connects vertices in the same component, skip it</li>
            </ul>
            <p>IV. Once <code>V-1</code> edges have been added, the MST is complete</p>
            <h5>Step by Step Example</h5>
            <p>Consider a graph with vertices <strong>A</strong>, <strong>B</strong>, <strong>C</strong>, <strong>D</strong>, and <strong>E</strong>. The weighted edges are:</p>
            <p>
            <div>
                <pre><code class="language-shell">A-B: 2
A-C: 3
B-D: 1
B-E: 3
C-D: 4
C-E: 5
D-E: 2</code></pre>
            </div>
            </p>
            <p>The adjacency matrix (âˆž indicates no direct edge):</p>
            <p>
            <table>
                <tr>
                    <td></td>
                    <td>A</td>
                    <td>B</td>
                    <td>C</td>
                    <td>D</td>
                    <td>E</td>
                </tr>
                <tr>
                    <td><strong>A</strong></td>
                    <td>0</td>
                    <td>2</td>
                    <td>3</td>
                    <td>âˆž</td>
                    <td>âˆž</td>
                </tr>
                <tr>
                    <td><strong>B</strong></td>
                    <td>2</td>
                    <td>0</td>
                    <td>âˆž</td>
                    <td>1</td>
                    <td>3</td>
                </tr>
                <tr>
                    <td><strong>C</strong></td>
                    <td>3</td>
                    <td>âˆž</td>
                    <td>0</td>
                    <td>4</td>
                    <td>5</td>
                </tr>
                <tr>
                    <td><strong>D</strong></td>
                    <td>âˆž</td>
                    <td>1</td>
                    <td>4</td>
                    <td>0</td>
                    <td>2</td>
                </tr>
                <tr>
                    <td><strong>E</strong></td>
                    <td>âˆž</td>
                    <td>3</td>
                    <td>5</td>
                    <td>2</td>
                    <td>0</td>
                </tr>
            </table>
            </p>
            <p><strong>Sort edges</strong> by weight:</p>
            <p>
            <div>
                <pre><code class="language-shell">B-D: 1
A-B: 2
D-E: 2
A-C: 3
B-E: 3
C-D: 4
C-E: 5</code></pre>
            </div>
            </p>
            <ol>
                <li><strong>Pick B-D (1)</strong>: Include it. MST has {B-D}, weight = 1. </li>
                <li><strong>Pick A-B (2)</strong>: Include it. MST has {B-D, A-B}, weight = 3. </li>
                <li><strong>Pick D-E (2)</strong>: Include it. MST has {B-D, A-B, D-E}, weight = 5. </li>
                <li><strong>Pick A-C (3)</strong>: Include it. MST has {B-D, A-B, D-E, A-C}, weight = 8. </li>
                <li><strong>Pick B-E (3)</strong>: Would form a cycle (B, D, E already connected), skip. </li>
                <li><strong>Pick C-D (4)</strong>: Would form a cycle (C, D already connected), skip. </li>
                <li><strong>Pick C-E (5)</strong>: Would form a cycle as well, skip. </li>
            </ol>
            <p>The MST edges are <strong>B-D, A-B, D-E, and A-C</strong>, total weight = <strong>8</strong>.</p>
            <h5>Special Characteristics</h5>
            <ul>
                <li>It always picks the <strong>smallest available edge</strong> that won't create a cycle. </li>
                <li>In case of a <strong>tie</strong>, any equally weighted edge can be chosen. </li>
                <li>The approach is particularly efficient for <strong>sparse graphs</strong>. </li>
                <li>Sorting edges takes <strong>O(E \log E)</strong> time, and disjoint-set operations can be considered almost <strong>O(1)</strong> on average.</li>
            </ul>
            <h5>Applications</h5>
            <ul>
                <li><strong>Network design</strong>: Connecting servers or cities using minimal cable length. </li>
                <li><strong>Infrastructure</strong>: Building road systems, water lines, or power grids with the smallest total cost. </li>
                <li><strong>Any MST requirement</strong>: Ensuring connectivity among all nodes at minimum cost.</li>
            </ul>
            <h5>Implementation</h5>
            <ul>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/tree/master/src/graphs/cpp/kruskal">C++</a></li>
                <li><a href="https://github.com/djeada/Algorithms-And-Data-Structures/tree/master/src/graphs/python/kruskal">Python</a></li>
            </ul>
        </section>
        <div id="table-of-contents">
            <h2>Table of Contents</h2>
            <ol><a href="#graphs">Graphs</a>
                <ol>
                    <li><a href="#graph-terminology">Graph Terminology</a></li>
                    <li><a href="#representation-of-graphs-in-computer-memory">Representation of Graphs in Computer Memory</a>
                        <ol>
                            <li><a href="#adjacency-matrix">Adjacency Matrix</a></li>
                            <li><a href="#adjacency-list">Adjacency List</a></li>
                        </ol>
                    </li>
                    <li><a href="#planarity">Planarity</a>
                        <ol>
                            <li><a href="#what-is-a-planar-graph-">What is a Planar Graph?</a></li>
                            <li><a href="#planar-embedding">Planar Embedding</a></li>
                            <li><a href="#examples">Examples</a></li>
                            <li><a href="#strategies-for-assessing-planarity">Strategies for Assessing Planarity</a></li>
                        </ol>
                    </li>
                    <li><a href="#traversals">Traversals</a>
                        <ol>
                            <li><a href="#breadth-first-search-bfs-">Breadth-First Search (BFS)</a></li>
                            <li><a href="#depth-first-search-dfs-">Depth-First Search (DFS)</a></li>
                        </ol>
                    </li>
                    <li><a href="#shortest-paths">Shortest paths</a>
                        <ol>
                            <li><a href="#dijkstra-s-algorithm">Dijkstra's Algorithm</a></li>
                            <li><a href="#bellman-ford-algorithm">Bellman-Ford Algorithm</a></li>
                            <li><a href="#a-a-star-algorithm">A* (A-Star) Algorithm</a></li>
                        </ol>
                    </li>
                    <li><a href="#minimal-spanning-trees">Minimal Spanning Trees</a>
                        <ol>
                            <li><a href="#prim-s-algorithm">Prim's Algorithm</a></li>
                            <li><a href="#kruskal-s-algorithm">Kruskal's Algorithm</a></li>
                        </ol>
                    </li>
                </ol>
            </ol>
            <div id="related-articles">
                <h2>Related Articles</h2>
                <ol>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/backtracking.html">Backtracking</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/basic_concepts.html">Basic Concepts</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/brain_teasers.html">Brain Teasers</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/data_structures.html">Data Structures</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/dynamic_programming.html">Dynamic Programming</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/graphs.html">Graphs</a></li>
                    <li><a href="https://adamdjellouli.com/articles/algorithms_and_data_structures/sorting.html">Sorting</a></li>
                </ol>
            </div>
        </div>
    </div>
    <footer>
        <div class="footer-columns">
            <div class="footer-column">
                <img alt="Adam Djellouli Symbol" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/symbol.png" />
            </div>
            <div class="footer-column">
                <h2><a href="https://adamdjellouli.com/core/privacy_policy.html" title="Privacy Policy">Our Privacy Policy</a></h2>
                <p>
                    Thank you for visiting my personal website. All of the <br />
                    content on this site is free to use, but please remember <br />
                    to be a good human being and refrain from any abuse<br />
                    of the site. If you would like to contact me, please use <br />
                    my <a href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" title="LinkedIn Profile">LinkedIn profile</a> or my <a href="https://github.com/djeada" title="GitHub Profile">GitHub</a> if you have any technical <br />
                    issues or ideas to share. I wish you the best and hope you <br />
                    have a fantastic life. <br />
                </p>
            </div>
            <div class="footer-column">
                <h2>Follow me</h2>
                <ul class="social-media">
                    <li>
                        <a class="fa fa-youtube" href="https://www.youtube.com/channel/UCGPoHTVjMN77wcGknXPHl1Q" target="_blank" title="YouTube">
                        </a>YouTube
                    </li>
                    <li>
                        <a class="fa fa-linkedin" href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" target="_blank" title="LinkedIn">
                        </a>LinkedIn
                    </li>
                    <li>
                        <a class="fa fa-instagram" href="https://www.instagram.com/linuxchallenges/" target="_blank" title="Instagram">
                        </a>Instagram
                    </li>
                    <li>
                        <a class="fa fa-github" href="https://github.com/djeada" title="GitHub">
                        </a>Github
                    </li>
                </ul>
            </div>
        </div>
        <div>
            <p id="copyright">
                Â© Adam Djellouli. All rights reserved.
            </p>
        </div>
        <script>
            document.getElementById("copyright").innerHTML = "&copy; " + new Date().getFullYear() + " Adam Djellouli. All rights reserved.";
        </script>
        <script src="../../app.js"></script>
    </footer>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-bash.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-cpp.min.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
jax: ["input/TeX", "output/HTML-CSS"],
extensions: ["tex2jax.js"],
"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] },
tex2jax: { inlineMath: [ ["$", "$"] ], displayMath: [ ["$$","$$"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
TeX: { noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } } },
messageStyle: "none"
});
</script>
<script async="" id="MathJax-script" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>

</html>