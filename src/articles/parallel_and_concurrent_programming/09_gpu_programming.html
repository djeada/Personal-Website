<!DOCTYPE html>

<html lang="en">

<head>
    <script async="" crossorigin="anonymous" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5593122079896089"></script>
    <meta charset="utf-8" />
    <title>GPU Programming</title>
    <meta content="GPUs (Graphics Processing Units) excel at performing the same operation on many data elements in parallel." name="description" />
    <meta content="Adam Djellouli" name="author" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <meta content="IE=edge" http-equiv="X-UA-Compatible" />
    <link crossorigin="" href="https://fonts.googleapis.com" rel="preconnect" />
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/icon.ico" rel="icon" />
    <link href="../../resources/style.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
</head>

<body>
    <nav aria-label="Main navigation">
        <a class="logo" href="https://adamdjellouli.com">
            <img alt="Adam Djellouli - Home Page Logo" id="logo-image" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/logo.PNG" />
        </a>
        <input aria-label="Toggle navigation menu" id="navbar-toggle" type="checkbox" />
        <ul aria-labelledby="navbar-toggle" role="menu">
            <li role="menuitem">
                <a href="../../index.html" title="Go to Home Page"> Home </a>
            </li>
            <li role="menuitem">
                <a class="active" href="../../core/blog.html" title="Read Adam Djellouli Blog on Programming and Technology"> Blog </a>
            </li>
            <li role="menuitem">
                <a href="../../core/tools.html" title="Discover Tools Created by Adam Djellouli"> Tools </a>
            </li>
            <li role="menuitem">
                <a href="../../core/projects.html" title="Explore Projects Developed by Adam Djellouli"> Projects </a>
            </li>
            <li role="menuitem">
                <a href="../../core/resume.html" title="View Adam Djellouli Professional Resume"> Resume </a>
            </li>
            <li>
                <script async="" src="https://cse.google.com/cse.js?cx=8160ef9bb935f4f68"></script>
                <div class="gcse-search"></div>
            </li>
            <li>
                <button aria-label="Toggle dark mode" id="dark-mode-button"></button>
            </li>
        </ul>
    </nav>
    <div id="article-wrapper"><article-section id="article-body">
            <div class="article-action-buttons"><button class="btn-suggest-edit" title="Suggest Edit">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <path d="M4 21h4l11-11-4-4L4 17v4z" stroke="currentColor" stroke-width="2"></path>
                    </svg>
                </button><button class="btn-create-issue" title="Create Issue">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2"></circle>
                        <line stroke="currentColor" stroke-width="2" x1="12" x2="12" y1="8" y2="12"></line>
                        <circle cx="12" cy="16" fill="currentColor" r="1"></circle>
                    </svg>
                </button><button class="btn-download" title="Download">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <path d="M12 5v14m0 0l-6-6m6 6l6-6" stroke="currentColor" stroke-width="2"></path>
                    </svg>
                </button></div>
            <p style="text-align: right;"><i>Last modified: September 22, 2025</i></p>
            <p style="text-align: right;"><i>This article is written in: üá∫üá∏</i></p>
            <h2 id="gpu-programming">GPU Programming</h2>
            <p>GPUs (Graphics Processing Units) excel at performing the same operation on many data elements in parallel. Originally, GPUs were used just for rendering images, but their highly parallel nature also makes them ideal for general-purpose tasks with large data sets, such as scientific simulations, machine learning, and other compute-intensive workloads.</p>
            <p><strong>What‚Äôs special about GPU programming?</strong><br />
                - GPUs have many cores organized to handle massive parallelism.<br />
                - They often use specialized memory hierarchies (shared memory, constant memory, etc.) to achieve high bandwidth.<br />
                - The programming model (e.g., CUDA, OpenCL) provides ways to map computations onto thousands of threads, which then run in parallel.<br />
                - Achieving good performance can require careful attention to memory accesses, thread organization, and instruction throughput.</p>
            <h3 id="time-space-duality">Time-Space Duality</h3>
            <p>GPU architectures (and more broadly, parallel processors) often exploit a concept called <strong>time-space duality</strong>, which compares two main ways of doing parallel operations: array processors and vector processors. Understanding these helps illustrate general principles behind GPU designs.</p>
            <p>
            <div>
                <pre><code class="language-shell">====================================================
ARRAY PROCESSOR (Spatial Parallelism)
====================================================
         |   T0   |   T1   |   T2   |   T3   |
----------------------------------------------------
 PE0     |  LD0   |  ADD0  |  MUL0  |  ST0   |
 PE1     |  LD1   |  ADD1  |  MUL1  |  ST1   |
 PE2     |  LD2   |  ADD2  |  MUL2  |  ST2   |
 PE3     |  LD3   |  ADD3  |  MUL3  |  ST3   |
----------------------------------------------------
(Same operation across all PEs in each time slot)

====================================================
VECTOR PROCESSOR (Temporal Parallelism)
====================================================
Time --&gt;    T0     T1     T2     T3     T4     T5     T6     T7
----------------------------------------------------------------
 Elem0:     LD0    ADD0   MUL0   ST0
 Elem1:            LD1    ADD1   MUL1   ST1
 Elem2:                   LD2    ADD2   MUL2   ST2
 Elem3:                          LD3    ADD3   MUL3   ST3
----------------------------------------------------------------
(Each data element "flows" through the pipeline over time)</code></pre>
            </div>
            </p>
            <p><strong>How it fits into GPU programming?</strong></p>
            <ol>
                <li><strong>Array Processors (Spatial Parallelism)</strong> </li>
                <li>Multiple processing elements (PEs) operate in parallel on different data elements. </li>
                <li>In each clock cycle, all PEs perform the same instruction (like LD or ADD) but on separate parts of the data. </li>
                <li>This gives high throughput since all data elements are processed simultaneously. </li>
                <li>
                    <p>Hardware cost is higher (because each PE needs its own functional unit), but you complete one operation across all data elements in one cycle.</p>
                </li>
                <li>
                    <p><strong>Vector Processors (Temporal Parallelism)</strong> </p>
                </li>
                <li>A single (or a few) functional unit(s) are reused over time to process many data elements in a pipeline. </li>
                <li>Each data element flows through the pipeline stages (LD, ADD, MUL, ST) one after another. </li>
                <li>Hardware cost is lower because the functional units are shared in time. </li>
                <li>It takes multiple cycles to get all elements processed since they move through the pipeline in sequence.</li>
            </ol>
            <p>In modern GPUs, there are elements of both approaches. You can think of each GPU ‚Äúcore‚Äù as being replicated (spatial parallelism), but within each core, pipelined operations occur (temporal parallelism). This combination helps GPUs handle large-scale parallelism efficiently.</p>
            <h3 id="vector-processor">Vector Processor</h3>
            <p>A <strong>vector processor</strong> is an architecture that operates on entire vectors (1D arrays) with a single instruction. This approach is relevant to GPU programming because GPUs often provide ‚ÄúSIMD‚Äù (Single Instruction, Multiple Data) capabilities similar to vector processors.</p>
            <ul>
                <li>A vector is a list of elements, like ([x_0, x_1, x_2, \dots]). </li>
                <li>Instead of running a loop that processes each element one by one, a vector processor uses a single vector instruction (e.g., <code>VADD</code>) to add pairs of elements across two vectors in one pipeline. </li>
                <li>Multiple elements can be stored in <strong>vector registers</strong>, which are larger than normal scalar registers. </li>
                <li>A <strong>vector length register</strong> specifies how many elements to process if the vector does not always span the full hardware capacity. </li>
                <li>A <strong>vector stride register</strong> tells the hardware how far apart consecutive elements are in memory. This is crucial for non-contiguous data accesses. </li>
                <li>Vector instructions reduce loop overhead and can increase data throughput by letting the pipeline work on different elements in consecutive cycles.</li>
            </ul>
            <p><strong>Benefits</strong></p>
            <ul>
                <li>Each pipeline stage can process a different element in parallel. </li>
                <li>No intra-vector data dependencies mean simpler hardware scheduling (no waiting for one element to finish before starting the next). </li>
                <li>Regular memory access patterns (especially stride-1) are easy to fetch into registers or caches. </li>
            </ul>
            <h3 id="strides">Strides</h3>
            <p>When data is laid out in memory, sometimes elements that belong together (e.g., all elements of a column in a matrix) are not next to each other. Stride tells the hardware how far to jump in memory to reach the next element of a vector.</p>
            <h4 id="row-major-layout-example">Row-major layout example</h4>
            <p>Consider a (4 \times 4) matrix (A) in row-major order:</p>
            <p>
            <div>
                <pre><code class="language-shell">A(0,0) A(0,1) A(0,2) A(0,3)
A(1,0) A(1,1) A(1,2) A(1,3)
A(2,0) A(2,1) A(2,2) A(2,3)
A(3,0) A(3,1) A(3,2) A(3,3)</code></pre>
            </div>
            </p>
            <p>In memory (row-major), row 0 is first, then row 1, etc. Accessing a <strong>row</strong> is contiguous (stride = 1), but accessing a <strong>column</strong> is not contiguous (stride = number of columns).</p>
            <h4 id="matrix-multiplication">Matrix multiplication</h4>
            <p>When computing (C = A \times B), each element (C(i,j)) is the dot product of row (i) of (A) and column (j) of (B). Both (A) and (B) are also in row-major format. So:</p>
            <ol>
                <li><strong>Load row of A</strong> </li>
                <li>Elements are in consecutive memory addresses (stride = 1). </li>
                <li>
                    <p>Example: row (i) might be ([A(i,0), A(i,1), \dots]).</p>
                </li>
                <li>
                    <p><strong>Load column of B</strong> </p>
                </li>
                <li>Elements are spaced by the row width of (B). If (B) has 10 columns, the stride is 10. </li>
                <li>
                    <p>Example: column (j) might be ([B(0,j), B(1,j), B(2,j), \dots]).</p>
                </li>
                <li>
                    <p><strong>Vector multiply and accumulate</strong> </p>
                </li>
                <li>Multiply corresponding elements, sum them up to get (C(i,j)).</li>
            </ol>
            <p>By setting a vector stride correctly, a single vector instruction can fetch or process these elements in a single pass. This eliminates the need for complex address computations in a loop, letting the hardware handle it efficiently.</p>
            <h3 id="loading-storing-vectors-from-memory">Loading Storing Vectors from Memory</h3>
            <ul>
                <li>
                    <p><strong>Loading and storing vectors from memory involves retrieving multiple elements, which is useful for data-level parallelism.</strong><br />
                        In vector or SIMD-oriented architectures, a single instruction can fetch many data elements at once (e.g., an entire row of a matrix), thereby reducing loop overhead and instruction count.</p>
                </li>
                <li>
                    <p><strong>The stride between elements is a constant distance, which can be set to match different memory layouts.</strong><br />
                        This allows a single ‚Äúvector load‚Äù instruction to correctly access contiguous data (stride = 1) or spaced-out data (stride &gt; 1), depending on the layout in memory.</p>
                </li>
                <li>
                    <p><strong>Elements can be loaded in consecutive cycles if each cycle initiates the load of one new element, which is beneficial for high throughput.</strong><br />
                        By pipelining memory operations, each clock cycle can start a new load while previous loads are still completing. This overlap helps utilize memory bandwidth efficiently.</p>
                </li>
                <li>
                    <p><strong>A memory that takes more than one cycle per access can be managed by banking and interleaving elements across multiple banks, which is helpful for overlapping load operations.</strong><br />
                        With multiple memory banks operating in parallel, different parts of a vector can be fetched simultaneously, reducing access bottlenecks.</p>
                </li>
                <li>
                    <p><strong>Assuming a stride of one simplifies address calculations, which can be practical for contiguous data.</strong><br />
                        Contiguous arrays (e.g., typical row-major storage) allow easy increments in the base address by 1 for each subsequent element, minimizing the arithmetic needed to generate memory addresses.</p>
                </li>
            </ul>
            <p>In practice, vector loads/stores are a key part of high-performance computing. When data is well-organized in memory and has a suitable stride, the hardware can fetch multiple elements at once, reducing the number of individual instructions and improving overall throughput.</p>
            <h3 id="memory-banking">Memory Banking</h3>
            <p>Each bank has its own <strong>Memory Address Register (MAR)</strong> and <strong>Memory Data Register (MDR)</strong>, and they all connect to the <strong>CPU</strong> via a shared <strong>address bus</strong> and <strong>data bus</strong>. The following diagram shows the high-level structure of a system with multiple memory banks:</p>
            <p>
            <div>
                <pre><code class="language-shell">+-----------------+
                 |      CPU       |
                 |  (exec unit,   |
                 |   control)     |
                 +--------+-------+
                          |
             +------------+------------+
             |   Address Bus &amp;        |
             |     Data Bus           |
             +------------+------------+
                          |
         -------------------------------------------------
         |          |           |       ...       |      |
         v          v           v                 v      v
+-----------+  +-----------+  +-----------+   ...   +-----------+
|  Bank 0   |  |  Bank 1   |  |  Bank 2   |         | Bank 15   |
| (MAR,MDR) |  | (MAR,MDR) |  | (MAR,MDR) |         | (MAR,MDR)  |
+-----------+  +-----------+  +-----------+   ...   +-----------+</code></pre>
            </div>
            </p>
            <ul>
                <li>
                    <p><strong>CPU</strong>: Issues addresses and reads/writes data.<br />
                        The CPU (or GPU core) generates memory requests and coordinates read/write operations through the memory controller.</p>
                </li>
                <li>
                    <p><strong>Address Bus</strong>: Carries the memory address from the CPU to the appropriate memory bank‚Äôs MAR.<br />
                        All banks see the same address bus, but only the selected bank (based on address bits) will respond to a request.</p>
                </li>
                <li>
                    <p><strong>Data Bus</strong>: Carries data to/from the CPU and each bank‚Äôs MDR.<br />
                        Once the correct bank is addressed, data is transferred through this shared bus.</p>
                </li>
                <li>
                    <p><strong>Banks</strong>: Multiple memory banks (e.g., Bank 0, Bank 1, ‚Ä¶ Bank 15). Each has its own <strong>MAR</strong> and <strong>MDR</strong> to handle address/data in parallel.<br />
                        By having multiple banks, memory can serve different requests in parallel (or in a pipelined fashion), which helps hide latency and improve bandwidth.</p>
                </li>
            </ul>
            <p>Memory banking is essential for high-performance vector or GPU architectures because it increases effective memory bandwidth. If each element of a vector is mapped to a different bank, the system can read multiple elements simultaneously or in rapid succession.</p>
            <h3 id="vectorizable-loops">Vectorizable Loops</h3>
            <ul>
                <li>
                    <p><strong>A loop is considered vectorizable if each iteration is independent from the others.</strong><br />
                        No data hazard (e.g., writing a value that another iteration reads) should exist between loop iterations. This independence allows all iterations to be processed together.</p>
                </li>
                <li>
                    <p><strong>The example loop <code>for i = 0 to 49, C[i] = (A[i] + B[i]) / 2</code> meets this condition because each element can be processed separately.</strong><br />
                        The operation on <code>C[i]</code> depends only on <code>A[i]</code> and <code>B[i]</code>, not on <code>C[i-1]</code> or other elements. So the hardware can safely execute these 50 computations in parallel or in a pipeline.</p>
                </li>
                <li>
                    <p><strong>The vectorized version of this loop sets the vector length register to 50 and the vector stride register to 1.</strong><br />
                        This tells the processor to apply one vector instruction to the entire range of indices from 0 to 49, stepping by 1 in memory.</p>
                </li>
                <li>
                    <p><strong>The instructions load A into V0, load B into V1, add V0 and V1 to produce V2, shift V2 right by one bit to produce V3, and store V3 into C.</strong><br />
                        By using vector instructions, each register holds multiple elements, so one instruction can handle multiple array indices at once.</p>
                </li>
                <li>
                    <p><strong>Each instruction has a specific latency that depends on the hardware implementation and the vector length.</strong><br />
                        For example, a vector add might take a certain number of cycles per element, but with pipelining, each new element can enter the pipeline on each cycle.</p>
                </li>
                <li>
                    <p><strong>The shift right by one bit is mathematically equivalent to dividing by two, which calculates the average of the corresponding elements of A and B.</strong><br />
                        Shifting is often faster than integer division, making it a common optimization in assembly-level or vectorized code.</p>
                </li>
                <li>
                    <p><strong>Vectorizing the loop can reduce loop overhead by issuing a single instruction for multiple data elements.</strong><br />
                        Instead of 50 separate add instructions, we have just one vector add instruction (plus a setup of the vector registers). This reduces the instruction count and improves performance.</p>
                </li>
            </ul>
            <p>Vectorizable loops are a prime candidate for GPU acceleration. Each GPU thread might handle a portion of the data, or specialized instructions can process multiple elements per thread. In either case, independence between loop iterations makes it easy to parallelize the computation.</p>
            <h3 id="gpus-are-simd-engines">GPUs Are SIMD Engines</h3>
            <ul>
                <li>
                    <p><strong>GPUs use an instruction pipeline that operates like a SIMD pipeline, which is beneficial for parallel processing.</strong><br />
                        ‚ÄúSIMD‚Äù (Single Instruction, Multiple Data) means one instruction can act on many data elements in parallel, a natural fit for graphics tasks and other data-parallel workloads.</p>
                </li>
                <li>
                    <p><strong>User programming is done with threads rather than explicit SIMD instructions, but the hardware still runs threads in a SIMD fashion under the hood.</strong><br />
                        High-level languages like CUDA and OpenCL let you write kernel code for many threads, yet the GPU hardware often groups these threads together to execute the same instruction on multiple data simultaneously.</p>
                </li>
                <li>
                    <p><strong>Each GPU core executes many threads in lockstep, which can be helpful for hiding memory latency.</strong><br />
                        While some threads wait on data from memory, other threads can run. This keeps the GPU‚Äôs functional units busy.</p>
                </li>
                <li>
                    <p><strong>The hardware groups threads into warps or wavefronts that share the same instruction stream, and this is relevant for achieving data-level parallelism.</strong><br />
                        For example, on NVIDIA GPUs, a ‚Äúwarp‚Äù typically has 32 threads executing the same instruction at the same time.</p>
                </li>
                <li>
                    <p><strong>Parallelizable code examples map naturally onto the thread-based model, although each thread often executes the same instructions in a SIMD manner.</strong><br />
                        This helps programmers focus on dividing work among threads, while the GPU arranges the threads for efficient SIMD execution.</p>
                </li>
                <li>
                    <p><strong>Recognizing the difference between thread-based and SIMD-based approaches can be useful for optimizing GPU applications.</strong><br />
                        Understanding the underlying SIMD nature lets you write kernels that avoid unnecessary divergence (where threads in the same warp do different tasks) and maintain good memory coalescing.</p>
                </li>
            </ul>
            <h3 id="simd-vs-simt">SIMD vs SIMT</h3>
            <ul>
                <li><strong>SIMD</strong>: Rigid single instruction stream, ideal for uniform data operations. </li>
                <li>
                    <p><strong>SIMT</strong>: More flexible, each thread can have a distinct instruction flow; hardware still attempts to run threads in a SIMD fashion if their instructions match. </p>
                </li>
                <li>
                    <p><strong>SIMD is a single sequential instruction stream that operates on multiple data elements in parallel.</strong><br />
                        With classic SIMD, a single instruction (like <code>VADD</code>) is applied to multiple data elements simultaneously. Hardware typically provides specialized vector registers and instructions to handle several elements per operation.</p>
                </li>
                <li>
                    <p><strong>SIMT uses multiple instruction streams of scalar instructions, and threads are grouped dynamically into warps.</strong><br />
                        Under SIMT (Single Instruction, Multiple Threads), each thread executes its own instruction stream, but the hardware can group threads that run the same instruction at once. This grouping is often done automatically at runtime.</p>
                </li>
                <li>
                    <p><strong>Traditional SIMD hardware employs instructions like VLD, VADD, and VST, with a vector length register to manage data elements.</strong><br />
                        The vector length register (VL) indicates how many elements the SIMD operation will process. The hardware then iterates over these elements in parallel or in a pipelined fashion.</p>
                </li>
                <li>
                    <p><strong>SIMT hardware relies on thread-based instructions, such as CUDA kernels, and defines parameters like NumThreads for parallel execution.</strong><br />
                        Developers write GPU kernels that specify how many threads to launch. Under the hood, the GPU hardware arranges these threads into warps (e.g., 32 threads per warp on many NVIDIA GPUs) and executes them concurrently.</p>
                </li>
                <li>
                    <p><strong>One advantage of SIMT is that it can treat each thread independently on any type of scalar pipeline, which allows flexible MIMD-style processing.</strong><br />
                        Each thread can run its own path, so the hardware can behave like ‚Äúmultiple instruction, multiple data‚Äù (MIMD) when divergence occurs (though performance may degrade if too many threads diverge).</p>
                </li>
                <li>
                    <p><strong>Another advantage of SIMT is that it can group threads into warps dynamically, which provides a way to exploit data-parallel execution while maintaining flexibility.</strong><br />
                        Threads that follow the same instruction path can be grouped for SIMD-like execution, but if they diverge, each thread (or subset of threads) can continue independently in scalar form.</p>
                </li>
            </ul>
            <p>Below are two simple diagrams showing an abstract view of SIMD vs. SIMT.</p>
            <hr />
            <p>
            <div>
                <pre><code class="language-shell">===============================================
SIMD (Single Instruction, Multiple Data)
===============================================
          +------------------------+
          |  Instruction Fetch    |
          |  (one instruction)    |
          +-----------+-----------+
                      |
                      v
    +-----------------+-----------------+-----------------+-----------------+
    |     Lane 0      |     Lane 1      |     Lane 2      |     Lane 3      |
    |  (data element) |  (data element) |  (data element) |  (data element) |
    +-----------------+-----------------+-----------------+-----------------+

(One instruction is applied to multiple data elements simultaneously 
 in parallel lanes. All lanes share the same Program Counter.)</code></pre>
            </div>
            </p>
            <ul>
                <li>One instruction stream (shared Program Counter). </li>
                <li>Multiple data lanes operate in lockstep (e.g., VADD across 4 elements). </li>
                <li>Typically uses specialized vector registers. </li>
                <li>Great for uniform data-parallel tasks where each element does the same operation.</li>
            </ul>
            <hr />
            <p>
            <div>
                <pre><code class="language-shell">===============================================
SIMT (Single Instruction, Multiple Threads)
===============================================
           +-------------------------------------------------+
           |         Warp Scheduler / Dispatch Unit          |
           +------------------------+-------------------------+
                                    |
                (Groups threads     |  Same instruction if
                into warps          |  they converge in PC)
                                    v
   +------------+   +------------+   +------------+   +------------+
   |  Thread 0  |   |  Thread 1  |   |  Thread 2  |   |  Thread 3  |
   | Instr. Strm|   | Instr. Strm|   | Instr. Strm|   | Instr. Strm|
   +------------+   +------------+   +------------+   +------------+

(Each thread has its own instruction stream and Program Counter, 
 but threads that execute the same instruction can run in lockstep 
 as a warp, effectively behaving like SIMD when they follow one path.)</code></pre>
            </div>
            </p>
            <ul>
                <li>Multiple threads, each with its own Program Counter (PC). </li>
                <li>A hardware scheduler groups threads with the same PC into a warp for SIMD-like execution. </li>
                <li>If threads diverge, they can continue independently, though performance may drop. </li>
                <li>Commonly used by GPUs (e.g., CUDA, OpenCL) where thousands of threads can be launched, and hardware dynamically forms warps from these threads.</li>
            </ul>
            <h3 id="fine-grained-multithreading">Fine-Grained Multithreading</h3>
            <ul>
                <li>
                    <p><strong>Fine-grained multithreading uses multiple thread contexts, which allows each cycle to fetch instructions from a different thread.</strong><br />
                        Unlike traditional single-thread pipelines, the hardware can switch which thread‚Äôs instruction is fetched each cycle, interleaving many threads.</p>
                </li>
                <li>
                    <p><strong>The pipeline fetches from a new thread while previous instructions are still resolving, which can reduce idle cycles.</strong><br />
                        This ‚Äúbarrel processor‚Äù approach helps hide latencies (like memory waits) by running instructions from other threads in the meantime.</p>
                </li>
                <li>
                    <p><strong>There is no additional hardware logic needed for handling data dependencies within a thread, because threads proceed independently.</strong><br />
                        Each thread has its own registers and state, so the processor can simply swap to another thread without worrying about dependencies among instructions from different threads.</p>
                </li>
                <li>
                    <p><strong>This approach tolerates control and data dependence latencies by overlapping them with useful work from other threads.</strong><br />
                        If thread A stalls waiting for memory, the hardware can schedule thread B‚Äôs instructions, keeping the pipeline busy.</p>
                </li>
                <li>
                    <p><strong>It helps utilize pipeline stages more fully by having multiple threads in flight.</strong><br />
                        The pipeline remains more active because there's usually another thread ready to execute.</p>
                </li>
                <li>
                    <p><strong>Single-thread performance is reduced, because the pipeline switches among threads rather than focusing on one thread.</strong><br />
                        The hardware only dedicates a fraction of its cycles to any single thread, which can increase latency for that thread‚Äôs completion.</p>
                </li>
                <li>
                    <p><strong>Extra hardware is required to support multiple thread contexts, which increases design complexity.</strong><br />
                        Each thread needs its own program counters, register sets, and state. The system must quickly swap these contexts every cycle or every few cycles.</p>
                </li>
                <li>
                    <p><strong>If there are not enough threads ready to run, the pipeline can still stall.</strong><br />
                        In situations where all threads are waiting on long-latency operations (e.g., memory), fine-grained multithreading cannot completely eliminate stalls.</p>
                </li>
            </ul>
            <h3 id="high-level-gpu-architecture">high-level GPU architecture</h3>
            <ul>
                <li>A <strong>front-end</strong> (Program Counter, mask registers, instruction cache, decode logic, etc.). </li>
                <li>Multiple <strong>scalar pipelines</strong> and a <strong>SIMD execution</strong> block. </li>
                <li>An <strong>interconnection network</strong> connecting multiple <strong>shader cores</strong>. </li>
                <li>Multiple <strong>memory controllers</strong> connected to <strong>GDDR</strong> memory.</li>
            </ul>
            <p>
            <div>
                <pre><code class="language-shell">+--------------------------------+
                              |           PC, Mask             |
                              |        +--------------+        |
                              |        |   I-Cache    |        |
                              |        +--------------+        |
                              |             Decode             |
                              |                                |
                              |  +--------------+  +--------+  |
                              |  | Scalar Pipe  |  |  ...   |  |  &lt;-- Possibly multiple
                              |  +--------------+  +--------+  |      scalar pipelines
                              |  | Scalar Pipe  |               |
                              |  +--------------+               |
                              |         ...                     |
                              |        SIMD Exec                |
                              +---------------+-----------------+
                                              |
                                              |
            +----------------------+-----------+----------------------+
            |                Interconnection Network                |
            +------------+------------+------------+----------------+
                         |            |            |
                         v            v            v
                  +-----------+  +-----------+  +-----------+  ...
                  |ShaderCore |  |ShaderCore |  |ShaderCore |
                  +-----------+  +-----------+  +-----------+
                         |            |            |
                         +-----+------+------+-----+
                               |      |      |
         +---------------------+------+------+---------------------+
         |                 Memory Controller(s)                   |
         |                 +--------------+                       |
         |                 |    GDDRx     |  (e.g., GDDR3, GDDR5) |
         +-----------------+--------------+------------------------+</code></pre>
            </div>
            </p>
            <ol>
                <li><strong>Front-End</strong> </li>
                <li><strong>PC (Program Counter), Mask</strong>: Tracks instruction addresses and active lanes (threads). </li>
                <li><strong>I-Cache</strong>: Holds instructions to be decoded. </li>
                <li><strong>Decode</strong>: Decodes instructions into micro-ops for the pipelines. </li>
                <li><strong>Scalar Pipelines</strong>: Execute scalar operations (e.g., address calculations, control flow). </li>
                <li>
                    <p><strong>SIMD Execution</strong>: Executes vector (wide) operations for parallel data processing (shaders).</p>
                </li>
                <li>
                    <p><strong>Interconnection Network</strong> </p>
                </li>
                <li>
                    <p>Connects the front-end and memory subsystem to multiple <strong>shader cores</strong> (compute units). </p>
                </li>
                <li>
                    <p><strong>Shader Cores</strong> </p>
                </li>
                <li>
                    <p>Each core has ALUs, registers, and scheduling hardware for parallel threads (shaders).</p>
                </li>
                <li>
                    <p><strong>Memory Controllers + GDDR</strong> </p>
                </li>
                <li>Multiple controllers handle high-bandwidth GDDR memory accesses in parallel.</li>
            </ol>
            <h3 id="general-purpose-programming-on-gpu">General Purpose Programming on GPU</h3>
            <ul>
                <li>
                    <p><strong>General-purpose processing on GPUs can be helpful for workloads that exhibit data-level parallelism.</strong><br />
                        Many algorithms‚Äîlike image processing, matrix multiplication, or deep learning‚Äîoperate on large data arrays. By running them on the GPU, you can take advantage of thousands of parallel cores.</p>
                </li>
                <li>
                    <p><strong>The SPMD programming model is frequently used because it is versatile for many different tasks.</strong><br />
                        ‚ÄúSingle Program, Multiple Data‚Äù (SPMD) means the same program (kernel) runs across many data points. Each data point is handled by a different thread or work item.</p>
                </li>
                <li>
                    <p><strong>Matrices, image processing, and deep neural networks can exploit parallel execution on GPU hardware.</strong><br />
                        Tasks with repeated operations on large arrays benefit from running in parallel.</p>
                </li>
                <li>
                    <p><strong>Using a GPU for these tasks requires a new programming model that can be useful for large-scale data operations.</strong><br />
                        Frameworks like CUDA or OpenCL provide abstractions (kernels, blocks, threads) for launching many parallel tasks at once.</p>
                </li>
                <li>
                    <p><strong>The trade-off for this flexibility involves additional resource usage and increased complexity in coding.</strong><br />
                        Programmers need to learn how to manage GPU memory, thread block organization, and synchronization, which adds development effort.</p>
                </li>
                <li>
                    <p><strong>CPU few out-of-order cores</strong><br />
                        Modern CPUs typically have a small number of complex cores with out-of-order execution, good for general-purpose tasks but not as effective at massive parallelism.</p>
                </li>
                <li>
                    <p><strong>GPU many in-order FGMT cores</strong><br />
                        GPUs have many simpler in-order cores that rely on fine-grained multithreading (FGMT) and hardware scheduling to keep pipelines busy. This design is highly optimized for parallel workloads but less flexible for single-thread performance.</p>
                </li>
            </ul>
            <p><strong>Typical GPU Execution Flow (Three Steps):</strong> </p>
            <ol>
                <li><strong>Load Data to GPU</strong> </li>
                <li>The CPU (host) allocates GPU (device) memory. </li>
                <li>
                    <p>Input data is transferred from <strong>host memory</strong> to <strong>device memory</strong>. </p>
                </li>
                <li>
                    <p><strong>Execute GPU Kernel</strong> </p>
                </li>
                <li>A <strong>kernel</strong> function is launched on the GPU. </li>
                <li>
                    <p>Thousands of <strong>threads</strong> run in parallel on the GPU, accessing device memory to process data. </p>
                </li>
                <li>
                    <p><strong>Copy Results Back</strong> </p>
                </li>
                <li>Once the kernel finishes, the CPU transfers the <strong>results</strong> from <strong>device memory</strong> back to <strong>host memory</strong>. </li>
                <li>The CPU can then use or display the computed results.</li>
            </ol>
            <p>Here‚Äôs a simplified diagram showing the <strong>basic</strong> data flow:</p>
            <p>
            <div>
                <pre><code class="language-shell">+-------------------------+       Step 1        +------------------------+
     |         CPU (Host)      | --(Host-&gt;Device)--&gt; |       GPU (Device)     |
     |                         | &lt;-(Device-&gt;Host)--  |                        |
     |   (Runs host code)      |       Step 3        | (Executes GPU kernels) |
     +-------------------------+                     +-----------+------------+
                                                            ^
                                                            | Step 2
                                                            |
                                                          Kernel
                                                          Launch</code></pre>
            </div>
            </p>
            <ul>
                <li><strong>Step 1 (Host -&gt; Device)</strong>: The CPU allocates device memory (e.g., <code>cudaMalloc</code>) and calls a memory copy function (e.g., <code>cudaMemcpy</code>) to transfer inputs to the GPU. </li>
                <li><strong>Step 2 (Kernel Launch)</strong>: The CPU tells the GPU to execute a kernel (e.g., <code>myKernel&lt;&lt;&lt;blocks, threads&gt;&gt;&gt;(args)</code>). The GPU processes data in parallel, using many threads. </li>
                <li><strong>Step 3 (Device -&gt; Host)</strong>: When the kernel finishes, the CPU may copy results back to host memory (again using <code>cudaMemcpy</code>). </li>
                <li>In some workflows, you might <strong>skip</strong> copying data back to the host if the GPU is going to process it further or if the final output is displayed directly from GPU memory (e.g., graphics rendering). </li>
                <li>You can also run multiple kernels in a row without transferring data back and forth each time‚Äîoften done in complex GPU-accelerated pipelines. </li>
                <li>The <strong>three-step</strong> process remains a useful mental model: allocate &amp; copy in, run GPU code, and copy out if needed.</li>
            </ul>
            <h3 id="warps-and-blocks">Warps and Blocks</h3>
            <ul>
                <li>
                    <p><strong>CPU threads often handle sequential or modestly parallel tasks, while GPU kernels handle massively parallel workloads.</strong><br />
                        CPUs excel at handling complex control flows and irregular tasks. GPUs shine when the same operation is repeated over large data sets.</p>
                </li>
                <li>
                    <p><strong>GPU warps are hardware-level groupings of threads that are not directly exposed to the programmer.</strong><br />
                        A warp is typically 32 threads (on NVIDIA hardware) that run in lockstep, sharing the same instruction but operating on different data.</p>
                </li>
                <li>
                    <p><strong>The programmer launches parallel kernels on the GPU from the host code using syntax like <code>KernelA&lt;&lt;&lt;nBlk, nThr&gt;&gt;&gt;(args)</code>.</strong> </p>
                </li>
                <li><code>nBlk</code>: The number of blocks in the grid. </li>
                <li>
                    <p><code>nThr</code>: The number of threads in each block.</p>
                </li>
                <li>
                    <p><strong>Each GPU kernel is split into many threads, but the hardware manages how these threads are grouped into warps.</strong><br />
                        Once you request a certain block and thread count, the GPU creates warps automatically under the hood.</p>
                </li>
                <li>
                    <p><strong>The programmer can focus on writing thread-level code without managing or interacting with warp formation.</strong><br />
                        You write the kernel as if each thread executes the same function independently. Warp grouping is handled by the GPU driver and hardware.</p>
                </li>
                <li>
                    <p><strong>The host code typically runs serially between kernel launches, and the GPU runs many threads in parallel within each kernel.</strong><br />
                        This separation allows the CPU to focus on other tasks or orchestrate multiple kernel launches, while the GPU handles the parallel computation.</p>
                </li>
                <li>
                    <p><strong>Warps schedule threads that execute the same instruction stream, but this scheduling is hidden from the user.</strong><br />
                        If all threads within a warp take the same path, they execute in a fully parallel SIMD fashion. If they diverge, the hardware manages it.</p>
                </li>
                <li>
                    <p><strong>This separation allows the GPU hardware to optimize performance internally while the user writes simpler thread-based code.</strong><br />
                        By abstracting away warp details, GPUs keep development more straightforward.</p>
                </li>
            </ul>
            <p>Below is a diagram that visualizes how <strong>blocks</strong> and <strong>warps</strong> fit into the overall GPU execution model. Each <strong>grid</strong> consists of one or more <strong>blocks</strong>, and each block contains many <strong>threads</strong>. Under the hood, the GPU hardware groups these threads into <strong>warps</strong> (on NVIDIA GPUs, typically 32 threads per warp). </p>
            <p>
            <div>
                <pre><code class="language-shell">+----------------------------------------------------+
   |                    GPU Grid                        |
   | (launched by Kernel&lt;&lt;&lt; numBlocks, threadsPerBlock &gt;&gt;&gt;(...)) 
   |                                                    |
   |  +------------------+    +------------------+       |
   |  |    Block 0       |    |    Block 1       |       |
   |  | (threads)        |    | (threads)        |  ...  |
   |  | +--------------+ |    | +--------------+ |       |
   |  | |   Warp 0     | |    | |   Warp 0     | |       |
   |  | | (th0..th31)  | |    | | (th0..th31)  | |       |
   |  | +--------------+ |    | +--------------+ |       |
   |  | +--------------+ |    | +--------------+ |       |
   |  | |   Warp 1     | |    | |   Warp 1     | |       |
   |  | | (th32..th63) | |    | | (th32..th63) | |       |
   |  | +--------------+ |    | +--------------+ |       |
   |  |       ...        |    |       ...        |       |
   |  +------------------+    +------------------+       |
   +----------------------------------------------------+</code></pre>
            </div>
            </p>
            <p><strong>How Blocks and Warps Relate</strong></p>
            <ol>
                <li><strong>Grid</strong>: The entire problem domain, composed of multiple blocks. A GPU kernel launch specifies:</li>
                <li><strong>Number of blocks</strong> (e.g., <code>numBlocks</code>)</li>
                <li>
                    <p><strong>Threads per block</strong> (e.g., <code>threadsPerBlock</code>)</p>
                </li>
                <li>
                    <p><strong>Blocks</strong>: Each block is an independent group of threads:</p>
                </li>
                <li>All threads in a block can cooperate using <strong>shared memory</strong> and <strong>barrier synchronization</strong> (<code>__syncthreads()</code> in CUDA). </li>
                <li>
                    <p>Blocks are also often arranged in one-, two-, or three-dimensional configurations (e.g., a 2D grid of threads for image processing).</p>
                </li>
                <li>
                    <p><strong>Threads</strong>: Each block has many threads:</p>
                </li>
                <li>Each thread has its own registers and local memory. </li>
                <li>
                    <p>Threads in the same block can communicate and synchronize.</p>
                </li>
                <li>
                    <p><strong>Warps</strong>: The GPU hardware divides the threads in each block into <strong>warps</strong>:</p>
                </li>
                <li>A warp is typically <strong>32 threads</strong> on NVIDIA GPUs (the exact number can vary by architecture/vendor). </li>
                <li>All threads in a warp <strong>execute in lockstep</strong> (SIMD fashion). </li>
                <li>If threads in the same warp diverge (e.g., different branches of an <code>if</code> statement), the warp executes each branch sequentially, reducing overall efficiency.</li>
            </ol>
            <h4 id="warp-based-simd">Warp-Based SIMD</h4>
            <ul>
                <li>
                    <p><strong>GPU cores rely on SIMD pipelines, which are known as streaming multiprocessors and streaming processors.</strong><br />
                        Each multiprocessor runs multiple warps in parallel, using single-instruction, multiple-data execution.</p>
                </li>
                <li>
                    <p><strong>A block of threads is divided into warps, and each warp usually contains 32 threads.</strong><br />
                        This is a hardware detail on many NVIDIA GPUs, ensuring uniform warp size for scheduling.</p>
                </li>
                <li>
                    <p><strong>Warps execute instructions in lockstep, which can be helpful for data-level parallelism.</strong><br />
                        If all threads in a warp run the same instruction at once, you achieve maximum efficiency.</p>
                </li>
                <li>
                    <p><strong>The hardware manages warp formation automatically, and programmers do not interact with warps directly.</strong><br />
                        You simply define grids and blocks, and the GPU does the warp scheduling internally.</p>
                </li>
                <li>
                    <p><strong>This design can be useful for balancing the workload across GPU resources.</strong><br />
                        If some warps stall (e.g., waiting on memory), the GPU can schedule other warps.</p>
                </li>
            </ul>
            <h4 id="comparing-traditional-simd-vs-warp-based-simd">Comparing Traditional SIMD vs. Warp-Based SIMD</h4>
            <ul>
                <li>
                    <p><strong>Traditional SIMD processes a single thread with multiple data lanes in lockstep, which can be beneficial for uniform computations.</strong><br />
                        A single instruction (like <code>VADD</code>) might operate on multiple data elements simultaneously.</p>
                </li>
                <li>
                    <p><strong>The programming model for traditional SIMD relies on explicit vector instructions, which can be useful for data-level parallelism.</strong><br />
                        Programmers explicitly specify operations on vector registers of fixed width (e.g., 128-bit, 256-bit).</p>
                </li>
                <li>
                    <p><strong>Warp-based SIMD (SIMT) runs multiple scalar threads in a SIMD manner, which means each warp executes the same instruction on different data.</strong><br />
                        Each thread has its own registers and program counter, but the hardware groups threads with the same instruction to run in lockstep.</p>
                </li>
                <li>
                    <p><strong>The hardware automatically groups threads into warps, which can be helpful for managing large numbers of threads.</strong><br />
                        No need to manually specify vector length or special vector registers; you just spawn thousands of threads.</p>
                </li>
                <li>
                    <p><strong>Traditional SIMD requires the software to specify vector lengths, which is practical for controlling how many data elements are processed.</strong><br />
                        This approach works well if your dataset fits neatly into a fixed-width vector.</p>
                </li>
                <li>
                    <p><strong>Warp-based SIMD conceals vector-length details from the programmer, which is convenient for thread-based coding.</strong><br />
                        Threads can diverge if necessary (though it‚Äôs costly), offering more flexibility than strict SIMD.</p>
                </li>
                <li>
                    <p><strong>Traditional SIMD ISAs often include vector instructions, while warp-based SIMD relies on scalar instructions repeated across many threads.</strong><br />
                        In SIMT, each thread sees itself as scalar code, and the GPU arranges them in SIMD groups under the hood.</p>
                </li>
            </ul>
            <h3 id="program-structure-in-cuda">Program Structure in CUDA</h3>
            <ul>
                <li><strong>A CUDA program typically includes function prototypes marked with <code>__global__</code> to indicate that these functions will run on the GPU.</strong><br />
                    Example: </li>
            </ul>
            <p>
            <div>
                <pre><code class="language-clike">__global__ void myKernel(float* data, int size) {
      // kernel code
  }</code></pre>
            </div>
            </p>
            <ul>
                <li><strong>The main function usually starts by allocating memory on the GPU using <code>cudaMalloc</code>, which reserves device memory.</strong> </li>
            </ul>
            <p>
            <div>
                <pre><code class="language-clike">float* d_data;
  cudaMalloc((void**)&amp;d_data, size * sizeof(float));</code></pre>
            </div>
            </p>
            <ul>
                <li><strong>After allocation, data is transferred from the host to the device with <code>cudaMemcpy</code>, which moves the input data to GPU memory.</strong> </li>
            </ul>
            <p>
            <div>
                <pre><code class="language-clike">cudaMemcpy(d_data, h_data, size * sizeof(float), cudaMemcpyHostToDevice);</code></pre>
            </div>
            </p>
            <ul>
                <li><strong>The kernel function is then launched using the triple angle bracket notation (<code>kernel&lt;&lt;&lt;blocks, threads&gt;&gt;&gt;(args)</code>), which specifies the execution configuration.</strong> </li>
            </ul>
            <p>
            <div>
                <pre><code class="language-clike">myKernel&lt;&lt;&lt;numblocks, threadsperblock=""&gt;&gt;&gt;(d_data, size);</code></pre>
            </div>
            </p>
            <ul>
                <li><strong>Once the kernel finishes execution, the results are transferred back to the host using <code>cudaMemcpy</code> to retrieve output data from the device.</strong> </li>
            </ul>
            <p>
            <div>
                <pre><code class="language-clike">cudaMemcpy(h_data, d_data, size * sizeof(float), cudaMemcpyDeviceToHost);</code></pre>
            </div>
            </p>
            <ul>
                <li>
                    <p><strong>A kernel function can use automatic variables that the compiler places in registers, which is efficient for frequently accessed data.</strong><br />
                        Such variables have fast access times but are limited in size.</p>
                </li>
                <li>
                    <p><strong>Shared memory is declared using <code>__shared__</code> inside the kernel, which can be helpful for reducing global memory accesses.</strong><br />
                        Example: </p>
                </li>
            </ul>
            <p>
            <div>
                <pre><code class="language-clike">__global__ void kernelExample(float* data) {
      __shared__ float tile[128];
      // ...
  }</code></pre>
            </div>
            </p>
            <ul>
                <li><strong>Intra-block synchronization is managed by calling <code>__syncthreads()</code>, which ensures that all threads within a block reach the same point before proceeding.</strong><br />
                    This barrier is essential when threads need to cooperate on shared data.</li>
            </ul>
            <p>Below is a table of common CUDA concepts. Each row outlines the <strong>concept</strong>, gives a <strong>brief description</strong>, shows a <strong>typical usage or syntax</strong>, and provides <strong>extra notes</strong> or examples for clarity.</p>
            <p>
            <table>
                <tr>
                    <td><strong>Concept</strong></td>
                    <td><strong>Description</strong></td>
                    <td><strong>Syntax / Example</strong></td>
                    <td><strong>Extra Notes / Examples</strong></td>
                </tr>
                <tr>
                    <td><strong>Kernel</strong></td>
                    <td>A function executed on the GPU in parallel by many threads. Marked with <code>__global__</code>.</td>
                    <td><code>&lt;br&gt;__global__ void myKernel(float* data) {&lt;br&gt; // GPU code&lt;br&gt;}&lt;br&gt;&lt;br&gt;// Launch&lt;br&gt;myKernel&lt;&lt;&lt;numBlocks, threadsPerBlock&gt;&gt;&gt;(d_data);&lt;br&gt;</code></td>
                    <td>- Each thread runs <code>myKernel()</code> independently.<br />- Grids and blocks specify the total thread count.<br />- Often used for data-parallel tasks (e.g., vector addition).</td>
                </tr>
                <tr>
                    <td><strong>Block</strong></td>
                    <td>A group of threads that can cooperate via shared memory and synchronization.</td>
                    <td>Specified in the kernel launch: <code>&lt;numBlocks, threadsPerBlock&gt;</code></td>
                    <td>- Example: <code>myKernel&lt;&lt;&lt;64, 256&gt;&gt;&gt;(...)</code> creates 64 blocks, each with 256 threads.<br />- Threads in the same block can access shared memory declared with <code>__shared__</code>.</td>
                </tr>
                <tr>
                    <td><strong>Grid</strong></td>
                    <td>The entire set of blocks launched for a kernel.</td>
                    <td>Same syntax as block specification but at a higher level (<code>numBlocks</code>).</td>
                    <td>- A grid can be 1D, 2D, or 3D, matching the shape of the data (e.g., image processing often uses 2D grids).</td>
                </tr>
                <tr>
                    <td><strong>Thread</strong></td>
                    <td>The basic unit of execution on the GPU. Each thread has its own registers and can identify itself by <code>threadIdx</code> within a block and <code>blockIdx</code> within the grid.</td>
                    <td><code>&lt;br&gt;int tx = threadIdx.x;&lt;br&gt;int bx = blockIdx.x;&lt;br&gt;int idx = bx * blockDim.x + tx;&lt;br&gt;</code></td>
                    <td>- <code>threadIdx</code>, <code>blockIdx</code>, and <code>blockDim</code> are built-in variables.<br />- Each thread typically handles one or more elements of the data.</td>
                </tr>
                <tr>
                    <td><strong>Barrier</strong> / <code>__syncthreads()</code></td>
                    <td>Synchronizes all threads in the same block. No thread passes the barrier until all threads have reached it.</td>
                    <td><code>&lt;br&gt;__shared__ float temp[256];&lt;br&gt;temp[threadIdx.x] = data[threadIdx.x];&lt;br&gt;__syncthreads();&lt;br&gt;// All threads have updated temp here&lt;br&gt;</code></td>
                    <td>- Only valid within a kernel.<br />- Ensures partial updates in shared memory are visible to all threads before proceeding.<br />- Does <strong>not</strong> synchronize across multiple blocks.</td>
                </tr>
                <tr>
                    <td><strong>Shared Memory</strong></td>
                    <td>Fast on-chip memory visible to all threads in the same block. Declared with <code>__shared__</code>.</td>
                    <td><code>&lt;br&gt;__global__ void myKernel(float* in){&lt;br&gt; __shared__ float tile[256];&lt;br&gt; // ...&lt;br&gt;}&lt;br&gt;</code></td>
                    <td>- Useful for caching data reused by threads in a block.<br />- Access is much faster than global memory but limited in size.<br />- Must be accessed carefully to avoid bank conflicts.</td>
                </tr>
                <tr>
                    <td><strong>Global Memory</strong></td>
                    <td>Main device memory accessible by all threads but with higher access latency than shared memory.</td>
                    <td>Allocated via <code>cudaMalloc((void**)&amp;d_ptr, size);</code><br />Accessed in kernels by pointer (<code>d_ptr[index]</code>).</td>
                    <td>- Large capacity but slower than shared or local memory.<br />- Important to ensure coalesced access (threads access consecutive addresses) for best performance.</td>
                </tr>
                <tr>
                    <td><strong>Host Code</strong></td>
                    <td>CPU-side code that sets up kernel launches, manages device memory, and coordinates data transfers.</td>
                    <td><code>&lt;br&gt;// Allocate GPU memory&lt;br&gt;cudaMalloc((void**)&amp;d_data, size);&lt;br&gt;// Launch kernel&lt;br&gt;myKernel&lt;&lt;&lt;blocks, threads&gt;&gt;&gt;(d_data);&lt;br&gt;// Copy results back&lt;br&gt;cudaMemcpy(h_data, d_data, size, cudaMemcpyDeviceToHost);&lt;br&gt;</code></td>
                    <td>- The host is responsible for orchestrating GPU operations (allocation, copy, launch).<br />- Synchronization functions (<code>cudaDeviceSynchronize()</code>) can ensure the GPU has finished before using results on the CPU.</td>
                </tr>
                <tr>
                    <td><strong>Device Function</strong></td>
                    <td>A function that runs on the GPU but is <strong>only</strong> called from another GPU function (kernel or device function). Declared with <code>__device__</code>.</td>
                    <td><code>&lt;br&gt;__device__ float deviceFunc(float x) {&lt;br&gt; return x * x;&lt;br&gt;}&lt;br&gt;&lt;br&gt;__global__ void kernelFunc(float* data){&lt;br&gt; data[threadIdx.x] = deviceFunc(data[threadIdx.x]);&lt;br&gt;}&lt;br&gt;</code></td>
                    <td>- Not callable from the host.<br />- Often used to break large kernels into smaller subroutines.</td>
                </tr>
                <tr>
                    <td><strong>Host Function</strong></td>
                    <td>Normal CPU function compiled for the host. Marked with <code>__host__</code> (optional unless combined with <code>__device__</code> in a function qualifier).</td>
                    <td><code>&lt;br&gt;__host__ void hostFunc(){&lt;br&gt; // Runs on CPU&lt;br&gt;}&lt;br&gt;</code></td>
                    <td>- Host code typically handles memory management, kernel launches, etc.<br />- <code>__host__ __device__</code> can make a function callable from both CPU and GPU, although limitations apply.</td>
                </tr>
            </table>
            </p>
            <ul>
                <li>This table is not exhaustive. Advanced CUDA concepts include streams, events, unified memory, texture memory, constant memory, warp-level primitives, cooperative groups, and more. </li>
                <li>The examples shown above are simplified to illustrate syntax and usage. Real-world code often includes error checking on all CUDA function calls (e.g., checking the return value of <code>cudaMalloc</code>, <code>cudaMemcpy</code>, etc.). </li>
                <li>The concept of <strong>warps</strong> is a lower-level detail (hardware grouping of threads). It is usually not directly controlled in the kernel code, but it‚Äôs useful to understand for performance tuning.</li>
            </ul>
        </article-section>
        <div id="table-of-contents">
            <h2>Table of Contents</h2>
            <ol><a href="#gpu-programming">GPU Programming</a>
                <ol>
                    <li><a href="#time-space-duality">Time-Space Duality</a></li>
                    <li><a href="#vector-processor">Vector Processor</a></li>
                    <li><a href="#strides">Strides</a>
                        <ol>
                            <li><a href="#row-major-layout-example">Row-major layout example</a></li>
                            <li><a href="#matrix-multiplication">Matrix multiplication</a></li>
                        </ol>
                    </li>
                    <li><a href="#loading-storing-vectors-from-memory">Loading Storing Vectors from Memory</a></li>
                    <li><a href="#memory-banking">Memory Banking</a></li>
                    <li><a href="#vectorizable-loops">Vectorizable Loops</a></li>
                    <li><a href="#gpus-are-simd-engines">GPUs Are SIMD Engines</a></li>
                    <li><a href="#simd-vs-simt">SIMD vs SIMT</a></li>
                    <li><a href="#fine-grained-multithreading">Fine-Grained Multithreading</a></li>
                    <li><a href="#high-level-gpu-architecture">high-level GPU architecture</a></li>
                    <li><a href="#general-purpose-programming-on-gpu">General Purpose Programming on GPU</a></li>
                    <li><a href="#warps-and-blocks">Warps and Blocks</a>
                        <ol>
                            <li><a href="#warp-based-simd">Warp-Based SIMD</a></li>
                            <li><a href="#comparing-traditional-simd-vs-warp-based-simd">Comparing Traditional SIMD vs. Warp-Based SIMD</a></li>
                        </ol>
                    </li>
                    <li><a href="#program-structure-in-cuda">Program Structure in CUDA</a></li>
                </ol>
            </ol>
            <div id="related-articles">
                <h2>Related Articles</h2>
                <ol>
                    <li><a href="https://adamdjellouli.com/articles/parallel_and_concurrent_programming/01_basic_terminology.html">Basic Terminology</a></li>
                    <li><a href="https://adamdjellouli.com/articles/parallel_and_concurrent_programming/02_multithreading.html">Multithreading</a></li>
                    <li><a href="https://adamdjellouli.com/articles/parallel_and_concurrent_programming/03_multiprocessing.html">Multiprocessing</a></li>
                    <li><a href="https://adamdjellouli.com/articles/parallel_and_concurrent_programming/04_asynchronous_programming.html">Asynchronous Programming</a></li>
                    <li><a href="https://adamdjellouli.com/articles/parallel_and_concurrent_programming/05_mpi.html">Mpi</a></li>
                    <li><a href="https://adamdjellouli.com/articles/parallel_and_concurrent_programming/06_hardware.html">Hardware</a></li>
                    <li><a href="https://adamdjellouli.com/articles/parallel_and_concurrent_programming/07_evaluating_performance.html">Evaluating Performance</a></li>
                    <li><a href="https://adamdjellouli.com/articles/parallel_and_concurrent_programming/08_designing_parallel_programs.html">Designing Parallel Programs</a></li>
                    <li><a href="https://adamdjellouli.com/articles/parallel_and_concurrent_programming/09_gpu_programming.html">Gpu Programming</a></li>
                </ol>
            </div>
        </div>
    </div>
    <footer>
        <div class="footer-columns">
            <div class="footer-column">
                <img alt="Adam Djellouli Symbol" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/symbol.png" />
            </div>
            <div class="footer-column">
                <h2><a href="https://adamdjellouli.com/core/privacy_policy.html" title="Privacy Policy">Our Privacy Policy</a></h2>
                <p>Thank you for visiting my personal website. All content here is free to use, but please remember to be respectful and avoid any misuse of the site. If you‚Äôd like to get in touch, feel free to reach out via my <a href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" title="LinkedIn Profile">LinkedIn profile</a> or connect with me on <a href="https://github.com/djeada" title="GitHub Profile">GitHub</a> if you have technical questions or ideas to share. Wishing you all the best and a fantastic life ahead!</p>
            </div>
            <div class="footer-column">
                <h2>Follow me</h2>
                <ul class="social-media">
                    <li>
                        <a class="fa fa-youtube" href="https://www.youtube.com/channel/UCGPoHTVjMN77wcGknXPHl1Q" target="_blank" title="YouTube">
                        </a>YouTube
                    </li>
                    <li>
                        <a class="fa fa-linkedin" href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" target="_blank" title="LinkedIn">
                        </a>LinkedIn
                    </li>
                    <li>
                        <a class="fa fa-instagram" href="https://www.instagram.com/linuxchallenges/" target="_blank" title="Instagram">
                        </a>Instagram
                    </li>
                    <li>
                        <a class="fa fa-github" href="https://github.com/djeada" title="GitHub">
                        </a>Github
                    </li>
                </ul>
            </div>
        </div>
        <div>
            <p id="copyright">
                ¬© Adam Djellouli. All rights reserved.
            </p>
        </div>
        <script>
            document.getElementById("copyright").innerHTML = "&copy; " + new Date().getFullYear() + " Adam Djellouli. All rights reserved.";
        </script>
        <script src="../../app.js"></script>
    </footer>
    <div id="pdf-spinner-overlay">
        <div class="spinner"></div>
    </div>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-bash.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-cpp.min.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
jax: ["input/TeX", "output/HTML-CSS"],
extensions: ["tex2jax.js"],
"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] },
tex2jax: { inlineMath: [ ["$", "$"] ], displayMath: [ ["$$","$$"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
TeX: { noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } } },
messageStyle: "none"
});
</script>
<script async="" id="MathJax-script" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>

</html>