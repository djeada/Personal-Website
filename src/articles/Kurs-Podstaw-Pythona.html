< html >
    <
    head >
    <
    meta charset = "utf-8" >
    <
    meta name = "generator"
content =
    "HTML Tidy for HTML5 for Linux version 5.6.0" >
    <
    title > Adam Djellouli - Index < /title> <
link rel = "icon"
href =
    "https://raw.githubusercontent.com/djeada/Personal-Website/master/images/icon.ico" >
    <
    link rel = "stylesheet"
type = "text/css"
href =
    "../resources/style.css" >
    <
    link rel = "stylesheet"
href =
    "https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" >
    <
    link rel = "preconnect"
href = "https://fonts.googleapis.com" >
    <
    link rel = "preconnect"
href = "https://fonts.gstatic.com"
crossorigin = "" >
    <
    meta name = "viewport"
content =
    "width=device-width, initial-scale=1.0" >
    <
    meta http - equiv = "X-UA-Compatible"
content = "ie-edge" >
    <
    /head> <
body >
    <
    nav > < a class = "logo"
href = "../index.html" > < img src =
    "https://raw.githubusercontent.com/djeada/Personal-Website/master/images/logo.PNG"
alt = "Adam Djellouli" > < /a> <input id="navbar-toggle" type=
"checkbox" >
<
ul >
    <
    li > < a href = "../index.html" > Home < /a></li >
    <
    li > < a href = "../core/blog.html"
class = "active" > Blog < /a></li >
    <
    li > < a href = "../core/tools.html" > Tools < /a></li >
    <
    li > < a href = "../core/projects.html" > Projects < /a></li >
    <
    li > < a href = "../core/resume.html" > Resume < /a></li >
    <
    li > < a href = "../core/about.html" > About < /a></li >
    <
    /ul> < /
    nav > <
    !-- === === === === === === === == Start Banner Area === === === === === === === == -- >
    <
    section class = "banner blog-page-banner" > < /section> <!-- === === === === === === === == End Banner Area === === === === === === === == -- >
    <
    h1 > Kurs - Podstaw - Pythona < /h1> <
p > Kurs podstaw Pythona. < /p> <
p > < img alt = "Capture"
src =
    "https://user-images.githubusercontent.com/37275728/185895408-59e16b58-4468-4bf3-8444-929e3fa4cc3d.PNG" > < /p> <
h2 > Spis Treści < /h2> <!--ts-- >
    <
    ul >
    <
    li > < a href = "#Podstawy" > Podstawy < /a> <
ul >
    <
    li > < a href =
    "#Instalacja-w-systemie-Windows" > Instalacja - w - systemie - Windows < /a></li >
    <
    li > < a href = "#Interaktywna-konsola" > Interaktywna - konsola < /a></li >
    <
    li > < a href = "#Zmienne" > Zmienne < /a></li >
    <
    li > < a href = "#Warunki" > Warunki < /a></li >
    <
    li > < a href = "#P%C4%99tle" > Pętle < /a></li >
    <
    li > < a href =
    "#P%C4%99tle-zagnie%C5%BCd%C5%BCone" > Pętle - zagnieżdżone < /a></li >
    <
    li > < a href = "#Funkcje" > Funkcje < /a></li >
    <
    li > < a href = "#Napisy" > Napisy < /a></li >
    <
    li > < a href = "#Struktury-danych" > Struktury - danych < /a></li >
    <
    li > < a href = "#Enum" > Enum < /a></li >
    <
    li > < a href = "#Liczby-losowe" > Liczby - losowe < /a></li >
    <
    /ul> < /
    li > <
    li > < a href = "#%C5%9Aredniozaawansowane" > Średniozaawansowane < /a> <
ul >
    <
    li > < a href = "#Klasy-i-obiekty" > Klasy - i - obiekty < /a></li >
    <
    li > < a href =
    "#Referencje-i-kopiowanie" > Referencje - i - kopiowanie < /a></li >
    <
    li > < a href =
    "#Czyste-funkcje-i-skutki-uboczne" > Czyste - funkcje - i - skutki - uboczne < /a></li >
    <
    li > < a href =
    "#Dziedziczenie-i-kompozycja" > Dziedziczenie - i - kompozycja < /a></li >
    <
    li > < a href =
    "#Wyra%C5%BCenia-regularne" > Wyrażenia - regularne < /a></li >
    <
    li > < a href = "#Wyj%C4%85tki" > Wyjątki < /a></li >
    <
    li > < a href = "#W%C4%85tki" > Wątki < /a></li >
    <
    li > < a href = "#Procesy" > Procesy < /a></li >
    <
    li > < a href = "#Asyncio" > Asyncio < /a></li >
    <
    li > < a href = "#Lambdy" > Lambdy < /a></li >
    <
    li > < a href =
    "#Programowanie-funkcyjne" > Programowanie - funkcyjne < /a></li >
    <
    li > < a href = "#Klasy-danych" > Klasy - danych < /a></li >
    <
    li > < a href = "#Generatory" > Generatory < /a></li >
    <
    li > < a href = "#Iteratory" > Iteratory < /a></li >
    <
    li > < a href = "#Dekoratory" > Dekoratory < /a></li >
    <
    li > < a href = "#Serializacja" > Serializacja < /a></li >
    <
    /ul> < /
    li > <
    li > < a href =
    "#In%C5%BCynieria-oprogramowania" > Inżynieria - oprogramowania < /a> <
ul >
    <
    li > < a href = "#Modu%C5%82y-i-pakiety" > Moduły - i - pakiety < /a></li >
    <
    li > < a href = "#Wersje-Pythona" > Wersje - Pythona < /a></li >
    <
    li > < a href = "#PIP-i-PyPI" > PIP - i - PyPI < /a></li >
    <
    li > < a href =
    "#%C5%9Arodowisko-wirtualne" > Środowisko - wirtualne < /a></li >
    <
    li > < a href =
    "#Dbanie-o-jako%C5%9B%C4%87-kodu-i-lintowanie" > Dbanie - o - jakość - kodu - i - lintowanie < /a></li >
    <
    li > < a href = "#Debugowanie" > Debugowanie < /a></li >
    <
    li > < a href = "#Testy-jednostkowe" > Testy - jednostkowe < /a></li >
    <
    li > < a href = "#Dokumentacja" > Dokumentacja < /a></li >
    <
    li > < a href =
    "#Pliki-wykonywalne-i-PyInstaller" > Pliki - wykonywalne - i - PyInstaller < /a></li >
    <
    li > < a href = "#Kod-bajtowy" > Kod - bajtowy < /a></li >
    <
    /ul> < /
    li > <
    li > < a href = "#Python-w-praktyce" > Python - w - praktyce < /a> <
ul >
    <
    li > < a href =
    "#Argumenty-linii-polece%C5%84" > Argumenty - linii - poleceń < /a></li >
    <
    li > < a href =
    "#Praca-z-plikami-i-folderami" > Praca - z - plikami - i - folderami < /a></li >
    <
    li > < a href = "#Pandas-i-csv" > Pandas - i - csv < /a></li >
    <
    li > < a href = "#Praca-z-plikami-PDF" > Praca - z - plikami - PDF < /a></li >
    <
    li > < a href =
    "#Informacje-o-systemie-operacyjnym" > Informacje - o - systemie - operacyjnym < /a></li >
    <
    li > < a href = "#HTTP-i-prosty-serwer" > HTTP - i - prosty - serwer < /a></li >
    <
    li > < a href = "#API-wraz-z-FastAPI" > API - wraz - z - FastAPI < /a></li >
    <
    li > < a href = "#Bazy-danych-z-SQLite" > Bazy - danych - z - SQLite < /a></li >
    <
    li > < a href = "#Tkinter" > Tkinter < /a></li >
    <
    li > < a href = "#Logi" > Logi < /a></li >
    <
    /ul> < /
    li > <
    li > < a href =
    "#Dodatkowe-materia%C5%82y" > Dodatkowe - materiały < /a></li >
    <
    /ul> <!--te-- >
    <
    h2 > Podstawy < /h2> <
p > Język Python jest językiem programowania ogólnego przeznaczenia,
    charakteryzującym się prostą składnią i dużą elastycznością.Jest
szeroko stosowany w różnych dziedzinach, od nauk ścisłych po
tworzenie aplikacji internetowych.W niniejszym artykule skupimy
się na fundamentach języka, a także na budowaniu małych programów i
pracy z strukturami danych. < /p> <
h3 > Instalacja w systemie Windows < /h3> <
p > Aby rozpocząć przygodę z Pythonem, należy najpierw przygotować
sobie odpowiednie środowisko.W tym celu najlepiej pobrać i
zainstalować oprogramowanie na swoim komputerze. < /p> <
p > Aby zainstalować Pythona w systemie Windows, musiszć wykonać
następujące kroki: < /p> <
ol >
    <
    li > Przejdź na stronę internetową < a href =
    "https://www.python.org/downloads/" > https: //www.python.org/downloads/</a>.</li>
    <
    li > W sekcji "Python Releases for Windows"
znajdź i kliknij link do
    najnowszej stabilnej wersji Pythona dla systemu Windows. < /li> <
li > Po pobraniu instalatora, uruchom go i postępuj według podanych
instrukcji. < /li> <
li > Podczas instalacji, upewnij się, że zaznaczyłeś opcję < em > Add
Python to PATH < /em>, dzięki której będziesz mógł uruchamiać Pythona
z dowolnego miejsca w systemie. < /li> <
li > Po zakończeniu instalacji, możesz uruchomić Python, wpisując w
wierszu poleceń polecenie < em > python < /em>.</li >
    <
    /ol> <
h3 > Interaktywna konsola < /h3> <
p > Konsola Pythona to interaktywne środowisko, w którym można
wpisywać i wykonywać pojedyncze polecenia.Aby otworzyć konsolę,
    należy wpisać polecenie < em > python < /em> w wierszu poleceń. Wówczas
zostanie wyświetlona informacja o wersji Pythona dostępnej w
systemie. < /p> <
pre > < code > & gt; & gt; & gt;
python
python 2.7 .13(
        default, Sep 2 2019, 20: 42: 59) <
    /code></pre >
    <
    p > Z poziomu konsoli można wykonywać wszystkie dostępne polecenia
Pythona.Po wpisaniu polecenia i naciśnięciu klawisza <
    em > Enter < /em>, zostanie ono natychmiast wykonane i zwrócony
ewentualny wynik(nie wszystkie komendy zwracają wynik).Polecenie <
    code > help < /code> pozwala uzyskać informacje o dostępnych komendach
i ich możliwych parametrach.Można również wywoływać funkcje z
bibliotek, takich jak np. < code > math.pi < /code>, która zwraca stałą
pi. < /p> <
pre > < code > & gt; & gt; & gt;
help
Type help() for interactive help, or help(object) for help about object.

    &
    gt; & gt; & gt;
3 + 4
7

    &
    gt; & gt; & gt;
print('Hello world')
Hello world

    &
    gt; & gt; & gt;
import math
    &
    gt; & gt; & gt;
math.pi
3.141592653589793
    <
    /code></pre >
    <
    h3 > Zmienne < /h3> <
p > Zmienne stanowią podstawę każdego języka programowania.Służą do
        przechowywania różnych rodzajów danych, takich jak liczby, napisy
    czy wartości logiczne.Każda zmienna ma swoją nazwę, poprzez którą
odwołujemy się do niej w programie. < /p> <
p > W Pythonie istnieją różne typy zmiennych, które odpowiadają
rodzajowi przechowywanych danych.Są to m.in. - Liczby całkowite( < em > int < /em>) - Liczby zmiennoprzecinkowe (<em>float</em > ) -
    Napisy( < em > string < /em>) - Typ logiczny (<em>bool</em > ) < /p> <
p > Nazwa zmiennej może składać się z liter i cyfr, ale nie może
zaczynać się od cyfry.Python nie ogranicza długości nazw.Dobrym
zwyczajem jest nadawanie zmiennym nazw odpowiadających ich roli w
programie.Dzięki temu nasz kod staje się bardziej czytelny i
łatwiejszy w utrzymaniu. < /p> <
p > Czy wiesz jaka liczba zostanie wypisana na konsoli w poniższym
przykładzie ? < /p> <
pre > < code > a = 3
b = a
b = 5
print(a) # ?? ?
    <
    /code></pre >
    <
    h3 > Warunki < /h3> <
p > Typ logiczny(bool) może przyjmować jedną z dwóch wartości:
    <
    code > True < /code> lub <code>False</code > .Typ logiczny ma istotne
znaczenie dla instrukcji warunkowej. < /p> <
p > Prosta zmienna typu logicznego: < /p> <
pre > < code > wiek = 18 # zmienna typu int
warunek = wiek & gt;
18 # zmienna typu bool
    <
    /code></pre >
    <
    p > Oto tabela z porównaniami dostępnymi w języku Python: < /p> <
p > | Symbol | Opis | | -- -- -- | -- -- | | & gt; | większy niż | |
    &
    gt; = | większy lub równy | | & lt; | mniejszy niż | | & lt; = |
mniejszy lub równy | | == | równy | | != | różny | < /p> <
p > Początkujący programiści często mylą pojedynczy znak równości( < code >= < /code>) z podwójnym znakiem równości
    ( < code >= = < /code>).</p >
        <
        ul >
        <
        li > < code > x = 5 < /code> oznacza przypisanie wartości 5 do zmiennej
        x. < /li> <
        li > < code > x == 5 < /code> oznacza sprawdzenie, czy zmienna x jest
        równa 5. < /li> < /
        ul > <
        p > Instrukcja warunkowa(
            if -
            else) ma następującą postać: < /p> <
        pre > < code >
        if warunek:
        kod
        else :
            kod <
            /code></pre >
            <
            p > Część kodu umieszczona w pierwszym wcięciu po instrukcji
        warunkowej < code >
        if </code> zostanie wykonana jedynie, gdy warunek
        zostanie oceniony na prawdziwy.Gdy warunek nie jest spełniony, ta część kodu zostanie całkowicie pominięta, a zamiast niej wykonany zostanie kod umieszczony w drugim wcięciu(pod instrukcjami sterującymi. < /p> <
            p > Operatory logiczne służą do łączenia warunków.W Pythonie mamy
            do dyspozycji trzy operatory logiczne: < code > and < /code>, <
            code > or < /code> i <code>not</code >: < /p> <
            ul >
            <
            li > < code > and < /code> – aby wyrażenie było prawdziwe, oba warunki
            muszą być prawdziwe. < /li> <
            li > < code > or < /code> – aby wyrażenie było prawdziwe, tylko jeden
            warunek musi być prawdziwy. < /li> <
            li > < code > not < /code> – zaprzeczenie wyrażenia.</li >
            <
            /ul> <
            p > Na przykład, wyrażenie < code > a != 0 and b == 5 < /code> będzie
            prawdziwe, jeśli oba warunki są spełnione, tzn.jeśli a jest różne od 0 i jednocześnie b jest równe 5. < /p> <
            p > Natomiast wyrażenie < code > x % 2 == 0 or x % 7 == 0 < /code> będzie
            prawdziwe, jeśli jeden z warunków jest spełniony, tzn.jeśli x jest podzielne przez 2 lub x jest podzielne przez 7. < /p> <
            p > Być może zastanawiasz się, co zostanie wypisane na konsoli w poniższym przykładzie: < /p> <
            pre > < code > odpowiedz = "TAK"
            print(odpowiedz == "tak"
                or "TAK") <
            /code></pre >
            <
            p > Wyjaśnienie: operator < code > or < /code> zwraca pierwszą wartość
            prawdziwą, jeśli taka istnieje, w przeciwnym razie zwraca drugą wartość.W tym przypadku pierwszy warunek jest fałszywy, ale drugi jest prawdziwy(bo "TAK"
                jest różne od fałszu).Z tego powodu całe wyrażenie zwraca drugi warunek, czyli wartość "TAK". < /p> <
            h3 > Pętle < /h3> <
            p > Pętle wraz z instrukcjami warunkowymi są podstawą wszystkich języków programowania.Pętle pozwalają na wielokrotne wykonanie pojedynczej instrukcji lub całego bloku instrukcji.Oprócz bloku instrukcji, każda pętla ma również warunek zakończenia.Pętla powtarza blok instrukcji, dopóki warunek kończący pętlę nie zostanie spełniony.W Pythonie mamy dwie pętle: < code > For < /code> i <
            code > While < /code>.</p >
            <
            h4 > For < /h4> <
            p > Pętla < code > For < /code> umożliwia wielokrotne wykonanie bloku
            instrukcji dla każdego elementu z danej kolekcji.Kolekcją może być np.lista, zbiór lub krotka.W przypadku pętli < code > For < /code>
            mamy pewność, że blok instrukcji zostanie wykonany określoną ilość razy, równą liczbie elementów w kolekcji.Pętla < code > For < /code>
            ogólnie ma postać: < /p> <
            pre > < code >
            for element in kolekcja:
            kod <
            /code></pre >
            <
            p > Na początek do tworzenia pętli będziemy używać funkcji range().
            Funkcja ta może przyjmować jeden, dwa lub trzy parametry. < /p> <
            ol >
            <
            li > < code > range(10) < /code> tworzy ciąg (0, 1, 2, 3, 4, 5, 6, 7, 8,
            9), więc pętla: < code >
        for x in range(10) < /code> zostanie wykonana
        10 razy. < /li> <
        li > < code > range(5, 12) < /code> tworzy ciąg (5, 6, 7, 8, 9, 10, 11),
        więc pętla: < code >
        for x in range(5, 12) < /code> zostanie wykonana 7
        razy. < /li> <
        li > < code > range(0, 50, 10) < /code> tworzy ciąg (0, 10, 20, 30, 40),
        więc pętla: < code >
        for x in range(0, 50, 10) < /code> zostanie
        wykonana 5 razy. < /li> < /
        ol > <
        p > Przykład użycia pętli < code > For < /code> z listą:</p >
        <
        pre > < code > dni_tygodnia = ['Poniedziałek', 'Wtorek', 'Środa', 'Czwartek', 'Piątek', 'Sobota', 'Niedziela']
        for dzien in dni_tygodnia:
        print(dzien) <
        /code></pre >
        <
        p > Wynikiem wykonania powyższego kodu będzie wypisanie na konsoli nazw wszystkich dni tygodnia. < /p> <
        h4 > While < /h4> <
        p > Pętla < code > While < /code> jest podobna w działaniu do pętli <
        code > For < /code>, ale istnieją również istotne różnice między
        obiema konstrukcjami.W przypadku pętli < code > While < /code> warunek
        zakończenia pętli jest sprawdzane przed każdym przejściem do
            kolejnej iteracji.Jeśli warunek nie jest spełniony, pętla zostaje
        zakończona.Dzięki temu pętla < code > While < /code> może być używana
        do wykonywania pewnych instrukcji w nieskończoność(jeśli warunek kończący pętlę zawsze jest prawdziwy). < /p> <
        p > Pętla < code > While < /code> ma postać:</p >
        <
        pre > < code >
        while warunek konczacy petle:
        kod <
        /code></pre >
        <
        p > Poniżej przedstawiony został prosty przykład użycia pętli <
        code > While < /code>:</p >
        <
        pre > < code > licznik = 0
        while licznik & lt; 5:
        print(licznik) licznik += 1 <
        /code></pre >
        <
        p > W powyższym przykładzie pętla < code > While < /code> będzie
        wykonywana do momentu, aż zmienna licznik będzie mniejsza od 5. W
        każdym obiegu pętli wyświetlana jest aktualna wartość zmiennej licznik, a następnie jej wartość zostaje zwiększona o 1. < /p> <
        p > W rezultacie, na konsoli zostaną wyświetlone kolejno liczby od 0 do 4. < /p> <
        h4 > Polecenia
        break i
        continue </h4> <
        p > Instrukcja < code >
        break </code> służy do natychmiastowego
        przerwania działania pętli.Jeśli jest ona wywołana wewnątrz pętli,
        natychmiast przechodzi do kodu znajdującego się po pętli.Może być
        ona używana w połączeniu z instrukcjami warunkowymi, aby natychmiastowo zakończyć działanie pętli. < /p> <
        p > Przykład: < /p> <
        pre > < code >
        for i in range(10):
        if i == 5:
        break print(i) <
            /code></pre >
            <
            p > W tym przykładzie pętla będzie wykonywana dla wartości zmiennej <
            em > i < /em> od 0 do 4, a następnie zostanie przerwana przez
        instrukcję < code >
        break </code>.</p >
            <
            p > Instrukcja < code >
            continue </code> jest używana w pętlach i
        powoduje przejście do następnego obiegu pętli.Wszystkie instrukcje
        umieszczone poniżej instrukcji < code >
        continue </code> w bloku pętli
        nie zostaną wykonane po jej wywołaniu.Przykład użycia instrukcji <
        code >
        continue </code>:</p >
            <
            pre > < code >
            for i in range(10):
            if i % 2 == 0: # jeśli i jest podzielne przez 2
        continue # przejdź do następnego obiegu pętli
            print(i) # wypisz i <
            /code></pre >
            <
            p > W powyższym przykładzie pętla zostanie wykonana dla wszystkich
        liczb z zakresu od 0 do 9, ale zostaną one wyświetlone jedynie w
        przypadku, gdy są nieparzyste.W rezultacie na konsoli zostaną wypisane liczby: 1, 3, 5, 7, 9. < /p> <
        h4 > Pętle zagnieżdżone < /h4> <
        p > Podobnie jak możemy zagnieżdżać instrukcje warunkowe, możemy również zagnieżdżać pętle.Pętle zagnieżdżone to pętle znajdujące się w ciele innych pętli. < /p> <
        p > Istnieją dwie zasady zagnieżdżania pętli: < /p> <
        ol >
        <
        li > pętla zewnętrzna pilnuje wysokości, < /li> <
        li > pętla wewnętrzna pilnuje szerokości. <
        pre > < code >
        for y in range(10): # wysokosc
        for x in range(5): # szerokosc kod <
        /code></pre > < /li> < /
        ol > <
        p > Pętla zewnętrzna ustawi nas w odpowiednim rzędzie, a pętla wewnętrzna na odpowiednim miejscu w danym rzędzie.Przykładowo,
        jeśli idziemy do sali kinowej i nasz bilet mówi, że przysługuje nam
        miejsce numer 5 w rzędzie numer 2, pętle zewnętrzna ustawi nas w odpowiednim rzędzie, a pętla wewnętrzna na odpowiednim miejscu. < /p> <
        p > W celu lepszego zobrazowania działania takiej konstrukcji posłużymy się graficznymi przykładami i będziemy wypisywać na konsoli różne kształty.Przykład zagnieżdżonej pętli z kształtami może być zapisany w następujący sposób: < /p> <
        pre > < code >
        for i in range(5):
        for j in range(5):
        print("*", end = "") print() <
        /code></pre >
        <
        p > W wyniku wykonania tego kodu zostanie wypisany na konsoli prostokąt z gwiazdek: < /p> <
        pre > < code > ** ** *
        **
        **
        *
        **
        **
        *
        **
        **
        *
        **
        **
        *
        <
        /code></pre >
        <
        p > Możemy również użyć zagnieżdżonych pętli, aby narysować bardziej skomplikowane kształty, takie jak trójkąty lub choinkę. < /p> <
        pre > < code >
        for i in range(5):
        for j in range(i + 1):
        print("*", end = "") print() <
        /code></pre >
        <
        p > W wyniku wykonania tego kodu zostanie wypisany na konsoli trójkąt z gwiazdek: < /p> <
        pre > < code > *
        **
        **
        *
        **
        **
        **
        **
        *
        <
        /code></pre >
        <
        h2 > Funkcje < /h2> <
        p > Funkcje są blokami instrukcji zamkniętymi pod jedną nazwą i pozwalającymi na kontrolowanie z zewnątrz poprzez przekazywanie argumentów.Definicja funkcji polega na określeniu, które instrukcje należą do ciała funkcji, ile argumentów oczekuje funkcja
        oraz jaką nazwą będzie ona wywoływana w innych miejscach kodu.Definicja sama w sobie nie uruchamia jeszcze żadnych instrukcji -
        potrzebne jest użycie nazwy funkcji wraz z wartościami argumentów w innym miejscu kodu, aby instrukcje zostały wykonane.Funkcje mają następującą postać: < /p> <
        pre > < code > def nazwa_funkcji(argumenty):
        kod # cialo funkcji <
        /code></pre >
        <
        p > Ciało funkcji może być dowolnie rozbudowane, ale zaleca się dzielenie większych funkcji na mniejsze, które mają jasno określony cel.W ten sposób zmniejsza się złożoność kodu i ułatwia jego czytanie. < /p> <
        p > Zdefiniowaną funkcję wywołujemy w kodzie poprzez jej nazwę.Przykład: < /p> <
        pre > < code > # w tym miejscu definiujemy funkcję def ryba():
        print('rybka')

        # w tym miejscu wywołujemy funkcję ryba() <
        /code></pre >
        <
        p > Funkcje mogą mieć dowolną ilość argumentów - możliwe jest stworzenie funkcji bez argumentów lub funkcji z 10 argumentami.Przykład: < /p> <
        pre > < code > def ryba(argument):
        # oczekujemy, że argument będzie liczbą naturalną
        for i in range(argument):
        print('ryba') <
        /code></pre >
        <
        p > Słowo kluczowe < code >
        return </code> powoduje opuszczenie funkcji
            (instrukcje umieszczone poniżej nie są wykonywane). <
            code >
            return </code> pozwala również na przekazanie wartości z
        wnętrza funkcji do reszty programu.Taka wartość po wywołaniu
        funkcji jest często zapisywana w zmiennej w innym miejscu programu.Na przykład: < /p> <
        pre > < code > def suma_trzech(a, b, c):
        return a + b + c

        suma_a = suma_trzech(3, 6, 2) suma_b = suma_trzech(4, 1, 7)

        print(suma_a) # wyświetli 11 print(suma_b) # wyświetli 12 <
        /code></pre >
        <
        p > Możemy również zdefiniować funkcję z domyślnymi argumentami,
        które zostaną użyte, jeśli nie zostaną przekazane żadne inne.Domyślne argumenty muszą być umieszczone po argumentach obowiązkowych, a ich ilość nie może przekroczyć ilości argumentów obowiązkowych.Przykład: < /p> <
        pre > < code > def suma_trzech(a, b, c = 0):
        return a + b + c

        suma_a = suma_trzech(3, 6) # a + b + c = 3 + 6 + 0 = 9 suma_b = suma_trzech(4, 1, 7) # a + b + c = 4 + 1 + 7 = 12

        print(suma_a) # wyświetli 9 print(suma_b) # wyświetli 12 <
        /code></pre >
        <
        p > Istnieje też sposób na zdefiniowanie funkcji z nieograniczoną liczbą argumentów obowiązkowych, przy czym nie możemy ich użyć w połączeniu z argumentami domyślnymi.Przykład: < /p> <
        pre > < code > def suma_n( * args):
        return sum(args)

        suma_a = suma_n(1, 2, 3, 4) # 1 + 2 + 3 + 4 = 10 suma_b = suma_n(10, 20, 30) # 10 + 20 + 30 = 60

        print(suma_a) # wyświetli 10 print(suma_b) # wyświetli 60 <
        /code></pre >
        <
        p > Ostatni sposób przkazywania arugmentów, to argumenty nazwane,
        które są przekazywane w postaci słownika.Przykład: < /p> <
        pre > < code > def suma_n( ** kwargs):
        return sum(kwargs.values())

        suma_a = suma_n(a = 1, b = 2, c = 3, d = 4) # 1 + 2 + 3 + 4 <
        /code></pre >
        <
        h3 > Napisy < /h3> <
        p > Napisy to typ danych tekstowych, które składają się z ciągu znaków.Nnapisy mogą być używane do wielu różnych celów, takich
        jak: < /p> <
        ul >
        <
        li > Wypisywanie tekstu na ekranie. < /li> <
        li > Przechowywanie danych tekstowych w programie. < /li> <
        li > Przetwarzanie i modyfikowanie tekstu. < /li> < /
        ul > <
        p > Możemy deklarować je używając apostrofów lub cudzysłowów. < /p> <
        pre > < code > napis = 'James'
        napis = "James"
        napis = ''
        'James'
        '' <
        /code></pre >
        <
        p > Napisy są indeksowane, co oznacza, że możemy odwołać się do
            konkretnego znaku w napisie za pomocą jego indeksu.Możemy również
        wyodrębnić fragment napisu, zwany składnią wycinka(slice). < /p> <
        pre > < code > napis = "James"
        print(napis[1]) # a print(napis[2: 5]) # mes <
        /code></pre >
        <
        p > Napisy są niemodyfikowalne, co oznacza, że nie możemy bezpośrednio zmienić poszczególnych znaków w napisie.Możemy jednak tworzyć nowe napisy na podstawie istniejących napisów, zmieniając ich zawartość lub łącząc je ze sobą. < /p> <
        pre > < code > napis = "pierwotny"
        napis = "nowy" <
        /code></pre >
        <
        p > f - string to sposób formatowania napisów w Pythonie, który pozwala na wstawienie do napisu wartości zmiennych wewnątrz tekstu.
        W celu użycia f - string, należy przed cudzysłowami postawić literkę "f", a w odpowiednim miejscu między nawiasami klamrowymi nazwę zmiennej, której chcemy użyć. < /p> <
        p > Przykład: < /p> <
        pre > < code > imie = "Jan"
        wiek = 30

        napis = f "Mam na imię {imie} i mam {wiek} lat."
        print(napis) <
        /code></pre >
        <
        p > W powyższym przykładzie zmienna "imie"
        zostanie zamieniona na "Jan", a zmienna "wiek"
        na "30".Ostatecznie w wyniku wywołania print(napis) na ekranie pojawi się napis "Mam na imię Jan i mam 30
        lat.
        ".</p> <
        p > f - string pozwala również na użycie wyrażeń arytmetycznych w napisach. < /p> <
        p > Przykład: < /p> <
        pre > < code > a = 10 b = 20

        napis = f "Suma a i b wynosi {a + b}."
        print(napis) <
        /code></pre >
        <
        p > W powyższym przykładzie zostanie wyświetlony napis "Suma a i b
        wynosi 30. ".</p> <
        h3 > Struktury danych < /h3> <
        p > Mamy do dyspozycji kilka różnych sposobów przechowywania danych.
        Te sposoby to tzw.struktury danych.Są to narzędzia, dzięki którym możemy zbierać i przechowywać duże ilości danych w sposób uporządkowany, co ułatwia nam pracę z tymi danymi. < /p> <
        p > Oto najpopularniejsze sturktury danych: < /p> <
        ul >
        <
        li > Listy: listy to uporządkowane kolekcje elementów, które mogą być dowolnego typu.Możemy do nich dodawać i usuwać elementy, a
        także zmieniać ich kolejność.W liście mogą występować duplikaty. < /li> <
        li > Krotki: krotki to podobne do list struktury, ale są one
        niezmienne.Raz utworzona krotka nie może być zmieniona.W krotkach również mogą występować duplikaty. < /li> <
        li > Zbiory: zbiory to nieuporządkowane kolekcje elementów, w których nie mogą występować duplikaty.Zbiory są szczególnie przydatne, gdy intersują nas jedynie unikalne wartości.duplikaty. < /li> <
        li > Słowniki: słowniki to indeksowane kolekcje par klucz - wartość.Wszystkie klucze w słowniku muszą być unikalne, natomiast wartości mogą być duplikatami.Słowniki są bardzo przydatne do
            przechowywania danych w formie tabeli. < /li> < /
            ul > <
            p > Oczywiście, istnieją również inne struktury danych ale te
        wymienione są najczęściej używane i najważniejsze dla początkujących. < /p> <
        h4 > Lista < /h4> <
        p > Lista jest strukturą danych służącą do przechowywania kilku
        wartości pod jedną nazwą. < /p> <
        p > Przykład listy złożonej z kilku liczb całkowitych: < /p> <
        pre > < code > lista = [3, 2, 3, 9, 10] <
        /code></pre >
        <
        p > Elementy listy nie muszą być tego samego typu: < /p> <
        pre > < code > lista = ['a', True, 0.3] <
        /code></pre >
        <
        p > Aby poznać liczbę elementów listy, należy użyć funkcji <
        code > len < /code>:</p >
        <
        pre > < code > n = len(lista) <
        /code></pre >
        <
        p > Aby dodać element a na końcu listy, użyj metody <
        code > append < /code>:</p >
        <
        pre > < code > lista.append(a) <
        /code></pre >
        <
        p > Aby dodać wszystkie elementy z listy lista2 na końcu listy lista1, użyj metody < code > extend < /code>:</p >
        <
        pre > < code > lista1.extend(lista2) <
        /code></pre >
        <
        p > Aby wstawić element a na pozycję i, użyj metody <
        code > insert < /code>:</p >
        <
        pre > < code > lista.insert(i, a) <
        /code></pre >
        <
        p > Aby usunąć pierwsze wystąpienie elementu a z listy, użyj metody <
        code > remove < /code>:</p >
        <
        pre > < code > lista.remove(a) <
        /code></pre >
        <
        p > Aby usunąć element z listy znajdujący się na pozycji i oraz zwrócić go jako wynik, użyj metody < code > pop < /code>:</p >
        <
        pre > < code > element = lista.pop([i]) <
        /code></pre >
        <
        p > Aby znaleźć liczbę wystąpień elementu a w liście, użyj metody <
        code > count < /code>:</p >
        <
        pre > < code > licznik = lista.count(a) <
        /code></pre >
        <
        p > Aby posortować listę, użyj metody < code > sort < /code>:</p >
        <
        pre > < code > lista.sort() <
        /code></pre >
        <
        p > Aby odwrócić kolejność elementów w liście, użyj metody <
        code > reverse < /code>:</p >
        <
        pre > < code > lista.reverse() <
        /code></pre >
        <
        p > Aby przy pomocy pętli przejść przez elementy listy, użyj słowa kluczowego < code >
        for < /code>:</p >
        <
        pre > < code >
        for element in lista:
        print(element) <
        /code></pre >
        <
        p > Aby otrzymać element i indeks, użyj funkcji <
        code > enumerate < /code>:</p >
        <
        pre > < code >
        for indeks, element in enumerate(lista):
        print(f '{indeks}: {element}') <
        /code></pre >
        <
        p > Aby przy pomocy pętli przejść przez elementy dwóch list równej długości, użyj funckji < code > zip < /code>:</p >
        <
        pre > < code >
        for elem_a, elem_b in zip(lista_a, lista_b):
        print(f 'element a: {elem_a}; element b: {elem_b}') <
        /code></pre >
        <
        h4 > Krotka < /h4> <
        p > Krotka to struktura danych, podobna do listy, ale niezmienna.To
        znaczy, że po utworzeniu krotki nie możemy jej zmodyfikować, np.dodając do niej nowe elementy czy usuwając już istniejące. < /p> <
        p > Krotek zamiast list, używamy gdy: * Liczy się szybkość.*Chcemy zabezpieczyć dane przed nadpisaniem. < /p> <
        p > Przykład krotki składającej się z kilku liczb całkowitych: < /p> <
        pre > < code > krotka = (3, 2, 3, 9, 10) <
        /code></pre >
        <
        p > Elementy krotki nie muszą być tego samego typu: < /p> <
        pre > < code > krotka = ('a', True, 0.3) <
        /code></pre >
        <
        p > Aby rozpakować krotkę składającą się z trzech elementów i zapisać je w trzech zmiennych, użyj: < /p> <
        pre > < code > a, b, c = krotka <
        /code></pre >
        <
        p > Aby znaleźć liczbę elementów krotki, użyj: < /p> <
        pre > < code > len(krotka) <
        /code></pre >
        <
        p > Aby przy pomocy pętli przejść przez elementy krotki, użyj: < /p> <
        pre > < code >
        for element in krotka:
        print(element) <
        /code></pre >
        <
        p > Aby otrzymać element i indeks, użyj funkcji <
        code > enumerate < /code>:</p >
        <
        pre > < code >
        for indeks, element in enumerate(krotka):
        print(f '{indeks}: {element}') <
        /code></pre >
        <
        p > Aby przy pomocy pętli przejść przez elementy dwóch krotek równej długości, użyj funckji < code > zip < /code>:</p >
        <
        pre > < code >
        for elem_a, elem_b in zip(krotka_a, krotka_b):
        print(f 'element a: {elem_a}; element b: {elem_b}') <
        /code></pre >
        <
        h4 > Zbiór < /h4> <
        p > Zbiór(ang.set) to nieuporządkowana kolekcja unikalnych elementów.Zbiory są zazwyczaj używane do eliminowania duplikatów
        lub do testowania przynależności elementu do kolekcji. < /p> <
            p > Aby utworzyć pusty zbiór, użyj: < /p> <
        pre > < code > zbior = set() <
        /code></pre >
        <
        p > Aby utworzyć zbiór z elementów podanych jako argumenty,
        użyj: < /p> <
        pre > < code > zbior = set([element1, element2, element3]) <
        /code></pre >
        <
        p > Aby utworzyć zbiór z elementów występujących w iterowalnym obiekcie(np.liście), użyj: < /p> <
        pre > < code > zbior = set(iterowalny_obiekt) <
        /code></pre >
        <
        p > Aby sprawdzić, czy element jest w zbiorze, użyj: < /p> <
        pre > < code > element in zbior <
        /code></pre >
        <
        p > Aby dodać element do zbioru, użyj: < /p> <
        pre > < code > zbior.add(element) <
        /code></pre >
        <
        p > Aby usunąć element ze zbioru, użyj: < /p> <
        pre > < code > zbior.remove(element) <
        /code></pre >
        <
        p > Aby usunąć element ze zbioru, jeśli istnieje, bez generowania błędu, użyj: < /p> <
        pre > < code > zbior.discard(element) <
        /code></pre >
        <
        p > Aby usunąć losowy element ze zbioru, użyj: < /p> <
        pre > < code > zbior.pop() <
        /code></pre >
        <
        p > Aby usunąć wszystkie elementy ze zbioru, użyj: < /p> <
        pre > < code > zbior.clear() <
        /code></pre >
        <
        p > Aby znaleźć liczbę elementów w zbiorze, użyj: < /p> <
        pre > < code > len(zbior) <
        /code></pre >
        <
        p > Aby złączyć zbiory, użyj operatora < code > | < /code>:</p >
        <
        pre > < code > zbior1 | zbior2 <
        /code></pre >
        <
        p > Aby wyświetlić elementy wspólne dla dwóch zbiorów, użyj operatora < code > & < /code>:</p >
        <
        pre > < code > zbior1 & zbior2 <
        /code></pre >
        <
        p > Aby wyświetlić elementy występujące w jednym zbiorze, ale nie w drugim, użyj operatora < code > ^ < /code>:</p >
        <
        pre > < code > zbior1 ^ zbior2 <
        /code></pre >
        <
        p > Aby wyświetlić elementy z pierwszego zbioru, ale nie z drugiego,
        użyj operatora < code > - < /code>:</p >
        <
        pre > < code > zbior1 - zbior2 <
        /code></pre >
        <
        p > Aby sprawdzić, czy zbiór jest podzbiorem innego zbioru, użyj operatora < code > & lt; = < /code>:</p >
        <
        pre > < code > zbior1 & lt; = zbior2 <
        /code></pre >
        <
        h4 > Słownik < /h4> <
        p > Słownik używamy, gdy chcemy mieć kilka wartości dostępnych pod różnymi nazwami(kluczami).Słownik jest nieuporządkowany i indeksowany. < /p> <
        p > W słowniku można używać jako kluczy dowolnych typów danych,
        które są niemutowalne(tj.nie mogą być zmieniane).Do niemutowalnych typów danych w Pythonie zaliczają się: < /p> <
        ul >
        <
        li > liczby całkowite(int) < /li> <
        li > liczby zmiennoprzecinkowe(float) < /li> <
        li > napisy(str) < /li> <
        li > krotki(tuple) < /li> < /
        ul > <
        p > Nie można natomiast używać jako kluczy mutowalnych typów danych,
        takich jak listy, zbiory lub słowniki, ponieważ nie spełniają one wymogu niemutowalności. < /p> <
        p > Przykłady poprawnych kluczy: < /p> <
        ul >
        <
        li > liczba całkowita: < code > slownik[42] < /code></li >
        <
        li > napis: < code > slownik['klucz'] < /code></li >
        <
        li > krotka: < code > slownik[(1, 2, 3)] < /code></li >
        <
        /ul> <
        p > Przykłady niepoprawnych kluczy: < /p> <
        ul >
        <
        li > lista: < code > slownik[[1, 2, 3]] < /code></li >
        <
        li > zbiór: < code > slownik {
            1,
            2,
            3
        } < /code></li >
        <
        li > słownik: < code > slownik {
            'klucz': 'wartosc'
        } < /code></li >
        <
        /ul> <
        p > Przykład słownika zawierającego kilka par klucz - wartość: < /p> <
        pre > < code > slownik = {
            'klucz1': 3,
            'klucz2': 2,
            'klucz3': 3
        } <
        /code></pre >
        <
        p > Elementy słownika nie muszą być tego samego typu: < /p> <
        pre > < code > slownik = {
            'klucz1': 'a',
            'klucz2': True,
            'klucz3': 0.3
        } <
        /code></pre >
        <
        p > Aby znaleźć liczbę elementów słownika, użyj: < /p> <
        pre > < code > len(slownik) <
        /code></pre >
        <
        p > Aby dodać element a pod kluczem 'klucz4', użyj: < /p> <
        pre > < code > slownik['klucz4'] = a <
        /code></pre >
        <
        p > Aby zmienić wartość pod kluczem 'klucz4', użyj: < /p> <
        pre > < code > slownik['klucz4'] = nowa_wartosc <
        /code></pre >
        <
        p > Aby usunąć element pod kluczem 'klucz4', użyj: < /p> <
        pre > < code > del slownik['klucz4'] <
        /code></pre >
        <
        p > Aby sprawdzić czy klucz 'klucz4'
        istnieje w słowniku, użyj: < /p> <
        pre > < code > 'klucz4' in slownik <
        /code></pre >
        <
        p > Aby przy pomocy pętli przejść przez elementy słownika, użyj: < /p> <
        pre > < code >
        for klucz, wartosc in slownik.items():
        print(f '{klucz}: {wartosc}') <
        /code></pre >
        <
        p > Aby przy pomocy pętli przejść tylko przez klucze słownika,
        użyj: < /p> <
        pre > < code >
        for klucz in slownik:
        print(klucz) <
        /code></pre >
        <
        p > Aby przy pomocy pętli przejść tylko przez wartości słownika,
        użyj: < /p> <
        pre > < code >
        for wartosc in slownik.values():
        print(wartosc) <
        /code></pre >
        <
        h3 > Enum < /h3> <
        p > Enum(od słowa enumerate - numerować) to specjalny typ danych,
        który pozwala na tworzenie stałych symbolicznych nazw dla wartości.W przeciwieństwie do zwykłych stałych, wartości Enumów są
        obiektami, a nie prostymi wartościami.Enum jest szczególnie przydatny, gdy chcemy przypisać nazwy symboliczne do wartości
        liczbowych. < /p> <
        p > Wewnątrz definicji klasy Enum tworzymy atrybuty klasy, które będą reprezentować nasze stałe symboliczne.Wartości atrybutów są automatycznie przypisane do kolejnych liczb całkowitych, począwszy
        od 1. Możemy również przypisać im jawnie określoną wartość. < /p> <
        p > Przykład definicji Enum dla kolorów: < /p> <
        pre > < code > class Kolor(enum.Enum):
        ZIELONY = enum.auto() CZERWONY = enum.auto() NIEBIESKI = enum.auto()

        kolor_a = Kolor.ZIELONY kolor_b = Kolor.CZERWONY

        print(kolor_a.name) # ZIELONY print(kolor_a.value) # 1

        print(kolor_b.name) # CZERWONY print(kolor_b.value) # 2 <
        /code></pre >
        <
        h3 > Liczby losowe < /h3> <
        p > Liczby losowe są często potrzebne w programach, gdyż umożliwiają symulację różnych zjawisk.W Pythonie do generowania liczb losowych
        można użyć modułu < code > random < /code>. Zawiera on wiele przydatnych
        funkcji, takich jak < code > random.random() < /code> czy <
        code > random.uniform(a, b) < /code>, które pozwalają na wylosowanie
        liczby zmiennoprzecinkowej z odpowiedniego przedziału.Możliwe jest również losowanie liczb całkowitych za pomocą funkcji <
        code > random.randint(a, b) < /code>.</p >
        <
        ul >
        <
        li > < code > random.random() < /code> wylosuje liczbę zmiennoprzecinkową
        z przedziału od < em > 0 < /em> do <em>1</em > . < /li> <
        li > < code > random.uniform(a, b) < /code> wylosuje liczbę
        zmiennoprzecinkową z przedziału od < em > a < /em> do <em>b</em > . < /li> <
        li > < code > random.randint(a, b) < /code> wylosuje liczbę całkowitą z
        przedziału od < em > a < /em> do <em>b</em > . < /li> < /
        ul > <
        p > Rozkład prawdopodobieństwa opisuje, jakie wartości są bardziej prawdopodobne, a jakie mniej prawdopodobne w losowaniu.Najprostszym przykładem rozkładu prawdopodobieństwa jest rozkład jednostajny, gdzie prawdopodobieństwo wystąpienia dowolnej wartości w przedziale < code > [a, b] < /code> jest stałe. Wartość gęstości
        prawdopodobieństwa poza tym przedziałem wynosi 0. < /p> <
        p > Innym rodzajem rozkładu jest rozkład Gaussa, gdzie wartości zbliżone do średniej mają znacznie większe prawdopodobieństwo
        wystąpienia niż te oddalone od średniej.Wartości tego rodzaju rozkładu są często wykorzystywane w symulacjach, gdyż przy wpływie wielu czynników rozkład prawdopodobieństwa jest zazwyczaj zbliżony do krzywej Gaussa, co opisuje centralne twierdzenie graniczne.
        "</p> <
        ul >
        <
        li > < code > random.gauss(mu, sigma) < /code> - losuje liczbę z rozkładu
        normalnego o średniej < code > mu < /code> i odchyleniu standardowym <
        code > sigma < /code>.</li >
        <
        li > < code > random.expovariate(lambd) < /code> - losuje liczbę z
        rozkładu wykładniczego o parametrze < code > lambd < /code>.</li >
        <
        li > < code > random.weibullvariate(alpha, beta) < /code> - losuje liczbę
        z rozkładu Weibulla o parametrach < code > alpha < /code> i <
        code > beta < /code>.</li >
        <
        li > < code > random.vonmisesvariate(mu, kappa) < /code> - losuje liczbę
        z rozkładu von Misesa o parametrach < code > mu < /code> i <
        code > kappa < /code>.</li >
        <
        /ul> <
        p > Przykład użycia: < /p> <
        pre > < code >
        import random

        # losowanie liczb z rozkładu normalnego o średniej 0 i odchyleniu standardowym 1 samples = [random.gauss(0, 1) for _ in range(10)] print(samples)

        # losowanie liczb z rozkładu wykładniczego o parametrze 0.5 samples = [random.expovariate(0.5) for _ in range(10)] print(samples) <
        /code></pre >
        <
        h2 > Średniozaawansowane < /h2> <
        p > Ten artykuł jest skierowany do osób, które już zdobyły
        podstawowe umiejętności w programowaniu w języku Python.Omawiane zagadnienia obejmują bardziej zaawansowane tematy, takie jak klasy i programowanie obiektowe, tworzenie własnych struktur danych,
        programowanie funkcyjne oraz mechanizmy takie jak wątki, wyjątki,
        iteratory, generatory i dekoratory. < /p> <
        h3 > Klasy i obiekty < /h3> <
        p > Klasa to abstrakcyjny model, który definiuje jakiś zestaw cech i zachowań.Obiekt to konkretna instancja klasy.Możemy tworzyć dowolne klasy, niemniej jednak należy zastanowić się nad tym, jakie dane najlepiej byłoby trzymać razem pod jednym pojemnikiem oraz jakie funkcje mogą być przydatne do pracy z tymi danymi. < /p> <
        p > Przykład: < /p> <
        pre > < code > class Osoba:
        def __init__(self, imie, nazwisko):
        self.imie = imie self.nazwisko = nazwisko

        def przedstaw_sie(self):
        print("Cześć, jestem " + self.imie + " " + self.nazwisko)

        osoba = Osoba("Jan", "Kowalski") # kazdy obiekt ma niezalezne wartosci zmiennych inna_osoba = Osoba("Adam", "Nowak") # obiket inna_osoba jest niezalezny od obiektu osoba osoba.przedstaw_sie() inna_osoba.przedstaw_sie() <
        /code></pre >
        <
        p > W powyższym przykładzie tworzymy klasę Osoba, która posiada dwa pola danych: imie i nazwisko.Klasa ta zawiera również funkcję przedstaw_sie, która wyświetla komunikat z imieniem i nazwiskiem osoby.Następnie tworzymy dwa obiekty klasy Osoba i wywołujemy dla nich metodę przedstaw_sie. < /p> <
        h4 > Dostęp do zmiennych w obiektach < /h4> <
        p > W programowaniu obiektowym, zmienne przechowywane są w obiektach.Aby uzyskać dostęp do tych zmiennych, należy podać nazwę
        obiektu, następnie kropkę i nazwę zmiennej, którą chcemy odczytać. < /p> <
        pre > < code > nazwa_obiektu.nazwa_zmiennej <
        /code></pre >
        <
        p > Możliwe jest również modyfikowanie wartości tych zmiennych tak,
        jak w przypadku zwykłych zmiennych. < /p> <
        pre > < code > osoba = Osoba("Jan", "Kowalski") print(osoba.imie) # Zostanie wyswietlone Jan osoba.imie = "Adam"
        print(osoba.imie) # Zostanie wyswietlone Adam <
        /code></pre >
        <
        p > Możemy również użyć dekoratorów < code > @property < /code> i <
        code > @nazwa_zmiennej.setter < /code>, aby wywoływać funkcje przy
        odczycie lub modyfikacji wartości zmiennych przechowywanych w obiektach. < /p> <
        pre > < code > class Osoba:
        def __init__(self, imie, nazwisko):
        self._imie = imie # utarlo sie ze nazwy zmiennych dla ktorych zdefiniowane jest @property self._nazwisko = nazwisko # oraz odpowiadajacy setter zaczynaja sie od podkreslnika

        @property def imie(self):
        print('Ktos probuje odczytac imie') return self._imie

        @imie.setter def imie(self, nowa_wartosc):
        print('Ktos modyfikuje imie') self._imie = nowa_wartosc <
        /code></pre >
        <
        p > Klasa Osoba posiada dwa atrybuty - imie oraz nazwisko.Zostały one oznaczone jako prywatne, poprzez dodanie podkreślnika na początku nazwy.Służy to do oznaczenia, że te atrybuty nie powinny
        być bezpośrednio modyfikowane lub odczytywane przez użytkownika klasy, lecz powinny być dostępne tylko poprzez odpowiednie metody. < /p> <
        p > Za pomocą dekoratorów < code > @property < /code> oraz <
        code > @imie.setter < /code> zostały zdefiniowane metody do odczytu
        oraz modyfikacji atrybutu imie.W momencie próby odczytu wartości atrybutu imie zostanie wyświetlony komunikat "Ktoś próbuje odczytać
        imię " oraz zostanie zwrócona jego wartość. Podobnie, w momencie
        próby modyfikacji atrybutu imie zostanie wyświetlony komunikat "Ktoś modyfikuje imię"
        oraz zostanie zmieniona jego wartość. < /p> <
        h4 > Pola i metody statyczne < /h4> <
        p > Pola i metody statyczne są używane w programowaniu obiektowym,
        ale nie należą one do konkretnych obiektów - należą do całej klasy.
            Pola statyczne to wszystkie pola zdefiniowane w klasie, natomiast
        metody statyczne są tworzone za pomocą dekoratora <
        code > @staticmethod < /code>. Dostęp do pól i metod statycznych
        możliwy jest zarówno poprzez nazwę klasy, jak i nazwę obiektu klasy. < /p> <
        pre > < code > class Czlowiek:
        liczba_glow = 1

        @staticmethod def wyswietl_glowy():
        print(f 'Liczba glow: {Czlowiek.liczba_glow}')

        Czlowiek.wyswietl_glowy() # Liczba glow: 1

        przykladowy_czlowiek = Czlowiek() przykladowy_czlowiek.wyswietl_glowy() # Liczba glow: 1 <
        /code></pre >
        <
        p > Metody klasowe to rozszerzenie metod statycznych - są tworzone za pomocą dekoratora < code > @classmethod < /code>. Pierwszym
        parametrem metod klasowych jest < code > cls < /code>, a nie <
        code > self < /code>, jak w przypadku metod obiektowych. Metody
        klasowe są przydatne, gdy chcemy uzyskać dostęp do pól klasy lub do
                innych metod klasy. < /p> <
            pre > < code > class Czlowiek:
            liczba_glow = 1

        @classmethod def wyswietl_glowy(cls):
        print(f 'Liczba glow: {Czlowiek.liczba_glow}')

        def zwykla_funkcja(self):
        self.wyswietl_glowy()

        Czlowiek.wyswietl_glowy() # Liczba glow: 1

        przykladowy_czlowiek = Czlowiek() przykladowy_czlowiek.wyswietl_glowy() # Liczba glow: 1 przykladowy_czlowiek.zwykla_funkcja() # Liczba glow: 1 <
        /code></pre >
        <
        p > Klasa < code > Czlowiek < /code> zawiera pole statyczne <
        code > liczba_glow < /code> oraz metodę klasową <
        code > wyswietl_glowy() < /code>. Metoda ta wyświetla wartość pola <
        code > liczba_glow < /code> przy pomocy f-stringów. Metoda <
        code > zwykla_funkcja() < /code> jest zwykłą metodą instancyjną i
        wywołuje metodę klasową < code > wyswietl_glowy() < /code>. Można się do
        niej odwołać zarówno poprzez nazwę klasy, jak i nazwę obiektu.W przykładzie są przedstawione trzy sposoby wywołania tej metody:
        bezpośrednio z poziomu klasy, z poziomu obiektu oraz z poziomu metody instancyjnej.W każdym przypadku wyświetlona zostanie wartość zmiennej < code > liczba_glow < /code>.</p >
        <
        h3 > Referencje i kopiowanie < /h3> <
        p > Dwa niezwykle istotne pojęcia w programowaniu to "referencja"
        i "kopiowanie".Referencja to odwołanie do oryginalnego obiektu, a
        kopiowanie to tworzenie nowego obiektu z tą samą zawartością co oryginalny.W języku Python przekazywanie obiektów do funkcji lub
        przypisywanie ich do nowych nazw odbywa się poprzez referencje.To
        oznacza, że zarówno oryginalny obiekt, jak i nowy obiekt będą wskazywać na to samo miejsce w pamięci.Wszelkie zmiany wprowadzone w jednym obiekcie będą widoczne również w drugim. < /p> <
        pre > < code > lista = [
            [1, 2, 3],
            [4, 5, 6]
        ] nowa_lista = lista

        nowa_lista.append([-1, -2, -3]) # modyfikuje obie listy nowa_lista[0].insert(1, 1) # modyfikuje obie listy print(lista) <
        /code></pre >
        <
        p > Aby uniknąć takiej sytuacji, możemy skorzystać z kopiowania płytkiego lub głębokiego. < /p> <
        ol >
        <
        li > Kopiowanie płytkie < /li> < /
        ol > <
        p > Kopiowanie płytkie pozwoli na utworzenie nowego obiektu dla zewnętrznej struktury danych, ale wewnętrzne struktury danych będą przekazywane przez referencję.W naszym przykładzie z listą 2 d,
        kopiowanie płytkie utworzy nowy obiekt dla zewnętrznej listy, ale wewnętrzne listy będą przekazane przez referencję. < /p> <
        pre > < code >
        import copy lista = [
            [1, 2, 3],
            [4, 5, 6]
        ] nowa_lista = copy.copy(lista)

        nowa_lista.append([-1, -2, -3]) # modyfikuje jedynie nowa liste nowa_lista[0].insert(1, 1) # modyfikuje obie listy print(lista) <
        /code></pre >
        <
        ol >
        <
        li > Kopiowanie głębokie < /li> < /
        ol > <
        p > Kopiowanie głębokie pozwoli natomiast na utworzenie nowych obiektów dla zarówno zewnętrznej, jak i wewnętrznych struktur danych. < /p> <
        pre > < code >
        import copy lista = [
            [1, 2, 3],
            [4, 5, 6]
        ] nowa_lista = copy.deepcopy(lista)

        nowa_lista.append([-1, -2, -3]) # modyfikuje jedynie nowa liste nowa_lista[0].insert(1, 1) # modyfikuje jedynie nowa liste print(lista) <
        /code></pre >
        <
        h3 > Czyste funkcje i skutki uboczne < /h3> <
        p > NW przeciwieństwie do funkcji produkujących skutki uboczne,
            czyste funkcje nie wpływają na środowisko poza swoim zasięgiem. < /p> <
        p > Skutki uboczne to m.in.*Zmiany w plikach.*Zmiany w bazie danych.*Wysyłanie informacji przez sieć.*Zmiany w globalnych zmiennych. < /p> <
        p > Przykłady czystych funkcji to: < /p> <
        ul >
        <
        li > Funkcja zwracająca wartość pola trójkąta na podstawie jego boków. < /li> <
        li > Funkcja zwracająca iloczyn elementów w liscie. < /li> <
        li > Funkcja zwracająca największy element w liscie. < /li> <
        li > Funkcja zwracająca nową listę z liczbami parzystymi z oryginalnej listy. < /li> <
        li > Funkcja zwracająca nowy słownik z tylko niektórymi kluczami z oryginalnego słownika. < /li> <
        li > Funkcja zwracająca nowy napis z dużymi literami z oryginalnego napisu. < /li> < /
        ul > <
        p > Czyste funkcje najlepiej pracują z niemutowalnymi obiektami.Można zaimplementować czystą funkcję także z użyciem mutowalnych obiektów, o ile nie modyfikujemy ich stanu podczas działania funkcji.Ważne jest, aby czysta funkcja nie powodowała żadnych skutków ubocznych, czyli żadnych zmian w stanie obiektów poza wartościami, które zwraca. < /p> <
        p > Obiekty mutowalne to obiekty, które po utworzeniu można zmienić.W Pythonie obiekty mutowalne to np.listy, słowniki i zbiory(set).Obiekty mutowalne są niebezpieczne, ponieważ ich stan może zostać zmieniony w nieoczekiwany sposób, dlatego lepiej preferować obiekty niemutowalne, które zapewniają większe bezpieczeństwo, choć za cenę mniejszej wydajności.Aby zwiększyć bezpieczeństwo, lepiej stosować funkcje, które zamiast modyfikować stan obiektów mutowalnych,
        zwracają nowy obiekt, nie ruszając przekazanych jako parametry obiektów. < /p> <
        p > Przykłady obiektów mutowalnych: < /p> <
        pre > < code > lista = [1, 2, 3] lista.append(4) print(lista) #[1, 2, 3, 4]

        slownik = {
            'klucz': 'wartosc'
        }
        slownik['nowy_klucz'] = 'nowa_wartosc'
        print(slownik) # {
            'klucz': 'wartosc',
            'nowy_klucz': 'nowa_wartosc'
        }

        zbior = {
            1,
            2,
            3
        }
        zbior.add(4) print(zbior) # {
            1,
            2,
            3,
            4
        } <
        /code></pre >
        <
        p > Przykłady obiektów niemutowalnych: < /p> <
        pre > < code > liczba = 5 liczba = 6 # możemy zmienić wartość zmiennej, ale nie możemy zmienić samej liczby

        napis = 'napis'
        napis[1] = 'a'
        # nie możemy zmienić poszczególnych znaków w napisie

        krotka = (1, 2, 3) krotka[1] = 4 # nie możemy zmienić wartości elementów w krotce <
        /code></pre >
        <
        h3 > Dziedziczenie i kompozycja < /h3> <
        p > Dziedziczenie i kompozycja to dwie techniki pozwalające na użycie kodu z innych klas w nowo tworzonej klasie.Dziedziczenie kopiuje wszystkie elementy z klasy nadrzędnej do klasy podrzędnej i
        pozwala na bezpośredni dostęp do pól i metod klasy nadrzędnej oraz
        możliwość zmiany ich definicji w klasie podrzędnej.Jest to używane, gdy nowa klasa jest specjalnym rodzajem już istniejącej klasy. < /p> <
        pre > < code > class Czlowiek:
        def __init__(self, imie: str, nazwisko: str, miejsce_urodzenia: str, zawod: str):
        self.imie = imie self.nazwisko = nazwisko self.miejsce_urodzenia = miejsce_urodzenia self.zawod = zawod

        def __str__(self):
        return f "{self.imie} {self.nazwisko} {self.miejsce_urodzenia} {self.zawod}"


        class Student(Czlowiek):
        def __init__(self, imie: str, nazwisko: str, miejsce_urodzenia: str, numer_albumu: int, kierunek_studiow: str):
        super().__init__(imie, nazwisko, miejsce_urodzenia, 'student') self.numer_albumu = numer_albumu self.kierunek_studiow = kierunek_studiow

        def __str__(self):
        return f "{super().__str__()} {self.numer_albumu} {self.kierunek_studiow}"

        def __repr__(self):
        return f "{super().__repr__()} {self.numer_albumu} {self.kierunek_studiow}" <
            /code></pre >
            <
            p > W powyższym przykładzie, klasa < code > Człowiek < /code> jest klasą
        nadrzędną, a klasa < code > Student < /code> jest klasą podrzędną. Klasa <
        code > Student < /code> dziedziczy po klasie <code>Człowiek</code > , co oznacza, że posiada wszystkie pola i metody zdefiniowane w klasie <
        code > Człowiek < /code>. Może również zmienić definicję metod z klasy
        nadrzędnej poprzez nadpisanie ich w klasie podrzędnej.W tym przykładzie, klasa < code > Student < /code> nadpisuje metodę <
        code > str() < /code> klasy <code>Człowiek</code > , aby dodać dodatkowe informacje o numerze albumu i kierunku studiów studenta.Klasa <
        code > Student < /code> również nadpisuje metodę <code>repr()</code >
        klasy Człowiek, co oznacza, że jej reprezentacja tekstowa będzie również zawierać te dodatkowe informacje. < /p> <
        p > Kompozycja zaś polega na umieszczeniu obiektu jednej klasy jako pola w innej klasie.W nowo definiowanej klasie nie ma bezpośredniego dostępu do pól ani metod klasy skomponowanej, ale
        można do nich dotrzeć poprzez instancję tej klasy.Kompozycja jest
        używana, gdy nowa klasa reprezentuje całość, której istniejąca klasa jest częścią. < /p> <
        pre > < code > class Pensja:

        def __init__(self, pensja: int, stopa_podwyzki: float):
        self.pensja = pensja self.stopa_podwyzki = stopa_podwyzki

        def __str__(self):
        return f "Pensja: {self.pensja}, stopa podwyzki: {self.stopa_podwyzki}"

        class Pracownik:

        def __init__(self, imie: str, nazwisko: str, pensja: Pensja):
        self.imie = imie self.nazwisko = nazwisko self.pensja = pensja # kompozycja, pensja jest czescia pracownika

        def __str__(self):
        return f "Pracownik: {self.imie} {self.nazwisko}, zarabia rocznie: {self.pensja.roczna_pensja()}" <
            /code></pre >
            <
            p > Ten przykład ilustruje kompozycję, gdzie klasa <
            code > Pracownik < /code> zawiera instancję klasy <code>Pensja</code >
            jako jedno z pól.W klasie < code > Pracownik < /code> mamy metodę <
        code > roczna_pensja < /code>, która zwraca wartość zapisaną w polu
        pensja pomnożoną przez stopę podwyżki.Klasa < code > Pracownik < /code>
        nie ma bezpośredniego dostępu do pól lub metod klasy <
            code > Pensja < /code>, ale może je użyć poprzez instancję tej klasy
        zapisaną w polu pensja.W ten sposób nowo definiowana klasa <
        code > Pracownik < /code> reprezentuje pewną całość, w której
        istniejąca klasa < code > Pensja < /code> jest jej częścią.</p >
        <
        h3 > Wyrażenia regularne < /h3> <
        p > Wyrażenia regularne to sposób na wyszukiwanie tekstu w oparciu o wzorce.Możemy używać ich do wyszukiwania wzorców w ciągach znaków,
            ale także do zastępowania znalezionych wzorców innymi ciągami
            znaków.Możemy również używać wyrażeń regularnych do sprawdzania,
                czy ciąg znaków spełnia określone kryteria(np.czy jest to adres e - mail).Typowym zadaniem dla wyrażeń regularnych to Przykładowo
            znalezienie wszystkich słów zaczynających się od < em > abc < /em> lub
        składających się wyłącznie z małych liter oraz cyfr parzystych. < /p> <
        p > Powiedzmy, że mamy plik gdzie każdy wiersz zawiera trzy informacje oddzielone ukośnikami: nazwisko pracownika, datę odczytu, oraz odczyt licnzika.Jak wyciągnąć datę z każdego wiersza ? Używając klasycznych funkcji znanej nam klasy <
        code > String < /code> moglibyśmy to zrobić w taki sposób:</p >
        <
        pre > < code > dane = 'Kowalski/Maj 15, 1983/1721.3'
        pracownik, data, odczyt = dane.split('/') miesiac, dzien, rok = data.split(' ') if dzien[-1] == ',' :
        dzien = dzien[: -1]

        print(f '{miesiac}, {dzien}, {rok}') # Maj, 15, 1983 <
        /code></pre >
        <
        p > Rozwiązanie działa, ale nie należy do najpiękniejszych.Co
        gorsza, jest bardzo kruche.Cokolwiek zmieni się w naszych danych,
        musimy przerabiać nasz algorytm.Za każdym razem musimy być bardzo uważni i rozumieć każdy wiersz kodu.W takim podejściu bardzo łatwo popełnić błąd.Istnieje jednak inna metoda.Wyrażenia regularne są deklaratywne, tzn.mówimy co chcemy mieć, a nie w jaki sposób. < /p> <
        pre > < code >
        import re

        dane = 'Kowalski/Maj 15, 1983/1721.3'
        match = re.search('(.*)/(.*)/(.*)', dane) data = match.group(2) # czesc tekstu odpowiadajaca drugiemu nawiasowi data = re.sub('[^\w\s]', '', data) # usun znaki interpunkcyjne miesiac, dzien, rok = re.split('[\s/]', data) # rozbij przy pomocy spacji

        print(f '{miesiac}, {dzien}, {rok}') # Maj, 15, 1983 <
        /code></pre >
        <
        p > Aby użyć wyrażeń regularnych, musimy najpierw zaimportować moduł <
        code > re < /code>. Następnie możemy użyć różnych funkcji modułu <
        code > re < /code>, takich jak <code>search</code > , < code > sub < /code>, <
        code > split < /code>, itd. Funkcja <code>search</code > służy do
            wyszukiwania wzorca w ciągu znaków, a funkcja < code > sub < /code> do
        zastępowania znalezionych wzorców innymi ciągami znaków.Funkcja <
        code > split < /code> służy do podziału ciągu znaków na fragmenty w
        oparciu o wzorzec. < /p> <
        p > Wyrażenia regularne składają się z ciągów znaków oraz specjalnych znaków.Specjalne znaki służą do określania rodzaju
        znaków, które chcemy znaleźć.Na przykład, znak "<code>.</code>"
        oznacza dowolny znak, a znak "<code>*</code>"
        oznacza dowolną ilość powtórzeń poprzedzającego znaku.Możemy również używać nawiasów kwadratowych, by określić zbiór znaków, które chcemy znaleźć.Na przykład, "<code>[0123456789]</code>"
        oznacza dowolną cyfrę, a "<code>[a-zA-Z]</code>"
        oznacza dowolną literę. < /p> <
        h4 > Znaki specjalne < /h4> <
        p > Oto lista najważniejszych znaków specjalnych, które warto znać: < /p> <
        ul >
        <
        li > < code > . < /code> - dowolny znak (oprócz nowego wiersza)</li >
        <
        li > < code > \d < /code> - cyfra</li >
        <
        li > < code > \D < /code> - dowolny znak, który nie jest cyfrą</li >
        <
        li > < code > \s < /code> - biały znak (spacja, tabulacja, nowy
        wiersz) < /li> <
    li > < code > \S < /code> - dowolny znak, który nie jest białym
    znakiem < /li> <
    li > < code > \w < /code> - dowolny znak alfanumeryczny (małe i duże
    litery, cyfry, znak podkreślenia) < /li> <
li > < code > \W < /code> - dowolny znak, który nie jest znakiem
alfanumerycznym < /li> <
li > < code > [] < /code> - zbiór, np. <code>[abc]</code > oznacza a, b
lub c < /li> <
li > < code > ^ < /code> - początek wiersza</li >
    <
    li > < code > $ < /code> - koniec wiersza</li >
    <
    li > < code > | < /code> - lub, np. <code>abc|def</code > oznacza a, b, c
lub d, e, f < /li> <
li > < code > () < /code> - grupa, np. <code>(abc){3}</code > oznacza a,
    b, c trzy razy < /li> <
li > -powtórzenie dowolne razy, np. < code > a < /code> oznacza 0 lub
więcej wystąpień a < /li> <
li > < code > + < /code> - powtórzenie co najmniej raz, np. <
code > a + < /code> oznacza 1 lub więcej wystąpień a</li >
    <
    li > < code > ? < /code> - powtórzenie 0 lub 1 raz, np. <code>a?</code >
    oznacza 0 lub 1 wystąpienie a < /li> <
li > < code > {
    m,
    n
} < /code> - powtórzenie od m do n razy, np. <
code > a {
        2,
        4
    } < /code> oznacza 2, 3 lub 4 wystąpienia a</li >
    <
    /ul> <
p > Oczywiście to tylko wybrane przykłady. < /p> <
h4 > Schemat pracy z wyrażeniami regularnymi < /h4> <
p > Omówimy teraz, jak krok po kroku przeprowadzić wszystkie
czynności potrzebne do użycia wyrażeń regularnych w rozwiązaniu
danego problemu.Oto krótki opis schematu: < /p> <
ol >
    <
    li > Zbuduj najprostszą wersję wyrażenia regularnego pasującą do
        twojego problemu. < /li> <
    li > Przetestuj czy wyrażenie regularne znajduje TYLKO to, co
chcesz, by zostało znalezione.Łatwo o wynik fałszywie
pozytywny. < /li> <
li > Upewnij się, że wyrażenie regularne zwraca wszystkie niezbędne
grupy.Pamiętaj, że grupy są oznaczone przez nawiasy <
    code > () < /code>.</li >
    <
    li > Poszerz rozwiązanie bazowe o dodatkowe wymogi. < /li> <
li > Upewnij się, że twój kod działa poprawnie dla różnych
przypadków testowych. < /li> < /
    ol > <
    p > Pamiętaj, że wyrażenia regularne mogą być skomplikowane i trudne
do zrozumienia.Ważne jest, aby dobrze zrozumieć schemat pracy z
nimi i systematycznie testować działanie wyrażenia przed użyciem go
w kodzie. < /p> <
h3 > Wyjątki < /h3> <
p > Wyjątkami nazywamy sytuacje, które uniemożliwiają poprawne
wykonanie danego bloku kodu.Tym samym terminem określany jest
również mechanizm języka Python pozwalający na radzenie sobie z
tymi sytuacjami. < /p> <
p > W Pythonie istnieje szereg wyjątków zdefiniowanych w
standardzie, takich jak < code > ZeroDivisionError < /code>, który
występuje, gdy próbujemy dzielić liczbę przez 0. < /p> <
pre > < code > print(5 / 0) <
    /code></pre >
    <
    p > Możemy również sami wywołać wyjątek, np.: < /p> <
pre > < code > raise ValueError("Podano nieprawidlowa wartosc") <
    /code></pre >
    <
    p > Uwaga, nic nie chroni nas przed wywołaniem wyjątku w
nieodpowiednim miejscu.Naszym zadaniem jest dbanie o to, aby
wywołanie wyjątku było wykonane w odpowiedniej sytuacji. < /p> <
h4 > Obsługa wyjątków < /h4> <
p > Obsługa wyjątków polega na zapobieżeniu zatrzymaniu programu w
przypadku wystąpienia nieoczekiwanej sytuacji.Jest to szczególnie
ważne w programach, które działają "w tle"
i nie są
interaktywne. < /p> <
p > Aby obsłużyć wyjątek, używamy bloku < code >
    try / except < /code>. W
bloku
try umieszczamy kod, który może spowodować wystąpienie
wyjątku.W przypadku wystąpienia wyjątku, wykonywany jest kod
znajdujący się w bloku except. < /p> <
p > Oto przykład obsługi wyjątku < code > ZeroDivisionError < /code>:</p >
    <
    pre > < code >
    try:
    print(5 / 0)
except ZeroDivisionError:
    print("Nie można dzielić przez zero") <
    /code></pre >
    <
    p > Wyjątek informuje nas o błędzie i nie powinniśmy go ignorować.Z
tego powodu nigdy nie umieszczaj < code > pass < /code> w bloku <
code > except < /code>.</p >
    <
    p > Możemy również obsłużyć wyjątek, który jest podklasą innego
wyjątku. < /p> <
pre > < code >
    try:
    print(int("abc"))
except ValueError:
    print("Nie można zamienić tekstu na liczbę") <
    /code></pre >
    <
    p > Istnieje opcja obsługi kilku różnych wyjątków w jednym bloku <
    code >
    try / except < /code>. W takim wypadku, musimy umieścić osobny
blok < code > except < /code> dla każdego z nich.</p >
    <
    pre > < code >
    try:
    print(5 / 0)
print(int("abc"))
except ZeroDivisionError:
    print("Nie można dzielić przez zero")
except ValueError:
    print("Nie można zamienić tekstu na liczbę") <
    /code></pre >
    <
    p > Jeśli chcemy obsłużyć wiele różnych wyjątków w jednym bloku,
    możemy umieścić ich nazwy po przecinku.Możemy też użyć wyjątku
ogólnego, np. < code > Exception < /code>, ale nie jest to zalecane,
ponieważ nie wiemy, jaki konkretny wyjątek wystąpił. < /p> <
pre > < code >
    try:
    # kod, ktory moze wywolac wyjatek
except(ValueError, TypeError):
    # kod, ktory zostanie wykonany w przypadku wystapienia wyjatku ValueError lub TypeError <
    /code></pre >
    <
    p > Możemy również zapisać wyjątek do zmiennej i użyć go w bloku <
        code > except < /code>.</p >
        <
        pre > < code >
        try:
        print(5 / 0)
    except ZeroDivisionError as e:
    print(f "Wystąpił wyjątek: {e}") <
    /code></pre >
    <
    p > Blok < code >
    else </code> jest opcjonalny i wykonywany jest, jeśli
nie wystąpił żaden wyjątek w bloku < code >
    try < /code>. Możemy go
wykorzystać do wykonania kodu, który ma być wykonany po prawidłowym
wykonaniu bloku
try.W przeciwieństwie do bloku except, blok
else
    nie przyjmuje argumentów. < /p> <
p > Blok < code >
    finally < /code> jest również opcjonalny, ale zawsze
wykonywany bez względu na to, czy wystąpił wyjątek czy nie.Może
być używany do wykonania kodu, który ma być wykonany zawsze,
    niezależnie od tego, czy wystąpił wyjątek czy nie.Może być
przydatny, gdy chcemy zamknąć plik lub połączenie z bazą danych po
zakończeniu pracy z nim. < /p> <
h4 > Własny wyjątek < /h4> <
p > Możemy również tworzyć własne wyjątki.Nasz wyjątek musi
dziedziczyć po klasie < code > Exception < /code> lub jednej z jej
podklas. < /p> <
pre > < code > class MojaWyjatkowaSytuacja(Exception):
    def __init__(self, value):
    self.value = value

def __str__(self):
    return repr(self.value) <
        /code></pre >
        <
        p > Możemy zgłosić nasz wyjątek za pomocą słowa kluczowego <
        code > raise < /code>.</p >
        <
        pre > < code > raise MojaWyjatkowaSytuacja("To jest moj wyjatek") <
        /code></pre >
        <
        p > Załóżmy, że chcemy sprawdzić czy liczba jest parzysta, gdyż
tylko taka liczba może zostać użyta w dalszej części programu. < /p> <
pre > < code > def sprawdz_parzystosc(liczba):
    if liczba % 2 != 0:
    raise ValueError("Podano nieparzysta liczbe")
else :
    return True <
        /code></pre >
        <
        p > Możemy użyć tej funkcji w taki sposób: < /p> <
pre > < code >
    try:
    sprawdz_parzystosc(5)
except ValueError as v:
    print(v)
else :
    print("Liczba jest parzysta") <
    /code></pre >
    <
    p > Wyświetlona zostanie informacja o błędzie "Podano nieparzysta
liczbe ".</p> <
h4 > Wyjątki jako mechanizm przepływu sterowania < /h4> <
p > Innym zastosowaniem wyjątków jest użycie ich jako mechanizm
przepływu sterowania.W poniższym przykładzie używamy wyjątku do
        sprawdzenia, czy napis reprezentuje liczbę całkowitą: < /p> <
    pre > < code > def czy_liczba(napis):
    try:
    int(napis)
except ValueError:
    return False
return True <
    /code></pre >
    <
    h3 > Wątki < /h3> <
p > Wątki, pozwalają na równoległe wykonywanie się kilku fragmentów
kodu.Z tego powodu są szczególnie przydatne do obsługi zadań,
        które mogą zająć dużo czasu, np.łączenie się z zewnętrznym
    serwerem lub wczytywanie dużych plików.W ten sposób nie musimy
czekać na zakończenie danego zadania, lecz możemy je wykonać
równolegle z pozostałymi czynnościami. < /p> <
p > Aby skorzystać z wątków, należy najpierw zaimportować moduł <
    code > threading < /code>. Następnie, aby utworzyć nowy wątek, należy
utworzyć obiekt klasy < code > Thread < /code>. Klasa ta przyjmuje jako
argument funkcję, która będzie wykonana jako wątek. < /p> <
pre > < code >
    import threading
def watek():
    print("Watek")

w1 = threading.Thread(target = watek) <
    /code></pre >
    <
    p > Aby uruchomić wątek, należy wywołać metodę < code > start < /code> na
obiekcie klasy < code > Thread < /code>.</p >
    <
    pre > < code > w1.start() <
    /code></pre >
    <
    p > Należy pamiętać, że wątki działają równolegle, więc nie ma
gwarancji kolejności wykonywania się poszczególnych wątków. < /p> <
h4 > Własny wątek < /h4> <
p > Aby utworzyć wątek, należy stworzyć klasę dziedziczącą po klasie <
    code > Thread < /code> z modułu <code>threading</code > i zdefiniować
metodę < code > run < /code>, która zostanie wywołana przy uruchomieniu
wątku.Następnie należy utworzyć obiekt tej klasy i wywołać metodę <
    code > start < /code>, aby rozpocząć działanie wątku.</p >
    <
    pre > < code >
    import threading

class MyThread(threading.Thread):
    def run(self):
    # kod, ktory zostanie wykonany w watku
print("Wątek uruchomiony")

thread = MyThread()
thread.start() <
    /code></pre >
    <
    p > Możemy również przekazać argumenty do metody < code > run < /code>
    poprzez konstruktor klasy. < /p> <
pre > < code >
    import threading

class MyThread(threading.Thread):
    def __init__(self, argument):
    self.argument = argument
super().__init__()

def run(self):
    # kod, ktory zostanie wykonany w watku
print(f "Wątek uruchomiony z argumentem: {self.argument}")

thread = MyThread("Hello World")
thread.start() <
    /code></pre >
    <
    h4 > Zatrzymanie wątku < /h4> <
p > W Pythonie można zatrzymać wątek poprzez wywołanie metody <
    code > Thread.join() < /code>. Ta metoda blokuje wywołujący wątek aż
do momentu, gdy wątek do którego została wywołana zakończy swoje
    działanie.Przykładowo, jeśli chcemy zatrzymać główny wątek
programu do momentu, gdy wszystkie wątki zostaną zakończone, możemy
użyć pętli
for i iterować po liście wątków i dla każdego z nich
wywołać metodę < code > join() < /code>:</p >
    <
    pre > < code > threads = [thread1, thread2, thread3]

for thread in threads:
    thread.join() <
    /code></pre >
    <
    p > Można również użyć metody < code > Thread.join(timeout) < /code> z
opcjonalnym parametrem < code > timeout < /code>. Parametr ten określa
maksymalny czas oczekiwania na zakończenie wątku.Jeśli wątek nie
zakończy działania w ciągu tego czasu, wątek wywołujący metodę
    <
    code > join() < /code> zostanie wznowiony.</p >
    <
    p > Innym sposobem zatrzymania wątku jest użycie zmiennej globalnej <
    code > threading.Event < /code> z metodami <code>wait()</code > i <
    code > set() < /code>. Wątek, który chcemy zatrzymać, może oczekiwać
na sygnał za pomocą metody < code > wait() < /code>, a wątek główny może
wysłać sygnał za pomocą metody < code > set() < /code>. W przypadku
użycia tej metody, wątek oczekujący może również ustawić opcjonalny
limit czasu oczekiwania. < /p> <
pre > < code >
    import threading

# utworzenie zmiennej Event
stop_event = threading.Event()

def worker_thread():
    while not stop_event.is_set():
    # wątek wykonuje swoje zadania
do_some_work()
# po otrzymaniu sygnalu zatrzymujemy watek
stop_event.clear()

#...

    # glowny watek chce zatrzymac worker_thread
stop_event.set() <
    /code></pre >
    <
    p > Należy pamiętać, że zatrzymanie wątku nie jest powszechnie
zalecaną metodą zarządzania wątkami.W wielu przypadkach lepszym
rozwiązaniem jest użycie warunków synchronizacyjnych lub zamknięcia
wątku za pomocą metody < code > join() < /code>. Zatrzymanie wątku może
powodować nieoczekiwane skutki uboczne i powinno być używane
jedynie w wyjątkowych sytuacjach. < /p> <
h4 > Dzielenie zasobów między wątkami < /h4> <
p > Dzielenie zasobów między wątkami polega na umożliwieniu kilku
wątkom równoczesnego dostępu do wspólnego zasobu.W przypadku, gdy
zasób jest zmienny, konieczne jest zapewnienie bezpieczeństwa jego
dostępu, tzn.zapobiegnięcie sytuacji, w której kilka wątków będzie
próbowało zmodyfikować ten sam zasób w tym samym czasie.Istnieją
mechanizmy umożliwiające bezpieczne dzielenie zasobów między
wątkami, takie jak obiekt < code > Lock < /code>.</p >
    <
    p > Przykład: < /p> <
pre > < code >
    import threading

# Zmienna globalna, do której będą miały dostęp wątki
zmienna_globalna = 0

# Obiekt Lock, który będziemy używali do synchronizacji dostępu do zmiennej globalnej
    lock = threading.Lock()

def watek1():
    global zmienna_globalna
for i in range(100):
    # Pobieramy lock, aby mieć pewność, że tylko jeden wątek będzie
# miał dostęp do zmiennej globalnej w danym momencie
lock.acquire()
zmienna_globalna += 1
lock.release()

def watek2():
    global zmienna_globalna
for i in range(100):
    # Pobieramy lock, aby mieć pewność, że tylko jeden wątek będzie
# miał dostęp do zmiennej globalnej w danym momencie
lock.acquire()
zmienna_globalna -= 1
lock.release()

# Uruchamiamy wątki
t1 = threading.Thread(target = watek1)
t2 = threading.Thread(target = watek2)

t1.start()
t2.start()

# Czekamy na zakończenie obu wątków
t1.join()
t2.join()

# Wypisujemy wartość zmiennej globalnej
print(zmienna_globalna) <
    /code></pre >
    <
    p > W tym przykładzie mamy dwie funkcje < code > watek1 < /code> i <
code > watek2 < /code>, które zmieniają wartość zmiennej globalnej <
code > zmienna_globalna < /code>. Aby zapewnić bezpieczne dzielenie
zasobów między wątkami, użyto mechanizmu blokady. < /p> <
h4 > GIL < /h4> <
p > GIL, czyli Global Interpreter Lock, to mechanizm, który
ogranicza możliwość jednoczesnego wykonywania kodu przez wiele
wątków.W Pythonie każdy wątek jest obsługiwany przez GIL, który
kontroluje dostęp do interpretera.W rezultacie tylko jeden wątek
jest w stanie wykonywać kod naraz, a pozostałe są zawieszane aż do
    momentu, gdy GIL zostanie zwolniony. < /p> <
p > GIL jest wbudowanym mechanizmem w Pythonie, który został dodany
w celu uniknięcia problemów związanych z współdzieleniem zasobów
przez wiele wątków.Chociaż GIL może mieć pewne ograniczenia w
przypadku bardzo obciążających procesów wielowątkowych, w
większości przypadków jest on wystarczający do obsługi
równoległości w Pythonie. < /p> <
p > Przykładowo, jeśli chcielibyśmy utworzyć program, który będzie
sumował elementy w liście, możemy to zrobić za pomocą wielu wątków.
Każdy wątek będzie odpowiedzialny za sumowanie części listy.
Niestety, GIL spowoduje, że tylko jeden wątek będzie wykonywany w
danym momencie, co spowolni działanie programu. < /p> <
p > Oto przykład programu sumującego elementy w liście z użyciem
wątków: < /p> <
pre > < code >
    import threading

def sum_list(numbers):
    # Funkcja sumująca elementy w liście
total = 0
for number in numbers:
    total += number
print(total)

# Utworzenie wątków
thread1 = threading.Thread(target = sum_list, args = ([1, 2, 3], ))
thread2 = threading.Thread(target = sum_list, args = ([4, 5, 6], ))
thread3 = threading.Thread(target = sum_list, args = ([7, 8, 9], ))

# Uruchomienie wątków
thread1.start()
thread2.start()
thread3.start()

# Oczekiwanie na zakończenie wątków
thread1.join()
thread2.join()
thread3.join() <
    /code></pre >
    <
    p > W powyższym przykładzie, chociaż mamy trzy wątki, GIL spowoduje,
    że tylko jeden z nich będzie wykonywany w danym momencie, co sprawi
że użycie wątków nie pomoże z przyspieszeniem działania
progrmau. < /p> <
h3 > Procesy < /h3> <
p > Procesy to niezależne od siebie instancje programów wykonywane w
systemie operacyjnym.Procesy dzielą pamięć i zasoby systemu, takie
jak pliki i gniazda sieciowe.W odróżnieniu od wątków, procesy są
całkowicie niezależne od siebie i nie mogą udostępniać swoich
zmiennych. < /p> <
p > W Pythonie mamy moduł < code > multiprocessing < /code>, który
umożliwia tworzenie procesów.Możemy użyć go, aby uruchomić nasz
kod w osobnym procesie. < /p> <
pre > < code >
    import multiprocessing
import time

def worker():
    print("Rozpoczynam prace")
time.sleep(2)
print("Koncze prace")

p = multiprocessing.Process(target = worker)
p.start() <
    /code></pre >
    <
    p > W przeciwieństwie do wątków, procesy nie mogą być zatrzymywane.
    Jeśli chcemy zatrzymać proces, musimy go zakończyć.W tym celu
możemy użyć metody < code > terminate() < /code>.</p >
    <
    pre > < code > p.terminate() <
    /code></pre >
    <
    p > Procesy są dobrym wyborem, gdy chcemy uruchamiać kod równolegle,
    ale nie potrzebujemy udostępniać zmiennych między procesami.
Procesy są również dobrym wyborem, gdy chcemy uniknąć problemu GIL,
który dotyczy wątków w Pythonie.Należy jednak pamiętać, że procesy
są bardziej zasobożerne niż wątki i nie nadają się do wszystkich
zastosowań. < /p> <
h3 > Asyncio < /h3> <
p > Asyncio to moduł umożliwiający programowanie asynchroniczne.
Asynchroniczne programowanie polega na wykonywaniu wielu zadań
jednocześnie, bez konieczności blokowania głównego wątku programu.
Aby funkcja mogła zostać wykonana asynchronicznie, należy użyć
słowa kluczowego async oraz await. < /p> <
p > Przykład użycia asyncio: < /p> <
pre > < code >
    import asyncio

async def main():
    await asyncio.sleep(1)
print("Hello, world!")

asyncio.run(main()) <
    /code></pre >
    <
    p > W tym przykładzie, funkcja < code > main < /code> jest oznaczona jako <
code > async </code>, co oznacza, że będzie wykonywana
asynchronicznie.Funkcja < code > asyncio.sleep(1) < /code> jest
funkcją, która zatrzymuje wykonanie wątku na 1 sekundę.Słowo
kluczowe < code > await </code> jest używane do oznaczenia miejsca, w
którym wątek ma czekać na zakończenie wykonywania funkcji
    <
    code > asyncio.sleep(1) < /code>.</p >
    <
    p > Moduł < code > asyncio < /code> umożliwia tworzenie wielu wątków
jednocześnie, co pozwala na lepsze wykorzystanie zasobów komputera.
Należy jednak pamiętać, że < code > asyncio < /code> nie jest
rozwiązaniem wszystkich problemów związanych z wielowątkowością.W
niektórych przypadkach lepszym rozwiązaniem może być użycie
biblioteki < code > threading < /code> lub <
code > multiprocessing < /code>.</p >
    <
    h3 > Lambdy < /h3> <
p > Wyrażenia lambda to funkcje składające się z jednego wiersza
instrukcji, definiowane za pomocą słowa kluczowego lambda.Lambdy
nie używają słowa kluczowego
return, ponieważ zawsze zwracają wynik
wykonania tworzącego je wiersza instrukcji. < /p> <
pre > < code > def zwykla_funkcja(liczba: int) - & gt;
int:
    return liczba ** 2

przyklad_lambdy = lambda liczba: liczba ** 2

wartosc = 2

print(zwykla_funkcja(wartosc)) # 4
print(przyklad_lambdy(wartosc)) # 4
print((lambda liczba: liczba ** 2)(wartosc)) # 4 <
    /code></pre >
    <
    p > W porównaniu do pełnoprawnych funkcji definiowanych za pomocą
    słowa kluczowego def, lambdy są ograniczone: < /p> <
ul >
    <
    li > Możemy użyć jedynie jednego wiersza instrukcji. < /li> <
li > Możliwe jest sprawdzenie warunku, ale nie można zagnieżdżać
warunków. < /li> <
li > Brak możliwości tworzenia zmiennych oraz przypisywania wartości
do istniejących zmiennych(dla obiektów możemy użyć <
        code > setattr() < /code>).</li >
        <
        li > Brak pętli. < /li> < /
        ul > <
        p > Lambdy są również przydatne, gdy chcemy dostosować się do
            wymagań danej funkcji, która przyjmuje jako argument funkcję.W
        takim przypadku nie musimy tworzyć pełnoprawnej funkcji i jej przekazywać, lecz możemy bezpośrednio podstawić lambda. < /p> <
        p > Na przykład, jeśli chcemy posortować listę obiektów według pewnego atrybutu, możemy skorzystać z metody < code > sorted() < /code>,
        która przyjmuje argument < code > key < /code> - funkcję, która ma
        zwracać wartość atrybutu według którego ma być sortowana lista.W takiej sytuacji lambda pozwala nam zdefiniować tę funkcję w miejscy wywołania < code > sorted() < /code>.</p >
        <
        pre > < code > lista = (('def', 100), ('ghi', 200), ('abc', 300)) print(sorted(lista, key = lambda x: x[0])) #[('abc', 300), ('def', 100), ('ghi', 200)] print(sorted(lista, key = lambda x: x[1])) #[('def', 100), ('ghi', 200), ('abc', 300)] <
        /code></pre >
        <
        h3 > Programowanie funkcyjne < /h3> <
        p > Istnieją różne narzędzia służące do transformacji danych.W tym
        artykule przyjrzymy się kilku z nich: < code > map() < /code>, <
        code > filter() < /code> i <code>reduce()</code > .Funkcje te są często używane w programowaniu funkcyjnym.Programowanie funkcyjne to paradygmat programowania, w którym głównym sposobem reprezentowania algorytmów są funkcje.W programowaniu funkcyjnym nacisk kładzie się na transformację danych przy użyciu funkcji, a nie na ich modyfikację w miejscu. < /p> <
        p > Funkcja < code > map() < /code> to narzędzie służące do
        transformowania elementów jednej listy według określonej reguły.Ma ona dwa parametry: nazwę funkcji przyjmującej jeden argument(może to być też wyrażenie lambda) oraz nazwę listy.Funkcja <
        code > map() < /code> zwraca nową listę, w której elementy są wynikami
        wywołania funkcji przekazanej jako pierwszy argument dla każdego elementu listy przekazanej jako drugi argument. < /p> <
        p > Istnieją również inne sposoby na osiągnięcie tego samego efektu,
        takie jak pętle
        for lub wyrażenia listowe.Aby lepiej zrozumieć działanie < code > map() < /code>, warto porównać je z innymi
        metodami: < /p> <
        pre > < code > lista = [5, 10, 15, 20, 25, 30, 35, 40]

        lista_a = [elem // 5 for elem in lista] # [1, 2, 3, 4, 5, 6, 7, 8]
            lista_b = list(map(lambda elem: elem // 5, lista)) # [1, 2, 3, 4, 5, 6, 7, 8]
                    <
                    /code></pre >
                    <
                    p > Podobnie działa funkcja < code > filter() < /code>. Jej wynikiem jest
                    również nowa lista, złożona z elementów listy przekazanej jako drugi argument, dla których wywołanie funkcji przekazanej jako pierwszy argument zwróciło wartość logiczną < code > True < /code>.
                    Także i tutaj możemy porównać działanie < code > filter() < /code> z
                    innymi sposobami: < /p> <
                    pre > < code > lista = [5, 10, 15, 20, 25, 30, 35, 40]

                    lista_a = [elem // 5 for elem in lista if elem % 2 == 0] # [2, 4, 6, 8]
                        lista_b = list(map(lambda elem: elem // 5, filter(lambda elem : elem % 2 == 0, lista))) # [2, 4, 6, 8]
                                <
                                /code></pre >
                                <
                                p > Funkcja < code > reduce() < /code> jest narzędziem służącym do
                                agregacji elementów sekwencji według określonej reguły.Podobnie jak < code > map() < /code> i <code>filter()</code > , <
                                code > reduce() < /code> przyjmuje jako argumenty funkcję oraz
                                sekwencję.Różnica polega na tym, że < code > reduce() < /code> wywołuje
                                funkcję iteracyjnie na elementach sekwencji i zwraca pojedynczy wynik agregacji.W poniższym przykładzie pokazane są dwa sposoby na utworzenie listy składającej się z numerów ASCII odpowiadających wielkim literom otrzymanego słowa: < /p> <
                                pre > < code > napis = 'Python is Love'
                                lista_a = [ord(znak) for znak in napis
                                    if znak.isupper()
                                ] lista_b = list(map(lambda znak: ord(znak), filter(lambda znak: znak.isupper(), napis)))

                                print(lista_a) #['p', 'l'] print(lista_b) #['p', 'l'] <
                                /code></pre >
                                <
                                p > Pętle możemy w naturalny sposób zagnieżdżać.Podobnie możemy również operować na funkcjach < code > map() < /code>, <
                                code > filter() < /code> i <code>reduce()</code >: < /p> <
                                pre > < code > x = [2, 3, 5] y = [1, 2]

                                lista_a = [elem_x + elem_y
                                    for elem_x in x
                                    for elem_y in y
                                ] #[3, 4, 4, 5, 6, 7] lista_b = list() list(map(lambda elem_x: list(map(lambda elem_y: lista_b.append(elem_x + elem_y), y)), x)) #[3, 4, 4, 5, 6, 7] <
                                /code></pre >
                                <
                                h3 > Klasy danych < /h3> <
                                p > Tworzenie klas często wiąże się z powtarzalnym pisaniem elementów, takich jak inicjalizacja zmiennych przy użyciu funkcji specjalnej < code > __init__ < /code> oraz implementacja operatorów
                                porównania.W takich przypadkach klasy danych(ang.data classes) mogą okazać się bardzo przydatne.Są one specjalnym rodzajem klas,
                                które automatyzują proces tworzenia powtarzalnych elementów, takich jak inicjalizacja zmiennych i implementacja operatorów porównania.W celu utworzenia klasy danych wystarczy, że w obrębie klasy zadeklarujemy pola, które chcemy przechowywać.Są one szczególnie przydatne, gdy głównym celem naszej klasy jest grupowanie danych. < /p> <
                                pre > < code > @dataclass(unsafe_hash = True, order = True) class RGB:
                                czerwony: int zielony: int niebieski: int <
                                /code></pre >
                                <
                                p > W powyższym przykładzie klasa < code > RGB < /code> jest oznaczona
                                dekoratorem < code > @dataclass < /code>, co oznacza, że jest to klasa
                                danych.Oznacza to, że automatycznie otrzyma ona metody specjalne,
                                takie jak < code > __init__ < /code>, <code>__eq__</code > i <
                                code > __repr__ < /code>, które są zwykle ręcznie implementowane w
                                klasach. < /p> <
                                p > Dekorator @dataclass przyjmuje również dwa dodatkowe argumenty:
                                <
                                code > unsafe_hash < /code> i <code>order</code > .Argument <
                                code > unsafe_hash < /code> określa, czy instancje tej klasy mają być
                                używane jako elementy słowników lub zbiorów(jeśli argument jest ustawiony na < code > True < /code>, instancje tej klasy mogą być
                                    używane jako elementy słowników lub zbiorów).Argument <
                                code > order < /code> określa, czy instancje tej klasy będą używane
                                jako elementy posortowanej sekwencji(np.listy).Jeśli argument order jest ustawiony na < code > True < /code>, instancje tej klasy będą
                                automatycznie posiadać metodę specjalną < code > __lt__ < /code>, która
                                pozwala na porównywanie instancji za pomocą operatora <
                                code > & lt; < /code>.</p >
                                <
                                p > | Funkcjonalność | Przykład | -- -- -- -- -- -- -- -- -- -- -- -
                                |
                                -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
                                |
                                |
                                Inicjalizacja pól | < code > kolor = RGB(255, 255, 0) < /code> | |
                                Konwersja na napis | < code > print(RGB(255, 255, 0)) # "RGB(czerwony=255, zielony=255, niebieski=0)" < /code> | | Porównanie | <
                                code > RGB(255, 255, 0) == RGB(255, 120, 255) < /code> | |
                                Porządkowanie | < code > sorted([RGB(255, 255, 0), RGB(255, 120,
                                    255)]) < /code> | | Funkcja haszująca | <code>slownik = {kolor :
                                "kolor"
                            } < /code> | | Rozpakowanie | <code>asdict(RGB(255, 255,
                            0)).values() < /code> | | Optymalizacja pamięci | <
                    code > sys.getsizeof(RGB) < /code> |</p >
                    <
                    h3 > Generatory < /h3> <
                    p > Generator to specjalny rodzaj funkcji, który zwraca wartości pojedynczo, zamiast zwracać ich wszystkie naraz w postaci listy lub innego iterowalnego obiektu.Generatory są bardziej efektywne pod względem pamięciowym niż listy, ponieważ nie wymagają przechowywania całej listy w pamięci, lecz tylko aktualnie zwracanej wartości.Generatory umożliwiają także klientowi rozpoczęcie przetwarzania zwracanych wartości zanim generator zakończy swoją pracę. < /p> <
                    p > Aby utworzyć generator, wystarczy zamiast słowa kluczowego <
                    code >
                    return </code> użyć słowa kluczowego <code>yield</code > .
                    Wartości, które generator ma zwracać są umieszczane po słowie kluczowym < code > yield < /code> w ciele funkcji. Przykłady użycia
                    generatorów znajdują się poniżej. < /p> <
                    p > a) W poniższym przykładzie zwracamy wartości z funkcji <
                code > foo() < /code> przy pomocy słowa kluczowego <
                code > yield < /code>:</p >
                    <
                    pre > < code > def foo():
                    yield 1
                yield 2
                yield 3

                print(list(foo())) <
                /code></pre >
                <
                p > Wynik po przekonwertowaniu na listę daje: < /p> <
                pre > < code > [1, 2, 3] <
                /code></pre >
                <
                p > b) W tym przykładzie zwracamy wartości z funkcji <
            code > bar() < /code> przy pomocy słowa kluczowego <
            code >
            return </code>:</p >
                <
                pre > < code > def bar():
                return 1
            return 2 #Martwy kod
            return 3

            print(bar()) <
            /code></pre >
            <
            p > Wynik: < /p> <
            pre > < code > 1 <
            /code></pre >
            <
            h3 > Iteratory < /h3> <
            p > Pętla < code >
            for < /code> jest narzędziem, które umożliwia
            przejście przez kolejne elementy sekwencji, takiej jak lista, ciąg
            znaków lub tuple.Możemy użyć pętli < code >
            for < /code> w następujący
            sposób: < /p> <
            pre > < code >
            for elem in lista:
            print(elem) <
            /code></pre >
            <
            p > Wbudowane kolekcje, takie jak listy, ciągi znaków i tuple,
            posiadają metodę < code > __iter__() < /code>, która zwraca iterator dla
            danej kolekcji.Iterator to obiekt, który umożliwia przejście przez
            elementy kolekcji po kolei.Możemy wywołać funkcję <
            code > next() < /code> z przekazanym jako argument iterator, aby
            pobrać kolejny element kolekcji.Jeśli iterator nie ma już więcej
            elementów do zwrócenia, zostanie rzucony wyjątek <
                code > StopIteration < /code>.</p >
                <
                pre > < code > lista = [1, 2, 3]
            iterator = iter(lista)
            print(next(iterator)) # wyswietli 1
            print(next(iterator)) # wyswietli 2
            print(next(iterator)) # wyswietli 3
            print(next(iterator)) # zostanie wyrzucony wyjatek <
            /code></pre >
            <
            p > Ten mechanizm jest używany wewnętrznie przez pętlę <
            code >
            for < /code>. Iteratory pozwalają na implementację własnych
            zasad przechodzenia przez kolekcję.Możemy stworzyć własną klasę
            iterowalną, implementując metodę < code > __iter__() < /code> i używając
            słowa kluczowego < code > yield < /code> w celu zwracania elementów
            kolekcji po kolei. < /p> <
            pre > < code > class ObiektIterowalny:

            def __init__(self):
            self.lista_a = [3, 2, 1]
            self.lista_b = [-1, -2, -3]

            def __iter__(self):
            licznik = 0
            while licznik & lt;len(self.lista_a) and len(self.lista_b):
            yield self.lista_a[licznik], self.lista_b[licznik]
            licznik += 1

            obiekt = ObiektIterowalny()

            for elem in obiekt:
            print(elem) <
            /code></pre >
            <
            p > Dzięki temu, że nasz obiekt jest iterowalny, możemy używać go w
            pętli < code >
            for < /code> w taki sam sposób, jak wbudowane
            kolekcje. < /p> <
            h3 > Dekoratory < /h3> <
            p > Przy pomocy dekoratorów możemy rozszerzać funkcjonalność
            istniejących funkcji bez ich modyfikowania.Możemy też używać ich
            jako dodatkowego sposobu na zabezpieczenie funkcji przed
            nieprawidłowym wykorzystaniem lub po prostu jako mechanizmu
            ułatwiającego debugowanie. < /p> <
            p > Aby zachować informacje o funkcji dekorowanej, możemy użyć
            dekoratora < code > functools.wraps() < /code>:</p >
            <
            pre > < code >
            import functools

            def dekoruj(funkcja):
            @functools.wraps(funkcja)
            def funkcja_wew():
            print('przetwarzam dane')
            funkcja()
            return funkcja_wew <
                /code></pre >
                <
                p > Dzięki temu wszystkie informacje o funkcji < code > foo < /code>,
            takie jak jej nazwa czy dokumentacja, zostaną zachowane po
            dekoracji. < /p> <
            p > Możemy też przekazywać argumenty do dekoratora i funkcji
            dekorowanej: < /p> <
            pre > < code > def dekoruj(funkcja):
            def funkcja_wew( * args, ** kwargs):
            <
            /code></pre >
            <
            h3 > Serializacja < /h3> <
            p > Serializacja to proces konwersji obiektu na strumień bajtów,
            który może być następnie zapisany, przesłany lub przechowywany w
            inny sposób.Dzięki serializacji możliwe jest zapisywanie stanu
            obiektów i ich późniejsze odtwarzanie, co może być przydatne np.w
            grach, gdzie chcemy zapisać postępy gracza lub w aplikacjach, gdzie
            chcemy zapisywać dane użytkownika. < /p> <
            p > Moduł < code > pickle < /code> służy do serializacji i deserializacji
            obiektów.Funkcja < code > dumps() < /code> pozwala na zserializowanie
            obiektu do strumienia bajtów, który może być następnie zapisany do
                    pliku lub przesłany do innego procesu.Funkcja < code > loads() < /code>
                    pozwala na odtworzenie obiektu ze strumienia bajtów. < /p> <
                p > Przykład użycia tych funkcji znajduje się poniżej.W kodzie
            tworzona jest klasa < code > Czlowiek < /code> z polami <
            code > imie < /code> i <code>numer</code > , a następnie serializowana i
            zapisywana do pliku.Następnie obiekt jest odtwarzany z pliku i
            wyświetlany na ekranie. < /p> <
            pre > < code >
            import pickle

            class Czlowiek:
            def __init__(self, imie, numer):
            self.imie = imie
            self.numer = numer

            def __repr__(self):
            return f 'Imie: {self.imie}, numer: {self.numer}'

            sciekza = 'przyklad.pickle'

            with open(sciekza, 'wb') as plik:
            pickle.dump(Czlowiek('James', 10), plik)


            with open(sciekza, 'rb') as plik:
            czlowiek = pickle.load(plik)
            print(czlowiek) #Imie: James, numer: 10 <
            /code></pre >
            <
            h2 > Inżynieria oprogramowania < /h2> <
            p > Inżynieria oprogramowania to dziedzina zajmująca się procesem
            tworzenia oprogramowania, od projektowania po implementację i
            utrzymanie.W tej dziedzinie ważne są takie aspekty jak dobór
            narzędzi i metodologii, zarządzanie projektem, czy współpraca w
            zespole. < /p> <
            h3 > Moduły i pakiety < /h3> <
            p > Za każdym razem, gdy używamy instrukcji < code >
            import < /code>,
            importujemy do skryptu zewnętrzny moduł.Każdy plik Pythona jest
            modułem, którego nazwa to nazwa pliku bez rozszerzenia.py. <
            a href = "https://docs.python.org/3/library/index.html" > Dokumentacja < /a>
            zawiera pełną listę wbudowanych modułów biblioteki standardowej
            Pythona.Przykładowo, tak możemy zaimporotwać moduł <
            code > requests < /code>:</p >
            <
            pre > < code >
            import requests
            print(type(requests)) # & lt;class 'module' & gt; <
            /code></pre >
            <
            p > Pakiety to foldery z modułami, w których znajduje się plik <
            code > init.py < /code>. Jest to plik specjalny, który jest potrzebny
            do odróżnienia pakietu od zwykłego folderu. < /p> <
            pre > < code > .└──nazwa_paczki├── __init__.py└── przykladowy_skrypt_a.py└── przykladowy_skrypt_b.py└── przykladowy_skrypt_c.py└── main.py <
            /code></pre >
            <
            p > Możemy importować moduły na kilka sposobów: < /p> <
            ul >
            <
            li >
            <
            p > Zaimportowanie całego modułu: < /p> <
            p >
            import nazwa_modulu < /p> < /
            li > <
            li >
            <
            p > Zaimportowanie całego modułu i nadanie mu aliasu: < /p> <
            p >
            import nazwa_modulu as alias < /p> < /
            li > <
            li >
            <
            p > Zaimportowanie wybranych funkcji z modułu: < /p> <
            p > from nazwa_modulu
            import
            fun_1, fun_2 < /p> < /
            li > <
            li >
            <
            p > Zaimportowanie wybranych funkcji z modułu i nadanie im
            aliasów: < /p> <
            p > from nazwa_modulu
            import fun_1 as f1, fun_2 as f2 < /p> < /
            li > <
            li >
            <
            p > Zaimportowanie wszystkich funkcji z modułu: < /p> <
            p > from nazwa_paczki.przykladowy_skrypt_a
            import * < /p> <
            p > fun_a() fun_b() < /p> < /
            li > <
            /ul> <
            p > Należy uważać z używaniem instrukcji < code > from modul
            import *
            <
            /code>, ponieważ zaimportowane zostają wszystkie zmienne i
            funkcje z modułu, niezależnie od tego czy ich będziemy używać czy
            nie.Może to prowadzić do konfliktów nazw oraz utrudnić odczytanie
            kodu. < /p> <
            p > Uwaga: instrukcje, które nie są częścią definicji żadnej
            funkcji, zostaną automatycznie wykonane podczas importowania
            modułu! < /p> <
            p > Przykład: < /p> <
            pre > < code > def fun_a():
            ...

            def fun_b():
            ...

            wyslij_rakiety() <
            /code></pre >
            <
            p > Jeśli ten moduł zostanie zaimportowany w innym skrypcie, to
            funkcja < code > wyslij_rakiety() < /code> zostanie wywołana podczas
            importowania modułu.Aby temu zapobiec, należy umieścić wszystkie
            instrukcje, które mają być wykonywane poza definicjami funkcji, w
            ciele następującego warunku < code >
            if name == "main": < /code> :</p >
            <
            pre > < code > def fun_a():
            ...

            def fun_b():
            ...

            if __name__ == "__main__":
            wyslij_rakiety() <
            /code></pre >
            <
            h3 > Wersje Pythona < /h3> <
            p > Narzędzie < code > Pyenv < /code> służy do izolowania różnych wersji
            Pythona.Jeśli na przykład chcesz przetestować swój kod w Pythonie
            2.5, 3.6 i 3.10, potrzebujesz prostego sposobu na przełączanie się
            między nimi. < code > Pyenv < /code> modyfikuje zmienną środowiskową
            PATH dodając do niej ścieżkę do specjalnego folderu < code > (pyenv root) / shims < /code>. Ponadto <code>Pyenv</code > umożliwia pobieranie
                i instalowanie różnych wersji Pythona za pomocą polecenia <
                code > pyenv install < /code>.</p >
                <
                p > Linki: < /p> <
            ul >
            <
            li > https: //github.com/pyenv/pyenv</li>
            <
            li > https: //github.com/pyenv-win/pyenv-win</li>
            <
            /ul> <
            p > Po zainstalowaniu pyenv, możemy użyć polecenia pyenv install aby
            zainstalować nową wersję Pythona.Na przykład, aby zainstalować
            wersję Python 3.10, użyjemy polecenia: < /p> <
            pre > < code > pyenv install 3.10 <
            /code></pre >
            <
            p > Aby ustawić wersję Pythona, która będzie używana dla danego
            katalogu, użyj polecenia pyenv local: < /p> <
            pre > < code > pyenv local 3.10 <
            /code></pre >
            <
            p > Aby ustawić wersję Pythona, która będzie używana dla całego
            systemu, użyj polecenia pyenv global: < /p> <
            pre > < code > pyenv global 3.10 <
            /code></pre >
            <
            p > Aby wyświetlić listę zainstalowanych wersji Pythona, użyj
            polecenia pyenv versions: < /p> <
            pre > < code > pyenv versions <
            /code></pre >
            <
            p > Aby wyświetlić bieżącą wersję Pythona, użyj polecenia pyenv
            version: < /p> <
            pre > < code > pyenv version <
            /code></pre >
            <
            h3 > PIP i PyPI < /h3> <
            p > PIP to narzędzie umożliwiające instalację pakietów Pythona
            dostępnych na stronie PyPI(Python Package Index). < /p> <
            p > Instalacja: < /p> <
            ol >
            <
            li > Pobierz skrypt < a href =
            "https://bootstrap.pypa.io/get-pip.py" > get - pip.py < /a>.</li >
            <
            li > Uruchom skrypt < code > python get - pip.py < /code>.</li >
            <
            li > Zweryfikuj poprawność instalcji wpisując w wierszu poleceń
            następujące komendy: < code > pip help < /code>.</li >
            <
            /ol> <
            p > Aby zainstalować konkretny pakiet, użyj: < /p> <
            pre > < code > pip install & lt;nazwa_pakietu & gt; <
            /code></pre >
            <
            p > Aby wyświetlić szczegóły zainstalowanego pakietu, użyj: < /p> <
            pre > < code > pip show & lt;nazwa_pakietu & gt; <
            /code></pre >
            <
            p > Aby wyświetlić listę wszystkich aktualnie używanych pakietów,
            użyj: < /p> <
            pre > < code > pip list <
            /code></pre >
            <
            p > Aby zapisać w pliku < em > requirements.txt < /em> listę wszystkich
            aktualnie używanych pakietów wraz z wersjami, użyj: < /p> <
            pre > < code > pip freeze & gt;requirements.txt <
            /code></pre >
            <
            p > Aby odinstalować pakiet, użyj: < /p> <
            pre > < code > pip uninstall & lt;nazwa_pakietu & gt; <
            /code></pre >
            <
            p > Aby zaktualizować program PIP, użyj: < /p> <
            pre > < code > pip install--upgrade pip <
            /code></pre >
            <
            p > Linki: < /p> <
            ul >
            <
            li > https: //pypi.org/</li>
            <
            /ul> <
            h3 > Środowisko wirtualne < /h3> <
            p > Środowisko wirtualne to odizolowane od reszty systemu wersje
            bibliotek i pakietów Pythona.Instalując daną wersję pakietu w
            środowisku wirtualnym jest ona dostępna tylko w nim.Gdy usuwamy
            środowisko wirtualne wraz z nim znika również wszystko to co
            zostało zainstalowane w jęgo obrębie. < /p> <
            p > Popularnym narzędziem do tworzenia środowisk wirtualnych jest <
                code > virtualenv < /code>. Narzędzie to tworzy specjalny folder o
            dowolnej nazwie(np. < code > env / < /code>) oraz modyfikuje zmienną
                środowiskową PATH dodając do niej refernecje do podfolderu <
                        code > bin < /code> znajdującego się w utworzonym folderze (np. <
                    code > env / bin / < /code>). Wszystkie pakiety i biblioteki instalowane
                w środowisku wirtualnym wędrują do tego folderu. < /p> <
                p > Aby zainstalować narzędzie < code > virtualenv < /code> przy pomocy
                menadźera pakietów < code > PIP < /code>, użyj:</p >
                <
                pre > < code > pip install virtualenv <
                /code></pre >
                <
                p > Aby utworzyć środowisko wirtualne o nazwie < em > env < /em> w
                aktualnym folderze, użyj: < /p> <
                pre > < code > virtualenv env <
                /code></pre >
                <
                p > Jeśli w systemie masz zainstalowane różne wersje Pythona, to możesz powiedzieć środowisku wirtualnemu, z której wersji ma korzystać.Przykładowo, jeśli mam interpreter Pythona w folderze <
                em > /usr/bin / python3 < /em> i chce, żeby z niego korzystało moje
                środowisko wirtualne, to używam następującej komendy: < /p> <
                pre > < code > virtualenv - p / usr / bin / python3 env <
                /code></pre >
                <
                p > Aby wejść do środowiska wirtualnego, użyj: < /p> <
                pre > < code > source env / bin / activate <
                /code></pre >
                <
                p > Aby wyjść ze środowiska wirtualnego, użyj: < /p> <
                pre > < code > deactivate <
                /code></pre >
                <
                p > Aby zapisać do pliku < em > requirements.txt < /em> wszystkie
                aktualnie zainstalowane biblioteki wraz z ich wersjami, użyj: < /p> <
                pre > < code > pip freeze & gt; requirements.txt <
                /code></pre >
                <
                p > Aby zainstalować biblioteki wymienione w pliku <
                em > requirements.txt < /em>, użyj:</p >
                <
                pre > < code > pip install - r requirements.txt <
                /code></pre >
                <
                p > Linki: < /p> <
                ul >
                <
                li > https: //github.com/pypa/virtualenv</li>
                <
                /ul> <
                h3 > Dbanie o jakość kodu i lintowanie < /h3> <
                p > Poprawny z punktu widzenia interpretera kod można napisać na wiele sposobów.Nawet jedna linia kodu może być zapisana na wiele sposobów.Jedną z przyczyn takiego stanu rzeczy są różnice w formatowaniu.Na przykład w kodzie do oddzielania instrukcji można
                użyć zarówno spacji, jak i tabów.Definicje funkcji można oddzielać jednym, dwoma lub trzema enterami.Linie kodu mogą być tak długie,
                że nie zmieszczą się na ekranie.Czy więc należy ograniczać ich długość ? Jeśli tak, to ile znaków powinno być górną granicą ? Dopóki z kodem pracujemy sami, wszystko wydaje się być w porządku, ale co jeśli ktoś inny będzie musiał czytać nasz kod ? Co jeśli ktoś inny będzie musiał go modyfikować ? Wtedy ważne staje się, by kod był czytelny i zrozumiały dla innych programistów.Z tych właśnie względów warto przestrzegać konwencji pisania kodu. < /p> <
                p > Narzędzia, takie jak < code > Pylint < /code> i <code>Black</code >
                pomagają nam uniknąć typowych błędów i niepoprawności, które mogą pojawić się podczas pisania kodu.Narzędzia te sprawdzają, czy kod jest zgodny z zasadami zapisanymi w dokumentach < code > PEP8 < /code> i <
                code > PEP257 < /code>.</p >
                <
                p > Aby użyć narzędzia < code > Pylint < /code>, zainstaluj je za pomocą <
                code > PIP < /code>:</p >
                <
                pre > < code > pip install pylint <
                /code></pre >
                <
                p > Aby sprawdzić kod za pomocą < code > Pylint < /code>, użyj
                polecenia : < /p> <
                pre > < code > pylint & lt; nazwa_pliku.py & gt; <
                /code></pre >
                <
                p > Aby użyć narzędzia < code > Black < /code>, zainstaluj je za pomocą <
                code > PIP < /code>:</p >
                <
                pre > < code > pip install black <
                /code></pre >
                <
                p > Aby użyć < code > Black < /code> do sformatowania kodu w pliku o
                nazwie < code > nazwa_pliku.py < /code>, użyj polecenia:</p >
                <
                pre > < code > black nazwa_pliku.py <
                /code></pre >
                <
                p > Black to narzędzie do automatycznej reformatowania kodu w celu
                dostosowania go do wytycznych PEP8.Nie pyta ono o zdanie
                programisty i zmienia formatowanie kodu bez możliwości konsultacji.Z tego względu Black jest narzędziem bardzo szybkim i prostym w użyciu.Jego główną wadą jest brak możliwości konfiguracji.Black nie pozwala na zmianę domyślnych ustawień ani na wyłączenie poszczególnych zasad formatowania. < /p> <
                p > Flake8 to narzędzie do sprawdzania jakości kodu.Oprócz
                formatowania kodu, Flake8 sprawdza także jego poprawność semantyczną oraz brak błędów składniowych.W porównaniu do Blacka,
                    Flake8 oferuje większą ilość opcji konfiguracyjnych.Możliwe jest
                m.in.wyłączenie poszczególnych zasad sprawdzania lub zmiana ich domyślnych ustawień.Jedną z wad Flake8 jest to, że jest ono wolniejsze od Blacka, ponieważ sprawdza także inne aspekty kodu niż tylko jego formatowanie. < /p> <
                p > Pylint to narzędzie do sprawdzania jakości kodu podobne do
                        Flake8.Oprócz sprawdzania formatowania kodu i braku błędów
                    składniowych, Pylint sprawdza także nazewnictwo zmiennych i funkcji
                oraz brak docstringów(komentarzy opisujących kod). < /p> <
                p > | | black | pylint | flake8 |
                |
                -- -- -- -- -- -- -- -- -- -- -- -- -- -- | -- -- -- -- | -- -- -- -- | -- -- -- - | |
                automatyczna korekcja | ✔️ | ❌ | ❌ | | wskazówki do stylu | 👷‍♂️ | ✔️ | 👷‍♂️ | | wyszukiwanie bugów | ❌ | ✔️ | 👷‍♂️ | | wskazywanie
                zbyt złożonego kodu | ❌ | 👷‍♂️ | ❌ | | dostępność pluginów | ❌ | ❌
                |
                ✔️ | < /p> <
                p > Linki : < /p> <
                ul >
                <
                li > https : //www.python.org/dev/peps/pep-0008/</li>
                <
                li > https : //www.python.org/dev/peps/pep-0257/</li>
                <
                li > https: //github.com/psf/black</li>
                <
                li > https: //github.com/PyCQA/pylint</li>
                <
                li > https: //github.com/PyCQA/flake8</li>
                <
                li > https: //github.com/myint/autoflake</li>
                <
                /ul> <
                h3 > Debugowanie < /h3> <
                p > Debuger jest bardzo przydatnym narzędziem, zwłaszcza przy pracy nad dużymi projektami.Dzięki niemu możemy zatrzymać program w dowolnym momencie, aby sprawdzić co się w nim dzieje.Możemy też prześledzić kolejne kroki programu, które zostały wykonane do
                    momentu zatrzymania, co pozwala na szybkie i skuteczne znajdowanie
                błędów. < /p> <
                p > Dwa główne zastosowania debugera: -Wyszukiwanie przyczyn bugów w kodzie. - Analiza działania programu przez zaznajamiających się z nim programistów. < /p> <
                p > Jedną z mocnych stron debugera jest też to, że pozwala nam zajrzeć "pod maskę"
                programu i zobaczyć jakie zmienne są zdefiniowane i jakie są ich wartości.Dzięki temu możemy szybciej zrozumieć co dzieje się w kodzie i co jest przyczyną jakichś błędów. < /p> <
                p > Słabą stroną debugera jest to, że korzystanie z niego może być czasochłonne.Zatrzymywanie programu i przechodzenie przez kolejne kroki wymaga czasu i cierpliwości.Czasem może też być trudno zrozumieć co dzieje się w kodzie, jeśli jest on bardzo skomplikowany lub niezrozumiały. < /p> <
                p > Większość współczesnych środowisk programistycznych(IDE) ma wbudowany debuger.Debugger w IDE umożliwia ustawienie punktów breakpoint, dzięki którym program zatrzymuje się automatycznie w wybranym miejscu, co ułatwia debugowanie.IDE zazwyczaj posiada również dodatkowe funkcje, takie jak możliwość podglądu zmiennych czy historii wywołań funkcji, które ułatwiają debugowanie. < /p> <
                p > Jeśli nie korzystamy z IDE, możemy użyć modułu pdb, który jest wbudowanym w Pythonie debugerem.Moduł ten umożliwia kontrolowanie wykonywania kodu z linii poleceń, co pozwala na debugowanie skryptów bez konieczności ich uruchamiania w środowisku programistycznym.Możliwe jest również uruchamianie pdb z poziomu kodu Pythona za pomocą funkcji importowanej z modułu <
                code > pdb < /code>: <code>pdb.set_trace()</code > .Po uruchomieniu tej funkcji program zatrzyma się i będziemy mogli kontrolować jego działanie z linii poleceń. < /p> <
                p > Linki: < /p> <
                ul >
                <
                li > https: //docs.python.org/3/library/pdb.html</li>
                <
                /ul> <
                h3 > Testy jednostkowe < /h3> <
                p > Testy jednostkowe są ważnym narzędziem w procesie tworzenia oprogramowania, ponieważ pomagają zapewnić, że nasz kod działa poprawnie i jest odporny na błędy.Pozwalają również na szybkie wykrycie błędów, które pojawiły się w wyniku zmian w kodzie, dzięki czemu możemy je szybko naprawić. < /p> <
                ul >
                <
                li > Czerwone testy, czyli testy, które nie przeszły, pokazują, że coś, co działało wcześniej, aktualnie nie działa.Może to być spowodowane tym, że została wprowadzona jakaś zmiana w kodzie,
                która spowodowała, że test nie zadziałał poprawnie.Czerwone testy są sygnałem, że coś jest nie tak i konieczne jest przeanalizowanie kodu i znalezienie przyczyny problemu. < /li> <
                li > Zielone testy, czyli testy, które przeszły, pokazują, że to, co było sprawdzane w testach działa poprawnie.Nie oznacza to jednak,
                że cały program działa poprawnie - mogą być jeszcze inne fragmenty kodu, które nie zostały sprawdzone w testach i które mogą działać niepoprawnie.Zielone testy są ważne, ponieważ pozwalają upewnić się, że kod działa zgodnie z założeniami, ale nie są wystarczające do całkowitego zabezpieczenia aplikacji przed błędami. < /li> < /
                    ul > <
                    p > Ogólnie w Pythonie mamy dwie popularne biblioteki służące do
                        testów jednostkowych: < code > unittest < /code> i <code>pytest</code > .
                    Obie biblioteki, dają nam możliwość tworzenia testów jednostkowych
                i uruchamiania ich automatycznie, co pozwala na skupienie się na kodowaniu i uniknięcie ręcznego testowania kodu.Obie biblioteki są dość proste w użyciu i oferują duże możliwości tworzenia i uruchamiania testów.Ostateczny wybór biblioteki zależy od indywidualnych potrzeb i preferencji programisty. < /p> <
                h4 > Unittest < /h4> <
                p > Biblioteka ta została zbudowana zgodnie z filozofią programowania obiektowego, co oznacza, że w kodzie tworzymy klasy i korzystamy z dziedziczenia.Unittest oferuje również wiele funkcji assert, które pozwalają na sprawdzenie różnych aspektów działania programu. < /p> <
                p > Przykład kodu z użyciem unittest: < /p> <
                pre > < code >
                import unittest

                class TestSMTP(unittest.TestCase):

                def smtp_connection(self):
                import smtplib
                return smtplib.SMTP("smtp.gmail.com", 587, timeout = 5)

                def test_helo(self):
                response_code, msg = self.smtp_connection().ehlo() self.assertEqual(response_code, 250) <
                /code></pre >
                <
                p > W powyższym przykładzie tworzymy klasę TestSMTP, która dziedziczy po klasie TestCase z biblioteki unittest.W tej klasie zdefiniowaliśmy funkcję smtp_connection, która tworzy połączenie z serwerem SMTP, oraz funkcję test_helo, która wywołuje metodę ehlo na połączeniu SMTP i sprawdza, czy otrzymano oczekiwany kod odpowiedzi(250). < /p> <
                p > Aby uruchomić testy jednostkowe, wystarczy wywołać odpowiednie polecenie w konsoli: < /p> <
                pre > < code > python - m unittest <
                /code></pre >
                <
                h4 > Pytest < /h4> <
                p > Pytest to również biblioteka służąca do tworzenia i uruchamiania
                testów jednostkowych w języku Python.Została zbudowana zgodnie z filozofią "im prościej, tym lepiej", co oznacza, że nie ma w niej klas i dziedziczenia.Pytest pozwala na tworzenie testów poprzez definiowanie funkcji oznaczonych adnotacją @pytest.fixture. < /p> <
                p > Przykład kodu z użyciem pytest: < /p> <
                pre > < code >
                import pytest

                @pytest.fixture def smtp_connection():
                import smtplib
                return smtplib.SMTP("smtp.gmail.com", 587, timeout = 5)

                def test_helo(smtp_connection):
                response_code, msg = smtp_connection.ehlo() assert response_code == 250 <
                /code></pre >
                <
                p > Test składa się z dwóch części: dekoratora <
                code > @pytest.fixture < /code> oraz funkcji testowej <
                code > test_helo() < /code>.</p >
                <
                p > Dekorator < code > @pytest.fixture < /code> mówi nam, że funkcja <
                code > smtp_connection() < /code> jest funkcją pomocniczą, która
                zostanie uruchomiona przed każdą funkcją testową.W tym przypadku <
                code > smtp_connection() < /code> tworzy obiekt <code>SMTP</code > i zwraca go jako wartość.Funkcja ta nie jest testem jednostkowym,
                ale służy do przygotowania środowiska testowego. < /p> <
                p > Natomiast funkcja testowa < code > test_helo() < /code> jest testem
                jednostkowym.Funkcja ta przyjmuje jako argument obiekt <
                code > smtp_connection < /code>, który został wcześniej utworzony
                przez dekorator < code > @pytest.fixture < /code>. Funkcja testowa
                wywołuje na tym obiekcie funkcję < code > ehlo() < /code> i sprawdza,
                czy kod odpowiedzi oraz wiadomość zwracana przez funkcję są takie same, jak oczekiwane wartości.Jeśli tak, to test zostaje zaliczony, w przeciwnym razie test zostaje uznany za nieudany(tzw.
                    "czerwony test"). < /p> <
                p > Aby uruchomić testy jednostkowe, wystarczy wywołać odpowiednie polecenie w konsoli: < /p> <
                pre > < code > pytest <
                /code></pre >
                <
                h4 > Korzyści z testów jednostkowych < /h4> <
                ul >
                <
                li > Pomagają innym programistom zrozumieć cel danego fragmentu kodu produkcyjnego. < /li> <
                li > Gdy programy są małe, programista może ręcznie sprawdzić ich działanie z każdą modyfikacją.Wraz ze wzrostem złożoności, ręczne testowanie wszystkich części programu staje się niemożliwe.Testy jednostkowe można uruchomić automatycznie. < /li> <
                li > Wymuszają separację zadań między poszczególnymi fragmentami kodu. < /li> <
                li > Pozwalają na szybkie sprawdzenie poprawności działania kodu po dokonaniu zmian w kodzie produkcyjnym. < /li> < /
                ul > <
                h4 > TDD < /h4> <
                p > Technika "test driven development"(TDD) to sposób pisania programów, w którym testy są pisane przed kodem produkcyjnym.Proces tworzenia programu składa się z trzech etapów: < /p> <
                ol >
                <
                li > Testy jednostkowe. < /li> <
                li > Kod produkcyjny. < /li> <
                li > Refkatoryzajca kodu produkcyjnego. < /li> < /
                ol > <
                p > Programista nigdy nie przechodzi do implementacji nowych
                funkcjonalności, dopóki wszystkie trzy etapy nie zostały zakończone dla aktualnie implementowanych funkcjonalności. < /p> <
                h4 > Losowe dane nie mają miejsca w testach < /h4> <
                p > Załóżmy, że masz własną implementację jednego z algorytmów sortowania.Jeśli chcesz porównać wynik jego działania, z wynikiem działania funkcji < code > sorted() < /code> z biblioteki standardowej
                to ręcznie przygotuj listy wejściowe. < /p> <
                pre > < code >
                import pytest

                def test_wlasne_sortowanie():
                lista_a = [1, 1, 1] lista_b = [3, 5, 2] lista_c = [-1, 2, 3, -1, 0] #
                import random # lista_d = [random.randint(-10, 10) for _ in range(5)] # ZLE

                assert wlasne_sortowanie(lista_a) == sorted(lista_a) assert wlasne_sortowanie(lista_b) == sorted(lista_b) assert wlasne_sortowanie(lista_c) == sorted(lista_c) <
                /code></pre >
                <
                p > Powyższy fragment kodu zawiera przykład użycia pytest do
                    testowania funkcji < code > wlasne_sortowanie < /code>. W tym przypadku,
                trzy listy są tworzone jako dane wejściowe: < code > lista_a < /code>, <
                code > lista_b < /code> i <code>lista_c</code > .Następnie są one porównywane z oczekiwanymi wynikami po wywołaniu funkcji <
                code > sorted() < /code> na tych samych danych wejściowych za pomocą
                polecenia < code > assert < /code>. Jeśli wynik zwrócony przez <
                code > wlasne_sortowanie() < /code> jest różny od oczekiwanego wyniku,
                zostanie wygenerowany błąd, który poinformuje o niepowodzeniu testu. < /p> <
                h4 > Od znalezienia buga do poprawnie działającego kodu < /h4> <
                p > Zauważono błąd w twoim programie.Co należy zrobić ? < /p> <
                ol >
                <
                li > Próbuj odtworzyć problematyczną sytuację.Na przykład, jeśli twoja aplikacja zamyka się po wciśnięciu przycisku mającego przenieść użytkownika na inną stronę, najpierw manualnie wykonaj wszystkie kroki prowadzące do pojawienia się niechcianego
                efektu. < /li> <
                li > Zlokalizuj w kodzie, który fragment jest odpowiedzialny za pojawienie się znalezionego błędu. < /li> <
                li > Dodaj test, który sprawdzi, czy niepożądana sytuacja występuje po wykonaniu zlokalizowanego fragmentu kodu.Na przykład, jeśli błąd pojawia się po wywołaniu funkcji < code > foo() < /code>, najpierw
                znajdź test < code > test_foo() < /code> i upewnij się, że funkcja <
                code > foo() < /code> jest wywoływana z parametrami, przy których
                pojawia się błąd.Dodaj test wykrywający wystąpienie niepożądanej sytuacji.Po uruchomieniu testu otrzymasz czerwony komunikat. < /li> <
                li > W kolejnym kroku przyjdzie ci naprawić funkcję <
                code > foo() < /code>. Możesz to zrobić na różne sposoby, ale
                pamiętaj, że celem jest zamienienie czerwonego komunikatu z testu na zielony.Możesz zmienić sposób działania funkcji, zmienić sposób przekazywania argumentów lub wyeliminować jakiś błąd.Ważne, by po zmianach test < code > test_foo() < /code> przeszedł pomyślnie.</li >
                <
                li > Gdy test przechodzi pomyślnie, możesz przejść do kolejnego
                etapu, czyli refaktoryzacji kodu.To etap, w którym dbamy o to, by kod był czytelny, elegancki i łatwy do zrozumienia.Może to
                oznaczać przemianowanie zmiennych, zmianę sposobu ich deklaracji, a nawet usunięcie niepotrzebnych linii kodu.Refaktoryzacja powinna być przeprowadzana zgodnie z zasadami zdrowego rozsądku i nie powinna wpływać na poprawność funkcji. < /li> <
                li > W przyszłości dbaj o to, by test już zawsze pozostał zielony. < /li> < /
                ol > <
                h4 > Inne typy testów < /h4> <
                ul >
                <
                li > Testy jednostkowe to testy sprawdzające odizolowane jednostki kodu, najczęściej pojedyncze funkcje. < /li> <
                li > Testy integracyjne to testy sprawdzające, jak różne elementy systemu współpracują ze sobą. < /li> <
                li > Testy całego systemu(end - to - end) to testy sprawdzające, jak system działa jako całość, od wejścia aż do wyjścia. < /li> < /
                    ul > <
                    p > Ogólnie rzecz biorąc, im mniej testów jednostkowych, tym więcej
                testów integracyjnych i testów całego systemu jest potrzebnych, aby zapewnić odpowiedni poziom testowania.Ważne jest, aby zachować odpowiedni balans między różnymi typami testów. < /p> <
                p > Zgodnie z zaleceniami autora < a href =
                "https://www.oreilly.com/library/view/software-engineering-at/9781492082781/" >
                "Software Engineering at Google" < /a> testy należy rozdzielić w
                następujących proporcjach : < /p> <
                ul >
                <
                li > 80 % testy jednostkowe < /li> <
                li > 15 % testy integracyjne < /li> <
                li > 5 % testy całego systemu(end - to - end) < /li> < /
                ul > <
                h4 > Generowanie danych testowych automatycznie < /h4> <
                p > Przy tworzeniu aplikacji, warto również zadbać o skrypty generujące dane testowe, które są potrzebne do pracy aplikacji.Na
                przykład, jeśli piszesz aplikację komunikującą się z bazą danych MySQL, powinieneś mieć skrypt, który automatycznie utworzy taką bazę danych i wypełni ją przykładowymi danymi.Dzięki temu, podczas pisania kodu, możesz od razu sprawdzić, czy działa on poprawnie,
                bez konieczności czekania na uruchomienie testów w środowisku produkcyjnym.Ponadto, masz możliwość automatycznego testowania całej aplikacji. < /p> <
                h4 > Organizacja projektu z testami < /h4> <
                p > Aby zachować porządek w projekcie, warto rozdzielić kod produkcyjny i testy jednostkowe do osobnych folderach.W ten sposób
                łatwiej będzie zarządzać plikami i szybko odnaleźć potrzebne testy. < /p> <
                p > Przykładowo, struktura projektu może wyglądać następująco: < /p> <
                pre > < code > projekt├── przykladowy_pakiet│├── __init__.py│└── modul_a.py│└── modul_b.py└── tests├── __init__.py└── test_modul_a.py└── test_modul_b.py <
                /code></pre >
                <
                p > W ten sposób z jednej strony ograniczymy wielkość plików z testami, a z drugiej strony ułatwimy wszystkim życie, gdyż znacznie łatwiej będzie zlokalizować konkretny test. < /p> <
                h4 > Automatyzacja testów < /h4> <
                p > W momencie, gdy nasz projekt zaczyna rosnąć w skali, warto zastanowić się nad automatyzacją testów.Możliwe opcje to użycie narzędzi takich jak < a href = "https://travis-ci.org/" > Travis CI < /a>, <
                a href = "https://jenkins.io/" > Jenkins < /a>, czy <a href=
                "https://circleci.com/" > CircleCI < /a>. Dzięki temu każdorazowa
                zmiana w kodzie źródłowym automatycznie uruchamia wszystkie testy,
                dzięki czemu mamy pewność, że zmiany nie zepsuły istniejącej funkcjonalności. < /p> <
                p > Automatyzacja testów to także dobre rozwiązanie, gdy nie chcemy tracić czasu na ręczne wykonywanie testów na wszystkich możliwych platformach i przeglądarkach.W takim przypadku warto zainwestować w narzędzia do testowania aplikacji w różnych przeglądarkach i
                systemach operacyjnych, takie jak < a href =
                "https://www.selenium.dev/" > Selenium < /a>.</p >
                <
                h3 > Dokumentacja < /h3> <
                p > Dokumentacja to ważny element każdego projektu, służący do
                    opisania działania aplikacji oraz jej funkcjonalności.Narzędziem
                służącym do tworzenia dokumentacji w Pythonie jest SPHINX.Pozwala
                on na tworzenie dokumentacji w różnych formatach, takich jak HTML,
                LaTeX, epub, czy zwykły tekst.Możliwe jest również przekształcenie pliku w formacie LaTeX do PDF. < /p> <
                p > Aby zbudować szkielet dokumentacji, wystarczy uruchomić komendę: < /p> <
                pre > < code > quickstart <
                /code></pre >
                <
                p > SPHINX zapyta cię o kilka szczegółów dotyczących projektu, na podstawie których wygeneruje odpowiednie pliki startowe i wypełni je treścią. < /p> <
                p > Aby utworzyć dokumentację z plików konfiguracyjnych, użyj komendy: < /p> <
                pre > < code > make html <
                /code></pre >
                <
                p > Program poinformuje cię o pomyślnym utworzeniu dokumentacji,
                jeśli w trakcie procesu nie pojawią się żadne błędy.W przeciwnym razie proces tworzenia dokumentacji zostanie przerwany, a na konsoli zostaną wyświetlone komunikaty o błędach. < /p> <
                h4 > reStructuredText < /h4> <
                p > Plikiem startowym dokumentacji jest < code > index.rst < /code>.
                Zapisany jest on w formacie < code > reStructuredText < /code>, który
                jest rozszerzeniem języka markdown.Jego głównym atutem jest możliwość instalowania przydatnych pluginów.Linkowanie plików jest również uproszczone, co jest ważne w dokumentacji.Komenda <
                code > make html < /code> generuje na podstawie plików z rozszerzeniem <
                code > .rst < /code> odpowiadające im pliki html.</p >
                <
                h4 > Jak pisać dobrą dokumentację ? < /h4> <
                ol >
                <
                li > Zacznij od tutoriali. < /li> <
                li > Pokaż użytkownikowi jak zainstalować oraz uruchomić twoją aplikację. < /li> <
                li > Przygotuj scenariusze użycia programu. < /li> <
                li > Zaprezentuj, do czego służy każdy z elementów graficznych. < /li> <
                li > Tutoriale to nie to samo co dokumentacja, ale dobrze przygotowane poradniki pozwolą ci zebrać wiele informacji, które później możesz przetworzyć na dokumentację. < /li> <
                li > Korzystaj z narzędzi automatyzujących pracę. < /li> <
                li > Sphinx pozwala na tworzenie dokumentacji w różnych formatach. < /li> <
                li > Jeśli używasz języka Python, skorzystaj z modułu <
                code > docstrings < /code>, który umożliwia tworzenie dokumentacji
                bezpośrednio w plikach źródłowych. < /li> <
                li > Pamiętaj o aktualności dokumentacji. < /li> <
                li > Utrzymuj dokumentację w równowadze z aktualną wersją aplikacji. < /li> <
                li > W razie zmian w kodzie, pamiętaj o odpowiednim zaktualizowaniu dokumentacji. < /li> <
                li > Staraj się być zrozumiały. < /li> <
                li > Unikaj skomplikowanych zwrotów i nieznanych szerzej pojęć. < /li> <
                li > Jeśli masz taką możliwość, dodaj przykłady użycia. < /li> <
                li > Dopracuj szczegóły. < /li> <
                li > Zadbaj o poprawność gramatyczną i ortograficzną. < /li> <
                li > Dodaj linki do dokumentacji zewnętrznych bibliotek, jeśli
                korzystasz z nich w swoim projekcie. < /li> <
                li > Utrzymuj porządek. < /li> <
                li > Dokumentacja powinna być czytelna i przejrzysta. < /li> <
                li > Dziel informacje na krótkie rozdziały i sekcje. < /li> <
                li > Zachęcaj do zgłaszania błędów i propozycji ulepszeń. < /li> <
                li > Jeśli użytkownicy znajdą błędy lub będą mieć propozycje ulepszeń, chętnie przyjmij ich uwagi. < /li> < /
                ol > <
                h4 > Automatyczne generowanie dokumentacji do API < /h4> <
                p > Jeśli tworzysz aplikację z interfejsem API, warto zadbać o automatyczne generowanie dokumentacji, która będzie zawierała wszystkie dostępne endpointy, opis ich działania, a także informacje o przyjmowanych i zwracanych parametrach.W Pythonie jednym z popularnych narzędzi do tego celu jest < a href =
                    "https://www.sphinx-doc.org/en/master/" > Sphinx < /a>.</p >
                    <
                    p > Aby skorzystać z tej funkcjonalności, należy zainstalować
                rozszerzenie < code > sphinx - apidoc < /code> i uruchomić go z
                odpowiednimi opcjami.W folderze z dokumentacją należy wywołać polecenie : < /p> <
                pre > < code > sphinx - apidoc - o docs / source / api / & lt; ścieżka do katalogu z kodem & gt; <
                /code></pre >
                <
                p > To polecenie utworzy plik < code > api.rst < /code> z automatycznie
                wygenerowaną dokumentacją.Następnie należy dodać go do pliku <
                    code > index.rst < /code>, aby pojawił się w głównym menu
                dokumentacji. < /p> <
                pre > < code > ..toctree::
                : maxdepth: 2: caption: Spis treści:

                api <
                /code></pre >
                <
                p > Po uruchomieniu polecenia < code > make html < /code> będzie można
                zobaczyć wygenerowaną dokumentację na stronie internetowej. < /p> <
                h4 > Linki < /h4> <
                ul >
                <
                li > https: //developers.google.com/style</li>
                <
                /ul> <
                h3 > Pliki wykonywalne i PyInstaller < /h3> <
                p > Jeśli chcesz udostępnić swoją aplikację innym osobom,
                prawdopodobnie będziesz chciał zapakować ją w plik wykonywalny.W przypadku systemu Windows najprostszym sposobem na stworzenie pliku wykonywalnego jest użycie programu < a href =
                "https://www.pyinstaller.org/" > PyInstaller < /a>.</p >
                <
                p > Aby użyć PyInstaller, należy zainstalować go za pomocą pip: < /p> <
                pre > < code > pip install pyinstaller <
                /code></pre >
                <
                p > Następnie możesz wygenerować plik wykonywalny za pomocą polecenia: < /p> <
                pre > < code > pyinstaller nazwa_pliku.py <
                /code></pre >
                <
                p > Po wykonaniu polecenia zostanie utworzony folder dist, w którym znajdziesz plik wykonywalny o nazwie nazwa_pliku.exe.Możesz go umieścić w dowolnym miejscu na dysku i uruchomić. < /p> <
                p > PyInstaller ma również opcje pozwalające na dostosowanie sposobu tworzenia plików wykonywalnych do swoich potrzeb.Przykładowo,
                    możesz wybrać, czy chcesz zawrzeć w pliku wykonywalnym zasoby(np.obrazy, dźwięki), czy też chcesz udostępnić je osobno.Możesz także
                określić, czy plik wykonywalny ma być uruchamiany w oknie konsoli,
                czy też w osobnym oknie.Więcej informacji o opcjach dostępnych w PyInstaller znajdziesz w < a href =
                "https://pyinstaller.readthedocs.io/en/stable/index.html" > dokumentacji < /a>.</p >
                <
                h3 > Kod bajtowy < /h3> <
                p > Moduł < code > dis < /code> służy do wyświetlania kodu bajtowego dla
                funkcji lub bloków kodu.Aby wyświetlić kod bajtowy dla funkcji,
                użyj funkcji < code > dis() < /code> w nastęþujący sposób:</p >
                <
                pre > < code > from dis
                import dis

                def suma(a, b):
                return a + b

                dis(suma) <
                /code></pre >
                <
                p > Aby wyświetlić kod bajtowy dla bloku kodu, użyj funkcji <
                code > disassemble() < /code>:</p >
                <
                pre > < code > from dis
                import disassemble

                code = ""
                "
                def suma(a, b):
                return a + b ""
                "

                disassemble(code) <
                /code></pre >
                <
                p > Kod bajtowy jest przydatny w przypadku gdy chcesz zrozumieć, jak interpreter konwertuje kod napisany w Pythonie na instrukcje, które są wykonywane przez maszynę.Może to być również pomocne przy optymalizacji kodu lub tworzeniu wtyczek do Pythona w innych
                językach. < /p> <
                p > Aby uzyskać kod z zewnętrznych bibliotek musimy użyć modułu <
                code > inspect < /code>. Biblioteka ta umożliwia uzyskanie informacji
                o strukturze programu.Może być używana do zapisywania lub
                odczytywania kodu źródłowego, dokumentacji i innych informacji o obiektach. < /p> <
                p > Niektóre przydatne funkcje w module inspect to: < /p> <
                ul >
                <
                li > < code > inspect.getsource(object) < /code> - zwraca kod źródłowy
                obiektu jako string < /li> <
                li > < code > inspect.getdoc(object) < /code> - zwraca dokumentację
                obiektu jako string < /li> <
                li > < code > inspect.getmembers(object) < /code> - zwraca listę krotek
                (name, value) dla wszystkich atrybutów obiektu < /li> <
                li > < code > inspect.isclass(object) < /code> - zwraca True, jeśli
                obiekt jest klasą < /li> <
                li > < code > inspect.isfunction(object) < /code> - zwraca True, jeśli
                obiekt jest funkcją < /li> <
                li > < code > inspect.ismethod(object) < /code> - zwraca True, jeśli
                obiekt jest metodą < /li> < /
                ul > <
                p > Przykład użycia: < /p> <
                pre > < code >
                import inspect
                import tkinter

                print(inspect.getsource(tkinter.Tk)) # podejzyj kod klasy Tk z modulu tkinter print(inspect.getdoc(tkinter.Tk)) # podejzyj docstring klasy Tk z modulu tkinter <
                /code></pre >
                <
                h2 > Python w praktyce < /h2> <
                p > W tej części przyjrzymy się różnym aspektom pracy z językiem Python w praktyce.Omówimy wiele narzędzi i bibliotek, które mogą być przydatne podczas tworzenia wszelakiego oprogramowania. < /p> <
                p > Początkowo skupimy się na obsłudze argumentów linii poleceń i pracy z plikami i folderami.Następnie przyjrzymy się bibliotece Pandas i sposobom obsługi plików CSV.Kolejnym tematem będzie praca z plikami PDF oraz uzyskiwanie informacji o systemie operacyjnym. < /p> <
                p > Przejdziemy również do tematów związanych z siecią, takich jak
                HTTP oraz prosty serwer.Nie zabraknie również wprowadzenia do
                    tworzenia API za pomocą biblioteki FastAPI oraz pracy z bazami
                danych za pomocą SQLite. < /p> <
                p > Na końcu zapoznamy się z biblioteką Tkinter do tworzenia
                interfejsu graficznego oraz narzędziem do gromadzenia logów. < /p> <
                h3 > Argumenty linii poleceń < /h3> <
                p > Python obsługuje argumenty linii poleceń.Jeśli chcemy, by nasz skrypt był sterowany przez argumenty przekazywane podczas jego uruchomienia, mamy do dyspozycji kilka narzędzi, które ułatwią nam
                to zadanie. < /p> <
                p > Moduł biblioteki standardowej sys zawiera zmienną argv, która przechowuje nazwę programu oraz listę argumentów przekazanych z linii poleceń.Zakłada się, że argumenty są oddzielone spacjami. < /p> <
                p > Przykładowo, jeśli mamy skrypt o nazwie suma.py i chcemy, by po jego uruchomieniu skrypt wypisał sumę argumentów przekazanych z linii poleceń, możemy to zrobić w następujący sposób: < /p> <
                pre > < code >
                import sys print(sum(sys.argv[1: ])) <
                /code></pre >
                <
                p > Dla następującej kombinacji liczb powinniśmy otrzymać następujący wynik: < /p> <
                pre > < code > $ python suma.py 3 2 1 6 <
                /code></pre >
                <
                p > Jeśli chcielibyśmy używać flag do nazywania dostępnych opcji,
                    możemy nadal użyć sys.argv, ale będziemy musieli napisać parser do
                        obsługi wszystkich możliwych kombinacji flag.Łatwiej skorzystać z
                    gotowego narzędzia.Również w bibliotece standardowej mamy moduł <
                    em > argparse < /em>. Moduł ten daje nam opcję zdefiniowania możliwych
                do użycia argumentów. < /p> <
                p > Załóżmy, że chcemy by nasz skrypt przyjmował nazwę pliku jako argument, a następnie dopisywał na końcu pliku wiersz "nowy
                wiersz ". Możemy to zrobić w następujący sposób:</p> <
                pre > < code >
                import argparse from pathlib
                import Path

                parser = argparse.ArgumentParser() parser.add_argument("plik", help = "sciezka do pliku ktory chcesz zmodyfikowac") args = parser.parse_args()

                plik = Path(args.plik) nowy_wiersz = "nowy wiersz"
                plik.write_text(plik.read_text() + nowy_wiersz) <
                /code></pre >
                <
                p > Jeśli teraz uruchomimy plik bez argumentu, to zostanie wyświetlony komunikat o błędzie: < /p> <
                pre > < code > $ python3 script.py usage: script.py[-h] plik script.py: error: the following arguments are required: plik <
                /code></pre >
                <
                p > Mamy możliwość wyświetlenia pomocy dla naszego skryptu.Moduł <
                em > argparse < /em> generuje pomoc automatycznie na podstawie
                argumentów, jakie ustawiliśmy. < /p> <
                pre > < code > $ python3 script.py - h usage: script.py[-h] plik

                positional arguments:
                plik sciezka do pliku ktory chcesz zmodyfikowac

                options:
                -h, --help show this help message and exit <
                /code></pre >
                <
                p > Jeśli chcemy by argument był opcjonalny to przy dodawaniu go musimy ustawić pole < em > required < /em> na <em>False</em > . < /p> <
                pre > < code > parser.add_argument("--argument", help = "Opcjonalny argument", required = False) <
                /code></pre >
                <
                p > Inne opcje to połączenie argumentu z flagą, nadanie wartości domyślnej oraz ustawienie oczekiwanego typu: < /p> <
                pre > < code > parser.add_argument("-a", "--argument", help = "Argument z wartością domyślną", type = int,
                    default = 10, required = False) <
                /code></pre >
                <
                h3 > Praca z plikami i folderami < /h3> <
                p > Standardowa biblioteka Pythona zawiera wiele funkcji do pracy z
                plikami i folderami.Skrypty Pythona mogą być używane do
                    automatyzacji prostych zadań biurowych. < /p> <
                h4 > Otwarcie pliku < /h4> <
                p > Do otwierania plików w Pythonie używamy funkcji open().Funkcja ta przyjmuje ścieżkę do pliku oraz tryb otwarcia.Po użyciu funkcji
                open() należy pamiętać o wywołaniu funkcji close(), aby zamknąć plik.Możemy to zrobić ręcznie lub skorzystać z konstrukcji with,
                która automatycznie zamknie plik po jej zakończeniu. < /p> <
                pre > < code > # otwarcie pliku w trybie odczytu plik = open("sciezka/do/pliku.txt", "r")

                ...

                plik.close()

                # lub z wykorzystaniem konstrukcji with with open("sciezka/do/pliku.txt", "r") as plik:
                ...
                <
                /code></pre >
                <
                p > Istnieją 4 standardowe tryby otwarcia pliku: < /p> <
                ol >
                <
                li > < code > r < /code> - odczytywanie.</li >
                <
                li > < code > r + < /code> - odczytywanie oraz modyfikacja.</li >
                <
                li > < code > w < /code> - modyfikacja wraz z usunięciem poprzedniej
                treści. < /li> <
                li > < code > a < /code> - modyfikacja wraz z dopisaniem nowej treści do
                poprzedniej treści pliku. < /li> < /
                ol > <
                h4 > Odczytywanie i zapisywanie danych < /h4> <
                p > Aby odczytać zawartość pliku, możemy skorzystać z funkcji readlines(), która zwraca listę napisów.Każdy napis w liście reprezentuje kolejny wiersz pliku.Aby zapisać dane do pliku,
                    używamy funkcji write.Funkcja ta przyjmuje jeden argument, napis,
                    gdzie kolejne wiersze powinny być oddzielone znakiem <
                    em > \n < /em>.</p >
                    <
                    pre > < code > with open("sciezka/do/pliku.txt") as plik:

                    # odczytaj tresc pliku
                wiersze = plik.readlines() for wiersz in wiersze:
                print(wiersz)

                # zapisz nowa tresc do pliku
                plik.write("nowy tekst\nwiersz nr. 2\n") <
                /code></pre >
                <
                h4 > Moduł pathlib < /h4> <
                p > Moduł pathlib pojawił się w Pythonie w wersji 3.4.Jest to zestaw narzędzi, które umożliwiają pracę z plikami i folderami w sposób bardziej przyjazny dla użytkownika. < /p> <
                p > Oto kilka przykładów metod z tego modułu: < /p> <
                ul >
                <
                li > < code > .exists() < /code> - zwraca True jeśli plik lub folder o
                podanej ścieżce istnieje, w przeciwnym wypadku zwraca False. < /li> <
                li > < code > .is_file() < /code> - zwraca True jeśli obiekt Path
                reprezentuje plik, w przeciwnym wypadku zwraca False. < /li> <
                li > < code > .is_dir() < /code> - zwraca True jeśli obiekt Path
                reprezentuje folder, w przeciwnym wypadku zwraca False. < /li> <
                li > < code > .read_text() < /code> - odczytuje zawartość pliku jako
                napis. < /li> <
                li > < code > .write_text() < /code> - zapisuje napis do pliku.</li >
                <
                li > < code > .open() < /code> - otwiera plik w trybie określonym przez
                drugi argument(domyślnie 'r'). < /li> < /
                ul > <
                p > Poniższy przykład pokazuje, jak można wykorzystać te metody: < /p> <
                pre > < code > from pathlib
                import Path

                sciezka = Path("/sciezka/do/pliku.txt")

                # sprawdzenie, czy plik istnieje
                if sciezka.exists():
                print("Plik istnieje.")
                else :
                    print("Plik nie istnieje.")

                # odczytanie zawartości pliku zawartosc = sciezka.read_text() print(zawartosc)

                # zapisanie nowej zawartości do pliku
                sciezka.write_text("Nowy tekst w pliku.") <
                /code></pre >
                <
                p > Aby uzyskać obiekt reprezentujący folder, należy utworzyć obiekt klasy Path z odpowiednią ścieżką do folderu: < /p> <
                pre > < code > folder = Path("sciezka/do/folderu") <
                /code></pre >
                <
                p > Następnie możemy użyć metod tego obiektu, takich jak iterdir() do iterowania po plikach i folderach w danym folderze: < /p> <
                pre > < code >
                for element in folder.iterdir():
                print(element) <
                /code></pre >
                <
                p > Możemy również sprawdzić, czy obiekt jest plikiem czy folderem za pomocą metod is_file() i is_dir(): < /p> <
                pre > < code >
                if element.is_file():
                print("To jest plik") elif element.is_dir():
                print("To jest folder") <
                /code></pre >
                <
                p > Inne przydatne metody to exists(), która sprawdza, czy dany element istnieje, oraz mkdir(), która tworzy nowy folder. < /p> <
                pre > < code >
                if not folder.exists():
                folder.mkdir() <
                /code></pre >
                <
                h3 > Pandas i csv < /h3> <
                p > Moduł Pandas to bardzo popularny moduł, używany do pracy z
                danymi tabelarycznymi.Do zapisywania danych tabelarycznych do
                    pliku csv oraz odczytywania danych z pliku csv, służą nam funkcje <
                    code > to_csv() < /code> oraz <code>read_csv()</code > . < /p> <
                p > Załóżmy, że mamy tabelę przedstawiającą rachunki za prąd w wybranym domu.Chcemy zapisać tę tabelę do pliku csv, a następnie
                odczytać dane z tego pliku.Możemy to zrobić w następujący sposób: < /p> <
                pre > < code >
                import pandas as pd

                # przygotowujemy dane do zapisania
                data = [
                    ["2022-01-01", 100],
                    ["2022-02-01", 120],
                    ["2022-03-01", 130]
                ] df = pd.DataFrame(data, columns = ["data", "kwota"])

                # zapisujemy dane do pliku csv
                df.to_csv("rachunki.csv", index = False)

                # odczytujemy dane z pliku csv df_odczytane = pd.read_csv("rachunki.csv") print(df_odczytane) <
                /code></pre >
                <
                p > Wynikiem tego kodu będzie tabela o takim wyglądzie: < /p> <
                p > | data | kwota | | -- -- | -- -- - | | 2022 - 01 - 01 | 100 | |
                2022 - 02 - 01 | 120 | | 2022 - 03 - 01 | 130 | < /p> <
                h4 > Podstawowe informacje o tabeli < /h4> <
                p > Po wczytaniu tabeli do pamięci, możemy wyświetlić podstawowe
                informacje o niej za pomocą funkcji < code > info() < /code>.</p >
                <
                pre > < code > df.info() <
                /code></pre >
                <
                p > Funkcja ta pokazuje nam takie informacje jak: < /p> <
                ul >
                <
                li > ilość wierszy i kolumn, < /li> <
                li > typy danych w poszczególnych kolumnach, < /li> <
                li > ilość niezapełnionych pól. < /li> < /
                ul > <
                h4 > Podgląd danych < /h4> <
                p > Aby sprawdzić, jakie dane mamy w tabeli, możemy wyświetlić jej fragment za pomocą funkcji < code > head() < /code> lub <
                code > tail() < /code>. Domyślnie obie funkcje wyświetlają 5
                pierwszych lub ostatnich wierszy tabeli.Możemy też podać ilość wierszy jaką chcemy wyświetlić jako argument. < /p> <
                pre > < code > df.head(10) # pierwsze 10 wierszy df.tail() # ostatnie 5 wierszy <
                /code></pre >
                <
                h4 > Selekcja kolumn < /h4> <
                p > Aby wybrać konkretne kolumny z tabeli, możemy użyć notacji z nawiasami kwadratowymi. < /p> <
                pre > < code > df[["kolumna_1", "kolumna_2"]] <
                /code></pre >
                <
                h4 > Filtrowanie danych < /h4> <
                p > Do filtrowania danych służy nam operator < code > [] < /code>. Możemy
                użyć go w połączeniu z operatorami logicznymi, takimi jak <
                code > & < /code> lub <code>|</code > . < /p> <
                p > Przykładowo, jeśli mamy tabelę zawierającą informacje o użytkownikach i interesują nas tylko ci użytkownicy, którzy mają więcej niż 30 lat, to możemy użyć następującej komendy: < /p> <
                pre > < code > df.loc[df['Wiek'] & gt; 30] <
                /code></pre >
                <
                p > Jeśli chcemy pokazać użytkowników, którzy mają więcej niż 30 lat i mieszkają w Warszawie, to możemy użyć następującej komendy: < /p> <
                pre > < code > df.loc[(df['Wiek'] & gt; 30) & (df['Miasto'] == 'Warszawa')] <
                /code></pre >
                <
                h3 > Praca z plikami PDF < /h3> <
                p > Istnieje kilka popularnych bibliotek do obsługi plików PDF.
                Jedną z najczęściej używanych jest biblioteka < code > PyPDF2 < /code>.
                Aby ją zainstalować, możemy użyć polecenia < code > pip install pypdf2 < /code>.</p >
                <
                h4 > Otwieranie pliku PDF < /h4> <
                p > Aby otworzyć plik PDF, używamy funkcji <
                code > PdfFileReader < /code> z modułu <code>PyPDF2</code > . < /p> <
                pre > < code > from PyPDF2
                import PdfFileReader

                # otworz plik with open('plik.pdf', 'rb') as plik:
                reader = PdfFileReader(plik) <
                /code></pre >
                <
                h4 > Wypisywanie informacji o pliku < /h4> <
                p > Aby wyświetlić informacje o pliku, takie jak ilość stron, autor czy tytuł, możemy skorzystać z odpowiednich właściwości obiektu <
                code > PdfFileReader < /code>:</p >
                <
                pre > < code > print(f "Ilość stron: {czytnik.getNumPages()}") print(f "Autor: {czytnik.getDocumentInfo().author}") print(f "Tytuł: {czytnik.getDocumentInfo().title}") <
                /code></pre >
                <
                h4 > Odczytywanie tekstu < /h4> <
                p > Aby wyświetlić zawartość pliku PDF, możemy użyć metody <
                code > getPage() < /code>. Metoda <code>getPage()</code > oczekuje obiektu < code > PageObject < /code> reprezentującego daną stronę.
                Metoda < code > getNumPages() < /code> zwraca liczbę stron w pliku.</p >
                <
                p > Poniższy kod wyświetla zawartość wszystkich stron pliku PDF: < /p> <
                pre > < code > # pobierz liczbe stron liczba_stron = reader.getNumPages()

                # dla kazdej strony
                for strona in range(liczba_stron):
                # pobierz tekst strony tekst = reader.getPage(strona).extractText() # wyswietl tekst print(tekst) <
                /code></pre >
                <
                h4 > Modyfikowanie pliku PDF < /h4> <
                p > Aby modyfikować plik PDF, możemy użyć obiektu <
                code > PdfFileWriter < /code> z modułu <code>PyPDF2</code > .Możemy dodawać nowe strony do pliku lub usuwać istniejące strony. < /p> <
                p > Poniższy kod dodaje nową stronę z tekstem "Hello, World!"
                do
                    pliku: < /p> <
                pre > < code > # utworz obiekt PdfFileWriter writer = PdfFileWriter()

                # dodaj nowa strone z tekstem writer.addPage(writer.newTextPage("Hello, World!"))

                # otworz plik do zapisu
                with open('nowy_plik.pdf', 'wb') as plik:
                # zapisz plik writer.write(plik) <
                /code></pre >
                <
                h4 > Łączenie plików PDF < /h4> <
                p > Możemy użyć poniższego kodu, aby połączyć wszystkie pliki PDF z listy: < /p> <
                pre > < code >
                import os
                import glob from PyPDF2
                import PdfFileMerger

                # utworzenie listy plikow pdf_files = []
                for filename in glob.glob('*.pdf'):
                pdf_files.append(filename)

                # utworzenie obiektu merger merger = PdfFileMerger()

                # laczenie plikow
                for pdf in pdf_files:
                merger.append(open(pdf, 'rb'))

                # zapis nowego pliku with open('sciezka/do/nowego_pliku.pdf', 'wb') as fout:
                merger.write(fout) <
                /code></pre >
                <
                h3 > Informacje o systemie operacyjnym < /h3> <
                p > Moduł < code > os < /code> w bibliotece standardowej umożliwia
                uzyskiwanie informacji o systemie operacyjnym oraz manipulowanie plikami i folderami. < /p> <
                p > Przykładowo, możemy uzyskać nazwę aktualnie używanego systemu operacyjnego za pomocą < code > os.name < /code>:</p >
                <
                pre > < code >
                import os print(os.name) <
                /code></pre >
                <
                h4 > Informacje o użytkownikach < /h4> <
                p > Aby uzyskać informacje o użytkownikach systemu oraz grupach,
                możemy skorzystać z modułu < code > pwd < /code>:</p >
                <
                pre > < code >
                import pwd

                # Pobierz informacje o użytkowniku user_info = pwd.getpwuid(os.getuid()) print(f "Nazwa użytkownika: {user_info.pw_name}") print(f " ID użytkownika: {user_info.pw_uid}") print(f " ID grupy: {user_info.pw_gid}") print(f " Katalog domowy: {user_info.pw_dir}")

                # Pobierz informacje o grupie group_info = pwd.getgrgid(user_info.pw_gid) print(f " Nazwa grupy: {group_info.gr_name}") print(f " ID grupy: {group_info.gr_gid}") print(f " Lista użytkowników w grupie: {group_info.gr_mem}") <
                /code></pre >
                <
                h4 > Dyski < /h4> <
                p > Aby uzyskać informacje o dostępnych dyskach oraz wolnym miejscu na nich, możemy skorzystać z modułu < code > os.statvfs < /code>:</p >
                <
                pre > < code >
                import os

                # Pobierz informacje o dysku disk_info = os.statvfs("/") print(f " Całkowita pojemność dysku: {disk_info.f_frsize * disk_info.f_blocks:,} bajtów") print(f " Wolne miejsce na dysku: {disk_info.f_frsize * disk_info.f_bfree:,} bajtów") <
                /code></pre >
                <
                h4 > Informacje o procesorze < /h4> <
                p > Moduł < code > os < /code> z biblioteki standardowej zawiera funkcję <
                code > cpu_count() < /code>, która zwraca liczbę rdzeni procesora.
                Możemy również uzyskać informacje o mocy obliczeniowej procesora za pomocą modułu < code > psutil < /code>. Poniższy przykład pokazuje, jak
                wyświetlić liczbę rdzeni oraz moc obliczeniową procesora: < /p> <
                pre > < code >
                import os
                import psutil

                # Liczba rdzeni procesora print(f "Liczba rdzeni procesora: {os.cpu_count()}")

                # Moc obliczeniowa procesora print(f "Moc obliczeniowa procesora: {psutil.cpu_freq().max} MHz") <
                /code></pre >
                <
                h4 > Zmienne środowiskowe < /h4> <
                p > Moduł < code > os < /code> zawiera również funkcję <
                code > environ < /code>, która zwraca słownik zawierający wszystkie
                zmienne środowiskowe.Możemy odczytać wartość konkretnej zmiennej środowiskowej, używając notacji słownikowej.Poniższy przykład pokazuje, jak wyświetlić zmienną środowiskową o nazwie SHELL: < /p> <
                pre > < code >
                import os

                # Wyświetl zmienną środowiskową SHELL print(f "Zmienna środowiskowa SHELL: {os.environ['SHELL']}") <
                /code></pre >
                <
                p > Aby zmienić zmienną środowiskową, można użyć funkcji <
                code > os.environ.update() < /code>. Przykładowo, aby ustawić zmienną
                środowiskową o nazwie < code > VAR < /code> na wartość value, można użyć
                następującego kodu: < /p> <
                pre > < code >
                import os

                os.environ.update({
                    'VAR': 'value'
                }) <
                /code></pre >
                <
                p > Uwaga: zmiany zmiennych środowiskowych zachodzą tylko w obrębie bieżącego procesu.Po zakończeniu działania skryptu zmiany te nie będą widoczne dla innych procesów.Aby zmiany zmiennych środowiskowych zostały zapisane dla całego systemu, należy je zapisać w odpowiednim pliku konfiguracyjnym(np. <
                    code > /etc/environment < /code> lub <code>/etc / bash.bashrc < /code> w
                    systemie Linux). < /p> <
                h3 > HTTP i prosty serwer < /h3> <
                p > HTTP(Hypertext Transfer Protocol) jest protokołem sieciowym używanym do przesyłania danych między klientem a serwerem.Jest to
                podstawowa technologia używana do przeglądania stron internetowych
                oraz komunikacji między aplikacjami. < /p> <
                p > Aby wysłać żądanie HTTP w Pythonie, można użyć modułu <
                code > requests < /code>. Poniższy przykład pokazuje, jak wysłać
                żądanie typu < code > GET < /code> do strony internetowej i otrzymać
                odpowiedź z serwera: < /p> <
                pre > < code >
                import requests

                url = "https://www.google.com"
                response = requests.get(url)

                print(response.status_code) # sprawdzamy kod odpowiedzi print(response.text) # wyświetlamy zawartość odpowiedzi <
                /code></pre >
                <
                p > Możliwe jest również wysyłanie żądań < code > POST < /code>, <
                code > PUT < /code>, <code>DELETE</code > itp.oraz dodawanie nagłówków i danych do żądania. < /p> <
                p > Jeśli chcesz stworzyć prosty serwer HTTP w Pythonie, możesz użyć modułu http.server.Poniższy przykład pokazuje, jak stworzyć serwer, który nasłuchuje na porcie 8000 i wyświetla zawartość pliku <
                code > index.html < /code> po otrzymaniu żądania <code>GET</code >: < /p> <
                pre > < code >
                import http.server
                import socketserver

                PORT = 8000

                Handler = http.server.SimpleHTTPRequestHandler

                with socketserver.TCPServer(("", PORT), Handler) as httpd:
                print("serving at port", PORT) httpd.serve_forever() <
                /code></pre >
                <
                p > Możesz również dostosować handler, aby obsługiwać różne typy żądań i odpowiednio reagować na nie. < /p> <
                h3 > API wraz z FastAPI < /h3> <
                p > FastAPI to nowoczesne i szybkie narzędzie do tworzenia API w
                Pythonie.Jest oparte na bibliotece Starlette i używa Pydantic do
                    walidacji danych wejściowych. < /p> <
                p > Aby rozpocząć pracę z FastAPI, należy najpierw zainstalować je za pomocą komendy: < /p> <
                pre > < code > pip install fastapi <
                /code></pre >
                <
                p > Przykład prostego API z FastAPI: < /p> <
                pre > < code > from fastapi
                import FastAPI

                app = FastAPI()

                @app.get("/") def read_root():
                return {
                    "Hello": "World"
                } <
                /code></pre >
                <
                p > API może przyjmować różne metody HTTP(np. < code > GET < /code>, <
                    code > POST < /code>, <code>DELETE</code > ) oraz zwracać różne formaty danych(np.JSON, HTML). < /p> <
                pre > < code > from fastapi
                import FastAPI from pydantic
                import BaseModel

                app = FastAPI()

                class Item(BaseModel):
                name: str description: str = None price: float tax: float = None

                @app.post("/items/") def create_item(item: Item):
                return item <
                    /code></pre >
                    <
                    p > W powyższym przykładzie zdefiniowano nowy model danych - Item,
                    który jest walidowany przy użyciu Pydantic.Następnie zdefiniowano
                nową ścieżkę < code > /items/ < /code> dostępną dla metody POST, która
                przyjmuje obiekt item i zwraca go jako odpowiedź. < /p> <
                p > FastAPI posiada też mechanizm do automatycznej generacji
                dokumentacji dla API.Aby skorzystać z tej funkcjonalności, należy użyć dekoratora < code > @app.docs < /code> i odpowiednio opisać
                poszczególne ścieżki i modele danych. < /p> <
                pre > < code > from fastapi
                import FastAPI from pydantic
                import BaseModel

                app = FastAPI()

                class Item(BaseModel):
                name: str description: str = None price: float tax: float = None

                @app.post("/items/") @app.docs(
                    summary = "Create a new item",
                    description = "This endpoint allows you to create a new item in the store",
                    responses = {
                        200: {
                            "description": "Success"
                        },
                        404: {
                            "description": "Not found"
                        },
                    },
                ) def create_item(item: Item):
                return item <
                    /code></pre >
                    <
                    p > Aby uruchomić aplikację, wystarczy wywołać metodę <
                    code > run() < /code> na obiekcie reprezentującym aplikację:</p >
                    <
                    pre > < code >
                    if __name__ == "__main__":
                app.run() <
                /code></pre >
                <
                p > Po uruchomieniu aplikacji możesz otworzyć adres <
                code > http: //localhost:8000/</code> w przeglądarce, aby zobaczyć
                odpowiedź zwróconą przez endpoint. < /p> <
                p > FastAPI oferuje również możliwość walidacji danych wejściowych i zwracanych przez endpointy.Możesz użyć typów Pythona, takich jak <
                code > int < /code> lub <code>str</code > , aby opisać argumenty wejściowe oraz typ zwracany przez endpoint.FastAPI automatycznie sprawdzi, czy dane wejściowe są poprawne. < /p> <
                h3 > Bazy danych z SQLite < /h3> <
                p > Istnieje wiele baz danych.Każda ma swoje wady i zalety.Baza danych SQLite jest niezależna od systemu operacyjnego i nie wymaga instalacji żadnego dodatkowego oprogramowania.Zaletą SQLite jest prostota użytku.Nie potrzeba nam żadnego serwera, cała baza danych może zostać sprowadzona do jednego pliku, który w programie jest w
                całości załadowany do pamięci RAM. < /p> <
                p > Przykładowe zbiory danych możesz pobrać z następujących stron: *
                <
                a href = "https://data.gov/" > data.gov < /a> * <a href=
                "https://www.kaggle.com/" >
                kaggle < /a></p >
                <
                p > Moduł sqlite3 pozwala na obsługę bazy danych SQLite. < /p> <
                h4 > Połączenie z bazą danych < /h4> <
                p > Do połączenia z bazą danych należy użyć funkcji <
                code > connect() < /code> z modułu sqlite3. Funkcja ta przyjmuje jako
                argument ścieżkę do pliku bazy danych.Jeśli podana baza danych nie
                istnieje, to zostanie ona utworzona. < /p> <
                pre > < code >
                import sqlite3

                connection = sqlite3.connect("baza_danych.db") <
                /code></pre >
                <
                h4 > Tworzenie tabel < /h4> <
                p > Aby utworzyć tabelę w bazie danych, należy wywołać metodę <
                code > execute() < /code> na obiekcie połączenia. Metoda ta przyjmuje
                jako argument polecenie SQL tworzące tabelę. < /p> <
                pre > < code > connection.execute("CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)") <
                /code></pre >
                <
                h4 > Dodawanie rekordów < /h4> <
                p > Aby dodać rekord do tabeli, należy wywołać polecenie <
                    code > INSERT INTO < /code> za pomocą metody <
                code > execute() < /code>.</p >
                <
                pre > < code > connection.execute("INSERT INTO users (username, password) VALUES (?, ?)", ("user1", "pass1")) connection.execute("INSERT INTO users (username, password) VALUES (?, ?)", ("user2", "pass2")) <
                /code></pre >
                <
                h4 > Pobieranie danych < /h4> <
                p > Aby pobrać dane z tabeli, należy wywołać polecenie <
                code > SELECT < /code> za pomocą metody <code>execute()</code > .Metoda ta zwraca obiekt cursor, z którego można pobrać rekordy za pomocą metody < code > fetchall() < /code>.</p >
                <
                pre > < code > cursor = connection.execute("SELECT * FROM users") users = cursor.fetchall() print(users) #[(1, 'user1', 'pass1'), (2, 'user2', 'pass2')] <
                /code></pre >
                <
                h4 > Zamykanie połączenia < /h4> <
                p > Po zakończeniu pracy z bazą danych należy wywołać metodę <
                code > close() < /code> na obiekcie połączenia.</p >
                <
                pre > < code > connection.close() <
                /code></pre >
                <
                h3 > Tkinter < /h3> <
                p > Tkinter jest modułem biblioteki standardowej, który służy do
                    tworzenia interfejsów graficznych(GUI).Możemy z niego korzystać,
                    aby tworzyć proste aplikacje okienkowe. < /p> <
                p > Tworzenie okna głównego za pomocą Tkinter wygląda następująco: < /p> <
                pre > < code >
                import tkinter as tk

                root = tk.Tk() root.mainloop() <
                /code></pre >
                <
                p > Możemy dodać różne elementy interfejsu, takie jak przyciski,
                etykiety, pola tekstowe i inne.Przykład dodania przycisku: < /p> <
                pre > < code >
                import tkinter as tk

                def przycisk_klik():
                print("Kliknięto przycisk")

                root = tk.Tk() przycisk = tk.Button(root, text = "Kliknij mnie", command = przycisk_klik) przycisk.pack() root.mainloop() <
                /code></pre >
                <
                p > Możemy również ustawić różne opcje dla elementów interfejsu,
                takie jak rozmiar, kolor tła, itp.Przykład: < /p> <
                pre > < code >
                import tkinter as tk

                root = tk.Tk() etykieta = tk.Label(root, text = "Witaj w Tkinter", font = ("Helvetica", 16), bg = "yellow") etykieta.pack() root.mainloop() <
                /code></pre >
                <
                p > Tkinter oferuje również możliwość tworzenia layoutów za pomocą ramki(frame).Możemy umieścić różne elementy w ramce i ustalić ich położenie za pomocą siatki(grid).Przykład: < /p> <
                pre > < code >
                import tkinter as tk

                root = tk.Tk()

                frame = tk.Frame(root) frame.pack()

                przycisk1 = tk.Button(frame, text = "Przycisk 1") przycisk2 = tk.Button(frame, text = "Przycisk 2") przycisk3 = tk.Button(frame, text = "Przycisk 3")

                przycisk1.grid(row = 0, column = 0) przycisk2.grid(row = 0, column = 1) przycisk3.grid(row = 0, column = 2)

                root.mainloop() <
                /code></pre >
                <
                h4 > Zdarzenia < /h4> <
                p > mamy możliwość obsługi zdarzeń za pomocą metody <
                code > bind() < /code>. Zdarzenia mogą być generowane przez
                użytkownika lub system.Do najczęściej używanych zdarzeń należą: < /p> <
                ul >
                <
                li > < code > & lt; Button - 1 & gt; < /code> - kliknięcie lewym przyciskiem
                myszy na komponencie < /li> <
                li > < code > & lt; ButtonRelease - 1 & gt; < /code> - puszczenie lewego
                przycisku myszy nad komponentem < /li> <
                li > < code > & lt; Double - Button - 1 & gt; < /code> - podwójne kliknięcie
                lewym przyciskiem myszy na komponencie < /li> <
                li > < code > & lt; Enter & gt; < /code> - najechanie myszką na
                komponent < /li> <
                li > < code > & lt; Leave & gt; < /code> - zjechanie myszką z komponentu</li >
                <
                li > < code > & lt; Key & gt; < /code> - naciśnięcie dowolnego klawisza na
                klawiaturze < /li> <
                li > < code > & lt; Return & gt; < /code> - naciśnięcie klawisza Enter</li >
                <
                /ul> <
                p > Aby obsłużyć zdarzenie, wystarczy wywołać metodę <
                code > bind() < /code> na obiekcie komponentu, przekazując do niej
                nazwę zdarzenia oraz funkcję obsługi zdarzenia. < /p> <
                p > Przykładowo, jeśli chcemy wyświetlić komunikat po najechaniu myszką na przycisk, możemy użyć następującego kodu: < /p> <
                pre > < code > from tkinter
                import Button, Tk

                def mouse_over(event):
                print("Myszka najechała na przycisk")

                root = Tk() button = Button(root, text = "Przycisk") button.bind("&lt;Enter&gt;", mouse_over) button.pack() root.mainloop() <
                /code></pre >
                <
                p > Możemy też użyć dekoratora < code > @event_decorator < /code> do
                obsługi zdarzeń.W tym przypadku nie musimy już ręcznie wywoływać metody < code > bind() < /code>, a dekorator automatycznie połączy
                funkcję z odpowiednim zdarzeniem. < /p> <
                pre > < code > from tkinter
                import Button, Tk

                root = Tk() button = Button(root, text = "Przycisk")

                @button.event_decorator("&lt;Enter&gt;") def mouse_over(event):
                print("Myszka najechała na przycisk")

                button.pack() root.mainloop() <
                /code></pre >
                <
                h3 > Logi < /h3> <
                p > Większość programów, które tworzyliśmy w obrębie tego kursu,
                była jednorazowo uruchamiana i od razu zamykana.W prawdziwym świecie programy mogą działać godzinami, dniami lub nawet całymi latami.W takim przypadku wypadałoby poza samym efektem działania programu co jakiś czas otrzymać od programu informacje o tym, co aktualnie robi, wraz z ewentualnymi komunikatami o błędach.Takie informacje, zwane logami, są często zapisywane do osobnego
                pliku. < /p> <
                p > Moduł < code > logging < /code> zawiera wiele przydatnych
                funkcjonalności do tworzenia logów. < /p> <
                p > Mamy dostępnych kilka poziomów logów: < /p> <
                p > | poziom | wartość | | -- -- -- | -- -- -- - | | CRITICAL | 50 | |
                ERROR | 40 | | WARNING | 30 | | INFO | 20 | | DEBUG | 10 | | NOTSET |
                0 | < /p> <
                p > Rzućmy okiem na prosty przykład, gdzie wypisujemy na konsoli komunikat "Przykładowa wiadomość": < /p> <
                pre > < code >
                import logging

                logging.basicConfig(level = logging.INFO) logging.info("Przykladowa wiadomosc.") <
                /code></pre >
                <
                p > W powyższym przykładzie, linia <
                code > logging.basicConfig(level = logging.INFO) < /code> ustawia poziom
                logów na < code > INFO < /code>. Poziomy logów określają ważność logów.
                W przypadku będą wyświetlane logi o poziomie < code > INFO < /code> i
                wszystkie powyżej niego(np. < code > WARNING < /code>, <
                    code > ERROR < /code>, <code>CRITICAL</code > ).Linia <
                code > logging.info("Przykladowa wiadomosc.") < /code> wyświetla
                komunikat "Przykladowa wiadomosc."
                na konsoli.W tym przypadku poziom logu jest ustawiony na < code > INFO < /code>. Jeśli poziom logów
                ustawiony przez < code > logging.basicConfig() < /code> jest równy lub
                wyższy niż poziom logu wyświetlanego przez <
                code > logging.info() < /code>, komunikat zostanie wyświetlony. W
                przeciwnym razie komunikat nie zostanie wyświetlony. < /p> <
                p > Aby zapisać logi do pliku potrzebujemy obiektu do obsługi plików(FileHandler): < /p> <
                    pre > < code >
                    import logging

                logger = logging.getLogger()

                fh = logging.FileHandler('plik.log') fh.setLevel(logging.WARNING) logger.addHandler(fh)

                logger.warning("Przykladowa wiadomosc.") <
                /code></pre >
                <
                p > W powyższym przykładzie tworzymy najpierw obiekt <
                code > logger < /code> służący do zarządzania logami, a następnie
                obiekt < code > fh < /code> służący do zapisywania logów do pliku. Nazwa
                pliku podana jest jako argument 'plik.log'.Linia <
                code > fh.setLevel(logging.WARNING) < /code> ustawia poziom logów dla
                obiektu < code > fh < /code> na <code>WARNING</code > .Poziomy logów określają ważność logów.W przypadku ustawienia poziomu na <
                code > WARNING < /code>, będą zapisywane logi o poziomie <
                code > WARNING < /code> i wszystkie powyżej niego. Linia <
                code > logger.addHandler(fh) < /code> dodaje obiekt <code>fh</code > do
                    obiektu < code > logger < /code>. W ten sposób logi wygenerowane przez <
                code > logger < /code> będą zapisywane do pliku przez obiekt <
                code > fh < /code>. Linia <code>logger.warning("Przykladowa
                wiadomosc.
                ")</code> zapisuje komunikat "
                Przykladowa wiadomość " do
                pliku o nazwie 'plik.log'. < /p> <
                h2 > Dodatkowe materiały < /h2> <
                ul >
                <
                li > https: //docs.python.org/3/tutorial/</li>
                <
                li >
                https: //ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-0001-introduction-to-computer-science-and-programming-in-python-fall-2016/</li>
                <
                li >
                https: //ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-0002-introduction-to-computational-thinking-and-data-science-fall-2016/</li>
                <
                li > https: //braydie.gitbook.io/how-to-be-a-programmer/</li>
                <
                li > https: //pythontutor.com/visualize.html#mode=edit</li>
                <
                li >
                https: //www.oreilly.com/library/view/fluent-python-2nd/9781492056348/</li>
                <
                /ul> <
                footer >
                <
                div class = "footer-columns" >
                <
                div class = "footer-column" > < img src =
                "https://media4.giphy.com/media/3o72FkreWNH9OlTtPq/200w.webp?cid=ecf05e47rnnplmcfqeu72szmq5f4gdqjhfu04iw9vgrirrsf&amp;rid=200w.webp&amp;ct=g"
                alt = "Adam Djellouli" > < /div> <
                div class = "footer-column" >
                <
                p > This is Adam Djellouli 's personal website.<br>
                All content is completely free to use. < br >
                If you want to contact me, please use my LinkedIn profile. < br >
                Please use my GitHub
                if you have any advice, ideas, or technical issues. < br >
                Remember to be a good human being and refrain from abusing my website. < br >
                I wish you a fantastic life, legend. < br >
                We 're all going to make it!</p> < /
                div > <
                div class = "footer-column" >
                <
                h2 > Follow me: < /h2> <
                ul class = "social-media" >
                <
                li > < a href =
                "https://www.youtube.com/channel/UCGPoHTVjMN77wcGknXPHl1Q"
                class =
                "fa fa-youtube"
                target = "_blank" > < /a>YouTube</li >
                <
                li > < a href = "https://www.linkedin.com/in/adam-djellouli-1bb54619a/"
                class = "fa fa-linkedin"
                target = "_blank" > < /a>LinkedIn</li >
                <
                li > < a href = "https://www.instagram.com/addjellouli/"
                class =
                "fa fa-instagram"
                target = "_blank" > < /a>Instagram</li >
                <
                li > < a href = "https://github.com/djeada"
                class =
                "fa fa-github" > < /a>Github</li >
                <
                /ul> < /
                div > <
                /div> <
                div >
                <
                p id = "copyright" > ©Adam Djellouli.All rights reserved. < /p> < /
                div > <
                script >
                document.getElementById("copyright").innerHTML = "&copy; " + new Date().getFullYear() + " Adam Djellouli. All rights reserved."; <
                /script></footer >
                <
                /body> < /
                html >