<!DOCTYPE html>

<html lang="pl">

<head>
    <script async="" crossorigin="anonymous" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5593122079896089"></script>
    <meta charset="utf-8" />
    <title>Moduły i pakiety</title>
    <meta content="W Pythonie moduły i pakiety są elementami umożliwiającymi organizację i strukturyzację kodu." name="description" />
    <meta content="Adam Djellouli" name="author" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <meta content="IE=edge" http-equiv="X-UA-Compatible" />
    <link crossorigin="" href="https://fonts.googleapis.com" rel="preconnect" />
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/icon.ico" rel="icon" />
    <link href="../../../resources/style.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />
</head>

<body>
    <nav aria-label="Main navigation">
        <a class="logo" href="https://adamdjellouli.com">
            <img alt="Adam Djellouli - Home Page Logo" id="logo-image" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/logo.PNG" />
        </a>
        <input aria-label="Toggle navigation menu" id="navbar-toggle" type="checkbox" />
        <ul aria-labelledby="navbar-toggle" role="menu">
            <li role="menuitem">
                <a href="../../../index.html" title="Go to Home Page"> Home </a>
            </li>
            <li role="menuitem">
                <a class="active" href="../../../core/blog.html" title="Read Adam Djellouli Blog on Programming and Technology"> Blog </a>
            </li>
            <li role="menuitem">
                <a href="../../../core/tools.html" title="Discover Tools Created by Adam Djellouli"> Tools </a>
            </li>
            <li role="menuitem">
                <a href="../../../core/projects.html" title="Explore Projects Developed by Adam Djellouli"> Projects </a>
            </li>
            <li role="menuitem">
                <a href="../../../core/resume.html" title="View Adam Djellouli Professional Resume"> Resume </a>
            </li>
            <li>
                <script async="" src="https://cse.google.com/cse.js?cx=8160ef9bb935f4f68"></script>
                <div class="gcse-search"></div>
            </li>
            <li>
                <button aria-label="Toggle dark mode" id="dark-mode-button"></button>
            </li>
        </ul>
    </nav>
    <div id="article-wrapper">
        <section id="article-body">
            <p style="text-align: right;"><i>Last modified: December 31, 2024</i></p>
            <p style="text-align: right;"><i>This article is written in: 🇵🇱</i></p>
            <header>Moduły i pakiety</header>
            <p>W Pythonie moduły i pakiety są elementami umożliwiającymi organizację i strukturyzację kodu. Dzięki nim programy stają się bardziej czytelne, łatwiejsze w utrzymaniu i skalowalne. Ułatwiają one zarządzanie dużymi projektami oraz współpracę z innymi programistami. Zrozumienie tych elementów jest niezbędne dla efektywnego programowania i utrzymania czystego, modularnego kodu. </p>
            <p><strong>Dzięki modułom i pakietom możemy unikać chaosu w dużych aplikacjach.</strong> Wyobraź sobie, że masz jeden bardzo długi plik z setkami funkcji i klas – odszukanie konkretnego fragmentu kodu czy naprawa błędu staje się wtedy dużo trudniejsze. Dzięki podziałowi na mniejsze pliki (moduły) i foldery (pakiety) szybko zidentyfikujesz, w którym miejscu należy wprowadzić zmiany, a cały projekt stanie się przejrzysty. Podzielenie aplikacji na logiczne sekcje (np. część odpowiedzialna za logikę biznesową, część obsługującą operacje na bazie danych itp.) sprawia również, że wielu programistów może jednocześnie pracować nad różnymi częściami aplikacji, zmniejszając ryzyko konfliktów i błędów w kodzie.</p>
            <h2 id="moduły">Moduły</h2>
            <p>Moduł to podstawowy sposób organizacji kodu. Jest to pojedynczy plik z rozszerzeniem <code>.py</code>, który może zawierać definicje funkcji, klas, zmiennych, a także kod wykonywalny. Moduły pozwalają na podzielenie kodu na mniejsze, logiczne części, co ułatwia zarządzanie i ponowne użycie kodu w innych projektach. Dzięki modułom możemy łatwo organizować nasz kod i unikać powielania funkcji, a także dzielić się nimi z innymi.</p>
            <p><strong>W praktyce oznacza to, że jeśli napiszemy kilka uniwersalnych funkcji matematycznych lub moduł obsługujący połączenie z bazą danych, możemy go wielokrotnie wykorzystywać w różnych projektach.</strong> Oszczędzamy w ten sposób czas i wysiłek, a także redukujemy ryzyko pojawienia się błędów, które mogłyby wkraść się przy powielaniu kodu.</p>
            <h3 id="przykład-prostego-modułu-"><strong>Przykład prostego modułu:</strong></h3>
            <p>Utwórz plik o nazwie <code>matematyka.py</code> z następującą zawartością:</p>
            <p>
            <div>
                <pre><code class="language-python"># matematyka.py

def dodaj(a, b):
    return a + b

def odejmij(a, b):
    return a - b

PI = 3.1415</code></pre>
            </div>
            </p>
            <p>W tym module:</p>
            <ul>
                <li><code>dodaj(a, b)</code> - funkcja, która zwraca sumę dwóch liczb.</li>
                <li><code>odejmij(a, b)</code> - funkcja, która zwraca różnicę między dwiema liczbami.</li>
                <li><code>PI</code> - zmienna przechowująca wartość liczby Pi z dokładnością do czterech miejsc po przecinku.</li>
            </ul>
            <p>Moduł <code>matematyka.py</code> jest teraz samodzielnym plikiem, który możemy zaimportować do innych skryptów, aby wykorzystać jego funkcje i zmienne.</p>
            <p><strong>Warto pamiętać, że moduł może również zawierać kod wykonywalny, który zostanie uruchomiony w momencie importu.</strong> Dlatego zwykle oddziela się część z definicjami funkcji czy klas od kodu, który faktycznie coś uruchamia, aby uniknąć niepożądanego działania przy imporcie.</p>
            <h3 id="importowanie-modułów">Importowanie modułów</h3>
            <p>Aby skorzystać z funkcji i zmiennych z modułu <code>matematyka.py</code> w innym pliku, możemy go zaimportować za pomocą instrukcji <code>import</code>. Dzięki temu możemy używać wszystkich funkcji i zmiennych, które znajdują się w module, odwołując się do nich przez nazwę modułu.</p>
            <p><strong>Importowanie modułu stanowi pierwszy krok do wykorzystania napisanych przez nas lub innych programistów bibliotek.</strong> Gdybyśmy mieli powtarzać definicje funkcji w każdym pliku, w którym chcemy ich używać, nasz kod szybko by się rozrósł. Dzięki prostemu <code>import matematyka</code> otrzymujemy dostęp do wszystkiego, co znajduje się w tym pliku, bez konieczności duplikowania kodu.</p>
            <h3 id="przykład-użycia-modułu-"><strong>Przykład użycia modułu:</strong></h3>
            <p>
            <div>
                <pre><code class="language-python"># main.py

import matematyka

wynik = matematyka.dodaj(5, 7)
print(wynik)  # Output: 12

print(matematyka.PI)  # Output: 3.1415</code></pre>
            </div>
            </p>
            <p>W tym przykładzie:</p>
            <ul>
                <li><code>import matematyka</code> wczytuje cały moduł <code>matematyka</code>, co pozwala nam na korzystanie z jego funkcji i zmiennych.</li>
                <li>Aby odwołać się do funkcji <code>dodaj</code> lub zmiennej <code>PI</code>, używamy prefiksu <code>matematyka.</code>.</li>
                <li>Dzięki temu unikamy potencjalnych konfliktów nazw, ponieważ wszystkie elementy modułu są wywoływane przez prefiks <code>matematyka</code>.
                    <strong>Dobrą praktyką jest, by nazwa modułu była krótka, opisowa i używała tylko małych liter, co ułatwia korzystanie z niej w dłuższych projektach.</strong> Sam import jest wykonywany tylko raz, przy pierwszym odwołaniu do modułu w danym pliku, a Python pamięta go w tzw. sys.modules, co zapobiega wielokrotnemu przeładowywaniu tego samego kodu.
                </li>
            </ul>
            <h3 id="importowanie-konkretnych-elementów">Importowanie konkretnych elementów</h3>
            <p>Zamiast importować cały moduł, możemy importować tylko konkretne funkcje lub zmienne, co sprawia, że kod staje się bardziej zwięzły i czytelny. Dzięki temu nie musimy używać prefiksu modułu za każdym razem.</p>
            <p><strong>To rozwiązanie sprawdza się szczególnie dobrze, gdy chcemy użyć zaledwie jednej lub dwóch funkcji z dużego modułu.</strong> Nie zawsze chcemy obciążać przestrzeni nazw całym zestawem elementów, zwłaszcza jeśli interesuje nas tylko niewielki wycinek funkcjonalności danego modułu.</p>
            <h3 id="przykład-"><strong>Przykład:</strong></h3>
            <p>CODE_BLOCK_PLACEHOLDER
                W tym przypadku:</p>
            <ul>
                <li><code>from matematyka import dodaj, PI</code> pozwala nam zaimportować tylko wybrane elementy z modułu <code>matematyka</code>.</li>
                <li>Dzięki temu możemy bezpośrednio wywołać funkcję <code>dodaj</code> oraz uzyskać dostęp do zmiennej <code>PI</code>, bez konieczności używania prefiksu <code>matematyka.</code>.
                    <strong>Jednocześnie warto pamiętać, że taki sposób importowania może spowodować konflikt nazw, jeśli inny moduł lub zmienna w naszym projekcie noszą tę samą nazwę.</strong> Wtedy Python nie będzie wiedział, do której definicji się odwołać. Z tego powodu trzeba świadomie zarządzać importami i ewentualnie używać aliasów.
                </li>
            </ul>
            <h3 id="aliasowanie-modułów-i-funkcji">Aliasowanie modułów i funkcji</h3>
            <p>Czasami nazwa modułu lub funkcji może być długa lub może powodować konflikt nazw z innymi elementami w kodzie. W takich przypadkach możemy nadać alias (inną nazwę) modułowi lub funkcji, co ułatwia ich używanie.</p>
            <p><strong>Alias pozwala nam skrócić i ujednolicić wywołania, zwłaszcza gdy nazwy modułów są długie bądź mało intuicyjne.</strong> Często w bibliotekach naukowych (jak <code>numpy</code>) stosuje się alias <code>np</code>, a w pandas – <code>pd</code>. Dzięki temu kod jest czytelniejszy i zrozumiały dla większości programistów używających tych standardowych aliasów.</p>
            <h3 id="przykład-aliasowania-modułu-"><strong>Przykład aliasowania modułu:</strong></h3>
            <p>
            <div>
                <pre><code class="language-python">from matematyka import dodaj, PI

wynik = dodaj(10, 15)
print(wynik)  # Output: 25

print(PI)  # Output: 3.1415</code></pre>
            </div>
            </p>
            <p>Tutaj:</p>
            <ul>
                <li><code>import matematyka as mat</code> oznacza, że moduł <code>matematyka</code> jest dostępny pod krótszą nazwą <code>mat</code>.</li>
                <li>Teraz możemy odwoływać się do funkcji i zmiennych tego modułu, używając prefiksu <code>mat</code>, co może być bardziej wygodne.</li>
            </ul>
            <h3 id="przykład-aliasowania-funkcji-"><strong>Przykład aliasowania funkcji:</strong></h3>
            <p>CODE_BLOCK_PLACEHOLDER
                W tym przypadku:</p>
            <ul>
                <li><code>from matematyka import dodaj as d</code> pozwala nam zaimportować funkcję <code>dodaj</code> i przypisać jej nazwę <code>d</code>.</li>
                <li>Dzięki temu możemy wywołać funkcję jako <code>d(3, 4)</code>, co jest krótsze i może być bardziej czytelne w niektórych kontekstach.
                    <strong>Dzięki aliasowaniu możemy uniknąć niejednoznaczności i sprawić, że kod będzie bardziej zrozumiały dla innych osób, które również z niego korzystają.</strong> Z drugiej strony, zbyt częste i nadmierne aliasowanie może utrudnić rozumienie, dlatego warto robić to rozważnie.
                </li>
            </ul>
            <h3 id="korzyści-z-używania-modułów">Korzyści z używania modułów</h3>
            <ul>
                <li>Funkcje i klasy z modułu mogą być używane w wielu programach.</li>
                <li>Podział kodu na moduły sprawia, że jest on bardziej czytelny i łatwiejszy w nawigacji.</li>
                <li>Moduły mają własną przestrzeń nazw, co pomaga w uniknięciu konfliktów.
                    <strong>Dzięki modułom możemy również przyspieszyć proces testowania i rozwoju oprogramowania.</strong> Zamiast przebudowywać całą aplikację, możemy skupić się na jednym pliku <code>.py</code> – module – a następnie przetestować tylko jego funkcjonalność, co jest szczególnie ważne w przypadku dużych projektów, w których oszczędność czasu odgrywa istotną rolę.
                </li>
            </ul>
            <h2 id="pakiety">Pakiety</h2>
            <p>Pakiet to struktura, która umożliwia grupowanie powiązanych modułów w jednym katalogu. Dzięki pakietom możemy organizować kod na wyższym poziomie niż przy użyciu pojedynczych modułów, co jest szczególnie przydatne w większych projektach. Pakiet to po prostu folder, który zawiera moduły (pliki <code>.py</code>) oraz specjalny plik <code>__init__.py</code>. Obecność pliku <code>__init__.py</code> informuje Pythona, że dany folder powinien być traktowany jako pakiet, co pozwala na jego importowanie w innych częściach programu.</p>
            <p><strong>Innymi słowy, pakiet to „skrzynka” pełna modułów, pogrupowanych według jakiegoś klucza – na przykład tematycznego (moduły związane z operacjami na liczbach mogą się znaleźć w jednym pakiecie), dzięki czemu łatwiej jest utrzymać porządek w projekcie.</strong></p>
            <h3 id="struktura-pakietu-"><strong>Struktura pakietu:</strong></h3>
            <p>CODE_BLOCK_PLACEHOLDER
                - <code>kalkulator/</code> - katalog, który pełni rolę pakietu. Zawiera moduły związane z obliczeniami matematycznymi.
                - <code>__init__.py</code> - plik specjalny, który sprawia, że Python rozpoznaje katalog <code>kalkulator</code> jako pakiet. Może być pusty, ale często zawiera kod inicjalizacyjny lub importy.
                - <code>arytmetyka.py</code> - moduł w pakiecie, który może zawierać funkcje do operacji arytmetycznych (np. dodawanie, odejmowanie).
                - <code>geometry.py</code> - moduł w pakiecie, który może zawierać funkcje związane z obliczeniami geometrycznymi (np. pole powierzchni, obwód).
                <strong>Kluczową różnicą między pakietem a zwykłym katalogiem jest obecność pliku <code>__init__.py</code>.</strong> Jego rola polega na zdefiniowaniu pewnych informacji na temat pakietu oraz (w razie potrzeby) na wykonaniu kodu inicjalizującego, gdy pakiet zostanie zaimportowany.
            </p>
            <h3 id="tworzenie-pakietu">Tworzenie pakietu</h3>
            <p>Aby utworzyć pakiet, wykonaj następujące kroki:</p>
            <p>I. <strong>Stwórz folder o nazwie pakietu</strong> - np. <code>kalkulator</code>, który będzie zawierał wszystkie moduły powiązane z tym pakietem.
                II. <strong>Utwórz plik <code>__init__.py</code> wewnątrz katalogu</strong> - może być pusty lub zawierać kod, który będzie wykonywany podczas importowania pakietu.
                III. <strong>Dodaj moduły (pliki <code>.py</code>) do katalogu pakietu</strong> - umieść tam pliki, takie jak <code>arytmetyka.py</code> czy <code>geometry.py</code>.</p>
            <p><strong>Tak utworzony pakiet może być zaimportowany w naszym głównym pliku Pythona lub w innym module, co pozwala na wygodne korzystanie z jego zawartości.</strong> W ten sposób struktura projektu pozostaje logicznie podzielona na mniejsze, wyspecjalizowane obszary.</p>
            <h3 id="przykład-modułu-w-pakiecie-"><strong>Przykład modułu w pakiecie:</strong></h3>
            <p>W pliku <code>arytmetyka.py</code> możemy zdefiniować podstawowe operacje matematyczne:</p>
            <p>
            <div>
                <pre><code class="language-python">import matematyka as mat

wynik = mat.odejmij(10, 5)
print(wynik)  # Output: 5</code></pre>
            </div>
            </p>
            <p>W tym przykładzie:</p>
            <ul>
                <li>Funkcja <code>dodaj(a, b)</code> zwraca sumę dwóch liczb.</li>
                <li>Funkcja <code>odejmij(a, b)</code> zwraca różnicę między dwiema liczbami.</li>
                <li>Moduł <code>arytmetyka.py</code> może być zaimportowany do innych części projektu, aby korzystać z tych funkcji.</li>
            </ul>
            <p>W ramach tego samego pakietu można utworzyć wiele modułów, z których każdy odpowiada za inny obszar funkcjonalny, np. <code>geometry.py</code> dla obliczeń geometrycznych czy <code>wyrazenia.py</code> dla obsługi bardziej skomplikowanych wyrażeń matematycznych.</p>
            <h3 id="importowanie-modułów-z-pakietu">Importowanie modułów z pakietu</h3>
            <p>Aby skorzystać z funkcji i klas zawartych w modułach pakietu, używamy notacji kropkowej (<code>.</code>). Możemy zaimportować cały moduł z pakietu, a następnie odwoływać się do jego zawartości za pomocą prefiksu modułu.</p>
            <h3 id="przykład-importowania-modułu-z-pakietu-"><strong>Przykład importowania modułu z pakietu:</strong></h3>
            <p>CODE_BLOCK_PLACEHOLDER
                W tym przykładzie:</p>
            <ul>
                <li><code>from kalkulator import arytmetyka</code> importuje moduł <code>arytmetyka</code> z pakietu <code>kalkulator</code>.</li>
                <li>Następnie wywołujemy funkcję <code>dodaj</code> z modułu <code>arytmetyka</code> używając notacji <code>arytmetyka.dodaj</code>.</li>
                <li>Dzięki temu możemy korzystać z funkcji modułu bez konieczności pisania całej ścieżki do pliku.
                    <strong>Dzięki temu rozwiązaniu możliwe jest budowanie rozbudowanych projektów, w których moduły są pogrupowane w pakiety, a pakiety mogą być nawet wielopoziomowe.</strong> W praktyce oznacza to, że w katalogu <code>kalkulator</code> może znajdować się kolejny folder (kolejny pakiet) – i tak dalej.
                </li>
            </ul>
            <h3 id="importowanie-konkretnych-funkcji-z-modułu-w-pakiecie">Importowanie konkretnych funkcji z modułu w pakiecie</h3>
            <p>Jeżeli chcemy zaimportować tylko wybrane funkcje lub klasy z modułu, możemy to zrobić bezpośrednio, co sprawia, że kod staje się bardziej zwięzły.</p>
            <h3 id="przykład-"><strong>Przykład:</strong></h3>
            <p>
            <div>
                <pre><code class="language-python">from matematyka import dodaj as d

wynik = d(3, 4)
print(wynik)  # Output: 7</code></pre>
            </div>
            </p>
            <p>W tym przypadku:</p>
            <ul>
                <li><code>from kalkulator.arytmetyka import odejmij</code> importuje tylko funkcję <code>odejmij</code> z modułu <code>arytmetyka</code> w pakiecie <code>kalkulator</code>.</li>
                <li>Dzięki temu możemy bezpośrednio wywoływać funkcję <code>odejmij</code> bez potrzeby używania prefiksu <code>arytmetyka.</code>.</li>
            </ul>
            <p>Taka elastyczność w sposobie importowania ma szczególne znaczenie w dużych projektach, gdzie chcemy ograniczyć zasób ładowanych do pamięci elementów tylko do tych naprawdę potrzebnych. Pozwala to również uniknąć niepotrzebnych konfliktów nazw z elementami, które nas w danej chwili nie interesują.</p>
            <h3 id="używanie-pliku-__init__-py">Używanie pliku <code>__init__.py</code></h3>
            <p>Plik <code>__init__.py</code> w pakiecie pełni kilka ważnych funkcji:</p>
            <ul>
                <li>Możemy w nim umieścić kod, który powinien być wykonany podczas pierwszego importu pakietu.</li>
                <li>Używając zmiennej <code>__all__</code>, możemy kontrolować, które moduły są importowane, gdy ktoś użyje <code>from pakiet import *</code>.</li>
                <li>Możemy zdefiniować, które moduły mają być widoczne na zewnątrz pakietu, a które powinny pozostać ukryte.
                    <strong>Takie podejście pozwala programistom świadomie zarządzać dostępnością poszczególnych modułów i funkcji.</strong> Jeśli chcemy, aby pewna część kodu pozostała w pakiecie jako wewnętrzna (ang. <em>internal</em>), to po prostu nie umieszczamy jej w <code>__all__</code>. Dzięki temu łatwiej kontrolować, co finalnie będzie dostępne dla użytkowników naszego kodu.
                </li>
            </ul>
            <h3 id="przykład-__init__-py-"><strong>Przykład <code>__init__.py</code>:</strong></h3>
            <p>CODE_BLOCK_PLACEHOLDER
                Dzięki powyższemu ustawieniu:</p>
            <ul>
                <li>Jeśli ktoś użyje <code>from kalkulator import *</code>, zaimportowane zostaną tylko moduły <code>arytmetyka</code> i <code>geometry</code>.</li>
                <li>Moduły, które nie są wymienione w <code>__all__</code>, nie zostaną automatycznie zaimportowane, co pomaga w zarządzaniu widocznością zawartości pakietu.</li>
            </ul>
            <h3 id="przykład-użycia-from-pakiet-import-"><strong>Przykład użycia <code>from pakiet import *</code>:</strong></h3>
            <p>
            <div>
                <pre><code class="language-shell">projekt/

├── kalkulator/

│   ├── __init__.py

│   ├── arytmetyka.py

│   └── geometry.py

└── main.py</code></pre>
            </div>
            </p>
            <p>W tym przypadku:</p>
            <ul>
                <li><code>from kalkulator import *</code> zaimportuje moduły <code>arytmetyka</code> i <code>geometry</code>, ponieważ są one wymienione w <code>__all__</code> pliku <code>__init__.py</code>.</li>
                <li>Następnie możemy bezpośrednio używać funkcji z tych modułów.
                    <strong>Warto zaznaczyć, że <code>from pakiet import *</code> nie zawsze jest zalecany, zwłaszcza w większych projektach.</strong> Może to skutkować niejasnościami co do tego, skąd pochodzi dana funkcja, i prowadzić do konfliktów nazw. Z drugiej strony, w małych projektach lub w środowiskach interaktywnych (<code>REPL</code>, Jupyter Notebook) takie podejście może być wygodne podczas szybkiego prototypowania.
                </li>
            </ul>
            <h2 id="importowanie-modułów-i-pakietów">Importowanie modułów i pakietów</h2>
            <p>Importowanie modułów i pakietów w Pythonie jest kluczowe dla efektywnego zarządzania przestrzenią nazw i unikania duplikacji kodu. Oto różne metody importowania:</p>
            <h3 id="zaimportowanie-całego-modułu">Zaimportowanie całego modułu</h3>
            <p>Pozwala to na dostęp do wszystkich funkcji, klas i zmiennych w module, używając notacji z kropką.</p>
            <p><strong>Przykład:</strong></p>
            <p>CODE_BLOCK_PLACEHOLDER
                <strong>Jest to jedna z najczęstszych praktyk, gdyż pozwala na szybkie korzystanie z całego modułu, o ile nazwa modułu nie jest zbyt długa ani nieintuicyjna.</strong> W Pythonie standardowym takie nazwy (np. <code>os</code>, <code>sys</code>) są krótkie i dobrze opisują swoje przeznaczenie.
            </p>
            <h3 id="zaimportowanie-modułu-z-aliasem">Zaimportowanie modułu z aliasem</h3>
            <p>Umożliwia korzystanie z krótszej nazwy modułu w kodzie.</p>
            <p><strong>Przykład:</strong></p>
            <p>
            <div>
                <pre><code class="language-python"># arytmetyka.py

def dodaj(a, b):
    return a + b

def odejmij(a, b):
    return a - b</code></pre>
            </div>
            </p>
            <p><strong>Tego typu aliasowanie jest często spotykane w społeczności naukowej, gdzie standardem są aliasy takie jak: <code>import numpy as np</code>, <code>import pandas as pd</code>, <code>import matplotlib.pyplot as plt</code>.</strong> Dzięki temu kody są nie tylko krótsze, ale i bardziej spójne pomiędzy różnymi projektami.</p>
            <h3 id="zaimportowanie-konkretnych-funkcji-z-modułu">Zaimportowanie konkretnych funkcji z modułu</h3>
            <p>Importuje tylko określone funkcje lub klasy.</p>
            <p><strong>Przykład:</strong></p>
            <p>CODE_BLOCK_PLACEHOLDER
                <strong>To podejście pomaga uniknąć „zaśmiecania” przestrzeni nazw niepotrzebnymi elementami i sprawia, że od razu widać, jakie konkretnie funkcje czy obiekty są nam potrzebne.</strong> Jest to też często praktykowane w krótkich skryptach, w których wielokrotnie używamy tylko jednej czy dwóch funkcji z całego modułu.
            </p>
            <h3 id="zaimportowanie-funkcji-z-aliasem">Zaimportowanie funkcji z aliasem</h3>
            <p>Pozwala na zmianę nazwy importowanej funkcji.</p>
            <p><strong>Przykład:</strong></p>
            <p>
            <div>
                <pre><code class="language-python"># main.py

from kalkulator import arytmetyka

wynik = arytmetyka.dodaj(2, 3)
print(wynik)  # Output: 5</code></pre>
            </div>
            </p>
            <p><strong>Aliasowanie funkcji może znacząco skrócić wywołania i poprawić czytelność kodu – zwłaszcza gdy pracujemy w zespołach, w których określone skróty są umowami między programistami.</strong> Jest to też sposób na uniknięcie konfliktów nazw z innymi elementami w naszym programie.</p>
            <h3 id="zaimportowanie-całej-zawartości-modułu">Zaimportowanie całej zawartości modułu</h3>
            <p>Importuje wszystkie publiczne elementy modułu.</p>
            <p><strong>Przykład:</strong></p>
            <p>
            <div>
                <pre><code class="language-python">from kalkulator.arytmetyka import odejmij

wynik = odejmij(10, 4)
print(wynik)  # Output: 6</code></pre>
            </div>
            </p>
            <p><strong>Uwaga:</strong> Ta metoda może prowadzić do konfliktów nazw i jest ogólnie odradzana.<br />
                <strong>Chociaż jest ona kusząca, szczególnie w przypadku szybkich eksperymentów (np. w trybie interaktywnym), w dużych projektach może powodować wiele niejasności.</strong> W takiej sytuacji nie wiadomo, czy dana funkcja <code>randint</code> pochodzi z modułu <code>random</code>, czy została zdefiniowana lokalnie w innym miejscu naszego kodu. Dlatego stosowanie <code>import *</code> powinno być rozważne i zwykle ograniczone do sytuacji prototypowania lub niewielkich projektów.
            </p>
            <h2 id="wykonywanie-kodu-podczas-importowania">Wykonywanie kodu podczas importowania</h2>
            <p>W Pythonie kod znajdujący się poza definicjami funkcji i klas w module jest wykonywany natychmiast podczas importowania tego modułu. Oznacza to, że jeśli w module znajdują się instrukcje, które nie są umieszczone w funkcjach lub klasach, zostaną one wykonane, gdy tylko zaimportujemy moduł w innym pliku. Może to prowadzić do nieoczekiwanych efektów, takich jak wywoływanie funkcji lub drukowanie komunikatów, których nie planowaliśmy podczas importu.</p>
            <h3 id="przykład-problematycznego-modułu-"><strong>Przykład problematycznego modułu:</strong></h3>
            <p>Załóżmy, że mamy moduł <code>misja.py</code> z następującą zawartością:</p>
            <p>
            <div>
                <pre><code class="language-python"># __init__.py

__all__ = ['arytmetyka', 'geometry']</code></pre>
            </div>
            </p>
            <p>W tym przykładzie:</p>
            <ul>
                <li>Funkcja <code>start_misji()</code> jest wywoływana bezpośrednio w module, poza definicjami funkcji.</li>
                <li>Kiedy zaimportujemy ten moduł w innym pliku, kod znajdujący się poza funkcjami zostanie wykonany automatycznie.</li>
            </ul>
            <h3 id="importowanie-modułu-"><strong>Importowanie modułu:</strong></h3>
            <p>Jeśli teraz zaimportujemy moduł <code>misja</code> w innym pliku:</p>
            <p>
            <div>
                <pre><code class="language-python"># main.py

from kalkulator import *

wynik = arytmetyka.dodaj(5, 5)
print(wynik)  # Output: 10</code></pre>
            </div>
            </p>
            <p>To w konsoli zostanie wyświetlone:</p>
            <p>
            <div>
                <pre><code class="language-python">import os

current_directory = os.getcwd()
print(current_directory)</code></pre>
            </div>
            </p>
            <p>Dzieje się tak dlatego, że Python wykonuje kod umieszczony poza definicjami funkcji natychmiast podczas importowania modułu. W tym przypadku nie chcieliśmy, aby funkcja <code>start_misji()</code> została uruchomiona podczas importu — powinna być wywoływana tylko wtedy, gdy rzeczywiście tego chcemy.</p>
            <h3 id="rozwiązanie-problemu">Rozwiązanie problemu</h3>
            <p>Aby uniknąć niechcianego wykonywania kodu podczas importowania, używamy konstrukcji:</p>
            <p>
            <div>
                <pre><code class="language-python">import numpy as np

array = np.array([1, 2, 3])
print(array)</code></pre>
            </div>
            </p>
            <p>Dzięki tej konstrukcji możemy określić, które fragmenty kodu mają być uruchamiane tylko wtedy, gdy moduł jest uruchamiany jako główny program, a nie podczas jego importowania.</p>
            <h3 id="poprawiony-moduł-"><strong>Poprawiony moduł:</strong></h3>
            <p>
            <div>
                <pre><code class="language-python">from math import sqrt, pi

print(sqrt(16))  # Output: 4.0
print(pi)        # Output: 3.141592653589793</code></pre>
            </div>
            </p>
            <p>W tym przykładzie:</p>
            <ul>
                <li>Kod <code>if __name__ == "__main__":</code> sprawia, że funkcja <code>start_misji()</code> zostanie uruchomiona tylko wtedy, gdy moduł <code>misja.py</code> zostanie uruchomiony bezpośrednio jako skrypt, a nie podczas importowania go w innym pliku.</li>
                <li>Teraz, gdy zaimportujemy moduł <code>misja</code> w innym pliku, funkcja <code>start_misji()</code> nie zostanie wywołana automatycznie, co eliminuje niepożądane efekty.</li>
            </ul>
            <h3 id="wyjaśnienie-działania-if-__name__-__main__-">Wyjaśnienie działania <code>if __name__ == "__main__":</code></h3>
            <ul>
                <li><strong><code>__name__</code>:</strong> To specjalna zmienna, która jest automatycznie ustawiana przez Pythona. Jej wartość zależy od tego, w jaki sposób uruchamiany jest moduł:</li>
                <li>Jeżeli moduł jest uruchamiany bezpośrednio jako główny skrypt (np. <code>python misja.py</code>), wówczas <code>__name__</code> przyjmuje wartość <code>"__main__"</code>.</li>
                <li>Jeżeli moduł jest importowany w innym pliku, <code>__name__</code> przyjmuje nazwę tego modułu (np. <code>"misja"</code>).</li>
                <li><strong>Konstrukcja <code>if __name__ == "__main__":</code></strong> umożliwia nam określenie, które fragmenty kodu mają być uruchamiane tylko wtedy, gdy moduł jest uruchamiany bezpośrednio jako skrypt. Pozwala to na oddzielenie kodu testowego lub przykładów użycia od kodu, który powinien być dostępny po zaimportowaniu modułu.</li>
            </ul>
            <h3 id="przykład-zastosowania-"><strong>Przykład zastosowania:</strong></h3>
            <p>
            <div>
                <pre><code class="language-python">from math import factorial as fac

print(fac(5))  # Output: 120</code></pre>
            </div>
            </p>
            <p>W tym module:</p>
            <ul>
                <li>Funkcja <code>testuj_funkcje()</code> zostanie wywołana tylko wtedy, gdy uruchomimy skrypt <code>narzedzia.py</code> bezpośrednio z linii poleceń.</li>
                <li>Gdy <code>narzedzia.py</code> jest importowane w innym skrypcie, kod w bloku <code>if __name__ == "__main__":</code> nie zostanie wykonany.</li>
            </ul>
            <h3 id="uruchamianie-narzedzia-py-bezpośrednio-"><strong>Uruchamianie <code>narzedzia.py</code> bezpośrednio:</strong></h3>
            <p>Jeśli uruchomimy plik <code>narzedzia.py</code> bezpośrednio z linii poleceń:</p>
            <p>
            <div>
                <pre><code class="language-python">from random import *

print(randint(1, 10))</code></pre>
            </div>
            </p>
            <p>To na wyjściu zobaczymy:</p>
            <p>
            <div>
                <pre><code class="language-python"># misja.py

def przygotuj_misje():
    print("Przygotowanie misji...")

def start_misji():
    print("Start misji!")

start_misji()  # Ta funkcja zostanie wywołana podczas importowania</code></pre>
            </div>
            </p>
            <p>Ponieważ w tym przypadku <code>__name__</code> przyjmuje wartość <code>"__main__"</code>, kod w bloku <code>if __name__ == "__main__":</code> zostaje wykonany.</p>
            <h3 id="importowanie-narzedzia-py-w-innym-pliku-"><strong>Importowanie <code>narzedzia.py</code> w innym pliku:</strong></h3>
            <p>Jeśli zaimportujemy <code>narzedzia.py</code> w innym pliku:</p>
            <p>
            <div>
                <pre><code class="language-python">import misja</code></pre>
            </div>
            </p>
            <p>Nie zobaczymy żadnego komunikatu w konsoli, ponieważ kod w bloku <code>if __name__ == "__main__":</code> nie zostanie wykonany — <code>__name__</code> w module <code>narzedzia</code> nie ma wartości <code>"__main__"</code> podczas importu.</p>
            <h2 id="importowanie-relatywne-i-absolutne">Importowanie relatywne i absolutne</h2>
            <p>W Pythonie możemy importować moduły i funkcje na dwa główne sposoby: za pomocą importów absolutnych oraz względnych. Obie metody mają swoje zastosowania i są wybierane w zależności od struktury projektu oraz potrzeb programisty.</p>
            <h3 id="importy-absolutne">Importy absolutne</h3>
            <p>Importy absolutne odwołują się do modułów, używając ich pełnej ścieżki, poczynając od katalogu głównego projektu. Oznacza to, że określamy dokładnie, skąd ma pochodzić importowany moduł, bez względu na to, w którym miejscu struktury katalogów znajduje się plik, który wykonuje import.</p>
            <p><strong>Przykład importu absolutnego:</strong></p>
            <p>
            <div>
                <pre><code class="language-shell">Start misji!</code></pre>
            </div>
            </p>
            <p>W tym przykładzie:
                - <code>from kalkulator.arytmetyka import dodaj</code> wskazuje, że funkcja <code>dodaj</code> powinna zostać zaimportowana z modułu <code>arytmetyka</code>, który znajduje się w pakiecie <code>kalkulator</code>.
                - Ścieżka do modułu <code>arytmetyka</code> jest podana w sposób pełny, poczynając od katalogu <code>kalkulator</code>.</p>
            <p>Zaletą importów absolutnych jest to, że są one jasne i czytelne – widać dokładnie, z którego modułu pochodzi import. Dzięki temu łatwiej jest zrozumieć strukturę projektu, zwłaszcza gdy jest on duży i zawiera wiele pakietów.</p>
            <h3 id="importy-względne">Importy względne</h3>
            <p>Importy względne odwołują się do modułów na podstawie ich położenia względem bieżącego modułu, w którym wykonujemy import. Są przydatne, gdy chcemy odwołać się do modułów, które znajdują się w tym samym pakiecie lub w pokrewnych pakietach. W przypadku importów względnych używamy kropek (<code>.</code>) do wskazania położenia modułów:</p>
            <ul>
                <li>Jedna kropka (<code>.</code>) odnosi się do bieżącego pakietu.</li>
                <li>Dwie kropki (<code>..</code>) odnoszą się do jednego poziomu wyżej, czyli do pakietu nadrzędnego.</li>
            </ul>
            <p><strong>Przykład importu względnego:</strong></p>
            <p>
            <div>
                <pre><code class="language-python">if __name__ == "__main__":
    # Kod, który zostanie wykonany tylko przy bezpośrednim uruchomieniu modułu</code></pre>
            </div>
            </p>
            <p>W tym przykładzie:
                - <code>from .arytmetyka import dodaj</code> wskazuje, że funkcja <code>dodaj</code> jest importowana z modułu <code>arytmetyka</code>, który znajduje się w tym samym pakiecie co bieżący plik.
                - Użycie jednej kropki (<code>.</code>) sprawia, że odwołujemy się do modułu <code>arytmetyka</code> w ramach tego samego pakietu.</p>
            <p>Importy względne są szczególnie przydatne w dużych projektach, w których moduły są zorganizowane w hierarchiczne struktury pakietów. Pozwalają one na łatwe przenoszenie całych pakietów bez konieczności zmieniania ścieżek importu, co ułatwia refaktoryzację kodu.</p>
            <h3 id="uwaga-ograniczenia-importów-względnych"><strong>Uwaga:</strong> Ograniczenia importów względnych</h3>
            <ul>
                <li>Importy względne można stosować <strong>tylko wewnątrz pakietów</strong>. Oznacza to, że działają one poprawnie jedynie wtedy, gdy moduł, w którym używamy importu względnego, jest częścią pakietu.</li>
                <li>Importy względne <strong>nie działają w skryptach uruchamianych bezpośrednio</strong>, czyli takich, które są uruchamiane jako główny plik programu (np. za pomocą <code>python skrypt.py</code>). W takim przypadku Python nie wie, w jakim kontekście należy interpretować kropki w importach względnych.</li>
            </ul>
            <h3 id="przykład-sytuacji-kiedy-import-względny-może-nie-działać-">Przykład sytuacji, kiedy import względny może nie działać:</h3>
            <p>Jeżeli mamy strukturę katalogów:</p>
            <p>
            <div>
                <pre><code class="language-python"># misja.py

def przygotuj_misje():
    print("Przygotowanie misji...")

def start_misji():
    print("Start misji!")

if __name__ == "__main__":
    start_misji()</code></pre>
            </div>
            </p>
            <p>i w pliku <code>arytmetyka.py</code> znajduje się import względny:</p>
            <p>
            <div>
                <pre><code class="language-python"># narzedzia.py

def testuj_funkcje():
    print("Testowanie funkcji...")

if __name__ == "__main__":
    testuj_funkcje()</code></pre>
            </div>
            </p>
            <p>To ten import będzie działał, gdy <code>arytmetyka.py</code> zostanie zaimportowany jako część pakietu <code>kalkulator</code>, na przykład w <code>main.py</code>:</p>
            <p>
            <div>
                <pre><code class="language-shell">python narzedzia.py</code></pre>
            </div>
            </p>
            <p>Ale jeśli spróbujemy uruchomić <code>arytmetyka.py</code> bezpośrednio:</p>
            <p>
            <div>
                <pre><code class="language-shell">Testowanie funkcji...</code></pre>
            </div>
            </p>
            <p>otrzymamy błąd, ponieważ importy względne nie działają, gdy plik jest uruchamiany bezpośrednio.</p>
            <h3 id="kiedy-używać-importów-absolutnych-a-kiedy-względnych-">Kiedy używać importów absolutnych, a kiedy względnych?</h3>
            <p><strong>Importy absolutne</strong>:</p>
            <ul>
                <li>Stosuj, gdy chcesz, aby struktura importów była jasna i niezależna od położenia pliku wykonującego import.</li>
                <li>Przydają się, gdy projekt jest złożony, a pełna ścieżka modułów pomaga zrozumieć zależności.</li>
                <li>Są bardziej uniwersalne i działają niezależnie od tego, czy moduł jest uruchamiany bezpośrednio, czy jest importowany.</li>
            </ul>
            <p><strong>Importy względne</strong>:</p>
            <ul>
                <li>Stosuj wewnątrz pakietów, gdy chcesz odwoływać się do modułów na podstawie ich położenia względem bieżącego modułu.</li>
                <li>Ułatwiają przenoszenie całych pakietów bez konieczności zmieniania ścieżek importu.</li>
                <li>Są bardziej podatne na błędy w przypadku refaktoryzacji struktury pakietu lub uruchamiania plików bezpośrednio.</li>
            </ul>
            <h2 id="dobre-praktyki">Dobre praktyki</h2>
            <ul>
                <li>Grupy powiązanych funkcji i klas umieszczaj w tym samym module lub pakiecie.</li>
                <li>Używaj opisowych nazw dla modułów i pakietów, pisanych małymi literami.</li>
                <li>Uważaj na nazwy modułów, które mogą kolidować z wbudowanymi modułami Pythona lub popularnymi bibliotekami.</li>
                <li>Dodawaj docstringi do modułów, funkcji i klas, aby ułatwić zrozumienie kodu przez innych programistów.</li>
                <li>Używaj go do inicjalizacji pakietu i kontrolowania, które moduły są eksportowane.</li>
                <li>Unikaj używania <code>from modul import *</code>, aby zapobiec konfliktom nazw i poprawić czytelność kodu.</li>
            </ul>
            <h2 id="praktyczne-przykłady">Praktyczne przykłady</h2>
            <h3 id="tworzenie-pakietu-analiza_danych">Tworzenie pakietu <code>analiza_danych</code></h3>
            <p>W poniższym przykładzie tworzymy pakiet <code>analiza_danych</code>, który będzie zawierał moduły odpowiedzialne za różne etapy analizy danych.</p>
            <p><strong>Struktura pakietu:</strong></p>
            <p>
            <div>
                <pre><code class="language-python"># main.py

import narzedzia</code></pre>
            </div>
            </p>
            <ul>
                <li><code>analiza_danych/</code> - katalog, który jest traktowany jako pakiet w Pythonie. W nim znajdują się wszystkie pliki odpowiadające za różne funkcjonalności.</li>
                <li><code>__init__.py</code> - plik, który pozwala traktować katalog <code>analiza_danych</code> jako pakiet. Zawiera on importy z modułów wewnątrz pakietu.</li>
                <li><code>wczytywanie.py</code> - moduł odpowiedzialny za wczytywanie danych.</li>
                <li><code>przetwarzanie.py</code> - moduł, w którym są zawarte funkcje przetwarzające dane (np. filtrowanie, agregacja).</li>
                <li><code>wizualizacja.py</code> - moduł zajmujący się tworzeniem wykresów i wizualizacją wyników.</li>
                <li><code>main.py</code> - główny skrypt, który korzysta z funkcji dostępnych w pakiecie <code>analiza_danych</code>.</li>
            </ul>
            <h3 id="moduł-wczytywanie-py">Moduł <code>wczytywanie.py</code></h3>
            <p>
            <div>
                <pre><code class="language-python">from kalkulator.arytmetyka import dodaj</code></pre>
            </div>
            </p>
            <p>W module <code>wczytywanie.py</code> znajduje się funkcja <code>wczytaj_csv</code>, która przyjmuje argument <code>sciezka</code>, czyli ścieżkę do pliku CSV, który chcemy wczytać. Ta funkcja mogłaby używać bibliotek takich jak <code>pandas</code>, aby załadować dane z pliku do DataFrame'a:</p>
            <p>
            <div>
                <pre><code class="language-python">from .arytmetyka import dodaj  # Importuje funkcję dodaj z modułu arytmetyka w bieżącym pakiecie</code></pre>
            </div>
            </p>
            <p>Powyższy kod wczytuje dane z pliku CSV i zwraca je w postaci DataFrame, co jest bardzo wygodne przy dalszej analizie danych.</p>
            <h3 id="moduł-przetwarzanie-py">Moduł <code>przetwarzanie.py</code></h3>
            <p>
            <div>
                <pre><code class="language-shell">projekt/
├── kalkulator/
│   ├── __init__.py
│   ├── arytmetyka.py
│   └── geometry.py
└── main.py</code></pre>
            </div>
            </p>
            <p>Funkcja <code>filtruj_dane</code> w module <code>przetwarzanie.py</code> zajmuje się przetwarzaniem danych. Jako argument przyjmuje <code>dane</code>, które mogą być np. DataFrame'em wczytanym wcześniej. Przykładowo, możemy chcieć odfiltrować dane na podstawie pewnych warunków:</p>
            <p>
            <div>
                <pre><code class="language-python"># arytmetyka.py

from .geometry import oblicz_pole</code></pre>
            </div>
            </p>
            <p>W tym przykładzie funkcja filtruje wiersze, w których wartość w danej kolumnie jest większa od podanej wartości. Dzięki temu możemy łatwo wybrać tylko te dane, które spełniają określone kryteria.</p>
            <h3 id="moduł-wizualizacja-py">Moduł <code>wizualizacja.py</code></h3>
            <p>
            <div>
                <pre><code class="language-python"># main.py

from kalkulator import arytmetyka</code></pre>
            </div>
            </p>
            <p>Moduł <code>wizualizacja.py</code> zawiera funkcję <code>wykres_liniowy</code>, która tworzy wykresy na podstawie dostarczonych danych. Zwykle takie wykresy są generowane za pomocą bibliotek takich jak <code>matplotlib</code> lub <code>seaborn</code>:</p>
            <p>
            <div>
                <pre><code class="language-shell">python kalkulator/arytmetyka.py</code></pre>
            </div>
            </p>
            <p>W powyższym kodzie funkcja <code>wykres_liniowy</code> rysuje wykres, gdzie <code>x</code> i <code>y</code> to nazwy kolumn, które mają być użyte do osi X i Y. Wykres zostanie wyświetlony za pomocą <code>matplotlib</code>.</p>
            <h3 id="plik-__init__-py">Plik <code>__init__.py</code></h3>
            <p>
            <div>
                <pre><code class="language-shell">projekt/
├── analiza_danych/
│   ├── __init__.py
│   ├── wczytywanie.py
│   ├── przetwarzanie.py
│   └── wizualizacja.py
└── main.py</code></pre>
            </div>
            </p>
            <p>Plik <code>__init__.py</code> pozwala na łatwy dostęp do funkcji pakietu <code>analiza_danych</code> z zewnątrz. Importując te funkcje wewnątrz <code>__init__.py</code>, możemy je potem bezpośrednio zaimportować w innych plikach, takich jak <code>main.py</code>. <code>__all__</code> definiuje listę funkcji, które są dostępne do importu z poziomu pakietu.</p>
            <h3 id="użycie-pakietu-w-main-py">Użycie pakietu w <code>main.py</code></h3>
            <p>
            <div>
                <pre><code class="language-python">def wczytaj_csv(sciezka):
    # Kod do wczytywania pliku CSV
    pass</code></pre>
            </div>
            </p>
            <p>W pliku <code>main.py</code> importujemy funkcje <code>wczytaj_csv</code>, <code>filtruj_dane</code> i <code>wykres_liniowy</code> z pakietu <code>analiza_danych</code> i używamy ich do przetworzenia danych. </p>
            <ol>
                <li>Funkcja <code>wczytaj_csv</code> ładuje dane z pliku <code>dane.csv</code> do DataFrame'a.</li>
                <li>Funkcja <code>filtruj_dane</code> przefiltrowuje dane, wybierając tylko te, gdzie wartość w kolumnie <code>'kolumna'</code> jest większa niż 100.</li>
                <li>Funkcja <code>wykres_liniowy</code> generuje wykres liniowy, pokazując zależność między kolumnami <code>'czas'</code> i <code>'wartość'</code>.</li>
            </ol>
        </section>
        <div id="table-of-contents">
            <h2>Spis Treści</h2>
            <ol>
                <li><a href="#moduły">Moduły</a>
                    <ol>
                        <li><a href="#przykład-prostego-modułu-">Przykład prostego modułu:</a></li>
                        <li><a href="#importowanie-modułów">Importowanie modułów</a></li>
                        <li><a href="#przykład-użycia-modułu-">Przykład użycia modułu:</a></li>
                        <li><a href="#importowanie-konkretnych-elementów">Importowanie konkretnych elementów</a></li>
                        <li><a href="#przykład-">Przykład:</a></li>
                        <li><a href="#aliasowanie-modułów-i-funkcji">Aliasowanie modułów i funkcji</a></li>
                        <li><a href="#przykład-aliasowania-modułu-">Przykład aliasowania modułu:</a></li>
                        <li><a href="#przykład-aliasowania-funkcji-">Przykład aliasowania funkcji:</a></li>
                        <li><a href="#korzyści-z-używania-modułów">Korzyści z używania modułów</a></li>
                    </ol>
                </li>
                <li><a href="#pakiety">Pakiety</a>
                    <ol>
                        <li><a href="#struktura-pakietu-">Struktura pakietu:</a></li>
                        <li><a href="#tworzenie-pakietu">Tworzenie pakietu</a></li>
                        <li><a href="#przykład-modułu-w-pakiecie-">Przykład modułu w pakiecie:</a></li>
                        <li><a href="#importowanie-modułów-z-pakietu">Importowanie modułów z pakietu</a></li>
                        <li><a href="#przykład-importowania-modułu-z-pakietu-">Przykład importowania modułu z pakietu:</a></li>
                        <li><a href="#importowanie-konkretnych-funkcji-z-modułu-w-pakiecie">Importowanie konkretnych funkcji z modułu w pakiecie</a></li>
                        <li><a href="#przykład-">Przykład:</a></li>
                        <li><a href="#używanie-pliku-__init__-py">Używanie pliku __init__.py</a></li>
                        <li><a href="#przykład-__init__-py-">Przykład __init__.py:</a></li>
                        <li><a href="#przykład-użycia-from-pakiet-import-">Przykład użycia from pakiet import *:</a></li>
                    </ol>
                </li>
                <li><a href="#importowanie-modułów-i-pakietów">Importowanie modułów i pakietów</a>
                    <ol>
                        <li><a href="#zaimportowanie-całego-modułu">Zaimportowanie całego modułu</a></li>
                        <li><a href="#zaimportowanie-modułu-z-aliasem">Zaimportowanie modułu z aliasem</a></li>
                        <li><a href="#zaimportowanie-konkretnych-funkcji-z-modułu">Zaimportowanie konkretnych funkcji z modułu</a></li>
                        <li><a href="#zaimportowanie-funkcji-z-aliasem">Zaimportowanie funkcji z aliasem</a></li>
                        <li><a href="#zaimportowanie-całej-zawartości-modułu">Zaimportowanie całej zawartości modułu</a></li>
                    </ol>
                </li>
                <li><a href="#wykonywanie-kodu-podczas-importowania">Wykonywanie kodu podczas importowania</a>
                    <ol>
                        <li><a href="#przykład-problematycznego-modułu-">Przykład problematycznego modułu:</a></li>
                        <li><a href="#importowanie-modułu-">Importowanie modułu:</a></li>
                        <li><a href="#rozwiązanie-problemu">Rozwiązanie problemu</a></li>
                        <li><a href="#poprawiony-moduł-">Poprawiony moduł:</a></li>
                        <li><a href="#wyjaśnienie-działania-if-__name__-__main__-">Wyjaśnienie działania if __name__ == "__main__":</a></li>
                        <li><a href="#przykład-zastosowania-">Przykład zastosowania:</a></li>
                        <li><a href="#uruchamianie-narzedzia-py-bezpośrednio-">Uruchamianie narzedzia.py bezpośrednio:</a></li>
                        <li><a href="#importowanie-narzedzia-py-w-innym-pliku-">Importowanie narzedzia.py w innym pliku:</a></li>
                    </ol>
                </li>
                <li><a href="#importowanie-relatywne-i-absolutne">Importowanie relatywne i absolutne</a>
                    <ol>
                        <li><a href="#importy-absolutne">Importy absolutne</a></li>
                        <li><a href="#importy-względne">Importy względne</a></li>
                        <li><a href="#uwaga-ograniczenia-importów-względnych">Uwaga: Ograniczenia importów względnych</a></li>
                        <li><a href="#przykład-sytuacji-kiedy-import-względny-może-nie-działać-">Przykład sytuacji, kiedy import względny może nie działać:</a></li>
                        <li><a href="#kiedy-używać-importów-absolutnych-a-kiedy-względnych-">Kiedy używać importów absolutnych, a kiedy względnych?</a></li>
                    </ol>
                </li>
                <li><a href="#dobre-praktyki">Dobre praktyki</a></li>
                <li><a href="#praktyczne-przykłady">Praktyczne przykłady</a>
                    <ol>
                        <li><a href="#tworzenie-pakietu-analiza_danych">Tworzenie pakietu analiza_danych</a></li>
                        <li><a href="#moduł-wczytywanie-py">Moduł wczytywanie.py</a></li>
                        <li><a href="#moduł-przetwarzanie-py">Moduł przetwarzanie.py</a></li>
                        <li><a href="#moduł-wizualizacja-py">Moduł wizualizacja.py</a></li>
                        <li><a href="#plik-__init__-py">Plik __init__.py</a></li>
                        <li><a href="#użycie-pakietu-w-main-py">Użycie pakietu w main.py</a></li>
                    </ol>
                </li>
            </ol>
            <div id="related-articles">
                <h2>Related Articles</h2>
                <ol>
                    <li>Podstawy<ol>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/01_podstawy/01_instalacja_w_systemie_windows.html">Instalacja w Systemie Windows</a></li>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/01_podstawy/02_interaktywna_konsola.html">Interaktywna Konsola</a></li>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/01_podstawy/03_zmienne.html">Zmienne</a></li>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/01_podstawy/04_warunki.html">Warunki</a></li>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/01_podstawy/05_petle.html">Petle</a></li>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/01_podstawy/06_funkcje.html">Funkcje</a></li>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/01_podstawy/07_napisy.html">Napisy</a></li>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/01_podstawy/08_struktury_danych.html">Struktury Danych</a></li>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/01_podstawy/09_enum.html">Enum</a></li>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/01_podstawy/10_liczby_losowe.html">Liczby Losowe</a></li>
                        </ol>
                    </li>
                    <li>Sredniozawansowane<ol>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/02_sredniozawansowane/01_klasy_i_obiekty.html">Klasy i Obiekty</a></li>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/02_sredniozawansowane/02_referencje_i_kopiowanie.html">Referencje i Kopiowanie</a></li>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/02_sredniozawansowane/03_czyste_funkcje_i_skutki_uboczne.html">Czyste Funkcje i Skutki Uboczne</a></li>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/02_sredniozawansowane/04_dziedziczenie_i_kompozycja.html">Dziedziczenie i Kompozycja</a></li>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/02_sredniozawansowane/05_wyrazenia_regularne.html">Wyrazenia Regularne</a></li>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/02_sredniozawansowane/06_wyjatki.html">Wyjatki</a></li>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/02_sredniozawansowane/07_watki.html">Watki</a></li>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/02_sredniozawansowane/08_procesy.html">Procesy</a></li>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/02_sredniozawansowane/09_asyncio.html">Asyncio</a></li>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/02_sredniozawansowane/10_lambdy.html">Lambdy</a></li>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/02_sredniozawansowane/11_programowanie_funkcyjne.html">Programowanie Funkcyjne</a></li>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/02_sredniozawansowane/12_klasy_danych.html">Klasy Danych</a></li>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/02_sredniozawansowane/13_generatory.html">Generatory</a></li>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/02_sredniozawansowane/14_iteratory.html">Iteratory</a></li>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/02_sredniozawansowane/15_dekoratory.html">Dekoratory</a></li>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/02_sredniozawansowane/16_serializacja.html">Serializacja</a></li>
                        </ol>
                    </li>
                    <li>Inzynieria Oprogramowania<ol>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/03_inzynieria_oprogramowania/01_moduly_i_pakiety.html">Moduly i Pakiety</a></li>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/03_inzynieria_oprogramowania/02_wersje_pythona.html">Wersje Pythona</a></li>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/03_inzynieria_oprogramowania/03_pip_i_pypi.html">Pip i Pypi</a></li>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/03_inzynieria_oprogramowania/04_srodowisko_wirtualne.html">Srodowisko Wirtualne</a></li>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/03_inzynieria_oprogramowania/05_dbanie_o_jakosc_kodu.html">Dbanie o Jakosc Kodu</a></li>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/03_inzynieria_oprogramowania/06_debugowanie.html">Debugowanie</a></li>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/03_inzynieria_oprogramowania/07_testy_jednostkowe.html">Testy Jednostkowe</a></li>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/03_inzynieria_oprogramowania/08_dokumentacja.html">Dokumentacja</a></li>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/03_inzynieria_oprogramowania/09_pliki_wykonywalne_i_pyinstaller.html">Pliki Wykonywalne i Pyinstaller</a></li>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/03_inzynieria_oprogramowania/10_kod_bajtowy.html">Kod Bajtowy</a></li>
                        </ol>
                    </li>
                    <li>Python w Praktyce<ol>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/04_python_w_praktyce/01_argumenty_linii_polecen.html">Argumenty Linii Polecen</a></li>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/04_python_w_praktyce/02_praca_z_plikami_i_folderami.html">Praca z Plikami i Folderami</a></li>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/04_python_w_praktyce/03_pandas_i_csv.html">Pandas i Csv</a></li>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/04_python_w_praktyce/04_praca_z_plikami_pdf.html">Praca z Plikami Pdf</a></li>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/04_python_w_praktyce/05_informacje_o_systemie_operacyjnym.html">Informacje o Systemie Operacyjnym</a></li>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/04_python_w_praktyce/06_http_i_prosty_serwer.html">Http i Prosty Serwer</a></li>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/04_python_w_praktyce/07_api_wraz_z_fastapi.html">Api wraz z Fastapi</a></li>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/04_python_w_praktyce/08_bazy_danych_z_sqlite.html">Bazy Danych z Sqlite</a></li>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/04_python_w_praktyce/09_tkinter.html">Tkinter</a></li>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/04_python_w_praktyce/10_logi.html">Logi</a></li>
                        </ol>
                    </li>
                    <li>Prezentacje<ol>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/05_prezentacje/git.html">Git</a></li>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/05_prezentacje/inspekcja_kodu.html">Inspekcja Kodu</a></li>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/05_prezentacje/jupyter_notebooks.html">Jupyter Notebooks</a></li>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/05_prezentacje/paradygmaty_programowania.html">Paradygmaty Programowania</a></li>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/05_prezentacje/programowanie_wstep.html">Programowanie Wstep</a></li>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/05_prezentacje/testy.html">Testy</a></li>
                            <li><a href="https://adamdjellouli.com/articles/kurs_podstaw_pythona/05_prezentacje/wprowadzenie_do_kursu.html">Wprowadzenie do Kursu</a></li>
                        </ol>
                    </li>
                </ol>
            </div>
        </div>
    </div>
    <footer>
        <div class="footer-columns">
            <div class="footer-column">
                <img alt="Adam Djellouli Symbol" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/symbol.png" />
            </div>
            <div class="footer-column">
                <h2><a href="https://adamdjellouli.com/core/privacy_policy.html" title="Privacy Policy">Our Privacy Policy</a></h2>
                <p>
                    Thank you for visiting my personal website. All of the <br />
                    content on this site is free to use, but please remember <br />
                    to be a good human being and refrain from any abuse<br />
                    of the site. If you would like to contact me, please use <br />
                    my <a href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" title="LinkedIn Profile">LinkedIn profile</a> or my <a href="https://github.com/djeada" title="GitHub Profile">GitHub</a> if you have any technical <br />
                    issues or ideas to share. I wish you the best and hope you <br />
                    have a fantastic life. <br />
                </p>
            </div>
            <div class="footer-column">
                <h2>Follow me</h2>
                <ul class="social-media">
                    <li>
                        <a class="fa fa-youtube" href="https://www.youtube.com/channel/UCGPoHTVjMN77wcGknXPHl1Q" target="_blank" title="YouTube">
                        </a>YouTube
                    </li>
                    <li>
                        <a class="fa fa-linkedin" href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" target="_blank" title="LinkedIn">
                        </a>LinkedIn
                    </li>
                    <li>
                        <a class="fa fa-instagram" href="https://www.instagram.com/linuxchallenges/" target="_blank" title="Instagram">
                        </a>Instagram
                    </li>
                    <li>
                        <a class="fa fa-github" href="https://github.com/djeada" title="GitHub">
                        </a>Github
                    </li>
                </ul>
            </div>
        </div>
        <div>
            <p id="copyright">
                © Adam Djellouli. All rights reserved.
            </p>
        </div>
        <script>
            document.getElementById("copyright").innerHTML = "&copy; " + new Date().getFullYear() + " Adam Djellouli. All rights reserved.";
        </script>
        <script src="../../../app.js"></script>
    </footer>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-bash.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-cpp.min.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
jax: ["input/TeX", "output/HTML-CSS"],
extensions: ["tex2jax.js"],
"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] },
tex2jax: { inlineMath: [ ["$", "$"] ], displayMath: [ ["$$","$$"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
TeX: { noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } } },
messageStyle: "none"
});
</script>
<script async="" id="MathJax-script" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>

</html>