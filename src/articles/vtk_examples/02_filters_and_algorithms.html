<!DOCTYPE html>

<html lang="en">

<head>
    <script async="" crossorigin="anonymous" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5593122079896089"></script>
    <meta charset="utf-8" />
    <title>Filters and Algorithms</title>
    <meta content="VTK‚Äôs filters and algorithms allow you to convert your data from ‚Äúa static dataset‚Äù to a dynamic pipeline: you generate something, clean it up, extract meaning, and reshape it into a form that‚Äôs easier to analyze or visualize." name="description" />
    <meta content="Adam Djellouli" name="author" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <meta content="IE=edge" http-equiv="X-UA-Compatible" />
    <link crossorigin="" href="https://fonts.googleapis.com" rel="preconnect" />
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/icon.ico" rel="icon" />
    <link href="../../resources/style.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    <link href="https://adamdjellouli.com/articles/vtk_examples/02_filters_and_algorithms" rel="canonical" />
    <script id="structured-data" type="application/ld+json">
        {
            "@context": "https://schema.org",
            "@type": "Article",
            "headline": "Filters and Algorithms",
            "author": {
                "@type": "Person",
                "name": "Adam Djellouli"
            },
            "mainEntityOfPage": {
                "@type": "WebPage",
                "@id": "https://adamdjellouli.com/articles/vtk_examples/02_filters_and_algorithms"
            },
            "url": "https://adamdjellouli.com/articles/vtk_examples/02_filters_and_algorithms",
            "description": "VTK\u2019s filters and algorithms allow you to convert your data from \u201ca static dataset\u201d to a dynamic pipeline: you generate something, clean it up, extract meaning, and reshape it into a form that\u2019s easier to analyze or visualize.",
            "dateModified": "2026-01-23"
        }
    </script>
</head>

<body>
    <nav aria-label="Main navigation">
        <a class="logo" href="../../index.html">
            <img alt="Adam Djellouli - Home Page Logo" id="logo-image" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/logo.PNG" />
        </a>
        <input aria-label="Toggle navigation menu" id="navbar-toggle" type="checkbox" />
        <ul aria-labelledby="navbar-toggle" role="menu">
            <li role="menuitem">
                <a href="../../index.html" title="Go to Home Page"> Home </a>
            </li>
            <li role="menuitem">
                <a href="../../core/blog.html" title="Read Adam Djellouli Blog on Programming and Technology"> Blog </a>
            </li>
            <li role="menuitem">
                <a href="../../core/tools.html" title="Discover Tools Created by Adam Djellouli"> Tools </a>
            </li>
            <li role="menuitem">
                <a href="../../core/projects.html" title="Explore Projects Developed by Adam Djellouli"> Projects </a>
            </li>
            <li role="menuitem">
                <a href="../../core/courses.html" title="Browse Courses by Adam Djellouli"> Courses </a>
            </li>
            <li role="menuitem">
                <a href="../../core/resume.html" title="View Adam Djellouli Professional Resume"> Resume </a>
            </li>
            <li>
                <script async="" src="https://cse.google.com/cse.js?cx=8160ef9bb935f4f68"></script>
                <div class="gcse-search"></div>
            </li>
            <li>
                <button aria-label="Toggle dark mode" id="dark-mode-button"></button>
            </li>
        </ul>
    </nav>
    <div id="article-wrapper">
        <aside id="article-sidebar">
            <div id="table-of-contents">
                <h2>Table of Contents</h2>
                <ol><a href="#filters-and-algorithms">Filters and Algorithms</a>
                    <ol>
                        <li><a href="#purpose-and-functionality">Purpose and functionality</a></li>
                        <li><a href="#interaction-with-data-connectivity">Interaction with data connectivity</a></li>
                        <li><a href="#understanding-connectivity">Understanding connectivity</a></li>
                        <li><a href="#data-flow">Data flow</a></li>
                        <li><a href="#vtkalgorithm">vtkAlgorithm</a></li>
                        <li><a href="#sources">Sources</a></li>
                        <li><a href="#geometric-filters">Geometric filters</a></li>
                        <li><a href="#topological-filters">Topological filters</a></li>
                        <li><a href="#scalars-and-attribute-filters-in-vtk">Scalars and attribute filters in VTK</a></li>
                        <li><a href="#temporal-filters-in-vtk">Temporal filters in VTK</a></li>
                        <li><a href="#why-some-meshes-detach-and-others-stay-connected-">Why some meshes detach and others stay connected?</a></li>
                        <li><a href="#example-creating-a-sphere-source-and-applying-a-shrink-filter">Example: Creating a Sphere Source and Applying a Shrink Filter</a></li>
                        <li><a href="#a-practical-connected-shrink-alternative-c-">A practical ‚Äúconnected shrink‚Äù alternative (C++)</a></li>
                        <li><a href="#summary">Summary</a></li>
                    </ol>
                </ol>
            </div>
            <div id="related-articles">
                <h2>Related Articles</h2>
                <ol>
                    <li><a href="https://adamdjellouli.com/articles/vtk_examples/01_data_types_and_structures.html">Data Types and Structures</a></li>
                    <li><a href="https://adamdjellouli.com/articles/vtk_examples/02_filters_and_algorithms.html">Filters and Algorithms</a></li>
                    <li><a href="https://adamdjellouli.com/articles/vtk_examples/03_input_and_output.html">Input and Output</a></li>
                    <li><a href="https://adamdjellouli.com/articles/vtk_examples/04_visualization_techniques.html">Visualization Techniques</a></li>
                    <li><a href="https://adamdjellouli.com/articles/vtk_examples/05_interactivity.html">Interactivity</a></li>
                    <li><a href="https://adamdjellouli.com/articles/vtk_examples/06_animations.html">Animations</a></li>
                    <li><a href="https://adamdjellouli.com/articles/vtk_examples/07_performance_optimization_and_parallelism.html">Performance Optimization and Parallelism</a></li>
                    <li><a href="https://adamdjellouli.com/articles/vtk_examples/08_integration_with_other_tools.html">Integration with Other Tools</a></li>
                    <li><a href="https://adamdjellouli.com/articles/vtk_examples/09_custom_filters_and_algorithms.html">Custom Filters and Algorithms</a></li>
                </ol>
            </div>
        </aside><article-section id="article-body">
            <div class="article-action-buttons"><button class="btn-suggest-edit" title="Suggest Edit">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <path d="M4 21h4l11-11-4-4L4 17v4z" stroke="currentColor" stroke-width="2"></path>
                    </svg>
                </button><button class="btn-create-issue" title="Create Issue">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2"></circle>
                        <line stroke="currentColor" stroke-width="2" x1="12" x2="12" y1="8" y2="12"></line>
                        <circle cx="12" cy="16" fill="currentColor" r="1"></circle>
                    </svg>
                </button><button class="btn-download" title="Download">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <path d="M12 5v14m0 0l-6-6m6 6l6-6" stroke="currentColor" stroke-width="2"></path>
                    </svg>
                </button></div>
            <p style="text-align: right;"><i>Last modified: January 23, 2026</i></p>
            <p style="text-align: right;"><i>This article is written in: üá∫üá∏</i></p>
            <h2 id="filters-and-algorithms">Filters and Algorithms</h2>
            <p>VTK‚Äôs filters and algorithms allow you to convert your data from ‚Äúa static dataset‚Äù to a dynamic pipeline: you generate something, clean it up, extract meaning, and reshape it into a form that‚Äôs easier to analyze or visualize. Think of it like a workshop line: raw material comes in, tools operate on it, and what comes out is clearer, lighter, or more informative.</p>
            <p>In real VTK projects you rarely render raw input directly. You almost always process it first: remove noise, compute derived quantities, simplify meshes, extract surfaces, reorganize time steps, or convert data into a representation that downstream steps can handle. Filters are the verbs of VTK. They‚Äôre how you <em>do things</em> to data.</p>
            <p>One of the major components of VTK is its extensive range of filters and algorithms, designed to process, manipulate, and generate data objects. The important part is not memorizing names, but recognizing what kind of change a filter is making and what assumptions it relies on.</p>
            <h3 id="purpose-and-functionality">Purpose and functionality</h3>
            <p>Filters and algorithms are primarily used for:</p>
            <ul>
                <li>processing and manipulating existing data objects</li>
                <li>generating new datasets (e.g., contours, glyphs, resampled volumes)</li>
                <li>extracting features (regions, surfaces, edges, connected components)</li>
                <li>transforming data into a more useful format (triangles instead of polygons, cleaned points, computed attributes)</li>
            </ul>
            <p>A practical habit is to ask: is this step changing <strong>geometry</strong>, <strong>topology</strong>, <strong>attributes</strong>, or <strong>time</strong>?</p>
            <ul>
                <li>When only the spatial coordinates are adjusted, <em>geometry</em> is affected because point positions move while cells continue to reference the same points, whereas omitting this type of operation leaves shapes unchanged; for example, a shrink or transform filter relocates vertices but keeps the original mesh connectivity intact.</li>
                <li>In cases where the structure of the mesh itself must change, <em>topology</em> is involved because connections between points are altered, while skipping such processing preserves the original cell relationships; for instance, a clipping or triangulation filter can split cells and introduce new triangles that did not previously exist.</li>
                <li>When derived data values are needed for analysis or visualization, modifying <em>attributes</em> is useful because new arrays are computed or existing scalars, vectors, or tensors are updated, whereas leaving attributes untouched limits what can be colored or analyzed; for example, computing normals or gradients adds vectors that can drive lighting or glyphs.</li>
                <li>For datasets that evolve over time, handling <em>time</em> explicitly is beneficial because multiple timesteps can be interpolated, shifted, or summarized, while ignoring time reduces the data to a single static snapshot; for example, a temporal averaging filter can condense many simulation steps into one representative result.</li>
            </ul>
            <p>That single question helps you predict what will break later, or why something that ‚Äúshould be the same shape‚Äù suddenly behaves differently.</p>
            <h3 id="interaction-with-data-connectivity">Interaction with data connectivity</h3>
            <p>A significant part of many operations involves altering or depending on the dataset‚Äôs <em>connectivity</em>.</p>
            <p><strong>Connectivity</strong> refers to relationships inside the data structure: which points belong to which cells, how cells touch, and what ‚Äútogetherness‚Äù means for the dataset. It‚Äôs the difference between ‚Äúpoints in space‚Äù and ‚Äúa surface,‚Äù ‚Äúa volume,‚Äù or ‚Äúa meaningful region.‚Äù</p>
            <p>Two datasets can have the <em>same coordinates</em> and still behave differently if connectivity differs. That‚Äôs why filters can feel so powerful: they‚Äôre not just moving numbers around, they‚Äôre preserving or rewriting the relationships that make the data interpretable.</p>
            <p>A practical way to phrase it:</p>
            <ul>
                <li>Some filters mainly move coordinates and assume the wiring stays meaningful.</li>
                <li>Other filters explicitly rewrite the wiring.</li>
                <li>Many filters do both, but one of those effects is usually the ‚Äúmain point.‚Äù</li>
            </ul>
            <h3 id="understanding-connectivity">Understanding connectivity</h3>
            <p>Connectivity is one of those ideas that seems obvious right until it bites you. If you‚Äôve ever smoothed a mesh and wondered why sharp features disappeared, triangulated polygons and got unexpected results, or extracted a region and got too many pieces, you‚Äôve already seen connectivity in action.</p>
            <p>In <code>vtkPolyData</code>, this is especially important because cells (polygons/triangles/lines) don‚Äôt store coordinates directly. They store <strong>point ids</strong> into a shared <code>Points</code> array. That means there‚Äôs a crucial difference between:</p>
            <ul>
                <li><strong>Sharing coordinates</strong> (two points happen to be in the same place)</li>
                <li><strong>Sharing point ids</strong> (two cells literally reference the same point in the points array)</li>
            </ul>
            <p>Only the second one is ‚Äúconnected‚Äù in the topological sense.</p>
            <p><em>Examples:</em></p>
            <ol>
                <li>Individual data points without any connectivity:</li>
            </ol>
            <div>
                <pre><code class="language-shell">*    *    *    *</code></pre>
            </div>
            <ol>
                <li>Points connected in a simple linear fashion:</li>
            </ol>
            <div>
                <pre><code class="language-shell">*---*---*---*</code></pre>
            </div>
            <ol>
                <li>Points connected to form a polygon:</li>
            </ol>
            <div>
                <pre><code class="language-shell">polygon:
    *---*
   /     \
  *       *
   \     /
    *---*</code></pre>
            </div>
            <p>And here‚Äôs the same idea visually (points + edges + faces as ‚Äúglue‚Äù):</p>
            <p><img alt="connectivity" src="https://github.com/djeada/Vtk-Examples/assets/37275728/f3a63ec5-0197-4aca-944c-6a5e61ae6878" /></p>
            <p><em>A common real-world pitfall: ‚Äúlooks connected‚Äù vs ‚Äúis connected‚Äù</em></p>
            <p>Many meshes coming from certain file formats or pipelines duplicate vertices per face (each polygon has its own private set of points). Visually it can still look like a single surface because the duplicated points have identical coordinates. But topologically it‚Äôs a set of separate faces.</p>
            <p>This shows up immediately with filters that act per-cell (or per-face), especially shrink-like operations. You shrink each polygon toward its own center and suddenly the mesh ‚Äúexplodes‚Äù into detached tiles. The filter isn‚Äôt being random; it‚Äôs revealing the true connectivity.</p>
            <h3 id="data-flow">Data flow</h3>
            <p>VTK‚Äôs pipeline is intentionally predictable: sources produce data, filters transform it, and outputs feed into the next step. That predictability is what makes large visualization workflows manageable. You can swap filters in and out without rewriting everything because the interfaces and execution model are consistent.</p>
            <p>It also makes debugging more systematic. When something looks wrong, the best approach is usually to inspect the pipeline stage-by-stage and find where geometry, topology, or attributes changed in a way you didn‚Äôt expect.</p>
            <p>The flow typically looks like this:</p>
            <ul>
                <li>Source ‚Üí Data object ‚Üí Filter ‚Üí Data object ‚Üí (more filters) ‚Üí Mapper/Renderer</li>
            </ul>
            <div>
                <pre><code class="language-shell">Input(s)          Filter         Output(s)
+-------------+   +-----------+   +-------------+
| vtkDataSet  |--&gt;| vtkFilter |--&gt;| vtkDataSet  |
+-------------+   +-----------+   +-------------+</code></pre>
            </div>
            <p>A small, practical note: when you‚Äôre not inside an active render loop, <code>Update()</code> is what forces a pipeline stage to execute. When you‚Äôre ‚Äújust testing,‚Äù it‚Äôs very easy to forget <code>Update()</code> and accidentally inspect stale data.</p>
            <h3 id="vtkalgorithm">vtkAlgorithm</h3>
            <p><code>vtkAlgorithm</code> is the standard interface that makes the pipeline work. If something is a <code>vtkAlgorithm</code>, it plays nicely in VTK: it has input ports, output ports, and can be connected into pipelines without special casing.</p>
            <p>A practical way to think about it:</p>
            <ul>
                <li><strong>Sources</strong> start the pipeline (create or read data).</li>
                <li><strong>Filters</strong> reshape/compute/convert data.</li>
                <li><strong>(Downstream consumers)</strong> like mappers and writers consume outputs.</li>
            </ul>
            <p>If you‚Äôre building VTK programs in C++ or Python, you‚Äôll constantly see this pattern:</p>
            <ul>
                <li>connect algorithms through ports (<code>SetInputConnection</code>)</li>
                <li>adjust parameters</li>
                <li>trigger execution (<code>Update()</code> or rendering)</li>
            </ul>
            <p><em>Subclasses and roles</em></p>
            <ul>
                <li>Source algorithms (e.g., <code>vtkSphereSource</code>, <code>vtkConeSource</code>) generate or read data objects.</li>
                <li>Filter algorithms (e.g., <code>vtkShrinkFilter</code>, <code>vtkSmoothPolyDataFilter</code>) process and transform data.</li>
            </ul>
            <p>The base class and its conventions are what let you create long, readable pipelines instead of one-off transformations.</p>
            <h3 id="sources">Sources</h3>
            <p>Sources are where your story begins: they generate data (procedural geometry) or read it from files. The reason sources matter isn‚Äôt just that they provide input; they define the initial <em>structure</em>, including connectivity, and that structure influences everything downstream.</p>
            <p>Examples of sources include:</p>
            <ul>
                <li>Procedural generators: <code>vtkSphereSource</code>, <code>vtkConeSource</code></li>
                <li>Readers: <code>vtkSTLReader</code>, <code>vtkXMLPolyDataReader</code></li>
            </ul>
            <p>For instance, <code>vtkSphereSource</code> produces <code>vtkPolyData</code> whose faces share points along edges. That means it‚Äôs already a welded surface. Many filters behave ‚Äúcleanly‚Äù on it because the topology is consistent.</p>
            <h3 id="geometric-filters">Geometric filters</h3>
            <p>Geometric filters are the ‚Äúshape editors.‚Äù They change point coordinates (move, rotate, smooth, shrink, warp) while often preserving the existing connectivity graph.</p>
            <p>This is the category you reach for when you want the <em>same object</em> but with different geometry: less noise, a different scale, a smoother surface, or a transformed pose.</p>
            <p>Examples include:</p>
            <ul>
                <li><code>vtkShrinkFilter</code> (shrinks cells inward)</li>
                <li><code>vtkSmoothPolyDataFilter</code> (adjusts point positions to smooth a surface)</li>
                <li><code>vtkTransformPolyDataFilter</code> (applies a general transform)</li>
                <li><code>vtkDecimatePro</code> (often treated as simplification; it reduces triangles and therefore can affect topology too‚Äîthis one sits on the boundary between ‚Äúgeometric‚Äù and ‚Äútopological‚Äù in effect)</li>
            </ul>
            <p>Even when connectivity is preserved, geometry changes still affect derived quantities such as normals, curvature, and measurements. That‚Äôs why geometric filters aren‚Äôt merely cosmetic.</p>
            <h3 id="topological-filters">Topological filters</h3>
            <p>Topological filters are the ‚Äúrewire the structure‚Äù tools. Instead of moving points, they change how points are connected, or generate entirely new cells from existing data.</p>
            <p>This matters because topology changes are a different kind of decision: you‚Äôre producing a derived representation. That‚Äôs often exactly what you want (triangles for rendering, contours for analysis), but it means downstream steps will see a new connectivity structure.</p>
            <p>Examples include:</p>
            <ul>
                <li><code>vtkTriangleFilter</code> (converts polygons to triangles)</li>
                <li><code>vtkDelaunay2D</code> (constructs 2D Delaunay triangulation, creating new connectivity)</li>
                <li><code>vtkContourFilter</code> (generates contours/isosurfaces, producing new geometry and new connectivity)</li>
            </ul>
            <p>A normal sign that a topological filter did its job is that counts change: number of points, number of cells, cell types, or the number of connected components.</p>
            <h3 id="scalars-and-attribute-filters-in-vtk">Scalars and attribute filters in VTK</h3>
            <p>Attribute filters make your data ‚Äúsmarter.‚Äù They add meaning by computing new arrays: gradients, curvature, magnitudes, and other derived quantities. This is where visualization turns into analysis: you‚Äôre not just looking at shape, you‚Äôre looking at computed properties of the shape.</p>
            <p>Examples include:</p>
            <ul>
                <li><code>vtkGradientFilter</code> (adds a vector field representing gradient)</li>
                <li><code>vtkVectorNorm</code> (computes vector magnitude as a scalar)</li>
                <li><code>vtkCurvatures</code> (computes Gaussian/mean curvature scalars)</li>
            </ul>
            <p>One detail that comes up constantly: attributes can live on <strong>points</strong> or on <strong>cells</strong>.</p>
            <ul>
                <li>Point data tends to interpolate smoothly across a surface.</li>
                <li>Cell data tends to look piecewise-constant (each polygon has a single value).</li>
            </ul>
            <p>If a filter outputs cell data but your mapper expects point data (or vice versa), the visualization can look wrong even though the numbers are fine.</p>
            <h3 id="temporal-filters-in-vtk">Temporal filters in VTK</h3>
            <p>Temporal filters exist because time series data has its own problems: timesteps may have changing values, changing attributes, and sometimes changing geometry. Temporal filters help interpolate, normalize, or compute statistics across time without reinventing that logic manually.</p>
            <p>Examples include:</p>
            <ul>
                <li><code>vtkTemporalInterpolator</code> (interpolates between timesteps)</li>
                <li><code>vtkTemporalShiftScale</code> (shifts and scales time values)</li>
                <li><code>vtkTemporalStatistics</code> (computes statistics over time, producing new attributes)</li>
            </ul>
            <h3 id="why-some-meshes-detach-and-others-stay-connected-">Why some meshes detach and others stay connected?</h3>
            <p>Shrink filters are a perfect example of why connectivity matters.</p>
            <p><code>vtkShrinkPolyData</code> / <code>vtkShrinkFilter</code> conceptually shrink each cell toward its own center. If the input mesh is welded (adjacent faces share point ids), the output often still looks like a connected surface‚Äîbecause shared points enforce shared motion at boundaries.</p>
            <p>If each polygon has its own unique points (duplicated vertices per face), then each polygon shrinks independently and gaps appear immediately. This is usually the explanation when people see ‚Äúdetached polygons‚Äù and wonder why a demo example stays connected.</p>
            <p>That leads to three practical approaches depending on intent:</p>
            <ol>
                <li>
                    <p><strong>If the mesh should be a single surface:</strong> merge coincident points first
                        A cleaning step (commonly <code>vtkCleanPolyData</code>) can weld duplicated points (within a tolerance), restoring connectivity.</p>
                </li>
                <li>
                    <p><strong>If you want to shrink the entire object uniformly:</strong> don‚Äôt use per-cell shrink
                        Compute a centroid and scale the entire mesh about that centroid (e.g., <code>vtkTransform</code> + <code>vtkTransformPolyDataFilter</code>). This preserves connectivity because you move shared points once, not cell-by-cell.</p>
                </li>
                <li>
                    <p><strong>If you truly want an ‚Äúexploded‚Äù look:</strong> per-cell shrink is doing exactly that
                        In that case detaching is not a bug; it‚Äôs the visual effect of independent cells.</p>
                </li>
            </ol>
            <p>A good mental shortcut: if the shrink filter reveals gaps, it‚Äôs usually exposing that your mesh wasn‚Äôt welded in the first place.</p>
            <h3 id="example-creating-a-sphere-source-and-applying-a-shrink-filter">Example: Creating a Sphere Source and Applying a Shrink Filter</h3>
            <p>Examples like this are useful because they show the pipeline idea in miniature: a source generates data with connectivity, then a filter modifies geometry while keeping connectivity intact. Once you internalize that pattern, most VTK workflows become variations on the same theme.</p>
            <p>In this example, we create a sphere and apply a shrink filter:</p>
            <div>
                <pre><code class="language-python">import vtk

# Create a sphere source
sphere_source = vtk.vtkSphereSource()
sphere_source.SetRadius(1.0)

# The sphere source generates points that are connected to form triangles,
# creating a spherical surface.

# Create a shrink filter
shrink_filter = vtk.vtkShrinkFilter()
shrink_filter.SetInputConnection(sphere_source.GetOutputPort())
shrink_filter.SetShrinkFactor(0.8)

# The shrink filter changes the positions of the points, making the sphere smaller,
# but the connectivity (how the points are connected to form triangles) remains the same.

# Update the filter to generate the output
shrink_filter.Update()</code></pre>
            </div>
            <p>We start by creating a <code>vtkSphereSource</code> object to generate a sphere with a radius of 1.0 units, which produces points connected to form a spherical surface. Then we apply a <code>vtkShrinkFilter</code>, connected to the sphere source‚Äôs output, and set a shrink factor of 0.8. Finally, we call <code>Update()</code> to force execution and obtain the shrunken output.</p>
            <p>Below is a visual representation of the shrunken sphere:</p>
            <p><img alt="sphere_shrink" src="https://github.com/djeada/Vtk-Examples/assets/37275728/aa343642-994f-46d9-ae84-11474860df6b" /></p>
            <h3 id="a-practical-connected-shrink-alternative-c-">A practical ‚Äúconnected shrink‚Äù alternative (C++)</h3>
            <p>If your goal is ‚Äúmake the whole mesh smaller toward its center‚Äù <em>without</em> breaking it into detached faces, a global transform is usually the cleanest solution. Unlike <code>vtkShrinkPolyData</code> / <code>vtkShrinkFilter</code> (which act per-cell), a transform acts on <strong>points</strong>. If your mesh is connected (adjacent cells share point ids), moving points with a single global transform keeps the surface connected automatically.</p>
            <p>The idea is simple:</p>
            <ul>
                <li>choose a center (mesh centroid or bounding-box center)</li>
                <li>translate so that center is at the origin</li>
                <li>scale</li>
                <li>translate back</li>
            </ul>
            <p>That‚Äôs it. You‚Äôre scaling the entire object as one piece.</p>
            <p><em>Option A: Scale about the centroid (good ‚Äúphysical‚Äù center)</em></p>
            <p>The centroid here is computed from the mesh‚Äôs points (optionally weighted). This often feels like ‚Äúshrink toward the mass center‚Äù and is a good default for irregular shapes.</p>
            <div>
                <pre><code class="language-clike">#include &lt;vtkSmartPointer.h&gt;
#include &lt;vtkPolyData.h&gt;
#include &lt;vtkCenterOfMass.h&gt;
#include &lt;vtkTransform.h&gt;
#include &lt;vtkTransformPolyDataFilter.h&gt;

// Scales a vtkPolyData uniformly about its centroid.
// scale &lt; 1.0 shrinks, scale &gt; 1.0 grows.
vtkSmartPointer&lt;vtkPolyData&gt; ScalePolyDataAboutCentroid(vtkPolyData* input, double scale)
{
    if (!input)
        return nullptr;

    // 1) Compute centroid (center of mass) from points.
    auto com = vtkSmartPointer&lt;vtkCenterOfMass&gt;::New();
    com-&gt;SetInputData(input);
    com-&gt;SetUseScalarsAsWeights(false); // set true if you want scalar-weighted centroid
    com-&gt;Update();

    double c[3];
    com-&gt;GetCenter(c);

    // 2) Build transform: T(c) * S(scale) * T(-c)
    auto transform = vtkSmartPointer&lt;vtkTransform&gt;::New();
    transform-&gt;PostMultiply();                 // apply in the order we add them
    transform-&gt;Translate(c[0], c[1], c[2]);
    transform-&gt;Scale(scale, scale, scale);
    transform-&gt;Translate(-c[0], -c[1], -c[2]);

    // 3) Apply transform to the polydata
    auto tfilter = vtkSmartPointer&lt;vtkTransformPolyDataFilter&gt;::New();
    tfilter-&gt;SetInputData(input);
    tfilter-&gt;SetTransform(transform);
    tfilter-&gt;Update();

    return tfilter-&gt;GetOutput();
}</code></pre>
            </div>
            <p><strong>What this does</strong></p>
            <ul>
                <li>Every point in the mesh is scaled relative to the same center.</li>
                <li>Connectivity is preserved because cells still reference the same point ids‚Äîonly point coordinates change.</li>
                <li>You get a ‚Äúconnected shrink‚Äù effect even when per-cell shrink would create gaps.</li>
            </ul>
            <p><strong>When centroid is a good choice</strong></p>
            <ul>
                <li>organic or irregular shapes</li>
                <li>meshes where ‚Äúvisual center‚Äù should track the distribution of points</li>
            </ul>
            <p><em>Option B: Scale about the bounding-box center (fast, predictable)</em></p>
            <p>Sometimes you want the center of the mesh‚Äôs bounds (midpoint of min/max in x/y/z). This is simpler and doesn‚Äôt require computing a centroid, and it matches what many people expect as a ‚Äúvisual center‚Äù for symmetric objects.</p>
            <div>
                <pre><code class="language-clike">#include &lt;vtkSmartPointer.h&gt;
#include &lt;vtkPolyData.h&gt;
#include &lt;vtkPoints.h&gt;
#include &lt;vtkTransform.h&gt;
#include &lt;vtkTransformPolyDataFilter.h&gt;

vtkSmartPointer&lt;vtkPolyData&gt; ScalePolyDataAboutBoundsCenter(vtkPolyData* input, double scale)
{
    if (!input)
        return nullptr;

    double bounds[6];
    input-&gt;GetBounds(bounds);

    const double cx = 0.5 * (bounds[0] + bounds[1]);
    const double cy = 0.5 * (bounds[2] + bounds[3]);
    const double cz = 0.5 * (bounds[4] + bounds[5]);

    auto transform = vtkSmartPointer&lt;vtkTransform&gt;::New();
    transform-&gt;PostMultiply();
    transform-&gt;Translate(cx, cy, cz);
    transform-&gt;Scale(scale, scale, scale);
    transform-&gt;Translate(-cx, -cy, -cz);

    auto tfilter = vtkSmartPointer&lt;vtkTransformPolyDataFilter&gt;::New();
    tfilter-&gt;SetInputData(input);
    tfilter-&gt;SetTransform(transform);
    tfilter-&gt;Update();

    return tfilter-&gt;GetOutput();
}</code></pre>
            </div>
            <p><strong>When bounds center is a good choice</strong></p>
            <ul>
                <li>symmetric objects (CAD-like)</li>
                <li>when you want behavior that‚Äôs stable even if point distribution is uneven</li>
            </ul>
            <p>Why this preserves connectivity (and shrink filters may not)?</p>
            <p>A <code>vtkPolyData</code> surface stays connected when adjacent polygons share <strong>the same point ids</strong>. A global transform modifies point coordinates in the <code>Points</code> array, but it does not change which points each cell references. So adjacency remains intact.</p>
            <p>By contrast, cell-based shrink filters conceptually pull each cell toward its own center. If your mesh isn‚Äôt welded (each polygon has its own duplicate vertices), cells don‚Äôt share points, so they shrink independently and gaps appear.</p>
            <ul>
                <li>When adjusting the amount of shrink visually, choosing a <em>scale factor</em> such as 0.95, 0.8, or 0.5 is helpful because the geometry becomes progressively smaller in a controlled way, whereas omitting this choice or using extreme values like 0.0 can collapse cells into unusable shapes; for example, a factor of 0.8 is often used in mesh inspection to clearly separate cells without destroying their overall form.</li>
                <li>In scenes that rely on lighting for depth perception, recomputing <em>surface normals</em> after shrinking is useful because lighting will correctly reflect the updated geometry, while skipping this step can result in flat or incorrect shading; for instance, applying <code>vtkPolyDataNormals</code> after shrinking a model ensures a rendered sphere still appears smoothly lit instead of patchy.</li>
                <li>If different amounts of shrink are desired along different axes, applying <em>anisotropic scaling</em> through separate x, y, and z scale values can be beneficial for controlled deformation, whereas omitting this option limits you to uniform changes that preserve proportions; for example, scaling more along the z-axis than x and y can intentionally flatten a sphere into an oblate shape for visualization experiments.</li>
            </ul>
            <p>This transform approach is a good ‚Äúfirst choice‚Äù when the mental model is ‚Äúshrink the object‚Äù rather than ‚Äúshrink each face.‚Äù</p>
            <h3 id="summary">Summary</h3>
            <p>This is a quick reference, but the more important takeaway is what each category <em>means</em>:</p>
            <ul>
                <li>sources start the data story</li>
                <li>geometric filters reshape existing geometry</li>
                <li>topological filters rewrite structure</li>
                <li>attribute filters add computed meaning</li>
                <li>temporal filters operate across timesteps</li>
            </ul>
            <p>
            <table>
                <tr>
                    <td>Category</td>
                    <td>Class Name</td>
                    <td>Description</td>
                </tr>
                <tr>
                    <td>Sources</td>
                    <td>vtkSphereSource</td>
                    <td>Generates spherical polydata.</td>
                </tr>
                <tr>
                    <td></td>
                    <td>vtkConeSource</td>
                    <td>Creates conical polydata.</td>
                </tr>
                <tr>
                    <td></td>
                    <td>vtkSTLReader</td>
                    <td>Reads STL files.</td>
                </tr>
                <tr>
                    <td></td>
                    <td>vtkXMLPolyDataReader</td>
                    <td>Reads VTK‚Äôs XML polydata files.</td>
                </tr>
                <tr>
                    <td>Geometric Filters</td>
                    <td>vtkShrinkFilter</td>
                    <td>Shrinks cells inward (appearance depends on connectivity).</td>
                </tr>
                <tr>
                    <td></td>
                    <td>vtkSmoothPolyDataFilter</td>
                    <td>Smooths polydata by adjusting point positions.</td>
                </tr>
                <tr>
                    <td></td>
                    <td>vtkDecimatePro</td>
                    <td>Reduces triangle count (often affects topology).</td>
                </tr>
                <tr>
                    <td>Topological Filters</td>
                    <td>vtkTriangleFilter</td>
                    <td>Converts polygons to triangles.</td>
                </tr>
                <tr>
                    <td></td>
                    <td>vtkDelaunay2D</td>
                    <td>Constructs a 2D Delaunay triangulation.</td>
                </tr>
                <tr>
                    <td></td>
                    <td>vtkContourFilter</td>
                    <td>Generates contours/isosurfaces from scalar fields.</td>
                </tr>
                <tr>
                    <td>Scalars &amp; Attribute Filters</td>
                    <td>vtkGradientFilter</td>
                    <td>Computes gradient of a scalar field (adds vector attribute).</td>
                </tr>
                <tr>
                    <td></td>
                    <td>vtkVectorNorm</td>
                    <td>Computes magnitude of vector data (adds scalar attribute).</td>
                </tr>
                <tr>
                    <td></td>
                    <td>vtkCurvatures</td>
                    <td>Computes curvature measures (adds scalar attributes).</td>
                </tr>
                <tr>
                    <td>Temporal Filters</td>
                    <td>vtkTemporalInterpolator</td>
                    <td>Interpolates data between time steps.</td>
                </tr>
                <tr>
                    <td></td>
                    <td>vtkTemporalShiftScale</td>
                    <td>Shifts and scales time values.</td>
                </tr>
                <tr>
                    <td></td>
                    <td>vtkTemporalStatistics</td>
                    <td>Computes statistics over time (adds attributes).</td>
                </tr>
                <tr>
                    <td>Other</td>
                    <td>vtkAlgorithm</td>
                    <td>Base pipeline interface for algorithms (ports + execution model).</td>
                </tr>
            </table>
            </p>
        </article-section>
    </div>
    <footer>
        <div class="footer-columns">
            <div class="footer-column footer-about">
                <h2>About</h2>
                <p class="footer-message">Thanks for stopping by. This site is free to use; please be respectful and avoid misuse. For questions or collaboration, reach me on <a href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" title="LinkedIn Profile">LinkedIn</a> or <a href="https://github.com/djeada" title="GitHub Profile">GitHub</a>.</p>
                <p class="footer-signature">Built with care in Berlin (UTC+1).</p>
            </div>
            <div class="footer-column footer-links">
                <h2>Quick Links</h2>
                <ul class="footer-links-list">
                    <li><a href="https://adamdjellouli.com/index.html" title="Home">Home</a></li>
                    <li><a href="https://adamdjellouli.com/core/projects.html" title="Projects">Projects</a></li>
                    <li><a href="https://adamdjellouli.com/core/tools.html" title="Tools">Tools</a></li>
                    <li><a href="https://adamdjellouli.com/core/courses.html" title="Courses">Courses</a></li>
                    <li><a href="https://adamdjellouli.com/core/resume.html" title="Resume">Resume</a></li>
                    <li><a href="https://adamdjellouli.com/core/privacy_policy.html" title="Privacy Policy">Privacy Policy</a></li>
                    <li><a href="https://adamdjellouli.com/sitemap.xml" title="Sitemap">Sitemap</a></li>
                </ul>
            </div>
            <div class="footer-column footer-social">
                <h2>Follow</h2>
                <ul class="social-media">
                    <li>
                        <a aria-label="YouTube" class="fa fa-youtube" href="https://www.youtube.com/channel/UCGPoHTVjMN77wcGknXPHl1Q" rel="noopener" target="_blank" title="YouTube"></a>
                        <span class="social-label">YouTube</span>
                    </li>
                    <li>
                        <a aria-label="LinkedIn" class="fa fa-linkedin" href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" rel="noopener" target="_blank" title="LinkedIn"></a>
                        <span class="social-label">LinkedIn</span>
                    </li>
                    <li>
                        <a aria-label="Instagram" class="fa fa-instagram" href="https://www.instagram.com/linuxchallenges/" rel="noopener" target="_blank" title="Instagram"></a>
                        <span class="social-label">Instagram</span>
                    </li>
                    <li>
                        <a aria-label="GitHub" class="fa fa-github" href="https://github.com/djeada" title="GitHub"></a>
                        <span class="social-label">GitHub</span>
                    </li>
                </ul>
                <img alt="" aria-hidden="true" class="footer-mark" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/symbol.png" />
            </div>
        </div>
        <div class="footer-bottom">
            <p id="copyright">
                ¬© Adam Djellouli. All rights reserved.
            </p>
        </div>
        <script>
            document.getElementById("copyright").innerHTML = "&copy; " + new Date().getFullYear() + " Adam Djellouli. All rights reserved.";
        </script>
        <script src="/app.js"></script>
    </footer>
    <div id="pdf-spinner-overlay">
        <div class="spinner"></div>
    </div>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-bash.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-cpp.min.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
jax: ["input/TeX", "output/HTML-CSS"],
extensions: ["tex2jax.js"],
"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] },
tex2jax: { inlineMath: [ ["$", "$"] ], displayMath: [ ["$$","$$"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
TeX: { noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } } },
messageStyle: "none"
});
</script>
<script async="" id="MathJax-script" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>

</html>