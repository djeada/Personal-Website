
<!DOCTYPE html>
<html lang="en">

<head>
    <title>Adam Djellouli - Tools</title>
    <meta charset="utf-8">
    <link rel="icon" href="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/icon.ico">
    <link rel="stylesheet" type="text/css" href="../../resources/style.css">
    <link rel="stylesheet" type="text/css" href="style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie-edge" />
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5593122079896089"
     crossorigin="anonymous"></script>
</head>


<body><nav>
    <a class="logo" href="../index.html">
        <img src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/logo.PNG" alt="Adam Djellouli">
    </a>
    <input id="navbar-toggle" type="checkbox" />
    <ul>
        <li> <a href="../index.html"> Home </a> </li>
        <li> <a href="../core/blog.html" class="active"> Blog </a> </li>
        <li> <a href="../core/tools.html"> Tools </a> </li>
        <li> <a href="../core/projects.html"> Projects </a> </li>
        <li> <a href="../core/resume.html"> Resume </a> </li>
        <li> <a href="../core/about.html"> About </a> </li>
    </ul>
</nav>
<section id="article-body">

<h3>Wątki</h3>
<p>Wątki, pozwalają na równoległe wykonywanie się kilku fragmentów kodu. Z tego powodu są szczególnie przydatne do obsługi zadań, które mogą zająć dużo czasu, np. łączenie się z zewnętrznym serwerem lub wczytywanie dużych plików. W ten sposób nie musimy czekać na zakończenie danego zadania, lecz możemy je wykonać równolegle z pozostałymi czynnościami.</p>
<p>Aby skorzystać z wątków, należy najpierw zaimportować moduł <code>threading</code>. Następnie, aby utworzyć nowy wątek, należy utworzyć obiekt klasy <code>Thread</code>. Klasa ta przyjmuje jako argument funkcję, która będzie wykonana jako wątek.</p>
<pre><code>import threading
def watek():
    print("Watek")

w1 = threading.Thread(target=watek)
</code></pre>
<p>Aby uruchomić wątek, należy wywołać metodę <code>start</code> na obiekcie klasy <code>Thread</code>.</p>
<pre><code>w1.start()
</code></pre>
<p>Należy pamiętać, że wątki działają równolegle, więc nie ma gwarancji kolejności wykonywania się poszczególnych wątków. </p>
<h4>Własny wątek</h4>
<p>Aby utworzyć wątek, należy stworzyć klasę dziedziczącą po klasie <code>Thread</code> z modułu <code>threading</code> i zdefiniować metodę <code>run</code>, która zostanie wywołana przy uruchomieniu wątku. Następnie należy utworzyć obiekt tej klasy i wywołać metodę <code>start</code>, aby rozpocząć działanie wątku.</p>
<pre><code>import threading

class MyThread(threading.Thread):
    def run(self):
        # kod, ktory zostanie wykonany w watku
        print("Wątek uruchomiony")

thread = MyThread()
thread.start()
</code></pre>
<p>Możemy również przekazać argumenty do metody <code>run</code> poprzez konstruktor klasy.</p>
<pre><code>import threading

class MyThread(threading.Thread):
    def __init__(self, argument):
        self.argument = argument
        super().__init__()

    def run(self):
        # kod, ktory zostanie wykonany w watku
        print(f"Wątek uruchomiony z argumentem: {self.argument}")

thread = MyThread("Hello World")
thread.start()
</code></pre>
<h4>Zatrzymanie wątku</h4>
<p>W Pythonie można zatrzymać wątek poprzez wywołanie metody <code>Thread.join()</code>. Ta metoda blokuje wywołujący wątek aż do momentu, gdy wątek do którego została wywołana zakończy swoje działanie. Przykładowo, jeśli chcemy zatrzymać główny wątek programu do momentu, gdy wszystkie wątki zostaną zakończone, możemy użyć pętli for i iterować po liście wątków i dla każdego z nich wywołać metodę <code>join()</code>:</p>
<pre><code>threads = [thread1, thread2, thread3]

for thread in threads:
    thread.join()
</code></pre>
<p>Można również użyć metody <code>Thread.join(timeout)</code> z opcjonalnym parametrem <code>timeout</code>. Parametr ten określa maksymalny czas oczekiwania na zakończenie wątku. Jeśli wątek nie zakończy działania w ciągu tego czasu, wątek wywołujący metodę <code>join()</code> zostanie wznowiony.</p>
<p>Innym sposobem zatrzymania wątku jest użycie zmiennej globalnej <code>threading.Event</code> z metodami <code>wait()</code> i <code>set()</code>. Wątek, który chcemy zatrzymać, może oczekiwać na sygnał za pomocą metody <code>wait()</code>, a wątek główny może wysłać sygnał za pomocą metody <code>set()</code>. W przypadku użycia tej metody, wątek oczekujący może również ustawić opcjonalny limit czasu oczekiwania.</p>
<pre><code>  import threading

  # utworzenie zmiennej Event
  stop_event = threading.Event()

  def worker_thread():
      while not stop_event.is_set():
          # wątek wykonuje swoje zadania
          do_some_work()
      # po otrzymaniu sygnalu zatrzymujemy watek
      stop_event.clear()

  # ...

  # glowny watek chce zatrzymac worker_thread
  stop_event.set()
</code></pre>
<p>Należy pamiętać, że zatrzymanie wątku nie jest powszechnie zalecaną metodą zarządzania wątkami. W wielu przypadkach lepszym rozwiązaniem jest użycie warunków synchronizacyjnych lub zamknięcia wątku za pomocą metody <code>join()</code>. Zatrzymanie wątku może powodować nieoczekiwane skutki uboczne i powinno być używane jedynie w wyjątkowych sytuacjach.</p>
<h4>Dzielenie zasobów między wątkami</h4>
<p>Dzielenie zasobów między wątkami polega na umożliwieniu kilku wątkom równoczesnego dostępu do wspólnego zasobu. W przypadku, gdy zasób jest zmienny, konieczne jest zapewnienie bezpieczeństwa jego dostępu, tzn. zapobiegnięcie sytuacji, w której kilka wątków będzie próbowało zmodyfikować ten sam zasób w tym samym czasie. Istnieją mechanizmy umożliwiające bezpieczne dzielenie zasobów między wątkami, takie jak obiekt <code>Lock</code>.</p>
<p>Przykład:</p>
<pre><code>import threading

# Zmienna globalna, do której będą miały dostęp wątki
zmienna_globalna = 0

# Obiekt Lock, który będziemy używali do synchronizacji dostępu do zmiennej globalnej
lock = threading.Lock()

def watek1():
  global zmienna_globalna
  for i in range(100):
    # Pobieramy lock, aby mieć pewność, że tylko jeden wątek będzie
    # miał dostęp do zmiennej globalnej w danym momencie
    lock.acquire()
    zmienna_globalna += 1
    lock.release()

def watek2():
  global zmienna_globalna
  for i in range(100):
    # Pobieramy lock, aby mieć pewność, że tylko jeden wątek będzie
    # miał dostęp do zmiennej globalnej w danym momencie
    lock.acquire()
    zmienna_globalna -= 1
    lock.release()

# Uruchamiamy wątki
t1 = threading.Thread(target=watek1)
t2 = threading.Thread(target=watek2)

t1.start()
t2.start()

# Czekamy na zakończenie obu wątków
t1.join()
t2.join()

# Wypisujemy wartość zmiennej globalnej
print(zmienna_globalna)
</code></pre>
<p>W tym przykładzie mamy dwie funkcje <code>watek1</code> i <code>watek2</code>, które zmieniają wartość zmiennej globalnej <code>zmienna_globalna</code>. Aby zapewnić bezpieczne dzielenie zasobów między wątkami, użyto mechanizmu blokady. </p>
<h4>GIL</h4>
<p>GIL, czyli Global Interpreter Lock, to mechanizm, który ogranicza możliwość jednoczesnego wykonywania kodu przez wiele wątków. W Pythonie każdy wątek jest obsługiwany przez GIL, który kontroluje dostęp do interpretera. W rezultacie tylko jeden wątek jest w stanie wykonywać kod naraz, a pozostałe są zawieszane aż do momentu, gdy GIL zostanie zwolniony.</p>
<p>GIL jest wbudowanym mechanizmem w Pythonie, który został dodany w celu uniknięcia problemów związanych z współdzieleniem zasobów przez wiele wątków. Chociaż GIL może mieć pewne ograniczenia w przypadku bardzo obciążających procesów wielowątkowych, w większości przypadków jest on wystarczający do obsługi równoległości w Pythonie.</p>
<p>Przykładowo, jeśli chcielibyśmy utworzyć program, który będzie sumował elementy w liście, możemy to zrobić za pomocą wielu wątków. Każdy wątek będzie odpowiedzialny za sumowanie części listy. Niestety, GIL spowoduje, że tylko jeden wątek będzie wykonywany w danym momencie, co spowolni działanie programu.</p>
<p>Oto przykład programu sumującego elementy w liście z użyciem wątków:</p>
<pre><code>  import threading

  def sum_list(numbers):
      # Funkcja sumująca elementy w liście
      total = 0
      for number in numbers:
          total += number
      print(total)

  # Utworzenie wątków
  thread1 = threading.Thread(target=sum_list, args=([1, 2, 3],))
  thread2 = threading.Thread(target=sum_list, args=([4, 5, 6],))
  thread3 = threading.Thread(target=sum_list, args=([7, 8, 9],))

  # Uruchomienie wątków
  thread1.start()
  thread2.start()
  thread3.start()

  # Oczekiwanie na zakończenie wątków
  thread1.join()
  thread2.join()
  thread3.join()
</code></pre>
<p>W powyższym przykładzie, chociaż mamy trzy wątki, GIL spowoduje, że tylko jeden z nich będzie wykonywany w danym momencie, co sprawi że użycie wątków nie pomoże z przyspieszeniem działania progrmau.</p>

</section>
<footer>
    <div class="footer-columns">
        <div class="footer-column">
            <img src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/symbol.png" alt="Adam Djellouli">

        </div>
        <div class="footer-column">

            <p>
                Thank you for visiting my personal website. All of the </br>
                content on this site is free to use, but please remember </br>
                to be a good human being and refrain from any abuse</br>
                of the site. If you would like to contact me, please use </br>
                my LinkedIn profile or my GitHub if you have any technical </br>
                issues or ideas to share. I wish you the best and hope you </br>
                have a fantastic life. </br>
            </p>

        </div>
        <div class="footer-column">
            <h2>Follow me</h2>
            <ul class="social-media">
                <li>
                    <a href="https://www.youtube.com/channel/UCGPoHTVjMN77wcGknXPHl1Q" class="fa fa-youtube" target="_blank">

                    </a>YouTube
                </li>
                <li>
                    <a href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" class="fa fa-linkedin" target="_blank">

                    </a>LinkedIn
                </li>
                <li>
                    <a href="https://www.instagram.com/addjellouli/" class="fa fa-instagram" target="_blank">
                    </a>Instagram

                </li>
                <li>
                    <a href="https://github.com/djeada" class="fa fa-github">
                    </a>Github

                </li>

            </ul>
        </div>
    </div>
    <div>
        <p id="copyright">
            &copy; Adam Djellouli. All rights reserved.
        </p>
    </div>
    <script>
        document.getElementById("copyright").innerHTML = "&copy; " + new Date().getFullYear() + " Adam Djellouli. All rights reserved.";
    </script>
</footer></body>

</html>

<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>