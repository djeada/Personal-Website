<!DOCTYPE html>

<html lang="en">

<head>
    <script async="" crossorigin="anonymous" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5593122079896089"></script>
    <meta charset="utf-8" />
    <title>Mounting and Unmounting</title>
    <meta content="If you come from a Windows world, the idea of mounting might sound strange at first, since Linux handles storage devices and filesystems quite differently." name="description" />
    <meta content="Adam Djellouli" name="author" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <meta content="IE=edge" http-equiv="X-UA-Compatible" />
    <link crossorigin="" href="https://fonts.googleapis.com" rel="preconnect" />
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/icon.ico" rel="icon" />
    <link href="../../resources/style.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
</head>

<body>
    <nav aria-label="Main navigation">
        <a class="logo" href="https://adamdjellouli.com">
            <img alt="Adam Djellouli - Home Page Logo" id="logo-image" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/logo.PNG" />
        </a>
        <input aria-label="Toggle navigation menu" id="navbar-toggle" type="checkbox" />
        <ul aria-labelledby="navbar-toggle" role="menu">
            <li role="menuitem">
                <a href="../../index.html" title="Go to Home Page"> Home </a>
            </li>
            <li role="menuitem">
                <a class="active" href="../../core/blog.html" title="Read Adam Djellouli Blog on Programming and Technology"> Blog </a>
            </li>
            <li role="menuitem">
                <a href="../../core/tools.html" title="Discover Tools Created by Adam Djellouli"> Tools </a>
            </li>
            <li role="menuitem">
                <a href="../../core/projects.html" title="Explore Projects Developed by Adam Djellouli"> Projects </a>
            </li>
            <li role="menuitem">
                <a href="../../core/resume.html" title="View Adam Djellouli Professional Resume"> Resume </a>
            </li>
            <li>
                <script async="" src="https://cse.google.com/cse.js?cx=8160ef9bb935f4f68"></script>
                <div class="gcse-search"></div>
            </li>
            <li>
                <button aria-label="Toggle dark mode" id="dark-mode-button"></button>
            </li>
        </ul>
    </nav>
    <div id="article-wrapper">
        <section id="article-body">
            <div class="article-action-buttons"><button class="btn-suggest-edit" title="Suggest Edit">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <path d="M4 21h4l11-11-4-4L4 17v4z" stroke="currentColor" stroke-width="2"></path>
                    </svg>
                </button><button class="btn-create-issue" title="Create Issue">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2"></circle>
                        <line stroke="currentColor" stroke-width="2" x1="12" x2="12" y1="8" y2="12"></line>
                        <circle cx="12" cy="16" fill="currentColor" r="1"></circle>
                    </svg>
                </button><button class="btn-download" title="Download">
                    <svg fill="none" height="20" viewbox="0 0 24 24" width="20">
                        <path d="M12 5v14m0 0l-6-6m6 6l6-6" stroke="currentColor" stroke-width="2"></path>
                    </svg>
                </button></div>
            <p style="text-align: right;"><i>Last modified: June 01, 2025</i></p>
            <p style="text-align: right;"><i>This article is written in: ðŸ‡ºðŸ‡¸</i></p>
            <h2 id="mounting-and-unmounting">Mounting and Unmounting</h2>
            <p>If you come from a Windows world, the idea of mounting might sound strange at first, since Linux handles storage devices and filesystems quite differently. In Linux, "mounting" is the process of making a storage device (such as a hard disk partition, USB drive, or network share) accessible within the filesystem hierarchy. Hereâ€™s a brief overview:</p>
            <p><strong>What Can Be Mounted:</strong></p>
            <ul>
                <li>Hard disk partitions, SSDs, optical drives, and USB flash drives. </li>
                <li>Shares via NFS (Network File System) or SMB/CIFS (used by Windows shares). </li>
                <li>Special pseudo-filesystems like <code>/proc</code>, <code>/sys</code>, and <code>/dev</code> that provide interface access to system resources.</li>
            </ul>
            <p><strong>Mandatory vs. Optional Mounting:</strong> </p>
            <ul>
                <li>Some filesystems must be mounted for the system to function properly. For example, root (<code>/</code>), <code>/proc</code>, <code>/sys</code>, and <code>/dev</code> are mounted at boot time by the system.</li>
                <li>External drives, additional partitions, and remote shares can be mounted manually by the user when needed or configured to auto-mount based on system settings.</li>
            </ul>
            <p><strong>System vs. Manual Mounting on Distros like Ubuntu:</strong></p>
            <ul>
                <li>Ubuntu and similar distributions use <em>automatic mounting</em> for essential filesystems during boot. The <code>/etc/fstab</code> file contains entries that help the system decide which filesystems to mount at startup and with what options. Modern desktop environments also auto-mount removable media when they are connected.</li>
                <li>Users may <em>manually mount</em> devices that arenâ€™t auto-mounted using the <code>mount</code> command. This is common for transient devices or non-standard partition layouts, and for troubleshooting or accessing specific partitions without permanent configuration changes.</li>
            </ul>
            <h3 id="understanding-mounting">Understanding Mounting</h3>
            <p>Mounting is the process of making a file system accessible at a certain point in the Linux directory tree. When you mount a device, you're telling the operating system to attach the file system on that device to a specific directory, known as a mount point. This action integrates the device's file system with the existing directory structure, allowing you to read and write data to it as if it were just another directory on your system.</p>
            <p>Imagine the Linux directory tree as a large, interconnected network of folders. By mounting a new device, you're effectively adding a new branch to this tree. This new branch can be accessed and navigated just like any other part of the tree.</p>
            <p>
            <div>
                <pre><code class="language-shell">Linux Directory Tree Before Mounting:

/
â”œâ”€â”€ bin
â”œâ”€â”€ etc
â”œâ”€â”€ home
â”‚   â”œâ”€â”€ user
â”œâ”€â”€ usr
â””â”€â”€ var

Linux Directory Tree After Mounting /dev/sdb1 at /mnt/external:

/
â”œâ”€â”€ bin
â”œâ”€â”€ etc
â”œâ”€â”€ home
â”‚   â”œâ”€â”€ user
â”œâ”€â”€ mnt
â”‚   â””â”€â”€ external  &lt;-- Mounted device /dev/sdb1
â”‚       â”œâ”€â”€ documents
â”‚       â”œâ”€â”€ photos
â”‚       â””â”€â”€ videos
â”œâ”€â”€ usr
â””â”€â”€ var</code></pre>
            </div>
            </p>
            <p>In this diagram, <code>/dev/sdb1</code> is a storage device (like a USB drive), and <code>/mnt/external</code> is the directory where it's mounted. After mounting, the contents of the device appear under <code>/mnt/external</code>.</p>
            <h3 id="the-mount-command">The Mount Command</h3>
            <p>To mount a file system, you use the <code>mount</code> command. This command attaches the file system found on a device to the directory tree at the specified mount point.</p>
            <p><strong>Basic Syntax:</strong></p>
            <p>
            <div>
                <pre><code class="language-bash">mount [OPTIONS] &lt;device&gt; &lt;mount_point&gt;</code></pre>
            </div>
            </p>
            <ul>
                <li><code>&lt;DEVICE&gt;</code> is the device file representing the storage device, such as <code>/dev/sdb1</code> for a specific partition.</li>
                <li><code>&lt;MOUNT_POINT&gt;</code> is the directory where you want to access the contents of the device, like <code>/mnt/external</code>.</li>
            </ul>
            <p><strong>Common Options (<code>[OPTIONS]</code>):</strong> </p>
            <ul>
                <li><code>-t &lt;filesystem_type&gt;</code> lets you specify the filesystem type, like <code>ext4</code> for Linux filesystems or <code>ntfs</code> for Windows filesystems. If you donâ€™t specify this, <code>mount</code> will try to detect the filesystem type automatically.</li>
                <li><code>-o &lt;options&gt;</code> allows you to pass specific options. For example, <code>ro</code> mounts the device as read-only, while <code>rw</code> makes it read-write. You can also use <code>noexec</code> to prevent files on the device from being executed or <code>uid=&lt;user_id&gt;</code> to set the ownership. </li>
            </ul>
            <p><strong>Example:</strong></p>
            <p>Suppose you have a USB drive at <code>/dev/sdb1</code> that you want to mount at <code>/mnt/external</code>. Here's how you can do it:</p>
            <p>I. <strong>Create a Mount Point:</strong></p>
            <p>First, create the directory if it doesn't exist:</p>
            <p>
            <div>
                <pre><code class="language-bash">sudo mkdir -p /mnt/external</code></pre>
            </div>
            </p>
            <p>II. <strong>Mount the Device:</strong></p>
            <p>
            <div>
                <pre><code class="language-bash">sudo mount /dev/sdb1 /mnt/external</code></pre>
            </div>
            </p>
            <p>This command mounts the device <code>/dev/sdb1</code> to the directory <code>/mnt/external</code>.</p>
            <p><strong>Understanding the Output:</strong></p>
            <p>After mounting, you can verify that the device is mounted by using the <code>mount</code> command without any arguments:</p>
            <p>
            <div>
                <pre><code class="language-bash">mount</code></pre>
            </div>
            </p>
            <p>This will display a list of all mounted file systems. Look for an entry like:</p>
            <p>
            <div>
                <pre><code class="language-shell">/dev/sdb1 on /mnt/external type ext4 (rw,relatime)</code></pre>
            </div>
            </p>
            <p>Breaking down the command:</p>
            <ul>
                <li><code>/dev/sdb1</code> is the device that's mounted.</li>
                <li><code>on /mnt/external</code> is the mount point.</li>
                <li><code>type ext4</code> is the file system type.</li>
                <li><code>(rw,relatime)</code> are mount options indicating it's read-write with relatime updates.</li>
            </ul>
            <h3 id="understanding-unmounting">Understanding Unmounting</h3>
            <p>Unmounting is the process of detaching a mounted file system from the directory tree. Before physically disconnecting a device, you should always unmount it to ensure that all data has been written to the device and to prevent data corruption.</p>
            <p>Think of unmounting as safely removing a book from a library shelf. You ensure that no one is reading or writing notes in it before you take it away.</p>
            <h3 id="the-umount-command">The Umount Command</h3>
            <p>To unmount a file system, you use the <code>umount</code> command (note there's no 'n' in 'umount').</p>
            <p><strong>Basic Syntax:</strong>
                Of course! Hereâ€™s a clear explanation for unmounting a device:</p>
            <p><strong>Basic Syntax:</strong></p>
            <p>
            <div>
                <pre><code class="language-bash">umount [OPTIONS] &lt;mount_point device="" or=""&gt;</code></pre>
            </div>
            </p>
            <ul>
                <li><code>&lt;MOUNT_POINT&gt;</code> or <code>&lt;DEVICE&gt;</code> specifies what you want to unmount. You can provide the directory where the device is mounted (e.g., <code>/mnt/external</code>) or the device itself (e.g., <code>/dev/sdb1</code>).</li>
            </ul>
            <p><strong>Common Options (<code>[OPTIONS]</code>):</strong></p>
            <ul>
                <li><code>-l</code> (Lazy unmount) allows the unmounting process to complete after the device is no longer in use. This is helpful if a process is currently accessing the device, as it will unmount once that process finishes.</li>
                <li><code>-f</code> (Force unmount) forces the device to unmount, even if itâ€™s currently in use. Use this with caution, as it can lead to data corruption if the device is actively writing or reading data.</li>
            </ul>
            <p><strong>Example:</strong></p>
            <p>To unmount the device we mounted earlier:</p>
            <p>
            <div>
                <pre><code class="language-bash">sudo umount /mnt/external</code></pre>
            </div>
            </p>
            <p><strong>Handling Common Issues:</strong></p>
            <p>Sometimes, you might encounter an error like:</p>
            <p>
            <div>
                <pre><code class="language-shell">umount: /mnt/external: target is busy.</code></pre>
            </div>
            </p>
            <p>This means that a process is still using the file system. To find out which processes are causing this, you can use:</p>
            <p>
            <div>
                <pre><code class="language-bash">sudo lsof +f -- /mnt/external</code></pre>
            </div>
            </p>
            <p>This command lists open files on the file system. The output will look something like:</p>
            <p>
            <div>
                <pre><code class="language-shell">COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
bash     1234 user  cwd    DIR   8,17     4096    2 /mnt/external</code></pre>
            </div>
            </p>
            <p>Below is a table explaining meaning of each field:</p>
            <p>
            <table>
                <tr>
                    <td><strong>Field</strong></td>
                    <td><strong>Description</strong></td>
                </tr>
                <tr>
                    <td><code>COMMAND</code></td>
                    <td>The name of the command or process that opened the file.</td>
                </tr>
                <tr>
                    <td><code>PID</code></td>
                    <td>The Process ID of the command or process.</td>
                </tr>
                <tr>
                    <td><code>USER</code></td>
                    <td>The user who owns the process that opened the file.</td>
                </tr>
                <tr>
                    <td><code>FD</code></td>
                    <td>The file descriptor (e.g., <code>cwd</code> for current directory, <code>rtd</code> for root, <code>txt</code> for code, <code>mem</code> for memory).</td>
                </tr>
                <tr>
                    <td><code>TYPE</code></td>
                    <td>The type of file, such as <code>REG</code> (regular file), <code>DIR</code> (directory), <code>CHR</code> (character device), <code>FIFO</code> (pipe), etc.</td>
                </tr>
                <tr>
                    <td><code>DEVICE</code></td>
                    <td>The device number (major and minor) for the file.</td>
                </tr>
                <tr>
                    <td><code>SIZE/OFF</code></td>
                    <td>The size of the file or the file offset.</td>
                </tr>
                <tr>
                    <td><code>NODE</code></td>
                    <td>The file's inode number.</td>
                </tr>
                <tr>
                    <td><code>NAME</code></td>
                    <td>The name or path of the file being accessed.</td>
                </tr>
            </table>
            </p>
            <p>To resolve the issue, you can close the application or navigate out of the directory in any terminal sessions. If necessary, you can terminate the process using:</p>
            <p>
            <div>
                <pre><code class="language-bash">sudo kill 1234</code></pre>
            </div>
            </p>
            <h3 id="verifying-drive-visibility">Verifying Drive Visibility</h3>
            <p>Before mounting a device, it's important to verify that the operating system recognizes it. This ensures that the device is properly connected and ready for use.</p>
            <p><strong>Using fdisk to List Devices:</strong></p>
            <p>The <code>fdisk -l</code> command lists all the disk partitions on the system.</p>
            <p>
            <div>
                <pre><code class="language-bash">sudo fdisk -l</code></pre>
            </div>
            </p>
            <p><strong>Sample Output:</strong></p>
            <p>
            <div>
                <pre><code class="language-shell">Disk /dev/sda: 256 GB
...
Disk /dev/sdb: 32 GB
Device     Boot Start       End   Sectors  Size Id Type
/dev/sdb1        2048  62521343  62519296 29.8G 83 Linux</code></pre>
            </div>
            </p>
            <ul>
                <li>The disk named <code>/dev/sdb</code> is configured with a <strong>total capacity</strong> of 32 GB, which can be used for various storage purposes.</li>
                <li>Within this disk, there exists a <strong>partition</strong> labeled <code>/dev/sdb1</code>, allowing for segmented storage allocation.</li>
                <li>This <strong>partition</strong> possesses a specific size, which may occupy the entire disk space or just a portion, depending on how it was set up.</li>
                <li>The <strong>type</strong> of the <code>/dev/sdb1</code> partition typically indicates its intended usage, such as <strong>Linux</strong> or <strong>swap</strong> partition, which defines how the system interacts with it. </li>
            </ul>
            <h3 id="mounting-file-systems-with-specific-types">Mounting File Systems with Specific Types</h3>
            <p>Sometimes, you may need to specify the file system type when mounting, especially if it's not a standard type or if the system doesn't auto-detect it.</p>
            <p><strong>Example: Mounting a NTFS File System</strong></p>
            <p>Suppose you have an external hard drive formatted with the NTFS file system (common with Windows). You can mount it using:</p>
            <p>
            <div>
                <pre><code class="language-bash">sudo mount -t ntfs /dev/sdb1 /mnt/external</code></pre>
            </div>
            </p>
            <p>Breaking down the command:</p>
            <ul>
                <li><code>-t ntfs</code> specifies the file system type as NTFS.</li>
            </ul>
            <h3 id="using-the-etc-fstab-file-for-persistent-mounts">Using the /etc/fstab File for Persistent Mounts</h3>
            <p>The <code>/etc/fstab</code> file contains information about file systems and mount points. By adding an entry here, you can configure the system to automatically mount a device at boot.</p>
            <p><strong>Example Entry:</strong></p>
            <p>
            <div>
                <pre><code class="language-shell">/dev/sdb1   /mnt/external   ext4    defaults    0   2</code></pre>
            </div>
            </p>
            <p>Below is a table explaining each field in the entry:</p>
            <p>
            <table>
                <tr>
                    <td><strong>Field</strong></td>
                    <td><strong>Description</strong></td>
                </tr>
                <tr>
                    <td><strong>Device</strong></td>
                    <td><code>/dev/sdb1</code> â€“ the device file or partition being mounted.</td>
                </tr>
                <tr>
                    <td><strong>Mount Point</strong></td>
                    <td><code>/mnt/external</code> â€“ the directory where the device is mounted.</td>
                </tr>
                <tr>
                    <td><strong>File System Type</strong></td>
                    <td><code>ext4</code> â€“ the type of file system on the device.</td>
                </tr>
                <tr>
                    <td><strong>Options</strong></td>
                    <td><code>defaults</code> â€“ standard mount options (e.g., read-write, async).</td>
                </tr>
                <tr>
                    <td><strong>Dump</strong></td>
                    <td><code>0</code> â€“ indicates if the partition should be backed up by the <code>dump</code> utility (<code>0</code> = no).</td>
                </tr>
                <tr>
                    <td><strong>Pass</strong></td>
                    <td><code>2</code> â€“ the fsck order during boot (<code>1</code> for root filesystem, <code>2</code> for other filesystems, <code>0</code> for no check).</td>
                </tr>
            </table>
            </p>
            <p><strong>Mounting All File Systems in fstab:</strong></p>
            <p>After editing <code>/etc/fstab</code>, you can mount all file systems listed there using:</p>
            <p>
            <div>
                <pre><code class="language-bash">sudo mount -a</code></pre>
            </div>
            </p>
            <h3 id="mounting-iso-images">Mounting ISO Images</h3>
            <p>An ISO image is a single file that contains the complete content and structure of a CD/DVD. You can mount an ISO file to access its contents without burning it to a physical disc.</p>
            <p><strong>Mounting an ISO File:</strong></p>
            <p>Suppose you have an ISO file named <code>ubuntu.iso</code> and you want to mount it at <code>/mnt/iso</code>.</p>
            <p>I. Create a Mount Point:</p>
            <p>
            <div>
                <pre><code class="language-bash">sudo mkdir -p /mnt/iso</code></pre>
            </div>
            </p>
            <p>II. Mount the ISO:</p>
            <p>
            <div>
                <pre><code class="language-bash">sudo mount -o loop ubuntu.iso /mnt/iso</code></pre>
            </div>
            </p>
            <p>Breaking down the command:</p>
            <ul>
                <li><code>-o</code> uses a loop device, allowing you to mount a file as a block device.</li>
            </ul>
            <p><strong>Accessing the ISO Contents:</strong></p>
            <p>Navigate to the mount point:</p>
            <p>
            <div>
                <pre><code class="language-bash">cd /mnt/iso
ls</code></pre>
            </div>
            </p>
            <p>You'll see the files and directories contained within the ISO image.</p>
            <h3 id="unmounting-the-iso-image">Unmounting the ISO Image</h3>
            <p>When you're done, unmount the ISO to free up the loop device:</p>
            <p>
            <div>
                <pre><code class="language-bash">sudo umount /mnt/iso</code></pre>
            </div>
            </p>
            <h3 id="visualizing-the-mounting-process">Visualizing the Mounting Process</h3>
            <p>Here's an ASCII diagram to help visualize how mounting integrates a device into the directory tree:</p>
            <p>
            <div>
                <pre><code class="language-shell">Before Mounting:

/
â”œâ”€â”€ bin
â”œâ”€â”€ etc
â”œâ”€â”€ home
â”‚   â”œâ”€â”€ user
â”œâ”€â”€ mnt
â”œâ”€â”€ usr
â””â”€â”€ var

After Mounting /dev/sdb1 at /mnt/external:

/
â”œâ”€â”€ bin
â”œâ”€â”€ etc
â”œâ”€â”€ home
â”‚   â”œâ”€â”€ user
â”œâ”€â”€ mnt
â”‚   â””â”€â”€ external
â”‚       â”œâ”€â”€ data
â”‚       â””â”€â”€ projects
â”œâ”€â”€ usr
â””â”€â”€ var</code></pre>
            </div>
            </p>
            <h3 id="the-mounting-workflow">The Mounting Workflow</h3>
            <p>I. Verify Device Visibility:</p>
            <p>Use <code>sudo fdisk -l</code> to list all devices and ensure your device is recognized.</p>
            <p>II. Create a Mount Point:</p>
            <p>If necessary, create a directory to serve as the mount point.</p>
            <p>
            <div>
                <pre><code class="language-bash">sudo mkdir /mnt/external</code></pre>
            </div>
            </p>
            <p>III. Mount the Device:</p>
            <p>
            <div>
                <pre><code class="language-bash">sudo mount /dev/sdb1 /mnt/external</code></pre>
            </div>
            </p>
            <p>IV. Access Files:</p>
            <p>Navigate to <code>/mnt/external</code> to access the device's files.</p>
            <p>V. Unmount When Done:</p>
            <p>
            <div>
                <pre><code class="language-bash">sudo umount /mnt/external</code></pre>
            </div>
            </p>
            <h3 id="ensuring-data-integrity">Ensuring Data Integrity</h3>
            <ul>
                <li>To avoid <strong>data loss</strong>, always unmount devices before physically removing them, as this allows the operating system to finalize any pending write operations.</li>
                <li>Since the operating system often <strong>caches</strong> write operations, data may not be written to the device immediately, so unmounting ensures all data has been properly saved.</li>
                <li>When you <strong>unmount</strong> a device, it confirms that all read and write processes have concluded, making it safe to remove the device without risking corruption.</li>
                <li>Failing to <strong>unmount</strong> a device before removing it can lead to incomplete data transfers and, consequently, corrupted files.</li>
            </ul>
            <h3 id="automating-mounting-with-udev-rules">Automating Mounting with udev Rules</h3>
            <ul>
                <li>Advanced users can set up <strong>udev rules</strong> to automate the mounting process whenever a device is connected, enhancing ease of access.</li>
                <li>Creating <strong>custom rules</strong> in the <code>/etc/udev/rules.d/</code> directory enables automatic actions based on device characteristics, like USB device type or specific serial numbers.</li>
                <li>With <strong>udev</strong> rules, frequently used devices can be automatically mounted at a predefined location, reducing repetitive manual mounting steps.</li>
                <li>This automation can improve <strong>workflow efficiency</strong> and minimize errors, especially if you regularly work with multiple external devices.</li>
            </ul>
            <h4 id="example-auto-mount-usb-drive-with-udev">Example: Auto-Mount USB Drive with udev</h4>
            <p>I. <strong>Identify the Device</strong>:</p>
            <ul>
                <li>First, connect the USB drive to your system and identify it using the <code>lsblk</code> or <code>dmesg</code> command.</li>
                <li>Find the device's <strong>UUID</strong> (Universally Unique Identifier) with the <code>blkid</code> command. This is necessary for ensuring that the rule applies to this specific device.</li>
            </ul>
            <p>
            <div>
                <pre><code class="language-bash">sudo blkid /dev/sdX1</code></pre>
            </div>
            </p>
            <p>II. <strong>Create the udev Rule</strong>:</p>
            <ul>
                <li>Open or create a new file in <code>/etc/udev/rules.d/</code>, for example, <code>99-usb-mount.rules</code>.</li>
                <li>Add the following rule, which will automatically mount the USB drive to a specified directory whenever itâ€™s connected:</li>
            </ul>
            <p>
            <div>
                <pre><code class="language-bash">ACTION=="add", KERNEL=="sdX1", SUBSYSTEM=="block", ENV{ID_FS_UUID}=="your-uuid-here", RUN+="/bin/mkdir -p /media/my_usb &amp;&amp; /bin/mount /dev/sdX1 /media/my_usb"</code></pre>
            </div>
            </p>
            <p>Replace <strong>sdX1</strong> with your specific device identifier, and <strong>your-uuid-here</strong> with the UUID of the device you found in the previous step.</p>
            <p>In this rule:</p>
            <ul>
                <li><code>ACTION=="add"</code> specifies that the rule should apply when the device is <strong>added</strong>.</li>
                <li><code>KERNEL=="sdX1"</code> matches the specific device you want to auto-mount.</li>
                <li><code>SUBSYSTEM=="block"</code> indicates that this rule applies to <strong>block devices</strong>, like hard drives or USB drives.</li>
                <li><code>ENV{ID_FS_UUID}=="your-uuid-here"</code> ensures the rule matches the <strong>exact device</strong> based on its UUID.</li>
                <li><code>RUN+="/bin/mkdir -p /media/my_usb &amp;&amp; /bin/mount /dev/sdX1 /media/my_usb"</code> defines the action, which is to create the mount directory if it doesnâ€™t exist and mount the device to that directory.</li>
            </ul>
            <p>III. <strong>Reload udev Rules</strong>:</p>
            <p>After saving the file, reload the <strong>udev</strong> rules with the following command:</p>
            <p>
            <div>
                <pre><code class="language-bash">sudo udevadm control --reload-rules</code></pre>
            </div>
            </p>
            <p>Then, to test the new rule, <strong>disconnect</strong> and <strong>reconnect</strong> your USB drive.</p>
            <p>IV. <strong>Remove Rules</strong>:</p>
            <p>If the drive is <strong>removed</strong>, you may want to create a separate rule to <strong>unmount</strong> it automatically:</p>
            <p>
            <div>
                <pre><code class="language-bash">ACTION=="remove", KERNEL=="sdX1", SUBSYSTEM=="block", ENV{ID_FS_UUID}=="your-uuid-here", RUN+="/bin/umount /media/my_usb"</code></pre>
            </div>
            </p>
            <p>By adding this <strong>removal rule</strong>, the device will be safely unmounted from the <code>/media/my_usb</code> directory whenever it is disconnected, helping to prevent <strong>data corruption</strong>.</p>
            <h3 id="troubleshooting-mounting-issues">Troubleshooting Mounting Issues</h3>
            <ul>
                <li>If you encounter a <strong>"Permission Denied"</strong> error, confirm that you have the necessary user permissions, or try using the <code>sudo</code> command for elevated access.</li>
                <li>When the system reports an <strong>"Unknown File System Type"</strong> error, you may need to install additional software packages, such as <code>ntfs-3g</code>, which provides support for NTFS file systems on Linux.</li>
                <li>A <strong>"Device is Busy"</strong> message indicates that files or processes are currently using the device; use commands like <code>lsof</code> or <code>fuser</code> to identify and close them before attempting to unmount.</li>
                <li>For devices that wonâ€™t unmount due to <strong>active processes</strong>, ending those processes can clear the device for proper unmounting, ensuring data integrity.</li>
            </ul>
            <h3 id="challenges">Challenges</h3>
            <ol>
                <li>Plug a USB drive into your system and use <code>lsblk</code> and <code>fdisk -l</code> to identify the device name and partition details. Discuss how device names are assigned and explain the difference between physical devices and partitions.</li>
                <li>Create a new directory under <code>/mnt</code> or <code>/media</code>, and mount your USB drive to this directory using the <code>mount</code> command. Describe the purpose of mount points and how they provide access to external storage devices on Linux.</li>
                <li>Navigate to the mount point of the USB drive and perform basic file operationsâ€”create, read, edit, and delete a file. Discuss how mounting makes files accessible and how permissions might affect file access on mounted devices.</li>
                <li>What happens if you mount a USB drive onto an existing non-empty directory? Is this allowed, and if so, what happens to the directoryâ€™s original contents?</li>
                <li>Create a virtual disk file in your home directory using the <code>dd</code> command, specifying its size and location. Discuss how virtual disk files can simulate actual disks and their potential uses in testing and development.</li>
                <li>Format the virtual disk file with an <code>ext4</code> filesystem using <code>mkfs.ext4</code>. Explain the significance of different filesystem types and why choosing an appropriate filesystem is important for specific use cases.</li>
                <li>Mount the formatted virtual disk file to a directory under <code>/mnt</code>, just as you would a physical device. Discuss the concept of loopback devices and how they allow files to be mounted as if they were physical disks.</li>
                <li>Investigate the differences between temporary and persistent mounting by adding an entry for your USB drive or virtual disk in <code>/etc/fstab</code>. Explain how persistent mounts work and the benefits of configuring automatic mounts for commonly used devices.</li>
                <li>Explore permissions on the mounted USB drive by changing the ownership and permissions of files on it. Discuss how Linux handles permissions for different users on mounted devices and the implications for shared drives.</li>
                <li>Create a script that automatically mounts and unmounts the USB drive upon insertion and removal, utilizing <code>udev</code> rules for automation. Explain how <code>udev</code> helps manage device events in Linux and the advantages of automated mounting for frequently used external devices.</li>
            </ol>
        </section>
        <div id="table-of-contents">
            <h2>Table of Contents</h2>
            <ol><a href="#mounting-and-unmounting">Mounting and Unmounting</a>
                <ol>
                    <li><a href="#understanding-mounting">Understanding Mounting</a></li>
                    <li><a href="#the-mount-command">The Mount Command</a></li>
                    <li><a href="#understanding-unmounting">Understanding Unmounting</a></li>
                    <li><a href="#the-umount-command">The Umount Command</a></li>
                    <li><a href="#verifying-drive-visibility">Verifying Drive Visibility</a></li>
                    <li><a href="#mounting-file-systems-with-specific-types">Mounting File Systems with Specific Types</a></li>
                    <li><a href="#using-the-etc-fstab-file-for-persistent-mounts">Using the /etc/fstab File for Persistent Mounts</a></li>
                    <li><a href="#mounting-iso-images">Mounting ISO Images</a></li>
                    <li><a href="#unmounting-the-iso-image">Unmounting the ISO Image</a></li>
                    <li><a href="#visualizing-the-mounting-process">Visualizing the Mounting Process</a></li>
                    <li><a href="#the-mounting-workflow">The Mounting Workflow</a></li>
                    <li><a href="#ensuring-data-integrity">Ensuring Data Integrity</a></li>
                    <li><a href="#automating-mounting-with-udev-rules">Automating Mounting with udev Rules</a>
                        <ol>
                            <li><a href="#example-auto-mount-usb-drive-with-udev">Example: Auto-Mount USB Drive with udev</a></li>
                        </ol>
                    </li>
                    <li><a href="#troubleshooting-mounting-issues">Troubleshooting Mounting Issues</a></li>
                    <li><a href="#challenges">Challenges</a></li>
                </ol>
            </ol>
            <div id="related-articles">
                <h2>Related Articles</h2>
                <ol>
                    <li><a href="https://adamdjellouli.com/articles/linux_notes/commands.html">Commands</a></li>
                    <li><a href="https://adamdjellouli.com/articles/linux_notes/cron_jobs.html">Cron Jobs</a></li>
                    <li><a href="https://adamdjellouli.com/articles/linux_notes/disk_io_analysis.html">Disk Io Analysis</a></li>
                    <li><a href="https://adamdjellouli.com/articles/linux_notes/disk_usage.html">Disk Usage</a></li>
                    <li><a href="https://adamdjellouli.com/articles/linux_notes/dwm.html">Dwm</a></li>
                    <li><a href="https://adamdjellouli.com/articles/linux_notes/encryption.html">Encryption</a></li>
                    <li><a href="https://adamdjellouli.com/articles/linux_notes/environment_modules.html">Environment Modules</a></li>
                    <li><a href="https://adamdjellouli.com/articles/linux_notes/environment_variable.html">Environment Variable</a></li>
                    <li><a href="https://adamdjellouli.com/articles/linux_notes/file_system.html">File System</a></li>
                    <li><a href="https://adamdjellouli.com/articles/linux_notes/files_and_dirs.html">Files and Dirs</a></li>
                    <li><a href="https://adamdjellouli.com/articles/linux_notes/finding_files.html">Finding Files</a></li>
                    <li><a href="https://adamdjellouli.com/articles/linux_notes/firewall.html">Firewall</a></li>
                    <li><a href="https://adamdjellouli.com/articles/linux_notes/grep.html">Grep</a></li>
                    <li><a href="https://adamdjellouli.com/articles/linux_notes/hardware.html">Hardware</a></li>
                    <li><a href="https://adamdjellouli.com/articles/linux_notes/inodes_and_symlinks.html">Inodes and Symlinks</a></li>
                    <li><a href="https://adamdjellouli.com/articles/linux_notes/introduction.html">Introduction</a></li>
                    <li><a href="https://adamdjellouli.com/articles/linux_notes/kernel.html">Kernel</a></li>
                    <li><a href="https://adamdjellouli.com/articles/linux_notes/ldap.html">Ldap</a></li>
                    <li><a href="https://adamdjellouli.com/articles/linux_notes/log_files_and_journals.html">Log Files and Journals</a></li>
                    <li><a href="https://adamdjellouli.com/articles/linux_notes/logical_volume_management.html">Logical Volume Management</a></li>
                    <li><a href="https://adamdjellouli.com/articles/linux_notes/managing_users.html">Managing Users</a></li>
                    <li><a href="https://adamdjellouli.com/articles/linux_notes/mounting.html">Mounting</a></li>
                    <li><a href="https://adamdjellouli.com/articles/linux_notes/networking.html">Networking</a></li>
                    <li><a href="https://adamdjellouli.com/articles/linux_notes/nfs.html">Nfs</a></li>
                    <li><a href="https://adamdjellouli.com/articles/linux_notes/package_managers.html">Package Managers</a></li>
                    <li><a href="https://adamdjellouli.com/articles/linux_notes/partitions.html">Partitions</a></li>
                    <li><a href="https://adamdjellouli.com/articles/linux_notes/performance_monitoring.html">Performance Monitoring</a></li>
                    <li><a href="https://adamdjellouli.com/articles/linux_notes/permissions.html">Permissions</a></li>
                    <li><a href="https://adamdjellouli.com/articles/linux_notes/pipe_and_redirect.html">Pipe and Redirect</a></li>
                    <li><a href="https://adamdjellouli.com/articles/linux_notes/ports.html">Ports</a></li>
                    <li><a href="https://adamdjellouli.com/articles/linux_notes/processes.html">Processes</a></li>
                    <li><a href="https://adamdjellouli.com/articles/linux_notes/running_executables.html">Running Executables</a></li>
                    <li><a href="https://adamdjellouli.com/articles/linux_notes/sed_and_awk.html">Sed and Awk</a></li>
                    <li><a href="https://adamdjellouli.com/articles/linux_notes/selinux.html">Selinux</a></li>
                    <li><a href="https://adamdjellouli.com/articles/linux_notes/services.html">Services</a></li>
                    <li><a href="https://adamdjellouli.com/articles/linux_notes/shells_and_bash_configuration.html">Shells and Bash Configuration</a></li>
                    <li><a href="https://adamdjellouli.com/articles/linux_notes/ssh_and_scp.html">Ssh and Scp</a></li>
                    <li><a href="https://adamdjellouli.com/articles/linux_notes/system_startup.html">System Startup</a></li>
                    <li><a href="https://adamdjellouli.com/articles/linux_notes/tar_and_gzip.html">Tar and Gzip</a></li>
                    <li><a href="https://adamdjellouli.com/articles/linux_notes/task_state_analysis.html">Task State Analysis</a></li>
                    <li><a href="https://adamdjellouli.com/articles/linux_notes/utilities.html">Utilities</a></li>
                    <li><a href="https://adamdjellouli.com/articles/linux_notes/virtual_machines.html">Virtual Machines</a></li>
                </ol>
            </div>
        </div>
    </div>
    <footer>
        <div class="footer-columns">
            <div class="footer-column">
                <img alt="Adam Djellouli Symbol" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/symbol.png" />
            </div>
            <div class="footer-column">
                <h2><a href="https://adamdjellouli.com/core/privacy_policy.html" title="Privacy Policy">Our Privacy Policy</a></h2>
                <p>
                    Thank you for visiting my personal website. All content here is free to use,
                    but please remember to be respectful and avoid any misuse of the site.
                    If youâ€™d like to get in touch, feel free to reach out via my
                    <a href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" title="LinkedIn Profile">LinkedIn profile</a>
                    or connect with me on
                    <a href="https://github.com/djeada" title="GitHub Profile">GitHub</a>
                    if you have technical questions or ideas to share.
                    Wishing you all the best and a fantastic life ahead!
                </p>
            </div>
            <div class="footer-column">
                <h2>Follow me</h2>
                <ul class="social-media">
                    <li>
                        <a class="fa fa-youtube" href="https://www.youtube.com/channel/UCGPoHTVjMN77wcGknXPHl1Q" target="_blank" title="YouTube">
                        </a>YouTube
                    </li>
                    <li>
                        <a class="fa fa-linkedin" href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" target="_blank" title="LinkedIn">
                        </a>LinkedIn
                    </li>
                    <li>
                        <a class="fa fa-instagram" href="https://www.instagram.com/linuxchallenges/" target="_blank" title="Instagram">
                        </a>Instagram
                    </li>
                    <li>
                        <a class="fa fa-github" href="https://github.com/djeada" title="GitHub">
                        </a>Github
                    </li>
                </ul>
            </div>
        </div>
        <div>
            <p id="copyright">
                Â© Adam Djellouli. All rights reserved.
            </p>
        </div>
        <script>
            document.getElementById("copyright").innerHTML = "&copy; " + new Date().getFullYear() + " Adam Djellouli. All rights reserved.";
        </script>
        <script src="../../app.js"></script>
    </footer>
    <div id="pdf-spinner-overlay">
        <div class="spinner"></div>
    </div>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-bash.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-cpp.min.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
jax: ["input/TeX", "output/HTML-CSS"],
extensions: ["tex2jax.js"],
"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] },
tex2jax: { inlineMath: [ ["$", "$"] ], displayMath: [ ["$$","$$"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
TeX: { noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } } },
messageStyle: "none"
});
</script>
<script async="" id="MathJax-script" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>

</html>