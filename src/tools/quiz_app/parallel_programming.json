{
    "questions": [
        {
            "text": "In Python's threading module, which method allows a thread to wait until it is notified?",
            "options": [
                "wait()",
                "hold()",
                "wait() on a Condition object",
                "sleep()",
                "pause()"
            ],
            "correctOptionIndex": 2
        },
        {
            "text": "In Python's threading module, which class should be used to implement a thread-safe counter?",
            "options": [
                "Lock",
                "Semaphore",
                "Event",
                "Timer",
                "RLock"
            ],
            "correctOptionIndex": 4
        },
        {
            "text": "A _____ contains one or more _____.",
            "options": [
                "process; other processes",
                "thread; processes",
                "thread; other threads",
                "process; threads"
            ],
            "correctOptionIndex": 3
        },
        {
            "text": "Parallel computing primarily enhances the _____.",
            "options": [
                "number of tasks a program executes in a set time",
                "speed at which a program executes a set number of tasks",
                "scale of problems a program can tackle",
                "all of these answers",
                "efficiency of memory usage"
            ],
            "correctOptionIndex": 1
        },
        {
            "text": "A Symmetric Multi-Processing (SMP) system has two or more _____ processors connected to a single _____ main memory.",
            "options": [
                "identical; shared",
                "dissimilar; shared",
                "dissimilar; distributed",
                "identical; distributed",
                "asynchronous; shared"
            ],
            "correctOptionIndex": 0
        },
        {
            "text": "The operating system assigns each process a unique _____.",
            "options": [
                "process ID number",
                "CPU core",
                "process name",
                "number of threads",
                "memory address"
            ],
            "correctOptionIndex": 0
        },
        {
            "text": "In C++, which of these scenarios describes the best use case for using a shared_mutex?",
            "options": [
                "Lots of threads need to modify the value of a shared variable, but only a few threads need to read its value.",
                "Only a few threads need to both read and modify the value of a shared variable.",
                "Lots of threads need to both read and modify the value of a shared variable.",
                "Lots of threads need to read the value of a shared variable, but only a few threads need to modify its value.",
                "All threads need exclusive access to the shared variable."
            ],
            "correctOptionIndex": 3
        },
        {
            "text": "Why would you use detached daemon threads to handle continuous background tasks?",
            "options": [
                "Daemon threads always execute at the lowest priority which makes them ideal for background tasks.",
                "Daemon threads will automatically spawn additional helper threads as needed when their workload increases.",
                "You should never trust a daemon. They're mischievous!",
                "The daemon thread will not prevent the program from terminating when the main thread is finished.",
                "Daemon threads are more efficient for high-priority tasks."
            ],
            "correctOptionIndex": 3
        },
        {
            "text": "Processes _____ than threads.",
            "options": [
                "are simpler to communicate between",
                "are considered more \"lightweight\"",
                "are faster to switch between",
                "require more overhead to create"
            ],
            "correctOptionIndex": 3
        },
        {
            "text": "In C++, what happens to a std::thread object immediately after being instantiated?",
            "options": [
                "It begins execution, pending OS scheduling.",
                "It waits in a \"blocked\" state until the parent thread starts it.",
                "It waits in a \"new thread\" state until the parent thread starts it.",
                "It remains idle until explicitly started."
            ],
            "correctOptionIndex": 0
        },
        {
            "text": "Barriers can be used to control _____.",
            "options": [
                "runaway threads to prevent memory leaks",
                "the relative order in which threads execute certain operations",
                "when operations are executed atomically",
                "the priority that determines which threads get scheduled first",
                "the maximum number of threads that can be created"
            ],
            "correctOptionIndex": 1
        },
        {
            "text": "In C++, what is the maximum number of threads that can have shared ownership of a shared_mutex at the same time?",
            "options": [
                "1",
                "2",
                "0",
                "no limit",
                "depends on the implementation"
            ],
            "correctOptionIndex": 3
        },
        {
            "text": "In C++, calling the detach() function on a thread makes it joinable.",
            "options": [
                "FALSE",
                "TRUE",
                "It depends on the thread state.",
                "Only if the thread has not started yet."
            ],
            "correctOptionIndex": 0
        },
        {
            "text": "In C++, how many times must a thread unlock a recursive_mutex before another thread can acquire it?",
            "options": [
                "once",
                "none because multiple threads can lock a recursive_mutex at the same time",
                "as many times as that thread locked it",
                "twice",
                "depends on the priority of the threads"
            ],
            "correctOptionIndex": 2
        },
        {
            "text": "In C++, what happens when a thread calls the try_lock() function on a mutex that is NOT currently locked by another thread?",
            "options": [
                "The function will block execution until the mutex is available, then lock it and return true.",
                "The function immediately locks the mutex and returns true.",
                "The function will block execution until the mutex is available, then lock it and return false.",
                "The function immediately locks the mutex and returns false.",
                "The function does nothing and returns false."
            ],
            "correctOptionIndex": 1
        },
        {
            "text": "A hyperthreaded processor with 8 logical cores will usually provide _____ performance compared to a regular processor with 8 physical cores.",
            "options": [
                "lower",
                "higher",
                "equivalent",
                "variable"
            ],
            "correctOptionIndex": 0
        },
        {
            "text": "Which of these applications would benefit the most from parallel execution?",
            "options": [
                "tool for downloading multiple files from the Internet at the same time",
                "math library for processing large matrices",
                "system logging application that frequently writes to a database",
                "graphical user interface (GUI) for an accounting application",
                "real-time data streaming service"
            ],
            "correctOptionIndex": 0
        },
        {
            "text": "You can safely expect threads to execute in the same relative order that you create them.",
            "options": [
                "TRUE",
                "FALSE",
                "It depends on the operating system",
                "It depends on the processor"
            ],
            "correctOptionIndex": 1
        },
        {
            "text": "Flynn's Taxonomy categorizes computer architectures based on the number of concurrent _____ streams and _____ streams.",
            "options": [
                "input; output",
                "instruction; data",
                "program; data",
                "memory; I/O",
                "data; cache"
            ],
            "correctOptionIndex": 1
        },
        {
            "text": "Which of these describes a program's \"latency\"?",
            "options": [
                "ratio of sequential execution time to the parallel execution time with some number of processors",
                "amount of time a task takes to execute",
                "number of tasks that can be executed in a certain amount of time",
                "number of processors used by the program"
            ],
            "correctOptionIndex": 1
        },
        {
            "text": "If 85% of a program is parallelizable so that using an 6-core processor will produce a 6x speedup for that portion of the code, what is the maximum overall speedup the program can achieve?",
            "options": [
                "4.62",
                "5.1",
                "1",
                "6",
                "5.5"
            ],
            "correctOptionIndex": 0
        },
        {
            "text": "In C++, a recursive_mutex can be locked _____.",
            "options": [
                "multiple times by different threads",
                "multiple times by the same thread",
                "once by multiple threads at the same time",
                "only once in total",
                "depends on the compiler settings"
            ],
            "correctOptionIndex": 1
        },
        {
            "text": "What is an advantage of using fine-grained parallelism with a large number of small tasks?",
            "options": [
                "high computation-to-communication ratio",
                "poor load balancing",
                "low computation-to-communication ratio",
                "good load-balancing",
                "reduced synchronization overhead"
            ],
            "correctOptionIndex": 3
        },
        {
            "text": "Distributed memory architectures are often considered _____ compared to shared memory systems.",
            "options": [
                "more responsive",
                "more scalable",
                "easier to program for",
                "less complex",
                "more cost-effective"
            ],
            "correctOptionIndex": 1
        },
        {
            "text": "What does calculating a program's efficiency (speedup divided by number of parallel processors) provide an indicator of?",
            "options": [
                "the maximum number of parallel processors the program can utilize",
                "how well the parallel program is performing compared to its sequential implementation",
                "how well the parallel processing resources are being utilized",
                "the optimal number of parallel processors for the program to use",
                "the minimum number of processors needed"
            ],
            "correctOptionIndex": 2
        },
        {
            "text": "In C++, why is the try_lock() function useful?",
            "options": [
                "It enables a thread to execute alternate operations if the mutex it needs to acquire is already taken.",
                "It enforces fairness among multiple threads competing for ownership of the same mutex.",
                "If multiple threads try to lock a mutex simultaneously, the try_lock() method will randomly pick one to succeed.",
                "It includes built-in protection against common locking errors.",
                "It guarantees immediate access to the mutex."
            ],
            "correctOptionIndex": 0
        },
        {
            "text": "In C++, what is the maximum number of threads that can have exclusive ownership of a shared_mutex at the same time?",
            "options": [
                "1",
                "no limit",
                "2",
                "0",
                "depends on the operating system"
            ],
            "correctOptionIndex": 0
        },
        {
            "text": "Which classification of Flynn's Taxonomy do modern multi-core PCs fall under?",
            "options": [
                "SIMD",
                "MISD",
                "SISD",
                "MIMD",
                "SPMD"
            ],
            "correctOptionIndex": 3
        },
        {
            "text": "In most modern multi-core CPUs, cache coherency is usually handled by the _____.",
            "options": [
                "user",
                "application software",
                "operating system",
                "processor hardware",
                "compiler"
            ],
            "correctOptionIndex": 3
        },
        {
            "text": "A thread that calls the join method on another thread will enter a _____ state until the other thread finishes executing.",
            "options": [
                "new",
                "runnable",
                "terminated",
                "blocked",
                "waiting"
            ],
            "correctOptionIndex": 3
        },
        {
            "text": "Why would you use the condition_variable's notify_one() function instead of notify_all()?",
            "options": [
                "You need to wake up a random number of waiting threads.",
                "You need all of the waiting threads to wake up and continue executing.",
                "You need to wake up one specific waiting thread.",
                "You only need to wake up one waiting thread and it does not matter which one.",
                "You want to ensure maximum efficiency."
            ],
            "correctOptionIndex": 3
        },
        {
            "text": "It is possible for two tasks to execute _____ using a single-core processor.",
            "options": [
                "in parallel",
                "concurrently",
                "concurrently or in parallel",
                "sequentially"
            ],
            "correctOptionIndex": 1
        },
        {
            "text": "When should a thread typically notify a condition_variable?",
            "options": [
                "Before locking the associated mutex",
                "It does not matter",
                "After doing something to change the state associated with the condition_variable and unlocking the associated mutex",
                "After locking the associated mutex and checking whether or not the condition is true",
                "Before checking the condition"
            ],
            "correctOptionIndex": 2
        },
        {
            "text": "How should the average rates of production and consumption be related in a producer-consumer architecture?",
            "options": [
                "The consumption and production rates must be exactly the same.",
                "The consumption rate should be greater than or equal to the production rate.",
                "It does not matter.",
                "The consumption rate should be less than or equal to the production rate.",
                "The production rate should always exceed the consumption rate."
            ],
            "correctOptionIndex": 3
        },
        {
            "text": "Which of these is a common use case for a counting semaphore?",
            "options": [
                "track the availability of a limited resource",
                "track how many threads the program has created",
                "track how long a program has been running",
                "enforce mutual exclusion in a critical section of code",
                "monitor memory usage"
            ],
            "correctOptionIndex": 0
        },
        {
            "text": "Which two mechanisms can be used together with a queue to make it thread-safe?",
            "options": [
                "semaphore and condition_variable",
                "mutex and semaphore",
                "standard C++ queues are already thread-safe",
                "mutex and condition_variable",
                "atomic variables and spinlocks"
            ],
            "correctOptionIndex": 3
        },
        {
            "text": "In CPP a thread that needs to execute a section of code before the barrier should call the Barrier's _____ function _____ executing the code.",
            "options": [
                "wait(); before",
                "wait(); after",
                "notify_all(); after",
                "notify_all(); before",
                "signal(); before"
            ],
            "correctOptionIndex": 1
        },
        {
            "text": "Which function can be used to submit tasks to a Boost C++ Library thread_pool?",
            "options": [
                "std::async()",
                "boost::asio::submit()",
                "boost::asio::post()",
                "boost::asio::swim()",
                "boost::asio::execute()"
            ],
            "correctOptionIndex": 2
        },
        {
            "text": "In C++, how many threads can take shared ownership of a shared_mutex while another thread has exclusive ownership of it?",
            "options": [
                "1",
                "2",
                "no limit",
                "0",
                "depends on the operating system"
            ],
            "correctOptionIndex": 3
        },
        {
            "text": "In C++, what is the difference between the try_lock() and regular lock() functions?",
            "options": [
                "try_lock() checks whether or not a mutex is already taken without actually locking it.",
                "try_lock() will not block execution if the mutex is already taken by another thread.",
                "try_lock() will continuously try to lock the mutex if it is already taken by another thread.",
                "lock() returns a boolean value to indicate whether or not it was successful.",
                "lock() can be used only with specific mutex types."
            ],
            "correctOptionIndex": 1
        },
        {
            "text": "What type of object does the std::async() function return?",
            "options": [
                "Future",
                "Thread",
                "Thread Pool",
                "Boolean",
                "Promise"
            ],
            "correctOptionIndex": 0
        },
        {
            "text": "What does the semaphore's acquire() function do to the counter value?",
            "options": [
                "always decrement the counter's value",
                "if the counter is positive, increment its value",
                "always increment the counter's value",
                "if the counter is positive, decrement its value",
                "reset the counter value"
            ],
            "correctOptionIndex": 3
        },
        {
            "text": "Which statement describes a difference between a binary semaphore and a mutex?",
            "options": [
                "The binary semaphore will have a value of 0, 1, 2, 3, etc.",
                "The binary semaphore can be acquired and released by different threads.",
                "The binary semaphore can only be acquired and released by the same thread.",
                "The binary semaphore can have a positive or negative value.",
                "The binary semaphore does not enforce mutual exclusion."
            ],
            "correctOptionIndex": 1
        },
        {
            "text": "In addition to modifying the counter value, what else does calling the semaphore's release() function do?",
            "options": [
                "block and wait until the semaphore is available",
                "nothing else",
                "block all other threads waiting on the semaphore",
                "signal another thread waiting to acquire the semaphore",
                "reset the semaphore's counter"
            ],
            "correctOptionIndex": 3
        },
        {
            "text": "Condition variables serve as a _____ for threads to _____.",
            "options": [
                "storage location; save their current state information",
                "conditional statement; pick among several possible paths of execution",
                "holding place; wait for a certain condition before continuing execution",
                "checkpoint; synchronize their execution steps",
                "lock; ensure mutual exclusion"
            ],
            "correctOptionIndex": 2
        },
        {
            "text": "What does the semaphore's release() function do to the counter value?",
            "options": [
                "if the counter is positive, decrement its value",
                "if the counter is positive, increment its value",
                "always increment the counter's value",
                "always decrement the counter's value",
                "reset the counter to zero"
            ],
            "correctOptionIndex": 2
        },
        {
            "text": "Condition variables work together with which other mechanism to serve as a monitor?",
            "options": [
                "a mutex",
                "a thread",
                "the OS execution scheduler",
                "a process",
                "a semaphore"
            ],
            "correctOptionIndex": 0
        },
        {
            "text": "Which of these describes a program's \"throughput\"?",
            "options": [
                "number of tasks that can be executed in a certain amount of time",
                "ratio of sequential execution time to the parallel execution time with some number of processors",
                "amount of time a task takes to execute",
                "number of processors used by the program"
            ],
            "correctOptionIndex": 0
        },
        {
            "text": "Which of these is responsible for causing a race condition?",
            "options": [
                "corrupted memory",
                "the execution scheduler",
                "a slow Internet connection",
                "not using a semaphore",
                "inadequate CPU resources"
            ],
            "correctOptionIndex": 3
        },
        {
            "text": "A race condition _____ a data race.",
            "options": [
                "only occurs when there is",
                "can occur independently of",
                "is just another name for",
                "is more severe than",
                "is unrelated to"
            ],
            "correctOptionIndex": 1
        },
        {
            "text": "In most operating systems the _____ determines when each of the threads and processes gets scheduled to execute.",
            "options": [
                "operating system",
                "processor hardware",
                "application software",
                "user",
                "scheduler algorithm"
            ],
            "correctOptionIndex": 1
        },
        {
            "text": "Which of these describes a program's \"critical path\"?",
            "options": [
                "longest series of sequential operations through the program",
                "sum of the time for all task nodes in a computational graph",
                "sum of the time for all task nodes along the critical path",
                "shortest execution path through the program"
            ],
            "correctOptionIndex": 0
        },
        {
            "text": "In Python, a thread that needs to execute a section of code before the barrier should call the Barrier's _____ function _____ executing the code.",
            "options": [
                "wait(); before",
                "wait(); after",
                "notify_all(); after",
                "notify_all(); before",
                "signal(); before"
            ],
            "correctOptionIndex": 1
        },
        {
            "text": "Which function can be used to submit tasks to a concurrent.futures ThreadPoolExecutor in Python?",
            "options": [
                "submit_task()",
                "add_task()",
                "submit()",
                "enqueue()",
                "execute()"
            ],
            "correctOptionIndex": 2
        },
        {
            "text": "In Python's threading module, how many threads can take shared ownership of a Lock while another thread has exclusive ownership of it?",
            "options": [
                "1",
                "2",
                "no limit",
                "0",
                "depends on the operating system"
            ],
            "correctOptionIndex": 3
        },
        {
            "text": "In Python's threading module, what is the difference between the try_lock() (try_acquire() in Python) and regular lock() (acquire() in Python) functions?",
            "options": [
                "try_lock() checks whether or not a mutex is already taken without actually locking it.",
                "try_lock() (try_acquire()) will not block execution if the mutex is already taken by another thread.",
                "try_lock() (try_acquire()) will continuously try to lock the mutex if it is already taken by another thread.",
                "lock() (acquire()) returns a boolean value to indicate whether or not it was successful.",
                "lock() (acquire()) can be used only with specific mutex types."
            ],
            "correctOptionIndex": 1
        },
        {
            "text": "What does a work-to-span ratio less than one indicate?",
            "options": [
                "A parallelized version of the program will execute faster than the sequential version.",
                "A parallelized version of the program will execute in the same amount of time as the sequential version.",
                "The work-to-span ratio cannot be less than one.",
                "A parallelized version of the program will execute slower than the sequential version.",
                "The program has no parallelism opportunities."
            ],
            "correctOptionIndex": 3
        },
        {
            "text": "Why are thread pools useful?",
            "options": [
                "Threads like to relax and go for a swim every once in a while.",
                "Threads within the same thread pool can more easily share data with each other than standard non-pool threads.",
                "They provide a convenient way to group and organize a collection of related threads.",
                "They reuse threads to reduce the overhead that would be required to create a new, separate thread for every concurrent task.",
                "They automatically manage thread synchronization issues."
            ],
            "correctOptionIndex": 3
        },
        {
            "text": "Increasing the number of processors with a fixed problem size per processor leverages weak scaling to accomplish _____ in _____.",
            "options": [
                "more work; more time",
                "same work; less time",
                "more work; less time",
                "more work; same time",
                "less work; same time"
            ],
            "correctOptionIndex": 2
        },
        {
            "text": "What is the purpose of a future?",
            "options": [
                "It serves as the counterpart to a programming past.",
                "It is a task that can be assigned to a thread pool for execution.",
                "It serves as a placeholder to access a result that may not been computed yet.",
                "It allows a program to change how it will function the next time it is run.",
                "It provides error handling for asynchronous operations."
            ],
            "correctOptionIndex": 2
        },
        {
            "text": "Which of these describes a program's \"work\"?",
            "options": [
                "sum of the time for all task nodes along the critical path",
                "longest series of sequential operations through the program",
                "sum of the time for all task nodes in a computational graph",
                "total number of operations performed by the program"
            ],
            "correctOptionIndex": 2
        },
        {
            "text": "What does a divide-and-conquer algorithm do when it reaches the base case?",
            "options": [
                "Stop subdividing the current problem and solve it.",
                "Recursively solve a set of smaller subproblems.",
                "Solve all of the subproblems that have been created.",
                "Divide the problem into two smaller subproblems.",
                "Return the initial problem unchanged."
            ],
            "correctOptionIndex": 0
        },
        {
            "text": "Why are computational graphs useful?",
            "options": [
                "They include all of the tasks within a program, from start to finish.",
                "They help to identify critical sections of code that will require mutual exclusion.",
                "They provide a good excuse to practice your drawing skills.",
                "They help to identify opportunities for parallel execution.",
                "They simplify the debugging process."
            ],
            "correctOptionIndex": 0
        },
        {
            "text": "Why should you average the execution time across multiple runs when measuring a program's performance?",
            "options": [
                "The system clock used to determine the start and end times of the program is inconsistent and may fluctuate randomly.",
                "It's good luck to do things multiple times.",
                "The program might crash so you should measure it multiple times to make sure you get at least one good run.",
                "The execution time will vary from run-to-run depending on how the operating system chooses to schedule your program.",
                "To account for hardware variability."
            ],
            "correctOptionIndex": 3
        },
        {
            "text": "Which stage of the parallel design process focuses on combining tasks and replicating data or computation as needed to increase program efficiency?",
            "options": [
                "mapping",
                "agglomeration",
                "communication",
                "partitioning",
                "synchronization"
            ],
            "correctOptionIndex": 1
        },
        {
            "text": "In Python's threading module, which class provides a way to run code periodically in the background?",
            "options": [
                "BackgroundTask",
                "Timer",
                "PeriodicExecutor",
                "IntervalThread",
                "PeriodicTask"
            ],
            "correctOptionIndex": 1
        },
        {
            "text": "In Python's concurrent.futures module, which method is used to cancel a future that has not started execution?",
            "options": [
                "stop()",
                "terminate()",
                "interrupt()",
                "cancel()",
                "halt()"
            ],
            "correctOptionIndex": 3
        },
        {
            "text": "Which of these describes a program's \"span\"?",
            "options": [
                "longest series of sequential operations through the program",
                "sum of the time for all task nodes along the critical path",
                "sum of the time for all task nodes in a computational graph",
                "total execution time of the program"
            ],
            "correctOptionIndex": 1
        },
        {
            "text": "Every thread is independent and has its own separate address space in memory.",
            "options": [
                "FALSE",
                "TRUE",
                "It depends on the operating system",
                "It depends on the language used"
            ],
            "correctOptionIndex": 0
        },
        {
            "text": "In Python's threading module, what does the is_alive() method do?",
            "options": [
                "Returns the thread's priority",
                "Returns the thread's current state",
                "Returns whether the thread is still running",
                "Returns the thread's identifier",
                "Returns the thread's exit code"
            ],
            "correctOptionIndex": 2
        },
        {
            "text": "In Python's threading module, which object can be used to wake up all threads waiting on it?",
            "options": [
                "Timer",
                "Barrier",
                "Lock",
                "Event",
                "Semaphore"
            ],
            "correctOptionIndex": 3
        },
        {
            "text": "In Python's threading module, which method can be used to put the current thread to sleep for a specified amount of time?",
            "options": [
                "rest()",
                "wait()",
                "sleep()",
                "pause()",
                "delay()"
            ],
            "correctOptionIndex": 2
        },
        {
            "text": "In Python, which module provides support for high-level asynchronous I/O?",
            "options": [
                "asyncio",
                "threading",
                "multiprocessing",
                "concurrent",
                "sched"
            ],
            "correctOptionIndex": 0
        },
        {
            "text": "In Python's asyncio module, which function is used to create a new task?",
            "options": [
                "start_task()",
                "new_task()",
                "create_task()",
                "schedule_task()",
                "add_task()"
            ],
            "correctOptionIndex": 2
        },
        {
            "text": "In Python, how can you ensure a section of code is executed by only one thread at a time?",
            "options": [
                "Use the Queue module",
                "Use a Lock",
                "Use a Semaphore",
                "Use an Event",
                "Use a Timer"
            ],
            "correctOptionIndex": 1
        },
        {
            "text": "In Python's asyncio module, which method of a future object returns the result or raises the exception of the future?",
            "options": [
                "fetch()",
                "obtain()",
                "result()",
                "acquire()",
                "get_value()"
            ],
            "correctOptionIndex": 2
        },
        {
            "text": "Why can it be risky to use a detached daemon thread to perform a task that involves writing data to a log file?",
            "options": [
                "Daemons only write their own name, so the log will just say \"Daemon, Daemon, Daemon, etc.\"",
                "Daemon threads cannot read or write files.",
                "The log file could be corrupted.",
                "The log file could end up with multiple, duplicate entries.",
                "Daemon threads might not have file access permissions."
            ],
            "correctOptionIndex": 2
        },
        {
            "text": "In Python's concurrent.futures module, which class is used to create a pool of threads?",
            "options": [
                "ThreadPool",
                "ThreadPoolExecutor",
                "ThreadManager",
                "TaskPool",
                "ConcurrentExecutor"
            ],
            "correctOptionIndex": 1
        },
        {
            "text": "Which of these describes a program's \"speedup\"?",
            "options": [
                "amount of time a task takes to execute",
                "ratio of sequential execution time to the parallel execution time with some number of processors",
                "number of tasks that can be executed in a certain amount of time",
                "number of processors used by the program"
            ],
            "correctOptionIndex": 1
        },
        {
            "text": "In Python's threading module, which synchronization primitive allows multiple threads to synchronize on a shared resource by acquiring and releasing it?",
            "options": [
                "Barrier",
                "Semaphore",
                "Event",
                "Timer",
                "Lock"
            ],
            "correctOptionIndex": 1
        },
        {
            "text": "Increasing the number of processors with a fixed total problem size leverages strong scaling to accomplish _____ in _____.",
            "options": [
                "more work; less time",
                "same work; less time",
                "more work; same time",
                "more work; more time",
                "less work; more time"
            ],
            "correctOptionIndex": 1
        },
        {
            "text": "Amdahl's Law calculates a(n) _____ for the overall speedup that parallelizing a program will achieve.",
            "options": [
                "upper and lower limit",
                "lower limit",
                "upper limit",
                "average value",
                "median value"
            ],
            "correctOptionIndex": 2
        },
        {
            "text": "What is an advantage of using coarse-grained parallelism with a small number of large tasks?",
            "options": [
                "high computation-to-communication ratio",
                "poor load balancing",
                "low computation-to-communication ratio",
                "good load-balancing",
                "reduced memory overhead"
            ],
            "correctOptionIndex": 0
        },
        {
            "text": "Why does the mapping design stage not apply to applications written for common desktop operating systems?",
            "options": [
                "The operating system automatically handles scheduling threads to execute on each processor core.",
                "Desktop computers do not have enough processor cores for mapping to be a concern.",
                "Most desktop computers only have one processor core.",
                "The mapping design stage is not necessary for modern applications.",
                "Mapping is handled by the application itself."
            ],
            "correctOptionIndex": 0
        },
        {
            "text": "Why does the partitioning design stage occur before the communication stage?",
            "options": [
                "You need to group the tasks together before planning the most effective communication strategy between them.",
                "You need to know how the problem will be divided in order to assess the communication needs between individual tasks.",
                "You need to know where each of the tasks will physically execute before deciding on a communication strategy.",
                "The \"order\" of the four design stages is arbitrary and does not really matter.",
                "Communication requirements determine how tasks are grouped."
            ],
            "correctOptionIndex": 1
        },
        {
            "text": "Which stage of the parallel design process focuses on breaking the problem down into discrete pieces of work?",
            "options": [
                "mapping",
                "agglomeration",
                "communication",
                "partitioning",
                "synchronization"
            ],
            "correctOptionIndex": 3
        },
        {
            "text": "In Python's threading module, which method is used to start a new thread?",
            "options": [
                "run()",
                "create()",
                "start()",
                "initiate()",
                "launch()"
            ],
            "correctOptionIndex": 2
        },
        {
            "text": "Which scenario describes the best use case for a point-to-point communication strategy?",
            "options": [
                "A small number of tasks need to send data a large number of other tasks.",
                "A large number of tasks will be sending data to a small number of receiving tasks.",
                "A large number of tasks need to communicate with each other.",
                "A small number of tasks need to communicate with each other.",
                "All tasks need to broadcast to all other tasks."
            ],
            "correctOptionIndex": 3
        },
        {
            "text": "Which stage of the parallel design process focuses on coordinating task execution and how they share information?",
            "options": [
                "mapping",
                "agglomeration",
                "partitioning",
                "communication",
                "synchronization"
            ],
            "correctOptionIndex": 3
        },
        {
            "text": "Granularity can be described as the ratio of _____ over _____.",
            "options": [
                "speedup; number of processors",
                "tasks; time",
                "tasks; number of processors",
                "computation; communication",
                "workload; processors"
            ],
            "correctOptionIndex": 3
        },
        {
            "text": "Which architecture consists of a chained together series of producer-consumer pairs?",
            "options": [
                "FIFO",
                "pipeline",
                "distributed",
                "client-server",
                "hierarchical"
            ],
            "correctOptionIndex": 1
        },
        {
            "text": "In Python's concurrent.futures module, which method is used to get the result of a future?",
            "options": [
                "fetch()",
                "obtain()",
                "get()",
                "result()",
                "acquire()"
            ],
            "correctOptionIndex": 3
        },
        {
            "text": "In Python, which method is used to stop a thread immediately?",
            "options": [
                "terminate()",
                "kill()",
                "exit()",
                "stop()",
                "None of the above"
            ],
            "correctOptionIndex": 4
        },
        {
            "text": "Why would ThreadA call the join() function on ThreadB?",
            "options": [
                "ThreadB needs to wait until after ThreadA has terminated to continue.",
                "ThreadA needs to wait until after ThreadB has terminated to continue.",
                "ThreadB is blocked so ThreadA needs to tell it to continue executing.",
                "ThreadA needs to terminate ThreadB immediately.",
                "ThreadA and ThreadB need to synchronize execution."
            ],
            "correctOptionIndex": 1
        },
        {
            "text": "In Python, which module provides a way to create and manage threads?",
            "options": [
                "threading",
                "multiprocessing",
                "asyncio",
                "concurrent",
                "sched"
            ],
            "correctOptionIndex": 0
        },
        {
            "text": "In Python's threading module, what is the purpose of the join() method?",
            "options": [
                "To start a thread",
                "To pause a thread",
                "To stop a thread",
                "To wait for a thread to finish",
                "To notify a thread"
            ],
            "correctOptionIndex": 3
        },
        {
            "text": "In Python's threading module, which method is used to release a lock?",
            "options": [
                "release()",
                "unlock()",
                "free()",
                "open()",
                "exit()"
            ],
            "correctOptionIndex": 0
        },
        {
            "text": "In Python's asyncio module, which function runs the event loop until the future (task) completes?",
            "options": [
                "run()",
                "execute()",
                "perform()",
                "run_until_complete()",
                "run_forever()"
            ],
            "correctOptionIndex": 3
        },
        {
            "text": "Which stage of the parallel design process focuses on specifying where each task will execute?",
            "options": [
                "communication",
                "mapping",
                "agglomeration",
                "partitioning",
                "load balancing"
            ],
            "correctOptionIndex": 1
        },
        {
            "text": "Which scenario creates the potential for a race condition to occur?",
            "options": [
                "the order in which two threads execute their respective operations will change the output",
                "one thread is modifying a shared variable while another thread concurrently reads its value",
                "a single-threaded program is competing with other processes for execution time on the CPU",
                "two threads are concurrently reading and writing the same shared variable",
                "multiple threads are waiting for a condition variable to be notified"
            ],
            "correctOptionIndex": 1
        }
    ]
}