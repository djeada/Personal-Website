<!DOCTYPE html>

<html lang="en">

<head>
    <script async="" crossorigin="anonymous" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5593122079896089"></script>
    <title>Graph Algorithm Visualization</title>
    <meta charset="utf-8" />
    <meta content="Interactive visualization of pathfinding algorithms. Explore DFS, BFS, Dijkstra, and A* on customizable grids." name="description" />
    <meta content="graph algorithms, algorithm visualization, DFS, BFS, Dijkstra, A*, Adam Djellouli, pathfinding" name="keywords" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/icon.ico" rel="icon" />
    <link href="../../resources/style.css" rel="stylesheet" type="text/css" />
    <link href="style.css" rel="stylesheet" type="text/css" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />
    <link href="https://fonts.googleapis.com" rel="preconnect" />
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <meta content="ie-edge" http-equiv="X-UA-Compatible" />
</head>

<body>
    <nav aria-label="Main navigation">
        <a class="logo" href="../../index.html">
            <img alt="Adam Djellouli - Home Page Logo" id="logo-image" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/logo.PNG" />
        </a>
        <input aria-label="Toggle navigation menu" id="navbar-toggle" type="checkbox" />
        <ul aria-labelledby="navbar-toggle" role="menu">
            <li role="menuitem">
                <a href="../../index.html" title="Go to Home Page"> Home </a>
            </li>
            <li role="menuitem">
                <a href="../../core/blog.html" title="Read Adam Djellouli Blog on Programming and Technology"> Blog </a>
            </li>
            <li role="menuitem">
                <a href="../../core/tools.html" title="Discover Tools Created by Adam Djellouli"> Tools </a>
            </li>
            <li role="menuitem">
                <a href="../../core/projects.html" title="Explore Projects Developed by Adam Djellouli"> Projects </a>
            </li>
            <li role="menuitem">
                <a href="../../core/courses.html" title="Browse Courses by Adam Djellouli"> Courses </a>
            </li>
            <li role="menuitem">
                <a href="../../core/resume.html" title="View Adam Djellouli Professional Resume"> Resume </a>
            </li>
            <li>
                <script async="" src="https://cse.google.com/cse.js?cx=8160ef9bb935f4f68"></script>
                <div class="gcse-search"></div>
            </li>
            <li>
                <button aria-label="Toggle dark mode" id="dark-mode-button"></button>
            </li>
        </ul>
    </nav>
    <div aria-live="polite" class="toast-container" id="toast-container"></div>
    <main class="tool-main">
        <!-- Hero Header -->
        <header class="tool-header">
            <div class="header-content">
                <div class="header-icon">
                    <span class="icon-sparkle">üîç</span>
                </div>
                <h1>Graph Algorithm Visualization</h1>
                <p class="subtitle">Explore pathfinding algorithms with interactive grid visualization</p>
                <div class="keyboard-hint">
                    Click cells to toggle walls ‚Ä¢ <kbd>Space</kbd> to start/pause
                </div>
            </div>
        </header>
        <!-- Stats Bar -->
        <div class="stats-bar">
            <div class="stat-item">
                <span class="stat-icon">üìä</span>
                <span class="stat-value" id="cells-visited">0</span>
                <span class="stat-label">Cells Visited</span>
            </div>
            <div class="stat-item">
                <span class="stat-icon">üìè</span>
                <span class="stat-value" id="path-length">0</span>
                <span class="stat-label">Path Length</span>
            </div>
            <div class="stat-item">
                <span class="stat-icon">‚è±Ô∏è</span>
                <span class="stat-value" id="elapsed-time">0ms</span>
                <span class="stat-label">Time</span>
            </div>
            <div class="stat-item">
                <span class="stat-icon">üéØ</span>
                <span class="stat-value" id="algorithm-name">DFS</span>
                <span class="stat-label">Algorithm</span>
            </div>
        </div>
        <section class="tool-content">
            <!-- Sidebar Options -->
            <aside class="options-sidebar">
                <div class="sidebar-header">
                    <h2><span class="icon">‚öôÔ∏è</span> Settings</h2>
                    <button class="preset-btn" id="reset-defaults" title="Reset to defaults">
                        <span>‚Ü∫</span>
                    </button>
                </div>
                <!-- Algorithm Selection -->
                <div class="option-card preset-card">
                    <h3><span class="card-icon">üßÆ</span> Algorithm</h3>
                    <div class="input-group">
                        <select id="algorithm">
                            <option value="dfs">Depth-First Search (DFS)</option>
                            <option value="bfs">Breadth-First Search (BFS)</option>
                            <option value="dijkstra">Dijkstra's Algorithm</option>
                            <option value="astar">A* Algorithm</option>
                        </select>
                    </div>
                </div>
                <!-- Grid Options -->
                <div class="option-card">
                    <button aria-expanded="true" class="card-toggle">
                        <h3><span class="card-icon">üìê</span> Grid</h3>
                        <span class="toggle-icon">‚ñº</span>
                    </button>
                    <div class="card-content">
                        <div class="input-group">
                            <label for="grid-size">Grid Size</label>
                            <input id="grid-size" max="50" min="5" type="number" value="20" />
                        </div>
                        <div class="input-group">
                            <label for="wall-density">Wall Density</label>
                            <input id="wall-density" max="50" min="0" step="5" type="range" value="30" />
                        </div>
                    </div>
                </div>
                <!-- Visualization Options -->
                <div class="option-card">
                    <button aria-expanded="true" class="card-toggle">
                        <h3><span class="card-icon">üé®</span> Visualization</h3>
                        <span class="toggle-icon">‚ñº</span>
                    </button>
                    <div class="card-content">
                        <div class="input-group">
                            <label for="speed">Animation Speed</label>
                            <input id="speed" max="10" min="1" type="range" value="5" />
                        </div>
                        <div class="option-item" title="Show grid lines on the canvas">
                            <label class="toggle-switch">
                                <input checked="" id="show-grid-lines" type="checkbox" />
                                <span class="toggle-slider"></span>
                            </label>
                            <span class="option-label">Show Grid Lines</span>
                        </div>
                    </div>
                </div>
                <!-- Controls Info -->
                <div class="option-card">
                    <h3><span class="card-icon">‚ÑπÔ∏è</span> Controls</h3>
                    <div class="card-content">
                        <p style="font-size: 0.85rem; color: var(--text-secondary); margin: 0; line-height: 1.6;">
                            ‚Ä¢ Click cells to add/remove walls<br />
                            ‚Ä¢ Start (green) is at top-left<br />
                            ‚Ä¢ End (red) is at bottom-right<br />
                            ‚Ä¢ Use Step for manual control
                        </p>
                    </div>
                </div>
            </aside>
            <!-- Main Canvas Area -->
            <div class="canvas-area">
                <!-- Canvas Container -->
                <div class="canvas-container">
                    <div class="canvas-header">
                        <span class="canvas-title">üó∫Ô∏è Pathfinding Grid</span>
                    </div>
                    <div class="canvas-wrapper">
                        <canvas id="maze-canvas"></canvas>
                    </div>
                </div>
                <!-- Action Buttons -->
                <div class="action-bar">
                    <div class="primary-actions">
                        <button class="action-btn primary large" id="start">
                            <span class="btn-icon">‚ñ∂Ô∏è</span>
                            <span class="btn-text">Start Search</span>
                        </button>
                    </div>
                    <div class="secondary-actions">
                        <button class="action-btn warning" id="pause" title="Pause/Resume">
                            <span class="btn-icon">‚è∏Ô∏è</span> Pause
                        </button>
                        <button class="action-btn" id="step" title="Step through one iteration">
                            <span class="btn-icon">‚è≠Ô∏è</span> Step
                        </button>
                        <button class="action-btn danger" id="reset" title="Reset the grid">
                            <span class="btn-icon">üîÑ</span> Reset
                        </button>
                    </div>
                </div>
                <!-- Legend Panel -->
                <div class="legend-panel">
                    <div class="legend-header">
                        <h3><span>üé®</span> Legend</h3>
                    </div>
                    <div class="legend-content">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #00FF00;"></div>
                            <span class="legend-label">Start</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #FF0000;"></div>
                            <span class="legend-label">End</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #000000;"></div>
                            <span class="legend-label">Wall</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #87CEEB;"></div>
                            <span class="legend-label">Open Set</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #FFA500;"></div>
                            <span class="legend-label">Visited</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #FFFF00;"></div>
                            <span class="legend-label">Path</span>
                        </div>
                    </div>
                </div>
            </div>
        </section>
        <!-- Help Box -->
        <div class="help-box">
            <strong>Need Help?</strong>
            <ul>
                <li>Select an algorithm from the sidebar dropdown.</li>
                <li>Adjust grid size and wall density to customize the maze.</li>
                <li>Click on cells to manually add or remove walls.</li>
                <li>Click "Start Search" to visualize the pathfinding algorithm.</li>
                <li>Use "Step" to advance one iteration at a time for detailed analysis.</li>
                <li>The stats bar shows real-time metrics during the search.</li>
                <li>Different colors represent different states (see Legend).</li>
            </ul>
        </div>
        <!-- Algorithm Background Section -->
        <section class="explanation-section">
            <div class="section-header">
                <h2>üìö Algorithm Background</h2>
            </div>
            <div class="explanation-content">
                <div class="explanation-card">
                    <h3>üó∫Ô∏è Graph Theory and Pathfinding</h3>
                    <p>
                        Graph algorithms are fundamental to computer science and have applications ranging from GPS navigation
                        to network routing, game AI, and social network analysis. A <strong>graph</strong> consists of
                        <strong>vertices (nodes)</strong> connected by <strong>edges</strong>. In our grid visualization,
                        each cell is a vertex, and adjacent cells are connected by edges.
                    </p>
                    <p>
                        The pathfinding problem seeks to find a sequence of vertices connecting a <strong>start vertex</strong>
                        to a <strong>goal vertex</strong>. Different algorithms employ different strategies‚Äîsome prioritize
                        finding <em>any</em> path quickly, while others guarantee finding the <em>shortest</em> path.
                    </p>
                </div>
                <div class="explanation-card">
                    <h3>üîç Depth-First Search (DFS)</h3>
                    <p>
                        <strong>Strategy:</strong> DFS explores as far as possible along each branch before backtracking.
                        It uses a <strong>stack</strong> (either explicit or via recursion) to remember which vertices to visit next.
                    </p>
                    <div class="formula-box">
                        <p><strong>Algorithm:</strong></p>
                        <p>1. Start at the initial vertex and mark it as visited</p>
                        <p>2. For each unvisited neighbor, recursively apply DFS</p>
                        <p>3. Backtrack when no unvisited neighbors remain</p>
                    </div>
                    <p><strong>Complexity:</strong></p>
                    <ul>
                        <li><strong>Time:</strong> O(V + E) where V = vertices, E = edges</li>
                        <li><strong>Space:</strong> O(V) for the recursion stack or explicit stack</li>
                    </ul>
                    <p>
                        <strong>Characteristics:</strong> DFS does <em>not</em> guarantee finding the shortest path.
                        It explores deeply before exploring broadly, making it memory efficient but potentially slow
                        if the goal is down a wrong branch. Useful for maze generation, detecting cycles, and topological sorting.
                    </p>
                    <p>
                        <strong>Applications:</strong> Solving puzzles, detecting connected components, generating mazes,
                        topological sorting, and finding strongly connected components in directed graphs.
                    </p>
                </div>
                <div class="explanation-card">
                    <h3>üåä Breadth-First Search (BFS)</h3>
                    <p>
                        <strong>Strategy:</strong> BFS explores all vertices at distance <em>k</em> from the start
                        before exploring vertices at distance <em>k+1</em>. It uses a <strong>queue</strong> to
                        process vertices in the order they are discovered.
                    </p>
                    <div class="formula-box">
                        <p><strong>Algorithm:</strong></p>
                        <p>1. Enqueue the start vertex and mark it as visited</p>
                        <p>2. While queue is not empty:</p>
                        <p>¬†¬†¬†a. Dequeue a vertex v</p>
                        <p>¬†¬†¬†b. For each unvisited neighbor u of v:</p>
                        <p>¬†¬†¬†¬†¬†¬†- Mark u as visited</p>
                        <p>¬†¬†¬†¬†¬†¬†- Enqueue u</p>
                        <p>¬†¬†¬†¬†¬†¬†- Record parent for path reconstruction</p>
                    </div>
                    <p><strong>Complexity:</strong></p>
                    <ul>
                        <li><strong>Time:</strong> O(V + E)</li>
                        <li><strong>Space:</strong> O(V) for the queue</li>
                    </ul>
                    <p>
                        <strong>Characteristics:</strong> BFS <strong>guarantees finding the shortest path</strong>
                        in unweighted graphs. It explores layer by layer, ensuring all shorter paths are considered first.
                        More memory-intensive than DFS for deep graphs but optimal for shortest-path problems.
                    </p>
                    <p>
                        <strong>Applications:</strong> Finding shortest paths in unweighted graphs, web crawling,
                        social networking (degrees of separation), broadcasting in networks, and GPS navigation in uniform cost scenarios.
                    </p>
                </div>
                <div class="explanation-card">
                    <h3>üéØ Dijkstra's Algorithm</h3>
                    <p>
                        <strong>Strategy:</strong> Dijkstra's algorithm finds the shortest path in <strong>weighted graphs</strong>
                        where edge weights are non-negative. It maintains a priority queue of vertices ordered by their
                        tentative distance from the start.
                    </p>
                    <div class="formula-box">
                        <p><strong>Algorithm:</strong></p>
                        <p>1. Initialize distance to start as 0, all others as ‚àû</p>
                        <p>2. Add all vertices to a priority queue (min-heap)</p>
                        <p>3. While queue is not empty:</p>
                        <p>¬†¬†¬†a. Extract vertex u with minimum distance</p>
                        <p>¬†¬†¬†b. For each neighbor v of u:</p>
                        <p>¬†¬†¬†¬†¬†¬†- Calculate: alt = dist[u] + weight(u, v)</p>
                        <p>¬†¬†¬†¬†¬†¬†- If alt &lt; dist[v]: update dist[v] = alt</p>
                    </div>
                    <p><strong>Mathematical Formulation:</strong></p>
                    <div class="formula-box">
                        <p><strong>dist[v] = min(dist[v], dist[u] + w(u,v))</strong></p>
                        <p>where w(u,v) is the weight of edge from u to v</p>
                    </div>
                    <p><strong>Complexity:</strong></p>
                    <ul>
                        <li><strong>Time:</strong> O((V + E) log V) with binary heap, O(V¬≤) with array</li>
                        <li><strong>Space:</strong> O(V)</li>
                    </ul>
                    <p>
                        <strong>Characteristics:</strong> Dijkstra's algorithm <strong>guarantees finding the shortest path</strong>
                        in weighted graphs with non-negative edge weights. It's a greedy algorithm that always expands
                        the most promising vertex (lowest distance so far).
                    </p>
                    <p>
                        <strong>Applications:</strong> GPS and map routing, network routing protocols (OSPF),
                        robot path planning, airline flight routing, and any scenario requiring optimal paths with varying costs.
                    </p>
                    <p>
                        <strong>Limitation:</strong> Cannot handle negative edge weights. For graphs with negative weights
                        (but no negative cycles), use the Bellman-Ford algorithm instead.
                    </p>
                </div>
                <div class="explanation-card">
                    <h3>‚≠ê A* (A-Star) Algorithm</h3>
                    <p>
                        <strong>Strategy:</strong> A* is an <strong>informed search algorithm</strong> that uses a heuristic
                        function to guide its search toward the goal more efficiently than Dijkstra's. It combines the
                        actual cost from the start with an estimated cost to the goal.
                    </p>
                    <div class="formula-box">
                        <p><strong>Core Formula:</strong></p>
                        <p><strong>f(n) = g(n) + h(n)</strong></p>
                        <p>where:</p>
                        <p>‚Ä¢ <strong>g(n)</strong> = actual cost from start to node n</p>
                        <p>‚Ä¢ <strong>h(n)</strong> = heuristic estimate of cost from n to goal</p>
                        <p>‚Ä¢ <strong>f(n)</strong> = estimated total cost of path through n</p>
                    </div>
                    <p><strong>Common Heuristics:</strong></p>
                    <ul>
                        <li><strong>Manhattan Distance:</strong> |x‚ÇÅ - x‚ÇÇ| + |y‚ÇÅ - y‚ÇÇ| (for grid with 4-directional movement)</li>
                        <li><strong>Euclidean Distance:</strong> ‚àö[(x‚ÇÅ - x‚ÇÇ)¬≤ + (y‚ÇÅ - y‚ÇÇ)¬≤] (straight-line distance)</li>
                        <li><strong>Chebyshev Distance:</strong> max(|x‚ÇÅ - x‚ÇÇ|, |y‚ÇÅ - y‚ÇÇ|) (for grid with 8-directional movement)</li>
                    </ul>
                    <p><strong>Algorithm:</strong></p>
                    <div class="formula-box">
                        <p>1. Initialize open set with start node (f = h(start))</p>
                        <p>2. While open set is not empty:</p>
                        <p>¬†¬†¬†a. Select node n with lowest f(n)</p>
                        <p>¬†¬†¬†b. If n is goal, reconstruct and return path</p>
                        <p>¬†¬†¬†c. Move n to closed set</p>
                        <p>¬†¬†¬†d. For each neighbor m of n:</p>
                        <p>¬†¬†¬†¬†¬†¬†- If m in closed set, skip</p>
                        <p>¬†¬†¬†¬†¬†¬†- Calculate tentative g(m) = g(n) + cost(n,m)</p>
                        <p>¬†¬†¬†¬†¬†¬†- If m not in open set or tentative g(m) &lt; g(m):</p>
                        <p>¬†¬†¬†¬†¬†¬†¬†¬†Update g(m), f(m) = g(m) + h(m), add to open set</p>
                    </div>
                    <p><strong>Complexity:</strong></p>
                    <ul>
                        <li><strong>Time:</strong> O(b^d) in worst case, but typically much better with good heuristic</li>
                        <li><strong>Space:</strong> O(b^d) where b is branching factor, d is solution depth</li>
                    </ul>
                    <p>
                        <strong>Optimality Guarantee:</strong> A* is guaranteed to find the optimal path if the heuristic
                        is <strong>admissible</strong> (never overestimates the actual cost) and <strong>consistent</strong>
                        (satisfies the triangle inequality: h(n) ‚â§ cost(n,m) + h(m)).
                    </p>
                    <p>
                        <strong>Characteristics:</strong> A* combines the best of Dijkstra's (optimality) and greedy
                        best-first search (speed). The quality of the heuristic directly impacts performance‚Äîbetter
                        heuristics lead to fewer explored nodes.
                    </p>
                    <p>
                        <strong>Applications:</strong> Video game pathfinding, robotics, puzzle solving (15-puzzle, Rubik's cube),
                        route planning with landmarks, and any scenario where you can estimate distance to goal.
                    </p>
                </div>
                <div class="explanation-card">
                    <h3>üìä Algorithm Comparison</h3>
                    <div class="comparison-table">
                        <table style="width: 100%; border-collapse: collapse; margin-top: 1rem;">
                            <thead>
                                <tr style="background: var(--card-background); border-bottom: 2px solid var(--border-color);">
                                    <th style="padding: 0.75rem; text-align: left;">Algorithm</th>
                                    <th style="padding: 0.75rem; text-align: center;">Completeness</th>
                                    <th style="padding: 0.75rem; text-align: center;">Optimality</th>
                                    <th style="padding: 0.75rem; text-align: center;">Time Complexity</th>
                                    <th style="padding: 0.75rem; text-align: center;">Space Complexity</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr style="border-bottom: 1px solid var(--border-color);">
                                    <td style="padding: 0.75rem;"><strong>DFS</strong></td>
                                    <td style="padding: 0.75rem; text-align: center;">Yes*</td>
                                    <td style="padding: 0.75rem; text-align: center;">No</td>
                                    <td style="padding: 0.75rem; text-align: center;">O(V + E)</td>
                                    <td style="padding: 0.75rem; text-align: center;">O(V)</td>
                                </tr>
                                <tr style="border-bottom: 1px solid var(--border-color);">
                                    <td style="padding: 0.75rem;"><strong>BFS</strong></td>
                                    <td style="padding: 0.75rem; text-align: center;">Yes</td>
                                    <td style="padding: 0.75rem; text-align: center;">Yes**</td>
                                    <td style="padding: 0.75rem; text-align: center;">O(V + E)</td>
                                    <td style="padding: 0.75rem; text-align: center;">O(V)</td>
                                </tr>
                                <tr style="border-bottom: 1px solid var(--border-color);">
                                    <td style="padding: 0.75rem;"><strong>Dijkstra</strong></td>
                                    <td style="padding: 0.75rem; text-align: center;">Yes</td>
                                    <td style="padding: 0.75rem; text-align: center;">Yes</td>
                                    <td style="padding: 0.75rem; text-align: center;">O((V+E) log V)</td>
                                    <td style="padding: 0.75rem; text-align: center;">O(V)</td>
                                </tr>
                                <tr style="border-bottom: 1px solid var(--border-color);">
                                    <td style="padding: 0.75rem;"><strong>A*</strong></td>
                                    <td style="padding: 0.75rem; text-align: center;">Yes</td>
                                    <td style="padding: 0.75rem; text-align: center;">Yes***</td>
                                    <td style="padding: 0.75rem; text-align: center;">O(b^d)</td>
                                    <td style="padding: 0.75rem; text-align: center;">O(b^d)</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    <p style="margin-top: 1rem; font-size: 0.9rem;">
                        <strong>Notes:</strong><br />
                        * DFS is complete in finite graphs<br />
                        ** BFS finds optimal solution in unweighted graphs<br />
                        *** A* finds optimal solution with admissible heuristic
                    </p>
                </div>
                <div class="explanation-card">
                    <h3>üéì When to Use Each Algorithm</h3>
                    <div class="algorithm-usage">
                        <div class="usage-item">
                            <h4>Use DFS when:</h4>
                            <ul>
                                <li>You want a memory-efficient solution</li>
                                <li>Finding any solution is sufficient (not necessarily shortest)</li>
                                <li>Exploring deep branches first makes sense for your problem</li>
                                <li>Detecting cycles or connectivity is the goal</li>
                            </ul>
                        </div>
                        <div class="usage-item">
                            <h4>Use BFS when:</h4>
                            <ul>
                                <li>You need the shortest path in an unweighted graph</li>
                                <li>Finding the closest solution is important</li>
                                <li>Level-by-level exploration makes sense</li>
                                <li>Broadcasting or propagation problems</li>
                            </ul>
                        </div>
                        <div class="usage-item">
                            <h4>Use Dijkstra when:</h4>
                            <ul>
                                <li>You have a weighted graph with non-negative weights</li>
                                <li>You need the optimal path considering edge costs</li>
                                <li>No heuristic information is available</li>
                                <li>Finding shortest paths from one source to all vertices</li>
                            </ul>
                        </div>
                        <div class="usage-item">
                            <h4>Use A* when:</h4>
                            <ul>
                                <li>You have weighted edges and a good heuristic function</li>
                                <li>Performance is critical and you can estimate goal distance</li>
                                <li>Finding the optimal path efficiently is required</li>
                                <li>Working with spatial problems (grids, maps)</li>
                            </ul>
                        </div>
                    </div>
                </div>
                <div class="explanation-card">
                    <h3>üåü Real-World Applications</h3>
                    <p>Graph algorithms power many technologies we use daily:</p>
                    <ul>
                        <li><strong>GPS Navigation:</strong> A* and Dijkstra's algorithms find optimal routes considering
                            distance, time, traffic, and road types. Modern systems use contraction hierarchies and
                            other optimizations for faster computation.</li>
                        <li><strong>Social Networks:</strong> BFS finds connections and degrees of separation.
                            DFS helps detect communities and influencers.</li>
                        <li><strong>Game AI:</strong> A* powers enemy pathfinding in video games, making NPCs navigate
                            complex environments realistically.</li>
                        <li><strong>Network Routing:</strong> Internet routers use variants of Dijkstra's algorithm
                            (like OSPF) to find optimal packet routes.</li>
                        <li><strong>Recommendation Systems:</strong> Graph algorithms analyze user-item relationships
                            to suggest products, movies, or connections.</li>
                        <li><strong>Robotics:</strong> Path planning algorithms help robots navigate physical spaces
                            while avoiding obstacles.</li>
                        <li><strong>Puzzle Solvers:</strong> A* and BFS solve puzzles like sliding tiles, Sudoku,
                            and maze problems.</li>
                    </ul>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <div class="footer-columns">
            <div class="footer-column">
                <img alt="Adam Djellouli Symbol" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/symbol.png" />
            </div>
            <div class="footer-column">
                <h2><a href="https://adamdjellouli.com/core/privacy_policy.html" title="Privacy Policy">Our Privacy Policy</a></h2>
                <p>Thank you for visiting my personal website. All content here is free to use, but please remember to be respectful and avoid any misuse of the site. If you‚Äôd like to get in touch, feel free to reach out via my <a href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" title="LinkedIn Profile">LinkedIn profile</a> or connect with me on <a href="https://github.com/djeada" title="GitHub Profile">GitHub</a> if you have technical questions or ideas to share. Wishing you all the best and a fantastic life ahead!</p>
            </div>
            <div class="footer-column">
                <h2>Follow me</h2>
                <ul class="social-media">
                    <li>
                        <a class="fa fa-youtube" href="https://www.youtube.com/channel/UCGPoHTVjMN77wcGknXPHl1Q" target="_blank" title="YouTube">
                        </a>YouTube
                    </li>
                    <li>
                        <a class="fa fa-linkedin" href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" target="_blank" title="LinkedIn">
                        </a>LinkedIn
                    </li>
                    <li>
                        <a class="fa fa-instagram" href="https://www.instagram.com/linuxchallenges/" target="_blank" title="Instagram">
                        </a>Instagram
                    </li>
                    <li>
                        <a class="fa fa-github" href="https://github.com/djeada" title="GitHub">
                        </a>Github
                    </li>
                </ul>
            </div>
        </div>
        <div>
            <p id="copyright">
                ¬© Adam Djellouli. All rights reserved.
            </p>
        </div>
        <script>
            document.getElementById("copyright").innerHTML = "&copy; " + new Date().getFullYear() + " Adam Djellouli. All rights reserved.";
        </script>
        <script src="../../app.js"></script>
    </footer>
</body>
<script src="app.js"></script>

</html>