<!DOCTYPE html>

<html lang="en">

<head>
    <script async="" crossorigin="anonymous" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5593122079896089"></script>
    <title>Search Algorithm Visualization</title>
    <meta charset="utf-8" />
    <meta content="Interactive visualization of search algorithms. Explore Linear, Binary, Jump, and Interpolation search on sorted arrays." name="description" />
    <meta content="search algorithms, visualization, linear search, binary search, jump search, interpolation search, Adam Djellouli" name="keywords" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/icon.ico" rel="icon" />
    <link href="../../resources/style.css" rel="stylesheet" type="text/css" />
    <link href="style.css" rel="stylesheet" type="text/css" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />
    <link href="https://fonts.googleapis.com" rel="preconnect" />
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <meta content="ie-edge" http-equiv="X-UA-Compatible" />
</head>

<body>
    <nav aria-label="Main navigation">
        <a class="logo" href="../../index.html">
            <img alt="Adam Djellouli - Home Page Logo" id="logo-image" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/logo.PNG" />
        </a>
        <input aria-label="Toggle navigation menu" id="navbar-toggle" type="checkbox" />
        <ul aria-labelledby="navbar-toggle" role="menu">
            <li role="menuitem">
                <a href="../../index.html" title="Go to Home Page"> Home </a>
            </li>
            <li role="menuitem">
                <a href="../../core/blog.html" title="Read Adam Djellouli Blog on Programming and Technology"> Blog </a>
            </li>
            <li role="menuitem">
                <a href="../../core/tools.html" title="Discover Tools Created by Adam Djellouli"> Tools </a>
            </li>
            <li role="menuitem">
                <a href="../../core/projects.html" title="Explore Projects Developed by Adam Djellouli"> Projects </a>
            </li>
            <li role="menuitem">
                <a href="../../core/courses.html" title="Browse Courses by Adam Djellouli"> Courses </a>
            </li>
            <li role="menuitem">
                <a href="../../core/resume.html" title="View Adam Djellouli Professional Resume"> Resume </a>
            </li>
            <li>
                <script async="" src="https://cse.google.com/cse.js?cx=8160ef9bb935f4f68"></script>
                <div class="gcse-search"></div>
            </li>
            <li>
                <button aria-label="Toggle dark mode" id="dark-mode-button"></button>
            </li>
        </ul>
    </nav>
    <div aria-live="polite" class="toast-container" id="toast-container"></div>
    <main class="tool-main">
        <!-- Hero Header -->
        <header class="tool-header">
            <div class="header-content">
                <div class="header-icon">
                    <span class="icon-sparkle">ğŸ”</span>
                </div>
                <h1>Search Algorithm Visualization</h1>
                <p class="subtitle">Explore search algorithms with interactive array visualization</p>
                <div class="keyboard-hint">
                    Watch elements being checked â€¢ <kbd>Space</kbd> to start/pause
                </div>
            </div>
        </header>
        <!-- Stats Bar -->
        <div class="stats-bar">
            <div class="stat-item">
                <span class="stat-icon">ğŸ“Š</span>
                <span class="stat-value" id="comparisons-count">0</span>
                <span class="stat-label">Comparisons</span>
            </div>
            <div class="stat-item">
                <span class="stat-icon">ğŸ¯</span>
                <span class="stat-value" id="target-value">-</span>
                <span class="stat-label">Target</span>
            </div>
            <div class="stat-item">
                <span class="stat-icon">â±ï¸</span>
                <span class="stat-value" id="elapsed-time">0ms</span>
                <span class="stat-label">Time</span>
            </div>
            <div class="stat-item">
                <span class="stat-icon">ğŸ”</span>
                <span class="stat-value" id="algorithm-name">Linear</span>
                <span class="stat-label">Algorithm</span>
            </div>
        </div>
        <section class="tool-content">
            <!-- Sidebar Options -->
            <aside class="options-sidebar">
                <div class="sidebar-header">
                    <h2><span class="icon">âš™ï¸</span> Settings</h2>
                    <button class="preset-btn" id="reset-defaults" title="Reset to defaults">
                        <span>â†º</span>
                    </button>
                </div>
                <!-- Algorithm Selection -->
                <div class="option-card preset-card">
                    <h3><span class="card-icon">ğŸ§®</span> Algorithm</h3>
                    <div class="input-group">
                        <select id="algorithm">
                            <option value="linear">Linear Search</option>
                            <option value="binary">Binary Search</option>
                            <option value="jump">Jump Search</option>
                            <option value="interpolation">Interpolation Search</option>
                        </select>
                    </div>
                </div>
                <!-- Array Options -->
                <div class="option-card">
                    <button aria-expanded="true" class="card-toggle">
                        <h3><span class="card-icon">ğŸ“</span> Array</h3>
                        <span class="toggle-icon">â–¼</span>
                    </button>
                    <div class="card-content">
                        <div class="input-group">
                            <label for="array-size">Array Size</label>
                            <input id="array-size" max="100" min="10" type="number" value="50" />
                        </div>
                        <div class="input-group">
                            <label for="search-target">Search Target</label>
                            <input id="search-target" max="1000" min="1" placeholder="Random if empty" type="number" />
                        </div>
                    </div>
                </div>
                <!-- Visualization Options -->
                <div class="option-card">
                    <button aria-expanded="true" class="card-toggle">
                        <h3><span class="card-icon">ğŸ¨</span> Visualization</h3>
                        <span class="toggle-icon">â–¼</span>
                    </button>
                    <div class="card-content">
                        <div class="input-group">
                            <label for="speed">Animation Speed</label>
                            <input id="speed" max="10" min="1" type="range" value="5" />
                        </div>
                    </div>
                </div>
                <!-- Controls Info -->
                <div class="option-card">
                    <h3><span class="card-icon">â„¹ï¸</span> Controls</h3>
                    <div class="card-content">
                        <p style="font-size: 0.85rem; color: var(--text-secondary); margin: 0; line-height: 1.6;">
                            â€¢ Array is sorted automatically<br />
                            â€¢ Red bar = current element<br />
                            â€¢ Green bar = found target<br />
                            â€¢ Gray = not found
                        </p>
                    </div>
                </div>
            </aside>
            <!-- Main Canvas Area -->
            <div class="canvas-area">
                <!-- Canvas Container -->
                <div class="canvas-container">
                    <div class="canvas-header">
                        <span class="canvas-title">ğŸ“Š Search Visualization</span>
                    </div>
                    <div class="canvas-wrapper">
                        <canvas id="searching-canvas"></canvas>
                    </div>
                </div>
                <!-- Action Buttons -->
                <div class="action-bar">
                    <div class="primary-actions">
                        <button class="action-btn primary large" id="start">
                            <span class="btn-icon">â–¶ï¸</span>
                            <span class="btn-text">Start Search</span>
                        </button>
                    </div>
                    <div class="secondary-actions">
                        <button class="action-btn warning" id="pause" title="Pause/Resume">
                            <span class="btn-icon">â¸ï¸</span> Pause
                        </button>
                        <button class="action-btn" id="step" title="Step through one iteration">
                            <span class="btn-icon">â­ï¸</span> Step
                        </button>
                        <button class="action-btn danger" id="reset" title="Reset the array">
                            <span class="btn-icon">ğŸ”„</span> Reset
                        </button>
                    </div>
                </div>
                <!-- Legend Panel -->
                <div class="legend-panel">
                    <div class="legend-header">
                        <h3><span>ğŸ¨</span> Legend</h3>
                    </div>
                    <div class="legend-content">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #eec747;"></div>
                            <span class="legend-label">Array Element</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #ef4444;"></div>
                            <span class="legend-label">Current Check</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #10b981;"></div>
                            <span class="legend-label">Found</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #9ca3af;"></div>
                            <span class="legend-label">Not Found</span>
                        </div>
                    </div>
                </div>
            </div>
        </section>
        <!-- Help Box -->
        <div class="help-box">
            <strong>Need Help?</strong>
            <ul>
                <li>Select a search algorithm from the sidebar dropdown.</li>
                <li>Adjust array size to change the number of elements.</li>
                <li>Enter a target value or leave empty for random selection.</li>
                <li>Click "Start Search" to visualize the algorithm.</li>
                <li>Use "Step" to advance one comparison at a time.</li>
                <li>The stats bar shows real-time metrics during search.</li>
            </ul>
        </div>
        <!-- Algorithm Background Section -->
        <section class="explanation-section">
            <div class="section-header">
                <h2>ğŸ“š Search Algorithm Background</h2>
            </div>
            <div class="explanation-content">
                <div class="explanation-card">
                    <h3>ğŸ” What is Searching?</h3>
                    <p>
                        Searching is the process of finding a specific element (target) within a collection of data.
                        It's one of the most fundamental operations in computer science, used in countless applications
                        from finding contacts in your phone to querying databases with billions of records.
                    </p>
                    <p>
                        The efficiency of a search algorithm can dramatically impact application performance. Different
                        algorithms have different requirements and trade-offs. Some work on any data, while others
                        require the data to be sorted. Understanding these differences helps you choose the optimal
                        algorithm for your specific use case.
                    </p>
                </div>
                <div class="explanation-card">
                    <h3>ğŸ“ Linear Search (Sequential Search)</h3>
                    <p>
                        <strong>Strategy:</strong> Linear Search is the simplest search algorithm. It checks every
                        element in the array sequentially from start to end until it finds the target or reaches the end.
                    </p>
                    <div class="formula-box">
                        <p><strong>Algorithm:</strong></p>
                        <p>1. For i = 0 to n-1:</p>
                        <p>Â Â Â If arr[i] == target:</p>
                        <p>Â Â Â Â Â Â Return i (found at index i)</p>
                        <p>2. Return -1 (not found)</p>
                    </div>
                    <p><strong>Complexity:</strong></p>
                    <ul>
                        <li><strong>Best Case:</strong> O(1) - target is at first position</li>
                        <li><strong>Average Case:</strong> O(n) - target is in middle on average</li>
                        <li><strong>Worst Case:</strong> O(n) - target is at end or not present</li>
                        <li><strong>Space:</strong> O(1) - no extra space needed</li>
                    </ul>
                    <p><strong>Mathematical Analysis:</strong></p>
                    <div class="formula-box">
                        <p>Average comparisons when element exists:</p>
                        <p><strong>(1 + 2 + 3 + ... + n) / n = (n + 1) / 2 â‰ˆ n/2</strong></p>
                        <p>This is still O(n) in Big-O notation</p>
                    </div>
                    <p>
                        <strong>Characteristics:</strong> Works on unsorted and sorted arrays. Simple to implement.
                        No preprocessing required. Inefficient for large datasets but optimal for small arrays or
                        single searches on unsorted data.
                    </p>
                    <p>
                        <strong>When to use:</strong> Small datasets (n &lt; 100), unsorted data, single or infrequent
                        searches, or when simplicity is more important than performance.
                    </p>
                </div>
                <div class="explanation-card">
                    <h3>âœ‚ï¸ Binary Search</h3>
                    <p>
                        <strong>Strategy:</strong> Binary Search is a divide-and-conquer algorithm that works on
                        <strong>sorted arrays</strong>. It repeatedly divides the search interval in half by comparing
                        the target with the middle element.
                    </p>
                    <div class="formula-box">
                        <p><strong>Algorithm:</strong></p>
                        <p>1. Set left = 0, right = n - 1</p>
                        <p>2. While left â‰¤ right:</p>
                        <p>Â Â Â mid = left + (right - left) / 2</p>
                        <p>Â Â Â If arr[mid] == target:</p>
                        <p>Â Â Â Â Â Â Return mid (found)</p>
                        <p>Â Â Â If arr[mid] &lt; target:</p>
                        <p>Â Â Â Â Â Â left = mid + 1 (search right half)</p>
                        <p>Â Â Â Else:</p>
                        <p>Â Â Â Â Â Â right = mid - 1 (search left half)</p>
                        <p>3. Return -1 (not found)</p>
                    </div>
                    <p><strong>Why mid = left + (right - left) / 2?</strong></p>
                    <p>
                        This formula avoids integer overflow that could occur with (left + right) / 2 when
                        left and right are large values. It's mathematically equivalent but safer.
                    </p>
                    <p><strong>Complexity:</strong></p>
                    <ul>
                        <li><strong>Best Case:</strong> O(1) - target is at middle</li>
                        <li><strong>Average Case:</strong> O(log n)</li>
                        <li><strong>Worst Case:</strong> O(log n) - target is at end or not present</li>
                        <li><strong>Space:</strong> O(1) iterative, O(log n) recursive (call stack)</li>
                    </ul>
                    <p><strong>Mathematical Analysis:</strong></p>
                    <div class="formula-box">
                        <p>After each comparison, search space is halved:</p>
                        <p>n â†’ n/2 â†’ n/4 â†’ n/8 â†’ ... â†’ 1</p>
                        <p>Number of steps: k where n / 2^k = 1</p>
                        <p>Solving: <strong>k = logâ‚‚(n)</strong></p>
                        <p>Therefore, time complexity is <strong>O(log n)</strong></p>
                    </div>
                    <p>
                        <strong>Characteristics:</strong> <strong>Requires sorted array</strong> - this is crucial!
                        Extremely efficient for large datasets. Much faster than linear search for repeated queries.
                        The basis for many advanced data structures (binary search trees, B-trees).
                    </p>
                    <p>
                        <strong>When to use:</strong> Sorted data, large datasets, multiple searches on same data,
                        or when O(log n) performance is critical. If data isn't sorted, consider if the cost of
                        sorting (O(n log n)) is worth it for multiple searches.
                    </p>
                </div>
                <div class="explanation-card">
                    <h3>ğŸ¦˜ Jump Search</h3>
                    <p>
                        <strong>Strategy:</strong> Jump Search is a searching algorithm for <strong>sorted arrays</strong>
                        that works by jumping ahead by fixed steps and then performing a linear search in the identified block.
                    </p>
                    <div class="formula-box">
                        <p><strong>Algorithm:</strong></p>
                        <p>1. Set jump = âˆšn (optimal step size)</p>
                        <p>2. prev = 0</p>
                        <p>3. While arr[min(jump, n) - 1] &lt; target:</p>
                        <p>Â Â Â prev = jump</p>
                        <p>Â Â Â jump += âˆšn</p>
                        <p>Â Â Â If prev â‰¥ n: return -1 (not found)</p>
                        <p>4. Linear search in block [prev, min(jump, n)]:</p>
                        <p>Â Â Â For i = prev to min(jump, n) - 1:</p>
                        <p>Â Â Â Â Â Â If arr[i] == target: return i</p>
                        <p>5. Return -1 (not found)</p>
                    </div>
                    <p><strong>Why âˆšn as step size?</strong></p>
                    <div class="formula-box">
                        <p>The optimal step size minimizes comparisons:</p>
                        <p>Jumps needed: n/m (where m is step size)</p>
                        <p>Linear search in block: m - 1</p>
                        <p>Total: n/m + m - 1</p>
                        <p>Taking derivative and setting to 0: m = âˆšn</p>
                        <p>This gives optimal time complexity: <strong>O(âˆšn)</strong></p>
                    </div>
                    <p><strong>Complexity:</strong></p>
                    <ul>
                        <li><strong>Best Case:</strong> O(1) - target at a jump position</li>
                        <li><strong>Average Case:</strong> O(âˆšn)</li>
                        <li><strong>Worst Case:</strong> O(âˆšn)</li>
                        <li><strong>Space:</strong> O(1)</li>
                    </ul>
                    <p>
                        <strong>Characteristics:</strong> Requires sorted array. Better than linear search but slower
                        than binary search. However, it's advantageous when jumping back is costly (like in systems
                        where backward movement in memory is expensive). Only jumps forward, making it cache-friendly.
                    </p>
                    <p>
                        <strong>When to use:</strong> Sorted data where backward movement is expensive, systems with
                        sequential access patterns, or when you want better performance than linear search without
                        the complexity of binary search.
                    </p>
                </div>
                <div class="explanation-card">
                    <h3>ğŸ“ Interpolation Search</h3>
                    <p>
                        <strong>Strategy:</strong> Interpolation Search is an improved variant of binary search for
                        <strong>sorted arrays with uniformly distributed values</strong>. Instead of always checking
                        the middle, it estimates where the target should be based on its value.
                    </p>
                    <div class="formula-box">
                        <p><strong>Position Estimation Formula:</strong></p>
                        <p><strong>pos = low + [(target - arr[low]) Ã— (high - low)] / (arr[high] - arr[low])</strong></p>
                        <p>This formula interpolates the probable position based on value distribution</p>
                    </div>
                    <div class="formula-box">
                        <p><strong>Algorithm:</strong></p>
                        <p>1. Set low = 0, high = n - 1</p>
                        <p>2. While low â‰¤ high and target in [arr[low], arr[high]]:</p>
                        <p>Â Â Â If low == high:</p>
                        <p>Â Â Â Â Â Â If arr[low] == target: return low</p>
                        <p>Â Â Â Â Â Â Return -1</p>
                        <p>Â Â Â pos = low + [(target - arr[low]) Ã— (high - low)] / (arr[high] - arr[low])</p>
                        <p>Â Â Â If arr[pos] == target:</p>
                        <p>Â Â Â Â Â Â Return pos (found)</p>
                        <p>Â Â Â If arr[pos] &lt; target:</p>
                        <p>Â Â Â Â Â Â low = pos + 1 (search right)</p>
                        <p>Â Â Â Else:</p>
                        <p>Â Â Â Â Â Â high = pos - 1 (search left)</p>
                        <p>3. Return -1 (not found)</p>
                    </div>
                    <p><strong>Intuitive Example:</strong></p>
                    <p>
                        Imagine searching for "Smith" in a phone book. You wouldn't open it in the middle (like binary search).
                        You'd estimate that "Smith" starts with 'S', which is about 75% through the alphabet, so you'd
                        open the book about 75% of the way through. That's interpolation search!
                    </p>
                    <p><strong>Complexity:</strong></p>
                    <ul>
                        <li><strong>Best Case:</strong> O(1) - target found on first try</li>
                        <li><strong>Average Case:</strong> O(log log n) - with uniformly distributed data</li>
                        <li><strong>Worst Case:</strong> O(n) - with non-uniform distribution</li>
                        <li><strong>Space:</strong> O(1)</li>
                    </ul>
                    <p><strong>Mathematical Insight:</strong></p>
                    <div class="formula-box">
                        <p>With uniform distribution, each probe divides search space by factor of log n</p>
                        <p>n â†’ n/log n â†’ n/(log n)Â² â†’ ...</p>
                        <p>This gives <strong>O(log log n)</strong> complexity</p>
                        <p>Example: For n = 1,000,000:</p>
                        <p>â€¢ Binary search: logâ‚‚(1,000,000) â‰ˆ 20 comparisons</p>
                        <p>â€¢ Interpolation: logâ‚‚(logâ‚‚(1,000,000)) â‰ˆ 4-5 comparisons</p>
                    </div>
                    <p>
                        <strong>Characteristics:</strong> Requires sorted array with uniformly distributed values.
                        Can be much faster than binary search for appropriate data. Poor performance on non-uniform
                        distributions. Sensitive to data distribution.
                    </p>
                    <p>
                        <strong>When to use:</strong> Large sorted datasets with uniformly distributed values
                        (numerical data, timestamps, IDs), when you need even better performance than binary search,
                        or when you can estimate target position from its value.
                    </p>
                    <p>
                        <strong>Warning:</strong> Avoid for non-uniform distributions or when arr[high] == arr[low]
                        (division by zero). Always validate input data distribution.
                    </p>
                </div>
                <div class="explanation-card">
                    <h3>ğŸ“Š Algorithm Comparison</h3>
                    <div class="comparison-table">
                        <table style="width: 100%; border-collapse: collapse; margin-top: 1rem;">
                            <thead>
                                <tr style="background: var(--card-background); border-bottom: 2px solid var(--border-color);">
                                    <th style="padding: 0.75rem; text-align: left;">Algorithm</th>
                                    <th style="padding: 0.75rem; text-align: center;">Sorted?</th>
                                    <th style="padding: 0.75rem; text-align: center;">Best</th>
                                    <th style="padding: 0.75rem; text-align: center;">Average</th>
                                    <th style="padding: 0.75rem; text-align: center;">Worst</th>
                                    <th style="padding: 0.75rem; text-align: center;">Space</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr style="border-bottom: 1px solid var(--border-color);">
                                    <td style="padding: 0.75rem;"><strong>Linear</strong></td>
                                    <td style="padding: 0.75rem; text-align: center;">No</td>
                                    <td style="padding: 0.75rem; text-align: center;">O(1)</td>
                                    <td style="padding: 0.75rem; text-align: center;">O(n)</td>
                                    <td style="padding: 0.75rem; text-align: center;">O(n)</td>
                                    <td style="padding: 0.75rem; text-align: center;">O(1)</td>
                                </tr>
                                <tr style="border-bottom: 1px solid var(--border-color);">
                                    <td style="padding: 0.75rem;"><strong>Binary</strong></td>
                                    <td style="padding: 0.75rem; text-align: center;">Yes</td>
                                    <td style="padding: 0.75rem; text-align: center;">O(1)</td>
                                    <td style="padding: 0.75rem; text-align: center;">O(log n)</td>
                                    <td style="padding: 0.75rem; text-align: center;">O(log n)</td>
                                    <td style="padding: 0.75rem; text-align: center;">O(1)</td>
                                </tr>
                                <tr style="border-bottom: 1px solid var(--border-color);">
                                    <td style="padding: 0.75rem;"><strong>Jump</strong></td>
                                    <td style="padding: 0.75rem; text-align: center;">Yes</td>
                                    <td style="padding: 0.75rem; text-align: center;">O(1)</td>
                                    <td style="padding: 0.75rem; text-align: center;">O(âˆšn)</td>
                                    <td style="padding: 0.75rem; text-align: center;">O(âˆšn)</td>
                                    <td style="padding: 0.75rem; text-align: center;">O(1)</td>
                                </tr>
                                <tr style="border-bottom: 1px solid var(--border-color);">
                                    <td style="padding: 0.75rem;"><strong>Interpolation</strong></td>
                                    <td style="padding: 0.75rem; text-align: center;">Yes*</td>
                                    <td style="padding: 0.75rem; text-align: center;">O(1)</td>
                                    <td style="padding: 0.75rem; text-align: center;">O(log log n)</td>
                                    <td style="padding: 0.75rem; text-align: center;">O(n)</td>
                                    <td style="padding: 0.75rem; text-align: center;">O(1)</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    <p style="margin-top: 1rem; font-size: 0.9rem;">
                        <strong>Note:</strong> * Interpolation Search requires sorted data with uniform distribution
                        for optimal performance
                    </p>
                </div>
                <div class="explanation-card">
                    <h3>ğŸ¯ Choosing the Right Algorithm</h3>
                    <div class="algorithm-usage">
                        <div class="usage-item">
                            <h4>Use Linear Search when:</h4>
                            <ul>
                                <li>Data is unsorted and small (n &lt; 100)</li>
                                <li>Performing a single or infrequent search</li>
                                <li>Cost of sorting exceeds benefit</li>
                                <li>Simplicity is prioritized over performance</li>
                                <li>Data structure doesn't support random access (linked lists)</li>
                            </ul>
                        </div>
                        <div class="usage-item">
                            <h4>Use Binary Search when:</h4>
                            <ul>
                                <li>Data is sorted (or cost of sorting is justified)</li>
                                <li>Performing multiple searches on same dataset</li>
                                <li>Need consistent O(log n) performance</li>
                                <li>Working with large datasets (n &gt; 1000)</li>
                                <li>General-purpose sorted searching (most common choice)</li>
                            </ul>
                        </div>
                        <div class="usage-item">
                            <h4>Use Jump Search when:</h4>
                            <ul>
                                <li>Backward traversal is expensive</li>
                                <li>Cache-friendly access patterns matter</li>
                                <li>Want simpler implementation than binary search</li>
                                <li>Data is stored in sequential-access medium</li>
                                <li>Need better than O(n) but O(log n) is overkill</li>
                            </ul>
                        </div>
                        <div class="usage-item">
                            <h4>Use Interpolation Search when:</h4>
                            <ul>
                                <li>Data is sorted AND uniformly distributed</li>
                                <li>Working with numerical data (IDs, timestamps)</li>
                                <li>Dataset is very large (millions of elements)</li>
                                <li>Can guarantee value distribution</li>
                                <li>Need best possible average-case performance</li>
                            </ul>
                        </div>
                    </div>
                    <p style="margin-top: 1rem;">
                        <strong>Important consideration:</strong> If your data isn't sorted, you need to sort it first.
                        The cost of sorting is O(n log n). This is worthwhile if you're doing many searches (more than
                        about log n searches), but for a single search on unsorted data, linear search at O(n) is better.
                    </p>
                </div>
                <div class="explanation-card">
                    <h3>ğŸŒŸ Real-World Applications</h3>
                    <p>Search algorithms are everywhere in computing:</p>
                    <ul>
                        <li><strong>Databases:</strong> Binary search underlies database indexing (B-trees, B+ trees)
                            for fast record retrieval. Database queries rely on efficient searching through millions
                            or billions of records.</li>
                        <li><strong>Dictionaries &amp; Spell Checkers:</strong> Binary search checks if words exist in
                            sorted dictionaries. Modern implementations use hash tables, but sorted dictionaries
                            still use binary search variants.</li>
                        <li><strong>File Systems:</strong> Finding files in directory structures, locating data
                            blocks on disk. File system indexes use advanced search structures.</li>
                        <li><strong>Machine Learning:</strong> Finding nearest neighbors, hyperparameter tuning with
                            grid search. Binary search determines optimal decision boundaries.</li>
                        <li><strong>Debugging:</strong> Binary search identifies which code commit introduced a bug
                            (git bisect). Also used to find boundary conditions in input space.</li>
                        <li><strong>Computer Graphics:</strong> Ray tracing uses binary search to find intersections.
                            Collision detection in games employs spatial searching.</li>
                        <li><strong>Network Protocols:</strong> Finding routing paths, searching cache entries.
                            DNS lookups use hierarchical searching.</li>
                        <li><strong>E-commerce:</strong> Product searches, filtering results. Autocomplete features
                            use prefix searching (trie-based, but conceptually similar).</li>
                        <li><strong>Scientific Computing:</strong> Root finding, numerical analysis. Binary search
                            finds solutions to equations.</li>
                    </ul>
                </div>
                <div class="explanation-card">
                    <h3>ğŸ”¬ Advanced Topics</h3>
                    <p><strong>Extensions and Variants:</strong></p>
                    <ul>
                        <li><strong>Exponential Search:</strong> Combines jumping and binary search. First finds range
                            with exponential jumps (1, 2, 4, 8, ...), then binary searches that range.
                            Useful for unbounded/infinite arrays.</li>
                        <li><strong>Fibonacci Search:</strong> Like binary search but divides array according to
                            Fibonacci numbers. Can be faster due to better cache locality (addition vs division).</li>
                        <li><strong>Ternary Search:</strong> Divides array into three parts instead of two.
                            Useful for finding maximum/minimum of unimodal functions.</li>
                        <li><strong>Hashing:</strong> Not comparison-based searching. Provides O(1) average search
                            time but requires extra space and good hash function.</li>
                        <li><strong>Trees:</strong> Binary Search Trees (BST), AVL trees, Red-Black trees provide
                            O(log n) search with dynamic insertions/deletions.</li>
                    </ul>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <div class="footer-columns">
            <div class="footer-column">
                <img alt="Adam Djellouli Symbol" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/symbol.png" />
            </div>
            <div class="footer-column">
                <h2><a href="https://adamdjellouli.com/core/privacy_policy.html" title="Privacy Policy">Our Privacy Policy</a></h2>
                <p>Thank you for visiting my personal website. All content here is free to use, but please remember to be respectful and avoid any misuse of the site. If youâ€™d like to get in touch, feel free to reach out via my <a href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" title="LinkedIn Profile">LinkedIn profile</a> or connect with me on <a href="https://github.com/djeada" title="GitHub Profile">GitHub</a> if you have technical questions or ideas to share. Wishing you all the best and a fantastic life ahead!</p>
            </div>
            <div class="footer-column">
                <h2>Follow me</h2>
                <ul class="social-media">
                    <li>
                        <a class="fa fa-youtube" href="https://www.youtube.com/channel/UCGPoHTVjMN77wcGknXPHl1Q" target="_blank" title="YouTube">
                        </a>YouTube
                    </li>
                    <li>
                        <a class="fa fa-linkedin" href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" target="_blank" title="LinkedIn">
                        </a>LinkedIn
                    </li>
                    <li>
                        <a class="fa fa-instagram" href="https://www.instagram.com/linuxchallenges/" target="_blank" title="Instagram">
                        </a>Instagram
                    </li>
                    <li>
                        <a class="fa fa-github" href="https://github.com/djeada" title="GitHub">
                        </a>Github
                    </li>
                </ul>
            </div>
        </div>
        <div>
            <p id="copyright">
                Â© Adam Djellouli. All rights reserved.
            </p>
        </div>
        <script>
            document.getElementById("copyright").innerHTML = "&copy; " + new Date().getFullYear() + " Adam Djellouli. All rights reserved.";
        </script>
        <script src="../../app.js"></script>
    </footer>
</body>
<script src="app.js"></script>

</html>