<!DOCTYPE html>

<html lang="en">

<head>
    <script async="" crossorigin="anonymous" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5593122079896089"></script>
    <title>Sorting Algorithm Visualization</title>
    <meta charset="utf-8" />
    <meta content="Interactive visualization of sorting algorithms. Explore Bubble, Selection, Insertion, Merge, Quick, Heap, and Radix sort." name="description" />
    <meta content="sorting algorithms, algorithm visualization, bubble sort, selection sort, insertion sort, merge sort, quick sort, heap sort, radix sort, Adam Djellouli" name="keywords" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/icon.ico" rel="icon" />
    <link href="../../resources/style.css" rel="stylesheet" type="text/css" />
    <link href="style.css" rel="stylesheet" type="text/css" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />
    <link href="https://fonts.googleapis.com" rel="preconnect" />
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <meta content="ie-edge" http-equiv="X-UA-Compatible" />
</head>

<body>
    <nav aria-label="Main navigation">
        <a class="logo" href="../../index.html">
            <img alt="Adam Djellouli - Home Page Logo" id="logo-image" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/logo.PNG" />
        </a>
        <input aria-label="Toggle navigation menu" id="navbar-toggle" type="checkbox" />
        <ul aria-labelledby="navbar-toggle" role="menu">
            <li role="menuitem">
                <a href="../../index.html" title="Go to Home Page"> Home </a>
            </li>
            <li role="menuitem">
                <a href="../../core/blog.html" title="Read Adam Djellouli Blog on Programming and Technology"> Blog </a>
            </li>
            <li role="menuitem">
                <a href="../../core/tools.html" title="Discover Tools Created by Adam Djellouli"> Tools </a>
            </li>
            <li role="menuitem">
                <a href="../../core/projects.html" title="Explore Projects Developed by Adam Djellouli"> Projects </a>
            </li>
            <li role="menuitem">
                <a href="../../core/courses.html" title="Browse Courses by Adam Djellouli"> Courses </a>
            </li>
            <li role="menuitem">
                <a href="../../core/resume.html" title="View Adam Djellouli Professional Resume"> Resume </a>
            </li>
            <li>
                <script async="" src="https://cse.google.com/cse.js?cx=8160ef9bb935f4f68"></script>
                <div class="gcse-search"></div>
            </li>
            <li>
                <button aria-label="Toggle dark mode" id="dark-mode-button"></button>
            </li>
        </ul>
    </nav>
    <div aria-live="polite" class="toast-container" id="toast-container"></div>
    <main class="tool-main">
        <!-- Hero Header -->
        <header class="tool-header">
            <div class="header-content">
                <div class="header-icon">
                    <span class="icon-sparkle">ğŸ“Š</span>
                </div>
                <h1>Sorting Algorithm Visualization</h1>
                <p class="subtitle">Watch sorting algorithms in action with real-time visualization</p>
                <div class="keyboard-hint">
                    Compare different algorithms â€¢ <kbd>Space</kbd> to start/pause
                </div>
            </div>
        </header>
        <!-- Stats Bar -->
        <div class="stats-bar">
            <div class="stat-item">
                <span class="stat-icon">ğŸ”„</span>
                <span class="stat-value" id="swaps-count">0</span>
                <span class="stat-label">Swaps</span>
            </div>
            <div class="stat-item">
                <span class="stat-icon">ğŸ“Š</span>
                <span class="stat-value" id="comparisons-count">0</span>
                <span class="stat-label">Comparisons</span>
            </div>
            <div class="stat-item">
                <span class="stat-icon">â±ï¸</span>
                <span class="stat-value" id="elapsed-time">0ms</span>
                <span class="stat-label">Time</span>
            </div>
            <div class="stat-item">
                <span class="stat-icon">ğŸ§®</span>
                <span class="stat-value" id="algorithm-name">Bubble</span>
                <span class="stat-label">Algorithm</span>
            </div>
        </div>
        <section class="tool-content">
            <!-- Sidebar Options -->
            <aside class="options-sidebar">
                <div class="sidebar-header">
                    <h2><span class="icon">âš™ï¸</span> Settings</h2>
                    <button class="preset-btn" id="reset-defaults" title="Reset to defaults">
                        <span>â†º</span>
                    </button>
                </div>
                <!-- Algorithm Selection -->
                <div class="option-card preset-card">
                    <h3><span class="card-icon">ğŸ§®</span> Algorithm</h3>
                    <div class="input-group">
                        <select id="algorithm">
                            <option value="bubble">Bubble Sort</option>
                            <option value="selection">Selection Sort</option>
                            <option value="insertion">Insertion Sort</option>
                            <option value="merge">Merge Sort</option>
                            <option value="quick">Quick Sort</option>
                            <option value="heap">Heap Sort</option>
                            <option value="radix">Radix Sort</option>
                        </select>
                    </div>
                </div>
                <!-- Array Options -->
                <div class="option-card">
                    <button aria-expanded="true" class="card-toggle">
                        <h3><span class="card-icon">ğŸ“</span> Array</h3>
                        <span class="toggle-icon">â–¼</span>
                    </button>
                    <div class="card-content">
                        <div class="input-group">
                            <label for="array-size">Array Size</label>
                            <input id="array-size" max="100" min="10" type="number" value="50" />
                        </div>
                    </div>
                </div>
                <!-- Visualization Options -->
                <div class="option-card">
                    <button aria-expanded="true" class="card-toggle">
                        <h3><span class="card-icon">ğŸ¨</span> Visualization</h3>
                        <span class="toggle-icon">â–¼</span>
                    </button>
                    <div class="card-content">
                        <div class="input-group">
                            <label for="speed">Animation Speed</label>
                            <input id="speed" max="10" min="1" type="range" value="5" />
                        </div>
                    </div>
                </div>
                <!-- Controls Info -->
                <div class="option-card">
                    <h3><span class="card-icon">â„¹ï¸</span> Controls</h3>
                    <div class="card-content">
                        <p style="font-size: 0.85rem; color: var(--text-secondary); margin: 0; line-height: 1.6;">
                            â€¢ Random array generated<br />
                            â€¢ Red bars = being compared<br />
                            â€¢ Yellow bars = normal state<br />
                            â€¢ Use Step for detailed view
                        </p>
                    </div>
                </div>
            </aside>
            <!-- Main Canvas Area -->
            <div class="canvas-area">
                <!-- Canvas Container -->
                <div class="canvas-container">
                    <div class="canvas-header">
                        <span class="canvas-title">ğŸ“Š Sorting Visualization</span>
                    </div>
                    <div class="canvas-wrapper">
                        <canvas id="sorting-canvas"></canvas>
                    </div>
                </div>
                <!-- Action Buttons -->
                <div class="action-bar">
                    <div class="primary-actions">
                        <button class="action-btn primary large" id="start">
                            <span class="btn-icon">â–¶ï¸</span>
                            <span class="btn-text">Start Sorting</span>
                        </button>
                    </div>
                    <div class="secondary-actions">
                        <button class="action-btn warning" id="pause" title="Pause/Resume">
                            <span class="btn-icon">â¸ï¸</span> Pause
                        </button>
                        <button class="action-btn" id="step" title="Step through one iteration">
                            <span class="btn-icon">â­ï¸</span> Step
                        </button>
                        <button class="action-btn danger" id="reset" title="Reset the array">
                            <span class="btn-icon">ğŸ”„</span> Reset
                        </button>
                    </div>
                </div>
                <!-- Legend Panel -->
                <div class="legend-panel">
                    <div class="legend-header">
                        <h3><span>ğŸ¨</span> Legend</h3>
                    </div>
                    <div class="legend-content">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #eec747;"></div>
                            <span class="legend-label">Array Element</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #ef4444;"></div>
                            <span class="legend-label">Comparing/Swapping</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #10b981;"></div>
                            <span class="legend-label">Sorted</span>
                        </div>
                    </div>
                </div>
            </div>
        </section>
        <!-- Help Box -->
        <div class="help-box">
            <strong>Need Help?</strong>
            <ul>
                <li>Select a sorting algorithm from the sidebar dropdown.</li>
                <li>Adjust array size to change the number of elements.</li>
                <li>Click "Start Sorting" to visualize the algorithm.</li>
                <li>Use "Step" to advance one operation at a time.</li>
                <li>Compare algorithm efficiency using the stats bar.</li>
                <li>Reset to generate a new random array.</li>
            </ul>
        </div>
        <!-- Algorithm Background Section -->
        <section class="explanation-section">
            <div class="section-header">
                <h2>ğŸ“š Sorting Algorithm Background</h2>
            </div>
            <div class="explanation-content">
                <div class="explanation-card">
                    <h3>ğŸ“Š What is Sorting?</h3>
                    <p>
                        Sorting is the process of arranging elements in a specific orderâ€”typically ascending or descending.
                        It's one of the most fundamental operations in computer science, used everywhere from organizing
                        databases to optimizing search algorithms. A well-chosen sorting algorithm can dramatically improve
                        the performance of other algorithms that require sorted data.
                    </p>
                    <p>
                        Different sorting algorithms have different strengths and weaknesses. Some are simple but slow,
                        others are complex but efficient. Some work well with nearly-sorted data, while others excel
                        with random data. Understanding these trade-offs helps you choose the right algorithm for your use case.
                    </p>
                </div>
                <div class="explanation-card">
                    <h3>ğŸ«§ Bubble Sort</h3>
                    <p>
                        <strong>Strategy:</strong> Bubble Sort repeatedly steps through the array, compares adjacent elements,
                        and swaps them if they're in the wrong order. This process continues until no more swaps are needed.
                    </p>
                    <div class="formula-box">
                        <p><strong>Algorithm:</strong></p>
                        <p>1. For i = 0 to n-1:</p>
                        <p>Â Â Â For j = 0 to n-i-2:</p>
                        <p>Â Â Â Â Â Â If arr[j] &gt; arr[j+1]:</p>
                        <p>Â Â Â Â Â Â Â Â Â Swap arr[j] and arr[j+1]</p>
                    </div>
                    <p><strong>Complexity:</strong></p>
                    <ul>
                        <li><strong>Best Case:</strong> O(n) - when array is already sorted</li>
                        <li><strong>Average Case:</strong> O(nÂ²)</li>
                        <li><strong>Worst Case:</strong> O(nÂ²) - when array is reverse sorted</li>
                        <li><strong>Space:</strong> O(1) - in-place sorting</li>
                    </ul>
                    <p>
                        <strong>Characteristics:</strong> Simple to understand and implement. Stable (preserves relative
                        order of equal elements). Very inefficient for large datasets. Named "bubble" because smaller
                        elements "bubble" to the top of the array.
                    </p>
                    <p>
                        <strong>When to use:</strong> Educational purposes, very small datasets, or when simplicity is
                        more important than efficiency.
                    </p>
                </div>
                <div class="explanation-card">
                    <h3>ğŸ¯ Selection Sort</h3>
                    <p>
                        <strong>Strategy:</strong> Selection Sort divides the array into sorted and unsorted regions.
                        It repeatedly finds the minimum element from the unsorted region and moves it to the end of
                        the sorted region.
                    </p>
                    <div class="formula-box">
                        <p><strong>Algorithm:</strong></p>
                        <p>1. For i = 0 to n-1:</p>
                        <p>Â Â Â Find minimum element in arr[i...n-1]</p>
                        <p>Â Â Â Swap it with arr[i]</p>
                    </div>
                    <p><strong>Complexity:</strong></p>
                    <ul>
                        <li><strong>Best Case:</strong> O(nÂ²)</li>
                        <li><strong>Average Case:</strong> O(nÂ²)</li>
                        <li><strong>Worst Case:</strong> O(nÂ²)</li>
                        <li><strong>Space:</strong> O(1) - in-place sorting</li>
                    </ul>
                    <p>
                        <strong>Characteristics:</strong> Simple and intuitive. Makes minimum number of swaps (O(n)),
                        which can be beneficial when writing to memory is expensive. Not stable in standard implementation.
                        Performance doesn't improve with partially sorted data.
                    </p>
                    <p>
                        <strong>When to use:</strong> When memory writes are expensive, small datasets, or when you
                        need a simple in-place sort.
                    </p>
                </div>
                <div class="explanation-card">
                    <h3>ğŸ”„ Insertion Sort</h3>
                    <p>
                        <strong>Strategy:</strong> Insertion Sort builds the final sorted array one element at a time.
                        It picks each element and inserts it into its correct position in the already-sorted portion.
                    </p>
                    <div class="formula-box">
                        <p><strong>Algorithm:</strong></p>
                        <p>1. For i = 1 to n-1:</p>
                        <p>Â Â Â key = arr[i]</p>
                        <p>Â Â Â j = i - 1</p>
                        <p>Â Â Â While j â‰¥ 0 and arr[j] &gt; key:</p>
                        <p>Â Â Â Â Â Â arr[j+1] = arr[j]</p>
                        <p>Â Â Â Â Â Â j = j - 1</p>
                        <p>Â Â Â arr[j+1] = key</p>
                    </div>
                    <p><strong>Complexity:</strong></p>
                    <ul>
                        <li><strong>Best Case:</strong> O(n) - when array is already sorted</li>
                        <li><strong>Average Case:</strong> O(nÂ²)</li>
                        <li><strong>Worst Case:</strong> O(nÂ²) - when array is reverse sorted</li>
                        <li><strong>Space:</strong> O(1) - in-place sorting</li>
                    </ul>
                    <p>
                        <strong>Characteristics:</strong> Stable and adaptive (efficient for nearly-sorted data).
                        Very efficient for small datasets. Online algorithm (can sort as it receives data).
                        Used in hybrid algorithms like Timsort.
                    </p>
                    <p>
                        <strong>When to use:</strong> Small datasets, nearly-sorted data, streaming data, or as part
                        of hybrid algorithms.
                    </p>
                </div>
                <div class="explanation-card">
                    <h3>ğŸŒ³ Merge Sort</h3>
                    <p>
                        <strong>Strategy:</strong> Merge Sort is a divide-and-conquer algorithm. It divides the array
                        into two halves, recursively sorts them, and then merges the sorted halves.
                    </p>
                    <div class="formula-box">
                        <p><strong>Algorithm:</strong></p>
                        <p>1. If array has one element, return (base case)</p>
                        <p>2. Divide array into two halves</p>
                        <p>3. Recursively sort both halves</p>
                        <p>4. Merge the two sorted halves:</p>
                        <p>Â Â Â Compare elements from both halves</p>
                        <p>Â Â Â Copy smaller element to result</p>
                        <p>Â Â Â Repeat until all elements are merged</p>
                    </div>
                    <p><strong>Complexity:</strong></p>
                    <ul>
                        <li><strong>Best Case:</strong> O(n log n)</li>
                        <li><strong>Average Case:</strong> O(n log n)</li>
                        <li><strong>Worst Case:</strong> O(n log n)</li>
                        <li><strong>Space:</strong> O(n) - requires additional memory for merging</li>
                    </ul>
                    <p>
                        <strong>Mathematical Analysis:</strong> The recurrence relation is T(n) = 2T(n/2) + O(n).
                        The tree has log n levels, and each level does O(n) work, giving O(n log n) total time.
                    </p>
                    <p>
                        <strong>Characteristics:</strong> Stable and predictable performance (always O(n log n)).
                        Not in-place (requires extra memory). Excellent for linked lists. Parallelizable.
                        Used in external sorting (sorting data that doesn't fit in memory).
                    </p>
                    <p>
                        <strong>When to use:</strong> When stability is required, guaranteed O(n log n) performance
                        is needed, or when sorting linked lists or external data.
                    </p>
                </div>
                <div class="explanation-card">
                    <h3>âš¡ Quick Sort</h3>
                    <p>
                        <strong>Strategy:</strong> Quick Sort is a divide-and-conquer algorithm that selects a 'pivot'
                        element and partitions the array around itâ€”elements smaller than pivot go left, larger go right.
                        It then recursively sorts the partitions.
                    </p>
                    <div class="formula-box">
                        <p><strong>Algorithm:</strong></p>
                        <p>1. If array has â‰¤ 1 element, return (base case)</p>
                        <p>2. Choose a pivot element</p>
                        <p>3. Partition array:</p>
                        <p>Â Â Â Elements &lt; pivot go to left partition</p>
                        <p>Â Â Â Elements &gt; pivot go to right partition</p>
                        <p>4. Recursively sort left and right partitions</p>
                        <p>5. Concatenate: [sorted left] + [pivot] + [sorted right]</p>
                    </div>
                    <p><strong>Complexity:</strong></p>
                    <ul>
                        <li><strong>Best Case:</strong> O(n log n) - balanced partitions</li>
                        <li><strong>Average Case:</strong> O(n log n)</li>
                        <li><strong>Worst Case:</strong> O(nÂ²) - when pivot is always min/max (e.g., already sorted)</li>
                        <li><strong>Space:</strong> O(log n) - for recursion stack (O(n) in worst case)</li>
                    </ul>
                    <p>
                        <strong>Pivot Selection Strategies:</strong>
                    </p>
                    <ul>
                        <li><strong>First/Last element:</strong> Simple but can cause O(nÂ²) on sorted data</li>
                        <li><strong>Random element:</strong> Avoids worst case with high probability</li>
                        <li><strong>Median-of-three:</strong> Choose median of first, middle, and last elements</li>
                    </ul>
                    <p>
                        <strong>Characteristics:</strong> Very fast in practice due to good cache locality.
                        In-place sorting (minimal extra memory). Not stable. Average case is excellent but
                        worst case is poor. The de facto standard sorting algorithm in many libraries.
                    </p>
                    <p>
                        <strong>When to use:</strong> General-purpose sorting when average case performance matters
                        more than worst-case guarantees. Default choice for most applications.
                    </p>
                </div>
                <div class="explanation-card">
                    <h3>ğŸ”ï¸ Heap Sort</h3>
                    <p>
                        <strong>Strategy:</strong> Heap Sort uses a binary heap data structure. It first builds a
                        max-heap from the array, then repeatedly extracts the maximum element (root) and rebuilds
                        the heap with the remaining elements.
                    </p>
                    <div class="formula-box">
                        <p><strong>Algorithm:</strong></p>
                        <p>1. Build a max-heap from input array</p>
                        <p>2. For i = n-1 down to 1:</p>
                        <p>Â Â Â Swap root (maximum) with arr[i]</p>
                        <p>Â Â Â Reduce heap size by 1</p>
                        <p>Â Â Â Heapify root to restore heap property</p>
                    </div>
                    <p><strong>Heap Property:</strong></p>
                    <div class="formula-box">
                        <p>For a max-heap at index i:</p>
                        <p>â€¢ Parent: (i-1) / 2</p>
                        <p>â€¢ Left child: 2i + 1</p>
                        <p>â€¢ Right child: 2i + 2</p>
                        <p>â€¢ Property: arr[i] â‰¥ arr[2i+1] and arr[i] â‰¥ arr[2i+2]</p>
                    </div>
                    <p><strong>Complexity:</strong></p>
                    <ul>
                        <li><strong>Best Case:</strong> O(n log n)</li>
                        <li><strong>Average Case:</strong> O(n log n)</li>
                        <li><strong>Worst Case:</strong> O(n log n)</li>
                        <li><strong>Space:</strong> O(1) - in-place sorting</li>
                    </ul>
                    <p>
                        <strong>Characteristics:</strong> Guaranteed O(n log n) performance. In-place sorting.
                        Not stable. Poor cache locality compared to Quick Sort. Useful when guaranteed performance
                        and minimal memory are both required.
                    </p>
                    <p>
                        <strong>When to use:</strong> When you need guaranteed O(n log n) time with O(1) space,
                        implementing priority queues, or when stability is not required.
                    </p>
                </div>
                <div class="explanation-card">
                    <h3>ğŸ“¦ Radix Sort</h3>
                    <p>
                        <strong>Strategy:</strong> Radix Sort is a non-comparison sorting algorithm. It sorts integers
                        by processing individual digits, starting from the least significant digit to the most significant
                        digit (LSD Radix Sort) or vice versa (MSD Radix Sort).
                    </p>
                    <div class="formula-box">
                        <p><strong>Algorithm (LSD):</strong></p>
                        <p>1. For each digit position (from least to most significant):</p>
                        <p>Â Â Â Use a stable sort (like Counting Sort) to sort by that digit</p>
                        <p>2. After processing all digits, array is sorted</p>
                    </div>
                    <p><strong>Example:</strong></p>
                    <div class="formula-box">
                        <p>Input: [170, 45, 75, 90, 802, 24, 2, 66]</p>
                        <p>After sorting by 1s place: [170, 90, 802, 2, 24, 45, 75, 66]</p>
                        <p>After sorting by 10s place: [802, 2, 24, 45, 66, 170, 75, 90]</p>
                        <p>After sorting by 100s place: [2, 24, 45, 66, 75, 90, 170, 802]</p>
                    </div>
                    <p><strong>Complexity:</strong></p>
                    <ul>
                        <li><strong>Time:</strong> O(d Ã— (n + k)) where d = number of digits, k = range of digit values</li>
                        <li><strong>Space:</strong> O(n + k)</li>
                        <li><strong>For base-10 integers:</strong> O(d Ã— n) where d is typically small and constant</li>
                    </ul>
                    <p>
                        <strong>Characteristics:</strong> Non-comparison based (can break the O(n log n) barrier).
                        Stable sorting. Very efficient for integers or strings with fixed-length keys.
                        Performance depends on number of digits, not the size of numbers.
                    </p>
                    <p>
                        <strong>When to use:</strong> Sorting integers within a known range, sorting strings of
                        similar length, or when you need linear time complexity and have appropriate data.
                    </p>
                </div>
                <div class="explanation-card">
                    <h3>ğŸ“Š Algorithm Comparison</h3>
                    <div class="comparison-table">
                        <table style="width: 100%; border-collapse: collapse; margin-top: 1rem;">
                            <thead>
                                <tr style="background: var(--card-background); border-bottom: 2px solid var(--border-color);">
                                    <th style="padding: 0.75rem; text-align: left;">Algorithm</th>
                                    <th style="padding: 0.75rem; text-align: center;">Best</th>
                                    <th style="padding: 0.75rem; text-align: center;">Average</th>
                                    <th style="padding: 0.75rem; text-align: center;">Worst</th>
                                    <th style="padding: 0.75rem; text-align: center;">Space</th>
                                    <th style="padding: 0.75rem; text-align: center;">Stable</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr style="border-bottom: 1px solid var(--border-color);">
                                    <td style="padding: 0.75rem;"><strong>Bubble</strong></td>
                                    <td style="padding: 0.75rem; text-align: center;">O(n)</td>
                                    <td style="padding: 0.75rem; text-align: center;">O(nÂ²)</td>
                                    <td style="padding: 0.75rem; text-align: center;">O(nÂ²)</td>
                                    <td style="padding: 0.75rem; text-align: center;">O(1)</td>
                                    <td style="padding: 0.75rem; text-align: center;">Yes</td>
                                </tr>
                                <tr style="border-bottom: 1px solid var(--border-color);">
                                    <td style="padding: 0.75rem;"><strong>Selection</strong></td>
                                    <td style="padding: 0.75rem; text-align: center;">O(nÂ²)</td>
                                    <td style="padding: 0.75rem; text-align: center;">O(nÂ²)</td>
                                    <td style="padding: 0.75rem; text-align: center;">O(nÂ²)</td>
                                    <td style="padding: 0.75rem; text-align: center;">O(1)</td>
                                    <td style="padding: 0.75rem; text-align: center;">No</td>
                                </tr>
                                <tr style="border-bottom: 1px solid var(--border-color);">
                                    <td style="padding: 0.75rem;"><strong>Insertion</strong></td>
                                    <td style="padding: 0.75rem; text-align: center;">O(n)</td>
                                    <td style="padding: 0.75rem; text-align: center;">O(nÂ²)</td>
                                    <td style="padding: 0.75rem; text-align: center;">O(nÂ²)</td>
                                    <td style="padding: 0.75rem; text-align: center;">O(1)</td>
                                    <td style="padding: 0.75rem; text-align: center;">Yes</td>
                                </tr>
                                <tr style="border-bottom: 1px solid var(--border-color);">
                                    <td style="padding: 0.75rem;"><strong>Merge</strong></td>
                                    <td style="padding: 0.75rem; text-align: center;">O(n log n)</td>
                                    <td style="padding: 0.75rem; text-align: center;">O(n log n)</td>
                                    <td style="padding: 0.75rem; text-align: center;">O(n log n)</td>
                                    <td style="padding: 0.75rem; text-align: center;">O(n)</td>
                                    <td style="padding: 0.75rem; text-align: center;">Yes</td>
                                </tr>
                                <tr style="border-bottom: 1px solid var(--border-color);">
                                    <td style="padding: 0.75rem;"><strong>Quick</strong></td>
                                    <td style="padding: 0.75rem; text-align: center;">O(n log n)</td>
                                    <td style="padding: 0.75rem; text-align: center;">O(n log n)</td>
                                    <td style="padding: 0.75rem; text-align: center;">O(nÂ²)</td>
                                    <td style="padding: 0.75rem; text-align: center;">O(log n)</td>
                                    <td style="padding: 0.75rem; text-align: center;">No</td>
                                </tr>
                                <tr style="border-bottom: 1px solid var(--border-color);">
                                    <td style="padding: 0.75rem;"><strong>Heap</strong></td>
                                    <td style="padding: 0.75rem; text-align: center;">O(n log n)</td>
                                    <td style="padding: 0.75rem; text-align: center;">O(n log n)</td>
                                    <td style="padding: 0.75rem; text-align: center;">O(n log n)</td>
                                    <td style="padding: 0.75rem; text-align: center;">O(1)</td>
                                    <td style="padding: 0.75rem; text-align: center;">No</td>
                                </tr>
                                <tr style="border-bottom: 1px solid var(--border-color);">
                                    <td style="padding: 0.75rem;"><strong>Radix</strong></td>
                                    <td style="padding: 0.75rem; text-align: center;">O(dÃ—n)</td>
                                    <td style="padding: 0.75rem; text-align: center;">O(dÃ—n)</td>
                                    <td style="padding: 0.75rem; text-align: center;">O(dÃ—n)</td>
                                    <td style="padding: 0.75rem; text-align: center;">O(n+k)</td>
                                    <td style="padding: 0.75rem; text-align: center;">Yes</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
                <div class="explanation-card">
                    <h3>ğŸ¯ Choosing the Right Algorithm</h3>
                    <p><strong>Decision factors:</strong></p>
                    <ul>
                        <li><strong>Data size:</strong> Small datasets (n &lt; 50): Insertion Sort is often fastest due to low overhead</li>
                        <li><strong>Nearly sorted data:</strong> Insertion Sort is optimal with O(n) performance</li>
                        <li><strong>Memory constraints:</strong> Heap Sort or Quick Sort (in-place algorithms)</li>
                        <li><strong>Stability required:</strong> Merge Sort, Insertion Sort, or Radix Sort</li>
                        <li><strong>Guaranteed performance:</strong> Merge Sort or Heap Sort (avoid Quick Sort's O(nÂ²) worst case)</li>
                        <li><strong>Average case performance:</strong> Quick Sort is typically fastest in practice</li>
                        <li><strong>Integer data with limited range:</strong> Radix Sort or Counting Sort</li>
                        <li><strong>External sorting:</strong> Merge Sort (disk-based sorting)</li>
                    </ul>
                    <p style="margin-top: 1rem;">
                        <strong>Real-world usage:</strong> Most programming languages use hybrid algorithms.
                        For example, Python's Timsort combines Merge Sort and Insertion Sort. Java uses Dual-Pivot
                        Quick Sort for primitives and Timsort for objects. C++ std::sort uses Introsort
                        (Quick Sort with Heap Sort fallback).
                    </p>
                </div>
                <div class="explanation-card">
                    <h3>ğŸŒŸ Real-World Applications</h3>
                    <p>Sorting algorithms are fundamental to many applications:</p>
                    <ul>
                        <li><strong>Databases:</strong> Query optimization, indexing, and result ordering rely heavily
                            on efficient sorting.</li>
                        <li><strong>Search Engines:</strong> Ranking and displaying search results requires sorting
                            millions of pages by relevance.</li>
                        <li><strong>E-commerce:</strong> Product listings sorted by price, popularity, ratings, etc.</li>
                        <li><strong>Data Analysis:</strong> Statistical analysis often requires sorted data
                            (median, percentiles, outlier detection).</li>
                        <li><strong>File Systems:</strong> Organizing and displaying files/folders alphabetically
                            or by modification date.</li>
                        <li><strong>Graphics:</strong> Painter's algorithm sorts polygons by depth for rendering.</li>
                        <li><strong>Scheduling:</strong> Task scheduling systems sort jobs by priority or deadline.</li>
                        <li><strong>Compression:</strong> Many compression algorithms (like Huffman coding) require sorted data.</li>
                    </ul>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <div class="footer-columns">
            <div class="footer-column">
                <img alt="Adam Djellouli Symbol" src="https://raw.githubusercontent.com/djeada/Personal-Website/master/images/symbol.png" />
            </div>
            <div class="footer-column">
                <h2><a href="https://adamdjellouli.com/core/privacy_policy.html" title="Privacy Policy">Our Privacy Policy</a></h2>
                <p>Thank you for visiting my personal website. All content here is free to use, but please remember to be respectful and avoid any misuse of the site. If youâ€™d like to get in touch, feel free to reach out via my <a href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" title="LinkedIn Profile">LinkedIn profile</a> or connect with me on <a href="https://github.com/djeada" title="GitHub Profile">GitHub</a> if you have technical questions or ideas to share. Wishing you all the best and a fantastic life ahead!</p>
            </div>
            <div class="footer-column">
                <h2>Follow me</h2>
                <ul class="social-media">
                    <li>
                        <a class="fa fa-youtube" href="https://www.youtube.com/channel/UCGPoHTVjMN77wcGknXPHl1Q" target="_blank" title="YouTube">
                        </a>YouTube
                    </li>
                    <li>
                        <a class="fa fa-linkedin" href="https://www.linkedin.com/in/adam-djellouli-1bb54619a/" target="_blank" title="LinkedIn">
                        </a>LinkedIn
                    </li>
                    <li>
                        <a class="fa fa-instagram" href="https://www.instagram.com/linuxchallenges/" target="_blank" title="Instagram">
                        </a>Instagram
                    </li>
                    <li>
                        <a class="fa fa-github" href="https://github.com/djeada" title="GitHub">
                        </a>Github
                    </li>
                </ul>
            </div>
        </div>
        <div>
            <p id="copyright">
                Â© Adam Djellouli. All rights reserved.
            </p>
        </div>
        <script>
            document.getElementById("copyright").innerHTML = "&copy; " + new Date().getFullYear() + " Adam Djellouli. All rights reserved.";
        </script>
        <script src="../../app.js"></script>
    </footer>
</body>
<script src="app.js"></script>

</html>